<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>InsightMaker Model Visualizer</title>
  <style>
/* this gets exported as style.css and can be used for the default theming */
/* these are the necessary styles for React Flow, they get used by base.css and style.css */
.react-flow {
  direction: ltr;
}
.react-flow__container {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
}
.react-flow__pane {
  z-index: 1;
  cursor: -webkit-grab;
  cursor: grab;
}
.react-flow__pane.selection {
    cursor: pointer;
  }
.react-flow__pane.dragging {
    cursor: -webkit-grabbing;
    cursor: grabbing;
  }
.react-flow__viewport {
  transform-origin: 0 0;
  z-index: 2;
  pointer-events: none;
}
.react-flow__renderer {
  z-index: 4;
}
.react-flow__selection {
  z-index: 6;
}
.react-flow__nodesselection-rect:focus,
.react-flow__nodesselection-rect:focus-visible {
  outline: none;
}
.react-flow .react-flow__edges {
  pointer-events: none;
  overflow: visible;
}
.react-flow__edge-path,
.react-flow__connection-path {
  stroke: #b1b1b7;
  stroke-width: 1;
  fill: none;
}
.react-flow__edge {
  pointer-events: visibleStroke;
  cursor: pointer;
}
.react-flow__edge.animated path {
    stroke-dasharray: 5;
    -webkit-animation: dashdraw 0.5s linear infinite;
            animation: dashdraw 0.5s linear infinite;
  }
.react-flow__edge.animated path.react-flow__edge-interaction {
    stroke-dasharray: none;
    -webkit-animation: none;
            animation: none;
  }
.react-flow__edge.inactive {
    pointer-events: none;
  }
.react-flow__edge.selected,
  .react-flow__edge:focus,
  .react-flow__edge:focus-visible {
    outline: none;
  }
.react-flow__edge.selected .react-flow__edge-path,
  .react-flow__edge:focus .react-flow__edge-path,
  .react-flow__edge:focus-visible .react-flow__edge-path {
    stroke: #555;
  }
.react-flow__edge-textwrapper {
    pointer-events: all;
  }
.react-flow__edge-textbg {
    fill: white;
  }
.react-flow__edge .react-flow__edge-text {
    pointer-events: none;
    -webkit-user-select: none;
       -moz-user-select: none;
            user-select: none;
  }
.react-flow__connection {
  pointer-events: none;
}
.react-flow__connection .animated {
    stroke-dasharray: 5;
    -webkit-animation: dashdraw 0.5s linear infinite;
            animation: dashdraw 0.5s linear infinite;
  }
.react-flow__connectionline {
  z-index: 1001;
}
.react-flow__nodes {
  pointer-events: none;
  transform-origin: 0 0;
}
.react-flow__node {
  position: absolute;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
  pointer-events: all;
  transform-origin: 0 0;
  box-sizing: border-box;
  cursor: -webkit-grab;
  cursor: grab;
}
.react-flow__node.dragging {
    cursor: -webkit-grabbing;
    cursor: grabbing;
  }
.react-flow__nodesselection {
  z-index: 3;
  transform-origin: left top;
  pointer-events: none;
}
.react-flow__nodesselection-rect {
    position: absolute;
    pointer-events: all;
    cursor: -webkit-grab;
    cursor: grab;
  }
.react-flow__handle {
  position: absolute;
  pointer-events: none;
  min-width: 5px;
  min-height: 5px;
  width: 6px;
  height: 6px;
  background: #1a192b;
  border: 1px solid white;
  border-radius: 100%;
}
.react-flow__handle.connectionindicator {
    pointer-events: all;
    cursor: crosshair;
  }
.react-flow__handle-bottom {
    top: auto;
    left: 50%;
    bottom: -4px;
    transform: translate(-50%, 0);
  }
.react-flow__handle-top {
    left: 50%;
    top: -4px;
    transform: translate(-50%, 0);
  }
.react-flow__handle-left {
    top: 50%;
    left: -4px;
    transform: translate(0, -50%);
  }
.react-flow__handle-right {
    right: -4px;
    top: 50%;
    transform: translate(0, -50%);
  }
.react-flow__edgeupdater {
  cursor: move;
  pointer-events: all;
}
.react-flow__panel {
  position: absolute;
  z-index: 5;
  margin: 15px;
}
.react-flow__panel.top {
    top: 0;
  }
.react-flow__panel.bottom {
    bottom: 0;
  }
.react-flow__panel.left {
    left: 0;
  }
.react-flow__panel.right {
    right: 0;
  }
.react-flow__panel.center {
    left: 50%;
    transform: translateX(-50%);
  }
.react-flow__attribution {
  font-size: 10px;
  background: rgba(255, 255, 255, 0.5);
  padding: 2px 3px;
  margin: 0;
}
.react-flow__attribution a {
    text-decoration: none;
    color: #999;
  }
@-webkit-keyframes dashdraw {
  from {
    stroke-dashoffset: 10;
  }
}
@keyframes dashdraw {
  from {
    stroke-dashoffset: 10;
  }
}
.react-flow__edgelabel-renderer {
  position: absolute;
  width: 100%;
  height: 100%;
  pointer-events: none;
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
}
.react-flow__edge.updating .react-flow__edge-path {
      stroke: #777;
    }
.react-flow__edge-text {
    font-size: 10px;
  }
.react-flow__node.selectable:focus,
  .react-flow__node.selectable:focus-visible {
    outline: none;
  }
.react-flow__node-default,
.react-flow__node-input,
.react-flow__node-output,
.react-flow__node-group {
  padding: 10px;
  border-radius: 3px;
  width: 150px;
  font-size: 12px;
  color: #222;
  text-align: center;
  border-width: 1px;
  border-style: solid;
  border-color: #1a192b;
  background-color: white;
}
.react-flow__node-default.selectable:hover, .react-flow__node-input.selectable:hover, .react-flow__node-output.selectable:hover, .react-flow__node-group.selectable:hover {
      box-shadow: 0 1px 4px 1px rgba(0, 0, 0, 0.08);
    }
.react-flow__node-default.selectable.selected,
    .react-flow__node-default.selectable:focus,
    .react-flow__node-default.selectable:focus-visible,
    .react-flow__node-input.selectable.selected,
    .react-flow__node-input.selectable:focus,
    .react-flow__node-input.selectable:focus-visible,
    .react-flow__node-output.selectable.selected,
    .react-flow__node-output.selectable:focus,
    .react-flow__node-output.selectable:focus-visible,
    .react-flow__node-group.selectable.selected,
    .react-flow__node-group.selectable:focus,
    .react-flow__node-group.selectable:focus-visible {
      box-shadow: 0 0 0 0.5px #1a192b;
    }
.react-flow__node-group {
  background-color: rgba(240, 240, 240, 0.25);
}
.react-flow__nodesselection-rect,
.react-flow__selection {
  background: rgba(0, 89, 220, 0.08);
  border: 1px dotted rgba(0, 89, 220, 0.8);
}
.react-flow__nodesselection-rect:focus,
  .react-flow__nodesselection-rect:focus-visible,
  .react-flow__selection:focus,
  .react-flow__selection:focus-visible {
    outline: none;
  }
.react-flow__controls {
  box-shadow: 0 0 2px 1px rgba(0, 0, 0, 0.08);
}
.react-flow__controls-button {
    border: none;
    background: #fefefe;
    border-bottom: 1px solid #eee;
    box-sizing: content-box;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 16px;
    height: 16px;
    cursor: pointer;
    -webkit-user-select: none;
       -moz-user-select: none;
            user-select: none;
    padding: 5px;
  }
.react-flow__controls-button:hover {
      background: #f4f4f4;
    }
.react-flow__controls-button svg {
      width: 100%;
      max-width: 12px;
      max-height: 12px;
    }
.react-flow__controls-button:disabled {
      pointer-events: none;
    }
.react-flow__controls-button:disabled svg {
        fill-opacity: 0.4;
      }
.react-flow__minimap {
  background-color: #fff;
}
.react-flow__minimap svg {
  display: block;
}
.react-flow__resize-control {
  position: absolute;
}
.react-flow__resize-control.left,
.react-flow__resize-control.right {
  cursor: ew-resize;
}
.react-flow__resize-control.top,
.react-flow__resize-control.bottom {
  cursor: ns-resize;
}
.react-flow__resize-control.top.left,
.react-flow__resize-control.bottom.right {
  cursor: nwse-resize;
}
.react-flow__resize-control.bottom.left,
.react-flow__resize-control.top.right {
  cursor: nesw-resize;
}
/* handle styles */
.react-flow__resize-control.handle {
  width: 4px;
  height: 4px;
  border: 1px solid #fff;
  border-radius: 1px;
  background-color: #3367d9;
  transform: translate(-50%, -50%);
}
.react-flow__resize-control.handle.left {
  left: 0;
  top: 50%;
}
.react-flow__resize-control.handle.right {
  left: 100%;
  top: 50%;
}
.react-flow__resize-control.handle.top {
  left: 50%;
  top: 0;
}
.react-flow__resize-control.handle.bottom {
  left: 50%;
  top: 100%;
}
.react-flow__resize-control.handle.top.left {
  left: 0;
}
.react-flow__resize-control.handle.bottom.left {
  left: 0;
}
.react-flow__resize-control.handle.top.right {
  left: 100%;
}
.react-flow__resize-control.handle.bottom.right {
  left: 100%;
}
/* line styles */
.react-flow__resize-control.line {
  border-color: #3367d9;
  border-width: 0;
  border-style: solid;
}
.react-flow__resize-control.line.left,
.react-flow__resize-control.line.right {
  width: 1px;
  transform: translate(-50%, 0);
  top: 0;
  height: 100%;
}
.react-flow__resize-control.line.left {
  left: 0;
  border-left-width: 1px;
}
.react-flow__resize-control.line.right {
  left: 100%;
  border-right-width: 1px;
}
.react-flow__resize-control.line.top,
.react-flow__resize-control.line.bottom {
  height: 1px;
  transform: translate(0, -50%);
  left: 0;
  width: 100%;
}
.react-flow__resize-control.line.top {
  top: 0;
  border-top-width: 1px;
}
.react-flow__resize-control.line.bottom {
  border-bottom-width: 1px;
  top: 100%;
}

/*! tailwindcss v4.1.18 | MIT License | https://tailwindcss.com */
@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-y-reverse:0;--tw-border-style:solid;--tw-gradient-position:initial;--tw-gradient-from:#0000;--tw-gradient-via:#0000;--tw-gradient-to:#0000;--tw-gradient-stops:initial;--tw-gradient-via-stops:initial;--tw-gradient-from-position:0%;--tw-gradient-via-position:50%;--tw-gradient-to-position:100%;--tw-font-weight:initial;--tw-tracking:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-duration:initial;--tw-ease:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-50:oklch(97.1% .013 17.38);--color-red-200:oklch(88.5% .062 18.334);--color-red-300:oklch(80.8% .114 19.571);--color-red-400:oklch(70.4% .191 22.216);--color-red-500:oklch(63.7% .237 25.331);--color-red-600:oklch(57.7% .245 27.325);--color-red-700:oklch(50.5% .213 27.518);--color-red-800:oklch(44.4% .177 26.899);--color-orange-50:oklch(98% .016 73.684);--color-orange-200:oklch(90.1% .076 70.697);--color-orange-700:oklch(55.3% .195 38.402);--color-yellow-50:oklch(98.7% .026 102.212);--color-yellow-200:oklch(94.5% .129 101.54);--color-yellow-800:oklch(47.6% .114 61.907);--color-green-50:oklch(98.2% .018 155.826);--color-green-200:oklch(92.5% .084 155.995);--color-green-600:oklch(62.7% .194 149.214);--color-green-700:oklch(52.7% .154 150.069);--color-green-800:oklch(44.8% .119 151.328);--color-blue-50:oklch(97% .014 254.604);--color-blue-100:oklch(93.2% .032 255.585);--color-blue-200:oklch(88.2% .059 254.128);--color-blue-500:oklch(62.3% .214 259.815);--color-blue-600:oklch(54.6% .245 262.881);--color-blue-700:oklch(48.8% .243 264.376);--color-blue-800:oklch(42.4% .199 265.638);--color-indigo-50:oklch(96.2% .018 272.314);--color-indigo-100:oklch(93% .034 272.788);--color-indigo-400:oklch(67.3% .182 276.935);--color-indigo-500:oklch(58.5% .233 277.117);--color-indigo-600:oklch(51.1% .262 276.966);--color-indigo-700:oklch(45.7% .24 277.023);--color-indigo-800:oklch(39.8% .195 277.366);--color-purple-50:oklch(97.7% .014 308.299);--color-purple-300:oklch(82.7% .119 306.383);--color-purple-500:oklch(62.7% .265 303.9);--color-pink-300:oklch(82.3% .12 346.018);--color-pink-500:oklch(65.6% .241 354.308);--color-gray-50:oklch(98.5% .002 247.839);--color-gray-100:oklch(96.7% .003 264.542);--color-gray-200:oklch(92.8% .006 264.531);--color-gray-300:oklch(87.2% .01 258.338);--color-gray-400:oklch(70.7% .022 261.325);--color-gray-500:oklch(55.1% .027 264.364);--color-gray-600:oklch(44.6% .03 256.802);--color-gray-700:oklch(37.3% .034 259.733);--color-gray-800:oklch(27.8% .033 256.848);--color-gray-900:oklch(21% .034 264.665);--color-black:#000;--color-white:#fff;--spacing:.25rem;--container-sm:24rem;--container-4xl:56rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-base:1rem;--text-base--line-height:calc(1.5/1);--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-xl:1.25rem;--text-xl--line-height:calc(1.75/1.25);--text-3xl:1.875rem;--text-3xl--line-height:calc(2.25/1.875);--font-weight-normal:400;--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;--tracking-tight:-.025em;--tracking-wide:.025em;--radius-md:.375rem;--radius-lg:.5rem;--radius-2xl:1rem;--ease-out:cubic-bezier(0,0,.2,1);--ease-in-out:cubic-bezier(.4,0,.2,1);--animate-spin:spin 1s linear infinite;--blur-sm:8px;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;-webkit-text-decoration:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab, red, red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}}@layer components;@layer utilities{.visible{visibility:visible}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.static{position:static}.sticky{position:sticky}.inset-0{inset:calc(var(--spacing)*0)}.top-0{top:calc(var(--spacing)*0)}.top-1{top:calc(var(--spacing)*1)}.top-1\/2{top:50%}.top-full{top:100%}.left-0{left:calc(var(--spacing)*0)}.left-1{left:calc(var(--spacing)*1)}.left-1\/2{left:50%}.z-10{z-index:10}.z-50{z-index:50}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.m-0{margin:calc(var(--spacing)*0)}.mx-auto{margin-inline:auto}.mt-0{margin-top:calc(var(--spacing)*0)}.mt-0\.5{margin-top:calc(var(--spacing)*.5)}.mt-1{margin-top:calc(var(--spacing)*1)}.mt-1\.5{margin-top:calc(var(--spacing)*1.5)}.mt-2{margin-top:calc(var(--spacing)*2)}.mt-3{margin-top:calc(var(--spacing)*3)}.mt-4{margin-top:calc(var(--spacing)*4)}.mt-6{margin-top:calc(var(--spacing)*6)}.mb-1{margin-bottom:calc(var(--spacing)*1)}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-3{margin-bottom:calc(var(--spacing)*3)}.mb-4{margin-bottom:calc(var(--spacing)*4)}.mb-6{margin-bottom:calc(var(--spacing)*6)}.ml-1{margin-left:calc(var(--spacing)*1)}.ml-2{margin-left:calc(var(--spacing)*2)}.ml-4{margin-left:calc(var(--spacing)*4)}.block{display:block}.contents{display:contents}.flex{display:flex}.grid{display:grid}.hidden{display:none}.inline-block{display:inline-block}.inline-flex{display:inline-flex}.table{display:table}.h-1{height:calc(var(--spacing)*1)}.h-1\.5{height:calc(var(--spacing)*1.5)}.h-2{height:calc(var(--spacing)*2)}.h-3{height:calc(var(--spacing)*3)}.h-4{height:calc(var(--spacing)*4)}.h-5{height:calc(var(--spacing)*5)}.h-6{height:calc(var(--spacing)*6)}.h-12{height:calc(var(--spacing)*12)}.h-24{height:calc(var(--spacing)*24)}.h-32{height:calc(var(--spacing)*32)}.h-\[96vh\]{height:96vh}.h-full{height:100%}.max-h-24{max-height:calc(var(--spacing)*24)}.max-h-48{max-height:calc(var(--spacing)*48)}.max-h-64{max-height:calc(var(--spacing)*64)}.max-h-\[90vh\]{max-height:90vh}.min-h-0{min-height:calc(var(--spacing)*0)}.w-2{width:calc(var(--spacing)*2)}.w-3{width:calc(var(--spacing)*3)}.w-4{width:calc(var(--spacing)*4)}.w-5{width:calc(var(--spacing)*5)}.w-6{width:calc(var(--spacing)*6)}.w-10{width:calc(var(--spacing)*10)}.w-12{width:calc(var(--spacing)*12)}.w-24{width:calc(var(--spacing)*24)}.w-32{width:calc(var(--spacing)*32)}.w-48{width:calc(var(--spacing)*48)}.w-72{width:calc(var(--spacing)*72)}.w-80{width:calc(var(--spacing)*80)}.w-\[98vw\]{width:98vw}.w-full{width:100%}.max-w-4xl{max-width:var(--container-4xl)}.max-w-\[98\%\]{max-width:98%}.max-w-\[120px\]{max-width:120px}.max-w-\[150px\]{max-width:150px}.max-w-sm{max-width:var(--container-sm)}.min-w-0{min-width:calc(var(--spacing)*0)}.flex-1{flex:1}.flex-shrink{flex-shrink:1}.flex-shrink-0{flex-shrink:0}.grow{flex-grow:1}.-translate-x-1{--tw-translate-x:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-x-1\/2{--tw-translate-x:calc(calc(1/2*100%)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-y-1{--tw-translate-y:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-y-1\/2{--tw-translate-y:calc(calc(1/2*100%)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.rotate-180{rotate:180deg}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.animate-spin{animation:var(--animate-spin)}.cursor-not-allowed{cursor:not-allowed}.cursor-pointer{cursor:pointer}.resize{resize:both}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.items-center{align-items:center}.items-start{align-items:flex-start}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.justify-end{justify-content:flex-end}.gap-1{gap:calc(var(--spacing)*1)}.gap-1\.5{gap:calc(var(--spacing)*1.5)}.gap-2{gap:calc(var(--spacing)*2)}.gap-3{gap:calc(var(--spacing)*3)}.gap-4{gap:calc(var(--spacing)*4)}.gap-5{gap:calc(var(--spacing)*5)}.gap-6{gap:calc(var(--spacing)*6)}:where(.space-y-1>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*1)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*1)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-2>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*2)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*2)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-4>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*4)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*4)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-5>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*5)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*5)*calc(1 - var(--tw-space-y-reverse)))}.self-stretch{align-self:stretch}.truncate{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.overflow-auto{overflow:auto}.overflow-hidden{overflow:hidden}.overflow-x-auto{overflow-x:auto}.overflow-y-auto{overflow-y:auto}.rounded{border-radius:.25rem}.rounded-2xl{border-radius:var(--radius-2xl)}.rounded-full{border-radius:3.40282e38px}.rounded-lg{border-radius:var(--radius-lg)}.rounded-md{border-radius:var(--radius-md)}.rounded-t-lg{border-top-left-radius:var(--radius-lg);border-top-right-radius:var(--radius-lg)}.border{border-style:var(--tw-border-style);border-width:1px}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-b-3{border-bottom-style:var(--tw-border-style);border-bottom-width:3px}.border-\[color\:var\(--swiss-red\)\]{border-color:var(--swiss-red)}.border-blue-200{border-color:var(--color-blue-200)}.border-blue-600{border-color:var(--color-blue-600)}.border-gray-100{border-color:var(--color-gray-100)}.border-gray-200{border-color:var(--color-gray-200)}.border-gray-300{border-color:var(--color-gray-300)}.border-gray-400{border-color:var(--color-gray-400)}.border-green-200{border-color:var(--color-green-200)}.border-indigo-100{border-color:var(--color-indigo-100)}.border-indigo-400{border-color:var(--color-indigo-400)}.border-orange-200{border-color:var(--color-orange-200)}.border-pink-300{border-color:var(--color-pink-300)}.border-purple-300{border-color:var(--color-purple-300)}.border-red-200{border-color:var(--color-red-200)}.border-red-300{border-color:var(--color-red-300)}.border-red-400{border-color:var(--color-red-400)}.border-yellow-200{border-color:var(--color-yellow-200)}.bg-black{background-color:var(--color-black)}.bg-black\/50{background-color:#00000080}@supports (color:color-mix(in lab, red, red)){.bg-black\/50{background-color:color-mix(in oklab,var(--color-black)50%,transparent)}}.bg-blue-50{background-color:var(--color-blue-50)}.bg-blue-100{background-color:var(--color-blue-100)}.bg-blue-600{background-color:var(--color-blue-600)}.bg-gray-50{background-color:var(--color-gray-50)}.bg-gray-100{background-color:var(--color-gray-100)}.bg-gray-200{background-color:var(--color-gray-200)}.bg-gray-300{background-color:var(--color-gray-300)}.bg-gray-600{background-color:var(--color-gray-600)}.bg-gray-700{background-color:var(--color-gray-700)}.bg-gray-900{background-color:var(--color-gray-900)}.bg-green-50{background-color:var(--color-green-50)}.bg-indigo-50{background-color:var(--color-indigo-50)}.bg-indigo-600{background-color:var(--color-indigo-600)}.bg-orange-50{background-color:var(--color-orange-50)}.bg-red-50{background-color:var(--color-red-50)}.bg-red-600{background-color:var(--color-red-600)}.bg-white{background-color:var(--color-white)}.bg-white\/90{background-color:#ffffffe6}@supports (color:color-mix(in lab, red, red)){.bg-white\/90{background-color:color-mix(in oklab,var(--color-white)90%,transparent)}}.bg-yellow-50{background-color:var(--color-yellow-50)}.bg-gradient-to-br{--tw-gradient-position:to bottom right in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.bg-gradient-to-r{--tw-gradient-position:to right in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.from-blue-600{--tw-gradient-from:var(--color-blue-600);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-gray-50{--tw-gradient-from:var(--color-gray-50);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-gray-400{--tw-gradient-from:var(--color-gray-400);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-gray-500{--tw-gradient-from:var(--color-gray-500);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-gray-600{--tw-gradient-from:var(--color-gray-600);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-green-600{--tw-gradient-from:var(--color-green-600);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-indigo-50{--tw-gradient-from:var(--color-indigo-50);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-purple-500{--tw-gradient-from:var(--color-purple-500);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-blue-700{--tw-gradient-to:var(--color-blue-700);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-gray-100{--tw-gradient-to:var(--color-gray-100);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-gray-500{--tw-gradient-to:var(--color-gray-500);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-gray-600{--tw-gradient-to:var(--color-gray-600);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-gray-700{--tw-gradient-to:var(--color-gray-700);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-green-700{--tw-gradient-to:var(--color-green-700);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-pink-500{--tw-gradient-to:var(--color-pink-500);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-purple-50{--tw-gradient-to:var(--color-purple-50);--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.p-0{padding:calc(var(--spacing)*0)}.p-1{padding:calc(var(--spacing)*1)}.p-1\.5{padding:calc(var(--spacing)*1.5)}.p-2{padding:calc(var(--spacing)*2)}.p-3{padding:calc(var(--spacing)*3)}.p-4{padding:calc(var(--spacing)*4)}.p-6{padding:calc(var(--spacing)*6)}.px-1{padding-inline:calc(var(--spacing)*1)}.px-1\.5{padding-inline:calc(var(--spacing)*1.5)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-2\.5{padding-inline:calc(var(--spacing)*2.5)}.px-3{padding-inline:calc(var(--spacing)*3)}.px-4{padding-inline:calc(var(--spacing)*4)}.px-5{padding-inline:calc(var(--spacing)*5)}.px-6{padding-inline:calc(var(--spacing)*6)}.px-8{padding-inline:calc(var(--spacing)*8)}.py-0{padding-block:calc(var(--spacing)*0)}.py-0\.5{padding-block:calc(var(--spacing)*.5)}.py-1{padding-block:calc(var(--spacing)*1)}.py-1\.5{padding-block:calc(var(--spacing)*1.5)}.py-2{padding-block:calc(var(--spacing)*2)}.py-2\.5{padding-block:calc(var(--spacing)*2.5)}.py-3{padding-block:calc(var(--spacing)*3)}.py-4{padding-block:calc(var(--spacing)*4)}.py-8{padding-block:calc(var(--spacing)*8)}.pt-2{padding-top:calc(var(--spacing)*2)}.pl-2{padding-left:calc(var(--spacing)*2)}.pl-4{padding-left:calc(var(--spacing)*4)}.text-center{text-align:center}.text-left{text-align:left}.text-right{text-align:right}.font-mono{font-family:var(--font-mono)}.text-3xl{font-size:var(--text-3xl);line-height:var(--tw-leading,var(--text-3xl--line-height))}.text-base{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xl{font-size:var(--text-xl);line-height:var(--tw-leading,var(--text-xl--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.text-\[10px\]{font-size:10px}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-normal{--tw-font-weight:var(--font-weight-normal);font-weight:var(--font-weight-normal)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.tracking-tight{--tw-tracking:var(--tracking-tight);letter-spacing:var(--tracking-tight)}.tracking-wide{--tw-tracking:var(--tracking-wide);letter-spacing:var(--tracking-wide)}.whitespace-nowrap{white-space:nowrap}.text-\[color\:var\(--swiss-red\)\]{color:var(--swiss-red)}.text-black{color:var(--color-black)}.text-blue-600{color:var(--color-blue-600)}.text-blue-700{color:var(--color-blue-700)}.text-gray-300{color:var(--color-gray-300)}.text-gray-400{color:var(--color-gray-400)}.text-gray-500{color:var(--color-gray-500)}.text-gray-600{color:var(--color-gray-600)}.text-gray-700{color:var(--color-gray-700)}.text-gray-800{color:var(--color-gray-800)}.text-gray-900{color:var(--color-gray-900)}.text-green-700{color:var(--color-green-700)}.text-indigo-600{color:var(--color-indigo-600)}.text-indigo-700{color:var(--color-indigo-700)}.text-orange-700{color:var(--color-orange-700)}.text-red-600{color:var(--color-red-600)}.text-red-700{color:var(--color-red-700)}.text-red-800{color:var(--color-red-800)}.text-white{color:var(--color-white)}.text-yellow-800{color:var(--color-yellow-800)}.lowercase{text-transform:lowercase}.uppercase{text-transform:uppercase}.italic{font-style:italic}.opacity-25{opacity:.25}.opacity-75{opacity:.75}.shadow-2xl{--tw-shadow:0 25px 50px -12px var(--tw-shadow-color,#00000040);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xl{--tw-shadow:0 20px 25px -5px var(--tw-shadow-color,#0000001a),0 8px 10px -6px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.blur{--tw-blur:blur(8px);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.invert{--tw-invert:invert(100%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.backdrop-blur-sm{--tw-backdrop-blur:blur(var(--blur-sm));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.backdrop-filter{-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-colors{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform{transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.duration-150{--tw-duration:.15s;transition-duration:.15s}.duration-300{--tw-duration:.3s;transition-duration:.3s}.ease-in-out{--tw-ease:var(--ease-in-out);transition-timing-function:var(--ease-in-out)}.ease-out{--tw-ease:var(--ease-out);transition-timing-function:var(--ease-out)}.outline-none{--tw-outline-style:none;outline-style:none}@media (hover:hover){.hover\:border-gray-300:hover{border-color:var(--color-gray-300)}.hover\:border-gray-400:hover{border-color:var(--color-gray-400)}.hover\:bg-blue-700:hover{background-color:var(--color-blue-700)}.hover\:bg-gray-50:hover{background-color:var(--color-gray-50)}.hover\:bg-gray-100:hover{background-color:var(--color-gray-100)}.hover\:bg-gray-300:hover{background-color:var(--color-gray-300)}.hover\:bg-gray-800:hover{background-color:var(--color-gray-800)}.hover\:bg-indigo-100:hover{background-color:var(--color-indigo-100)}.hover\:bg-red-700:hover{background-color:var(--color-red-700)}.hover\:text-gray-600:hover{color:var(--color-gray-600)}.hover\:text-gray-700:hover{color:var(--color-gray-700)}.hover\:text-gray-800:hover{color:var(--color-gray-800)}.hover\:text-gray-900:hover{color:var(--color-gray-900)}.hover\:shadow-lg:hover{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.hover\:shadow-md:hover{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}}.focus\:border-blue-500:focus{border-color:var(--color-blue-500)}.focus\:ring-1:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\:ring-blue-500:focus{--tw-ring-color:var(--color-blue-500)}.disabled\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\:opacity-50:disabled{opacity:.5}.disabled\:shadow-none:disabled{--tw-shadow:0 0 #0000;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}}:root{--swiss-red:#d62828;--swiss-black:#0b0b0b;--swiss-white:#fff;--swiss-gray-100:#f5f5f5;--swiss-gray-200:#e6e6e6;--swiss-gray-300:#d1d5db;--swiss-gray-600:#4b5563;--swiss-muted:#6b7280;--swiss-radius-sm:6px}html,body,#__next,#root{background:var(--swiss-white);height:100%;color:var(--swiss-black);margin:0;padding:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial}body>*{height:100%}.swiss-card{background:var(--swiss-white);border-left:6px solid var(--swiss-red);border-radius:var(--swiss-radius-sm);color:var(--swiss-black);box-shadow:0 6px 18px #0b0b0b0f}.swiss-header{border-bottom:1px solid var(--swiss-gray-200);padding:.75rem 1rem}.swiss-header h1,.swiss-header h2,.swiss-header h3{letter-spacing:-.02em;margin:0;font-weight:700}.swiss-btn{background:var(--swiss-black);color:var(--swiss-white);border:2px solid #0000000f;border-radius:6px;align-items:center;gap:.5rem;padding:.5rem .9rem;font-weight:600;transition:transform .12s,box-shadow .12s,opacity .12s;display:inline-flex}.swiss-btn:hover{transform:translateY(-1px);box-shadow:0 6px 16px #0b0b0b14}.swiss-btn[disabled]{opacity:.5;box-shadow:none;transform:none}.swiss-btn--secondary{color:var(--swiss-black);border:1px solid var(--swiss-gray-200);background:0 0}.swiss-btn--accent{background:var(--swiss-red);color:var(--swiss-white);border-color:var(--swiss-red)}.swiss-badge{text-transform:uppercase;background:var(--swiss-white);color:var(--swiss-black);border:1px solid var(--swiss-gray-200);border-radius:4px;padding:.2rem .5rem;font-size:.7rem;font-weight:700;display:inline-block}.swiss-muted{color:var(--swiss-muted)}.swiss-modal-inner{background:var(--swiss-white);border-left:6px solid var(--swiss-red);border-radius:10px;box-shadow:0 20px 60px #0b0b0b1f}.swiss-checkbox{border:2px solid var(--swiss-gray-300);background:var(--swiss-white);vertical-align:middle;border-radius:3px;width:16px;height:16px;transition:background .12s,border-color .12s;display:inline-block}.swiss-checkbox:checked{background:var(--swiss-red);border-color:var(--swiss-red)}.swiss-checkbox:focus{outline:3px solid #d632281f}.swiss-checkbox-label{align-items:center;gap:.5rem;display:inline-flex}.swiss-table thead th{color:var(--swiss-muted);font-weight:700}.swiss-table tbody td{color:var(--swiss-black)}.swiss-flow-btn{letter-spacing:.02em;font-weight:700}@media (max-width:640px){.swiss-card{border-left-width:4px;padding:.75rem}.swiss-header{padding:.5rem .75rem}}@property --tw-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-z{syntax:"*";inherits:false;initial-value:0}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-gradient-position{syntax:"*";inherits:false}@property --tw-gradient-from{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-via{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-to{syntax:"<color>";inherits:false;initial-value:#0000}@property --tw-gradient-stops{syntax:"*";inherits:false}@property --tw-gradient-via-stops{syntax:"*";inherits:false}@property --tw-gradient-from-position{syntax:"<length-percentage>";inherits:false;initial-value:0%}@property --tw-gradient-via-position{syntax:"<length-percentage>";inherits:false;initial-value:50%}@property --tw-gradient-to-position{syntax:"<length-percentage>";inherits:false;initial-value:100%}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-tracking{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-backdrop-blur{syntax:"*";inherits:false}@property --tw-backdrop-brightness{syntax:"*";inherits:false}@property --tw-backdrop-contrast{syntax:"*";inherits:false}@property --tw-backdrop-grayscale{syntax:"*";inherits:false}@property --tw-backdrop-hue-rotate{syntax:"*";inherits:false}@property --tw-backdrop-invert{syntax:"*";inherits:false}@property --tw-backdrop-opacity{syntax:"*";inherits:false}@property --tw-backdrop-saturate{syntax:"*";inherits:false}@property --tw-backdrop-sepia{syntax:"*";inherits:false}@property --tw-duration{syntax:"*";inherits:false}@property --tw-ease{syntax:"*";inherits:false}@keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>
<body>
  <div id="root"></div>
  <script>
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
    get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
  }) : x2)(function(x2) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x2 + '" is not supported');
  });
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  // node_modules/react/cjs/react.production.js
  var require_react_production = __commonJS({
    "node_modules/react/cjs/react.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler");
      var REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense");
      var REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo");
      var REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy");
      var REACT_ACTIVITY_TYPE = /* @__PURE__ */ Symbol.for("react.activity");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      };
      var assign = Object.assign;
      var emptyObject = {};
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      var isArrayImpl = Array.isArray;
      function noop3() {
      }
      var ReactSharedInternals = { H: null, A: null, T: null, S: null };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function ReactElement(type, key, props) {
        var refProp = props.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== refProp ? refProp : null,
          props
        };
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        return ReactElement(oldElement.type, newKey, oldElement.props);
      }
      function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      var userProvidedKeyEscapeRegex = /\/+/g;
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop3, noop3) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children3, array2, escapedPrefix, nameSoFar, callback) {
        var type = typeof children3;
        if ("undefined" === type || "boolean" === type) children3 = null;
        var invokeCallback = false;
        if (null === children3) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children3.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children3._init, mapIntoArray(
                    invokeCallback(children3._payload),
                    array2,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback)
          return callback = callback(children3), invokeCallback = "" === nameSoFar ? "." + getElementKey(children3, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array2, escapedPrefix, "", function(c2) {
            return c2;
          })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || children3 && children3.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + invokeCallback
          )), array2.push(callback)), 1;
        invokeCallback = 0;
        var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children3))
          for (var i2 = 0; i2 < children3.length; i2++)
            nameSoFar = children3[i2], type = nextNamePrefix + getElementKey(nameSoFar, i2), invokeCallback += mapIntoArray(
              nameSoFar,
              array2,
              escapedPrefix,
              type,
              callback
            );
        else if (i2 = getIteratorFn(children3), "function" === typeof i2)
          for (children3 = i2.call(children3), i2 = 0; !(nameSoFar = children3.next()).done; )
            nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i2++), invokeCallback += mapIntoArray(
              nameSoFar,
              array2,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children3.then)
            return mapIntoArray(
              resolveThenable(children3),
              array2,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array2 = String(children3);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array2 ? "object with keys {" + Object.keys(children3).join(", ") + "}" : array2) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children3, func, context) {
        if (null == children3) return children3;
        var result = [], count = 0;
        mapIntoArray(children3, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status) return payload._result.default;
        throw payload._result;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
      var Children = {
        map: mapChildren,
        forEach: function(children3, forEachFunc, forEachContext) {
          mapChildren(
            children3,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children3) {
          var n2 = 0;
          mapChildren(children3, function() {
            n2++;
          });
          return n2;
        },
        toArray: function(children3) {
          return mapChildren(children3, function(child) {
            return child;
          }) || [];
        },
        only: function(children3) {
          if (!isValidElement(children3))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children3;
        }
      };
      exports.Activity = REACT_ACTIVITY_TYPE;
      exports.Children = Children;
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(size) {
          return ReactSharedInternals.H.useMemoCache(size);
        }
      };
      exports.cache = function(fn2) {
        return function() {
          return fn2.apply(null, arguments);
        };
      };
      exports.cacheSignal = function() {
        return null;
      };
      exports.cloneElement = function(element, config, children3) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key;
        if (null != config)
          for (propName in void 0 !== config.key && (key = "" + config.key), config)
            !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children3;
        else if (1 < propName) {
          for (var childArray = Array(propName), i2 = 0; i2 < propName; i2++)
            childArray[i2] = arguments[i2 + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, props);
      };
      exports.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        return defaultValue;
      };
      exports.createElement = function(type, config, children3) {
        var propName, props = {}, key = null;
        if (null != config)
          for (propName in void 0 !== config.key && (key = "" + config.key), config)
            hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) props.children = children3;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), i2 = 0; i2 < childrenLength; i2++)
            childArray[i2] = arguments[i2 + 2];
          props.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === props[propName] && (props[propName] = childrenLength[propName]);
        return ReactElement(type, key, props);
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(render) {
        return { $$typeof: REACT_FORWARD_REF_TYPE, render };
      };
      exports.isValidElement = isValidElement;
      exports.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports.memo = function(type, compare2) {
        return {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare2 ? null : compare2
        };
      };
      exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop3, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function() {
        return ReactSharedInternals.H.useCacheRefresh();
      };
      exports.use = function(usable) {
        return ReactSharedInternals.H.use(usable);
      };
      exports.useActionState = function(action, initialState2, permalink) {
        return ReactSharedInternals.H.useActionState(action, initialState2, permalink);
      };
      exports.useCallback = function(callback, deps) {
        return ReactSharedInternals.H.useCallback(callback, deps);
      };
      exports.useContext = function(Context) {
        return ReactSharedInternals.H.useContext(Context);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(value, initialValue) {
        return ReactSharedInternals.H.useDeferredValue(value, initialValue);
      };
      exports.useEffect = function(create2, deps) {
        return ReactSharedInternals.H.useEffect(create2, deps);
      };
      exports.useEffectEvent = function(callback) {
        return ReactSharedInternals.H.useEffectEvent(callback);
      };
      exports.useId = function() {
        return ReactSharedInternals.H.useId();
      };
      exports.useImperativeHandle = function(ref, create2, deps) {
        return ReactSharedInternals.H.useImperativeHandle(ref, create2, deps);
      };
      exports.useInsertionEffect = function(create2, deps) {
        return ReactSharedInternals.H.useInsertionEffect(create2, deps);
      };
      exports.useLayoutEffect = function(create2, deps) {
        return ReactSharedInternals.H.useLayoutEffect(create2, deps);
      };
      exports.useMemo = function(create2, deps) {
        return ReactSharedInternals.H.useMemo(create2, deps);
      };
      exports.useOptimistic = function(passthrough, reducer) {
        return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function(reducer, initialArg, init2) {
        return ReactSharedInternals.H.useReducer(reducer, initialArg, init2);
      };
      exports.useRef = function(initialValue) {
        return ReactSharedInternals.H.useRef(initialValue);
      };
      exports.useState = function(initialState2) {
        return ReactSharedInternals.H.useState(initialState2);
      };
      exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return ReactSharedInternals.H.useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function() {
        return ReactSharedInternals.H.useTransition();
      };
      exports.version = "19.2.3";
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.production.js
  var require_scheduler_production = __commonJS({
    "node_modules/scheduler/cjs/scheduler.production.js"(exports) {
      "use strict";
      function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a: for (; 0 < index; ) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare2(parent, node))
            heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
          else break a;
        }
      }
      function peek(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
            var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare2(left, last))
              rightIndex < length && 0 > compare2(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
            else if (rightIndex < length && 0 > compare2(right, last))
              heap[index] = right, heap[rightIndex] = last, index = rightIndex;
            else break a;
          }
        }
        return first;
      }
      function compare2(a2, b2) {
        var diff = a2.sortIndex - b2.sortIndex;
        return 0 !== diff ? diff : a2.id - b2.id;
      }
      exports.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var localPerformance;
      var localDate;
      var initialTime;
      var taskQueue = [];
      var timerQueue = [];
      var taskIdCounter2 = 1;
      var currentTask = null;
      var currentPriorityLevel = 3;
      var isPerformingWork = false;
      var isHostCallbackScheduled = false;
      var isHostTimeoutScheduled = false;
      var needsPaint = false;
      var localSetTimeout = "function" === typeof setTimeout ? setTimeout : null;
      var localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null;
      var localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
      function advanceTimers(currentTime) {
        for (var timer2 = peek(timerQueue); null !== timer2; ) {
          if (null === timer2.callback) pop(timerQueue);
          else if (timer2.startTime <= currentTime)
            pop(timerQueue), timer2.sortIndex = timer2.expirationTime, push(taskQueue, timer2);
          else break;
          timer2 = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek(taskQueue))
            isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
          else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
      }
      var isMessageLoopRunning = false;
      var taskTimeoutID = -1;
      var frameInterval = 5;
      var startTime = -1;
      function shouldYieldToHost() {
        return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
      }
      function performWorkUntilDeadline() {
        needsPaint = false;
        if (isMessageLoopRunning) {
          var currentTime = exports.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      var schedulePerformWorkUntilDeadline;
      if ("function" === typeof localSetImmediate)
        schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      var channel;
      var port;
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_requestPaint = function() {
        needsPaint = true;
      };
      exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout2 = -1;
            break;
          case 2:
            timeout2 = 250;
            break;
          case 5:
            timeout2 = 1073741823;
            break;
          case 4:
            timeout2 = 1e4;
            break;
          default:
            timeout2 = 5e3;
        }
        timeout2 = options + timeout2;
        priorityLevel = {
          id: taskIdCounter2++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout2,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout2, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports.unstable_shouldYield = shouldYieldToHost;
      exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_scheduler_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.production.js
  var require_react_dom_production = __commonJS({
    "node_modules/react-dom/cjs/react-dom.production.js"(exports) {
      "use strict";
      var React6 = require_react();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i2 = 2; i2 < arguments.length; i2++)
            url += "&args[]=" + encodeURIComponent(arguments[i2]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function noop3() {
      }
      var Internals = {
        d: {
          f: noop3,
          r: function() {
            throw Error(formatProdErrorMessage(522));
          },
          D: noop3,
          C: noop3,
          L: noop3,
          m: noop3,
          X: noop3,
          S: noop3,
          M: noop3
        },
        p: 0,
        findDOMNode: null
      };
      var REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal");
      function createPortal$1(children3, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children: children3,
          containerInfo,
          implementation
        };
      }
      var ReactSharedInternals = React6.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      function getCrossOriginStringAs(as, input) {
        if ("font" === as) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports.createPortal = function(children3, container2) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container2 || 1 !== container2.nodeType && 9 !== container2.nodeType && 11 !== container2.nodeType)
          throw Error(formatProdErrorMessage(299));
        return createPortal$1(children3, container2, null, key);
      };
      exports.flushSync = function(fn2) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn2) return fn2();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
        }
      };
      exports.preconnect = function(href, options) {
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      exports.prefetchDNS = function(href) {
        "string" === typeof href && Internals.d.D(href);
      };
      exports.preinit = function(href, options) {
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      exports.preinitModule = function(href, options) {
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as) {
              var crossOrigin = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              );
              Internals.d.M(href, {
                crossOrigin,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
            }
          } else null == options && Internals.d.M(href);
      };
      exports.preload = function(href, options) {
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
          Internals.d.L(href, as, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      exports.preloadModule = function(href, options) {
        if ("string" === typeof href)
          if (options) {
            var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
            Internals.d.m(href, {
              as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0
            });
          } else Internals.d.m(href);
      };
      exports.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      exports.unstable_batchedUpdates = function(fn2, a2) {
        return fn2(a2);
      };
      exports.useFormState = function(action, initialState2, permalink) {
        return ReactSharedInternals.H.useFormState(action, initialState2, permalink);
      };
      exports.useFormStatus = function() {
        return ReactSharedInternals.H.useHostTransitionStatus();
      };
      exports.version = "19.2.3";
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom-client.production.js
  var require_react_dom_client_production = __commonJS({
    "node_modules/react-dom/cjs/react-dom-client.production.js"(exports) {
      "use strict";
      var Scheduler = require_scheduler();
      var React6 = require_react();
      var ReactDOM = require_react_dom();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i2 = 2; i2 < arguments.length; i2++)
            url += "&args[]=" + encodeURIComponent(arguments[i2]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function isValidContainer(node) {
        return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
      }
      function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate) for (; node.return; ) node = node.return;
        else {
          fiber = node;
          do
            node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
          while (fiber);
        }
        return 3 === node.tag ? nearestMounted : null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (13 === fiber.tag) {
          var suspenseState = fiber.memoizedState;
          null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
          if (null !== suspenseState) return suspenseState.dehydrated;
        }
        return null;
      }
      function getActivityInstanceFromFiber(fiber) {
        if (31 === fiber.tag) {
          var activityState = fiber.memoizedState;
          null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
          if (null !== activityState) return activityState.dehydrated;
        }
        return null;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw Error(formatProdErrorMessage(188));
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          alternate = getNearestMountedFiber(fiber);
          if (null === alternate) throw Error(formatProdErrorMessage(188));
          return alternate !== fiber ? null : fiber;
        }
        for (var a2 = fiber, b2 = alternate; ; ) {
          var parentA = a2.return;
          if (null === parentA) break;
          var parentB = parentA.alternate;
          if (null === parentB) {
            b2 = parentA.return;
            if (null !== b2) {
              a2 = b2;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (parentB = parentA.child; parentB; ) {
              if (parentB === a2) return assertIsMounted(parentA), fiber;
              if (parentB === b2) return assertIsMounted(parentA), alternate;
              parentB = parentB.sibling;
            }
            throw Error(formatProdErrorMessage(188));
          }
          if (a2.return !== b2.return) a2 = parentA, b2 = parentB;
          else {
            for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
              if (child$0 === a2) {
                didFindChild = true;
                a2 = parentA;
                b2 = parentB;
                break;
              }
              if (child$0 === b2) {
                didFindChild = true;
                b2 = parentA;
                a2 = parentB;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) {
              for (child$0 = parentB.child; child$0; ) {
                if (child$0 === a2) {
                  didFindChild = true;
                  a2 = parentB;
                  b2 = parentA;
                  break;
                }
                if (child$0 === b2) {
                  didFindChild = true;
                  b2 = parentB;
                  a2 = parentA;
                  break;
                }
                child$0 = child$0.sibling;
              }
              if (!didFindChild) throw Error(formatProdErrorMessage(189));
            }
          }
          if (a2.alternate !== b2) throw Error(formatProdErrorMessage(190));
        }
        if (3 !== a2.tag) throw Error(formatProdErrorMessage(188));
        return a2.stateNode.current === a2 ? fiber : alternate;
      }
      function findCurrentHostFiberImpl(node) {
        var tag = node.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
        for (node = node.child; null !== node; ) {
          tag = findCurrentHostFiberImpl(node);
          if (null !== tag) return tag;
          node = node.sibling;
        }
        return null;
      }
      var assign = Object.assign;
      var REACT_LEGACY_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.element");
      var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler");
      var REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo");
      var REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy");
      var REACT_ACTIVITY_TYPE = /* @__PURE__ */ Symbol.for("react.activity");
      var REACT_MEMO_CACHE_SENTINEL = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for("react.client.reference");
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x2) {
              }
          }
        return null;
      }
      var isArrayImpl = Array.isArray;
      var ReactSharedInternals = React6.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      var ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      var sharedNotPendingObject = {
        pending: false,
        data: null,
        method: null,
        action: null
      };
      var valueStack = [];
      var index = -1;
      function createCursor(defaultValue) {
        return { current: defaultValue };
      }
      function pop(cursor) {
        0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
      }
      function push(cursor, value) {
        index++;
        valueStack[index] = cursor.current;
        cursor.current = value;
      }
      var contextStackCursor = createCursor(null);
      var contextFiberStackCursor = createCursor(null);
      var rootInstanceStackCursor = createCursor(null);
      var hostTransitionProviderCursor = createCursor(null);
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance);
        push(contextFiberStackCursor, fiber);
        push(contextStackCursor, null);
        switch (nextRootInstance.nodeType) {
          case 9:
          case 11:
            fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
            break;
          default:
            if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
              nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
            else
              switch (fiber) {
                case "svg":
                  fiber = 1;
                  break;
                case "math":
                  fiber = 2;
                  break;
                default:
                  fiber = 0;
              }
        }
        pop(contextStackCursor);
        push(contextStackCursor, fiber);
      }
      function popHostContainer() {
        pop(contextStackCursor);
        pop(contextFiberStackCursor);
        pop(rootInstanceStackCursor);
      }
      function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
        var context = contextStackCursor.current;
        var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
        context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
      }
      var prefix;
      var suffix;
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix)
          try {
            throw Error();
          } catch (x2) {
            var match = x2.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || "";
            suffix = -1 < x2.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x2.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix + name + suffix;
      }
      var reentry = false;
      function describeNativeComponentFrame(fn2, construct) {
        if (!fn2 || reentry) return "";
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x2) {
                      var control = x2;
                    }
                    Reflect.construct(fn2, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$1) {
                      control = x$1;
                    }
                    fn2.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$2) {
                    control = x$2;
                  }
                  (Fake = fn2()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
              RunInRootFrame++;
            for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
              for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
                namePropDescriptor--;
            for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
              if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                  do
                    if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                      var frame2 = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                      fn2.displayName && frame2.includes("<anonymous>") && (frame2 = frame2.replace("<anonymous>", fn2.displayName));
                      return frame2;
                    }
                  while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                }
                break;
              }
          }
        } finally {
          reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
        }
        return (previousPrepareStackTrace = fn2 ? fn2.displayName || fn2.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
      }
      function describeFiber(fiber, childFiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return describeBuiltInComponentFrame(fiber.type);
          case 16:
            return describeBuiltInComponentFrame("Lazy");
          case 13:
            return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
          case 19:
            return describeBuiltInComponentFrame("SuspenseList");
          case 0:
          case 15:
            return describeNativeComponentFrame(fiber.type, false);
          case 11:
            return describeNativeComponentFrame(fiber.type.render, false);
          case 1:
            return describeNativeComponentFrame(fiber.type, true);
          case 31:
            return describeBuiltInComponentFrame("Activity");
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "", previous = null;
          do
            info += describeFiber(workInProgress2, previous), previous = workInProgress2, workInProgress2 = workInProgress2.return;
          while (workInProgress2);
          return info;
        } catch (x2) {
          return "\nError generating stack: " + x2.message + "\n" + x2.stack;
        }
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var scheduleCallback$3 = Scheduler.unstable_scheduleCallback;
      var cancelCallback$1 = Scheduler.unstable_cancelCallback;
      var shouldYield = Scheduler.unstable_shouldYield;
      var requestPaint = Scheduler.unstable_requestPaint;
      var now2 = Scheduler.unstable_now;
      var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
      var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
      var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
      var NormalPriority$1 = Scheduler.unstable_NormalPriority;
      var LowPriority = Scheduler.unstable_LowPriority;
      var IdlePriority = Scheduler.unstable_IdlePriority;
      var log$1 = Scheduler.log;
      var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
      var rendererID = null;
      var injectedHook = null;
      function setIsStrictModeForDevtools(newIsStrictMode) {
        "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && "function" === typeof injectedHook.setStrictMode)
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err) {
          }
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x2) {
        x2 >>>= 0;
        return 0 === x2 ? 32 : 31 - (log(x2) / LN2 | 0) | 0;
      }
      var nextTransitionUpdateLane = 256;
      var nextTransitionDeferredLane = 262144;
      var nextRetryLane = 4194304;
      function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes) return pendingSyncLanes;
        switch (lanes & -lanes) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
            return 128;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
            return lanes & 261888;
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return lanes & 3932160;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return lanes & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return lanes;
        }
      }
      function getNextLanes(root3, wipLanes, rootHasPendingCommit) {
        var pendingLanes = root3.pendingLanes;
        if (0 === pendingLanes) return 0;
        var nextLanes = 0, suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes;
        root3 = root3.warmLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
      }
      function checkIfRootIsPrerendering(root3, renderLanes2) {
        return 0 === (root3.pendingLanes & ~(root3.suspendedLanes & ~root3.pingedLanes) & renderLanes2);
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case 1:
          case 2:
          case 4:
          case 8:
          case 64:
            return currentTime + 250;
          case 16:
          case 32:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return currentTime + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i2 = 0; 31 > i2; i2++) laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated$1(root3, updateLane) {
        root3.pendingLanes |= updateLane;
        268435456 !== updateLane && (root3.suspendedLanes = 0, root3.pingedLanes = 0, root3.warmLanes = 0);
      }
      function markRootFinished(root3, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
        var previouslyPendingLanes = root3.pendingLanes;
        root3.pendingLanes = remainingLanes;
        root3.suspendedLanes = 0;
        root3.pingedLanes = 0;
        root3.warmLanes = 0;
        root3.expiredLanes &= remainingLanes;
        root3.entangledLanes &= remainingLanes;
        root3.errorRecoveryDisabledLanes &= remainingLanes;
        root3.shellSuspendCounter = 0;
        var entanglements = root3.entanglements, expirationTimes = root3.expirationTimes, hiddenUpdates = root3.hiddenUpdates;
        for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
          var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
          entanglements[index$7] = 0;
          expirationTimes[index$7] = -1;
          var hiddenUpdatesForLane = hiddenUpdates[index$7];
          if (null !== hiddenUpdatesForLane)
            for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
              var update = hiddenUpdatesForLane[index$7];
              null !== update && (update.lane &= -536870913);
            }
          remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, 0);
        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root3.tag && (root3.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
      }
      function markSpawnedDeferredLane(root3, spawnedLane, entangledLanes) {
        root3.pendingLanes |= spawnedLane;
        root3.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root3.entangledLanes |= spawnedLane;
        root3.entanglements[spawnedLaneIndex] = root3.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
      }
      function markRootEntangled(root3, entangledLanes) {
        var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
        for (root3 = root3.entanglements; rootEntangledLanes; ) {
          var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
          lane & entangledLanes | root3[index$8] & entangledLanes && (root3[index$8] |= entangledLanes);
          rootEntangledLanes &= ~lane;
        }
      }
      function getBumpedLaneForHydration(root3, renderLanes2) {
        var renderLane = renderLanes2 & -renderLanes2;
        renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
        return 0 !== (renderLane & (root3.suspendedLanes | renderLanes2)) ? 0 : renderLane;
      }
      function getBumpedLaneForHydrationByLane(lane) {
        switch (lane) {
          case 2:
            lane = 1;
            break;
          case 8:
            lane = 4;
            break;
          case 32:
            lane = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            lane = 128;
            break;
          case 268435456:
            lane = 134217728;
            break;
          default:
            lane = 0;
        }
        return lane;
      }
      function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
      }
      function resolveUpdatePriority() {
        var updatePriority = ReactDOMSharedInternals.p;
        if (0 !== updatePriority) return updatePriority;
        updatePriority = window.event;
        return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
      }
      function runWithPriority(priority, fn2) {
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          return ReactDOMSharedInternals.p = priority, fn2();
        } finally {
          ReactDOMSharedInternals.p = previousPriority;
        }
      }
      var randomKey = Math.random().toString(36).slice(2);
      var internalInstanceKey = "__reactFiber$" + randomKey;
      var internalPropsKey = "__reactProps$" + randomKey;
      var internalContainerInstanceKey = "__reactContainer$" + randomKey;
      var internalEventHandlersKey = "__reactEvents$" + randomKey;
      var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
      var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
      var internalRootNodeResourcesKey = "__reactResources$" + randomKey;
      var internalHoistableMarker = "__reactMarker$" + randomKey;
      function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) return targetInst;
        for (var parentNode = targetNode.parentNode; parentNode; ) {
          if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
            parentNode = targetInst.alternate;
            if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
              for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
                if (parentNode = targetNode[internalInstanceKey]) return parentNode;
                targetNode = getParentHydrationBoundary(targetNode);
              }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
          var tag = node.tag;
          if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
            return node;
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        var tag = inst.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
        throw Error(formatProdErrorMessage(33));
      }
      function getResourcesFromRoot(root3) {
        var resources = root3[internalRootNodeResourcesKey];
        resources || (resources = root3[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
        return resources;
      }
      function markNodeAsHoistable(node) {
        node[internalHoistableMarker] = true;
      }
      var allNativeEvents = /* @__PURE__ */ new Set();
      var registrationNameDependencies = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        registrationNameDependencies[registrationName] = dependencies;
        for (registrationName = 0; registrationName < dependencies.length; registrationName++)
          allNativeEvents.add(dependencies[registrationName]);
      }
      var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      );
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        return false;
      }
      function setValueForAttribute(node, name, value) {
        if (isAttributeNameSafe(name))
          if (null === value) node.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                node.removeAttribute(name);
                return;
              case "boolean":
                var prefix$10 = name.toLowerCase().slice(0, 5);
                if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
                  node.removeAttribute(name);
                  return;
                }
            }
            node.setAttribute(name, "" + value);
          }
      }
      function setValueForKnownAttribute(node, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttribute(name, "" + value);
        }
      }
      function setValueForNamespacedAttribute(node, namespace, name, value) {
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node.removeAttribute(name);
              return;
          }
          node.setAttributeNS(namespace, name, "" + value);
        }
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "bigint":
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value;
          case "object":
            return value;
          default:
            return "";
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
      }
      function trackValueOnNode(node, valueField, currentValue) {
        var descriptor = Object.getOwnPropertyDescriptor(
          node.constructor.prototype,
          valueField
        );
        if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
          var get3 = descriptor.get, set3 = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get3.call(this);
            },
            set: function(value) {
              currentValue = "" + value;
              set3.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          return {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              currentValue = "" + value;
            },
            stopTracking: function() {
              node._valueTracker = null;
              delete node[valueField];
            }
          };
        }
      }
      function track(node) {
        if (!node._valueTracker) {
          var valueField = isCheckable(node) ? "checked" : "value";
          node._valueTracker = trackValueOnNode(
            node,
            valueField,
            "" + node[valueField]
          );
        }
      }
      function updateValueIfChanged(node) {
        if (!node) return false;
        var tracker = node._valueTracker;
        if (!tracker) return true;
        var lastValue = tracker.getValue();
        var value = "";
        node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
        node = value;
        return node !== lastValue ? (tracker.setValue(node), true) : false;
      }
      function getActiveElement(doc2) {
        doc2 = doc2 || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof doc2) return null;
        try {
          return doc2.activeElement || doc2.body;
        } catch (e2) {
          return doc2.body;
        }
      }
      var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
      function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
        return value.replace(
          escapeSelectorAttributeValueInsideDoubleQuotesRegex,
          function(ch) {
            return "\\" + ch.charCodeAt(0).toString(16) + " ";
          }
        );
      }
      function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
        element.name = "";
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
        if (null != value)
          if ("number" === type) {
            if (0 === value && "" === element.value || element.value != value)
              element.value = "" + getToStringValue(value);
          } else
            element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
        else
          "submit" !== type && "reset" !== type || element.removeAttribute("value");
        null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
        null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
        null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
      }
      function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
        if (null != value || null != defaultValue) {
          if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
            track(element);
            return;
          }
          defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
          value = null != value ? "" + getToStringValue(value) : defaultValue;
          isHydrating2 || value === element.value || (element.value = value);
          element.defaultValue = value;
        }
        checked = null != checked ? checked : defaultChecked;
        checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
        element.checked = isHydrating2 ? element.checked : !!checked;
        element.defaultChecked = !!checked;
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
        track(element);
      }
      function setDefaultValue(node, type, value) {
        "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        node = node.options;
        if (multiple) {
          multiple = {};
          for (var i2 = 0; i2 < propValue.length; i2++)
            multiple["$" + propValue[i2]] = true;
          for (propValue = 0; propValue < node.length; propValue++)
            i2 = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i2 && (node[propValue].selected = i2), i2 && setDefaultSelected && (node[propValue].defaultSelected = true);
        } else {
          propValue = "" + getToStringValue(propValue);
          multiple = null;
          for (i2 = 0; i2 < node.length; i2++) {
            if (node[i2].value === propValue) {
              node[i2].selected = true;
              setDefaultSelected && (node[i2].defaultSelected = true);
              return;
            }
            null !== multiple || node[i2].disabled || (multiple = node[i2]);
          }
          null !== multiple && (multiple.selected = true);
        }
      }
      function updateTextarea(element, value, defaultValue) {
        if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
          element.defaultValue !== value && (element.defaultValue = value);
          return;
        }
        element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      }
      function initTextarea(element, value, defaultValue, children3) {
        if (null == value) {
          if (null != children3) {
            if (null != defaultValue) throw Error(formatProdErrorMessage(92));
            if (isArrayImpl(children3)) {
              if (1 < children3.length) throw Error(formatProdErrorMessage(93));
              children3 = children3[0];
            }
            defaultValue = children3;
          }
          null == defaultValue && (defaultValue = "");
          value = defaultValue;
        }
        defaultValue = getToStringValue(value);
        element.defaultValue = defaultValue;
        children3 = element.textContent;
        children3 === defaultValue && "" !== children3 && null !== children3 && (element.value = children3);
        track(element);
      }
      function setTextContent(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      }
      var unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      );
      function setValueForStyle(style3, styleName, value) {
        var isCustomProperty = 0 === styleName.indexOf("--");
        null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style3.setProperty(styleName, "") : "float" === styleName ? style3.cssFloat = "" : style3[styleName] = "" : isCustomProperty ? style3.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style3.cssFloat = value : style3[styleName] = ("" + value).trim() : style3[styleName] = value + "px";
      }
      function setValueForStyles(node, styles, prevStyles) {
        if (null != styles && "object" !== typeof styles)
          throw Error(formatProdErrorMessage(62));
        node = node.style;
        if (null != prevStyles) {
          for (var styleName in prevStyles)
            !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
          for (var styleName$16 in styles)
            styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
        } else
          for (var styleName$17 in styles)
            styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
      }
      function isCustomElement(tagName) {
        if (-1 === tagName.indexOf("-")) return false;
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var aliases = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]);
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      function noop$1() {
      }
      var currentReplayingEvent = null;
      function getEventTarget(nativeEvent) {
        nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
        return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
      }
      var restoreTarget = null;
      var restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (internalInstance && (target = internalInstance.stateNode)) {
          var props = target[internalPropsKey] || null;
          a: switch (target = internalInstance.stateNode, internalInstance.type) {
            case "input":
              updateInput(
                target,
                props.value,
                props.defaultValue,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name
              );
              internalInstance = props.name;
              if ("radio" === props.type && null != internalInstance) {
                for (props = target; props.parentNode; ) props = props.parentNode;
                props = props.querySelectorAll(
                  'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                    "" + internalInstance
                  ) + '"][type="radio"]'
                );
                for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                  var otherNode = props[internalInstance];
                  if (otherNode !== target && otherNode.form === target.form) {
                    var otherProps = otherNode[internalPropsKey] || null;
                    if (!otherProps) throw Error(formatProdErrorMessage(90));
                    updateInput(
                      otherNode,
                      otherProps.value,
                      otherProps.defaultValue,
                      otherProps.defaultValue,
                      otherProps.checked,
                      otherProps.defaultChecked,
                      otherProps.type,
                      otherProps.name
                    );
                  }
                }
                for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                  otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
              }
              break a;
            case "textarea":
              updateTextarea(target, props.value, props.defaultValue);
              break a;
            case "select":
              internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
          }
        }
      }
      var isInsideEventHandler = false;
      function batchedUpdates$1(fn2, a2, b2) {
        if (isInsideEventHandler) return fn2(a2, b2);
        isInsideEventHandler = true;
        try {
          var JSCompiler_inline_result = fn2(a2);
          return JSCompiler_inline_result;
        } finally {
          if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
            if (flushSyncWork$1(), restoreTarget && (a2 = restoreTarget, fn2 = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a2), fn2))
              for (a2 = 0; a2 < fn2.length; a2++) restoreStateOfTarget(fn2[a2]);
          }
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (null === stateNode) return null;
        var props = stateNode[internalPropsKey] || null;
        if (null === props) return null;
        stateNode = props[registrationName];
        a: switch (registrationName) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
            inst = !props;
            break a;
          default:
            inst = false;
        }
        if (inst) return null;
        if (stateNode && "function" !== typeof stateNode)
          throw Error(
            formatProdErrorMessage(231, registrationName, typeof stateNode)
          );
        return stateNode;
      }
      var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var passiveBrowserEventsSupported = false;
      if (canUseDOM)
        try {
          options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (e2) {
          passiveBrowserEventsSupported = false;
        }
      var options;
      var root2 = null;
      var startText = null;
      var fallbackText = null;
      function getData() {
        if (fallbackText) return fallbackText;
        var start2, startValue = startText, startLength = startValue.length, end, endValue = "value" in root2 ? root2.value : root2.textContent, endLength = endValue.length;
        for (start2 = 0; start2 < startLength && startValue[start2] === endValue[start2]; start2++) ;
        var minEnd = startLength - start2;
        for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
        return fallbackText = endValue.slice(start2, 1 < end ? 1 - end : void 0);
      }
      function getEventCharCode(nativeEvent) {
        var keyCode = nativeEvent.keyCode;
        "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
        10 === nativeEvent && (nativeEvent = 13);
        return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var propName in Interface)
            Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
          this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
          },
          persist: function() {
          },
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      };
      var SyntheticEvent = createSyntheticEvent(EventInterface);
      var UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 });
      var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
      var lastMovementX;
      var lastMovementY;
      var lastMouseEvent;
      var MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function(event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
          return lastMovementX;
        },
        movementY: function(event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      });
      var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
      var DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 });
      var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
      var FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 });
      var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
      var AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
      var ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      });
      var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
      var CompositionEventInterface = assign({}, EventInterface, { data: 0 });
      var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
      var normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var nativeEvent = this.nativeEvent;
        return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
      }
      function getEventModifierState() {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign({}, UIEventInterface, {
        key: function(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function(event) {
          return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        },
        which: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        }
      });
      var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
      var PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      });
      var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
      var TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      });
      var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
      var TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
      var WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
      var ToggleEventInterface = assign({}, EventInterface, {
        newState: 0,
        oldState: 0
      });
      var SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface);
      var END_KEYCODES = [9, 13, 27, 32];
      var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
      var documentMode = null;
      canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
      var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
      var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode);
      var SPACEBAR_CHAR = String.fromCharCode(32);
      var hasSpaceKeypress = false;
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
          case "keydown":
            return 229 !== nativeEvent.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        nativeEvent = nativeEvent.detail;
        return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
      }
      var isComposing = false;
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            if (32 !== nativeEvent.which) return null;
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing)
          return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root2 = null, isComposing = false, domEventName) : null;
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
              if (nativeEvent.char && 1 < nativeEvent.char.length)
                return nativeEvent.char;
              if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
        inst = accumulateTwoPhaseListeners(inst, "onChange");
        0 < inst.length && (nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target
        ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
      }
      var activeElement$1 = null;
      var activeElementInst$1 = null;
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) return targetInst;
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if ("change" === domEventName) return targetInst;
      }
      var isInputEventSupported = false;
      if (canUseDOM) {
        if (canUseDOM) {
          isSupported$jscomp$inline_427 = "oninput" in document;
          if (!isSupported$jscomp$inline_427) {
            element$jscomp$inline_428 = document.createElement("div");
            element$jscomp$inline_428.setAttribute("oninput", "return;");
            isSupported$jscomp$inline_427 = "function" === typeof element$jscomp$inline_428.oninput;
          }
          JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
        } else JSCompiler_inline_result$jscomp$286 = false;
        isInputEventSupported = JSCompiler_inline_result$jscomp$286 && (!document.documentMode || 9 < document.documentMode);
      }
      var JSCompiler_inline_result$jscomp$286;
      var isSupported$jscomp$inline_427;
      var element$jscomp$inline_428;
      function stopWatchingForValueChange() {
        activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
      }
      function handlePropertyChange(nativeEvent) {
        if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(
            dispatchQueue,
            activeElementInst$1,
            nativeEvent,
            getEventTarget(nativeEvent)
          );
          batchedUpdates$1(runEventInBatch, dispatchQueue);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
      }
      function getTargetInstForInputEventPolyfill(domEventName) {
        if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
          return getInstIfValueChanged(activeElementInst$1);
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if ("click" === domEventName) return getInstIfValueChanged(targetInst);
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if ("input" === domEventName || "change" === domEventName)
          return getInstIfValueChanged(targetInst);
      }
      function is(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return true;
        if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
          return false;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
        for (keysB = 0; keysB < keysA.length; keysB++) {
          var currentKey = keysA[keysB];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
            return false;
        }
        return true;
      }
      function getLeafNode(node) {
        for (; node && node.firstChild; ) node = node.firstChild;
        return node;
      }
      function getNodeForCharacterOffset(root3, offset) {
        var node = getLeafNode(root3);
        root3 = 0;
        for (var nodeEnd; node; ) {
          if (3 === node.nodeType) {
            nodeEnd = root3 + node.textContent.length;
            if (root3 <= offset && nodeEnd >= offset)
              return { node, offset: offset - root3 };
            root3 = nodeEnd;
          }
          a: {
            for (; node; ) {
              if (node.nextSibling) {
                node = node.nextSibling;
                break a;
              }
              node = node.parentNode;
            }
            node = void 0;
          }
          node = getLeafNode(node);
        }
      }
      function containsNode(outerNode, innerNode) {
        return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
      }
      function getActiveElementDeep(containerInfo) {
        containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
        for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
          try {
            var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
          } catch (err) {
            JSCompiler_inline_result = false;
          }
          if (JSCompiler_inline_result) containerInfo = element.contentWindow;
          else break;
          element = getActiveElement(containerInfo.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
      }
      var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode;
      var activeElement = null;
      var activeElementInst = null;
      var lastSelection = null;
      var mouseDown = false;
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc2 = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
        mouseDown || null == activeElement || activeElement !== getActiveElement(doc2) || (doc2 = activeElement, "selectionStart" in doc2 && hasSelectionCapabilities(doc2) ? doc2 = { start: doc2.selectionStart, end: doc2.selectionEnd } : (doc2 = (doc2.ownerDocument && doc2.ownerDocument.defaultView || window).getSelection(), doc2 = {
          anchorNode: doc2.anchorNode,
          anchorOffset: doc2.anchorOffset,
          focusNode: doc2.focusNode,
          focusOffset: doc2.focusOffset
        }), lastSelection && shallowEqual(lastSelection, doc2) || (lastSelection = doc2, doc2 = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc2.length && (nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: nativeEvent, listeners: doc2 }), nativeEvent.target = activeElement)));
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes = {};
        prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes["Webkit" + styleProp] = "webkit" + eventName;
        prefixes["Moz" + styleProp] = "moz" + eventName;
        return prefixes;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      };
      var prefixedEventNames = {};
      var style2 = {};
      canUseDOM && (style2 = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
        if (!vendorPrefixes[eventName]) return eventName;
        var prefixMap = vendorPrefixes[eventName], styleProp;
        for (styleProp in prefixMap)
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style2)
            return prefixedEventNames[eventName] = prefixMap[styleProp];
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend");
      var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
      var ANIMATION_START = getVendorPrefixedEventName("animationstart");
      var TRANSITION_RUN = getVendorPrefixedEventName("transitionrun");
      var TRANSITION_START = getVendorPrefixedEventName("transitionstart");
      var TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel");
      var TRANSITION_END = getVendorPrefixedEventName("transitionend");
      var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
      var simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
      simpleEventPluginEvents.push("scrollEnd");
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
      var concurrentQueues = [];
      var concurrentQueuesIndex = 0;
      var concurrentlyUpdatedLanes = 0;
      function finishQueueingConcurrentUpdates() {
        for (var endIndex = concurrentQueuesIndex, i2 = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i2 < endIndex; ) {
          var fiber = concurrentQueues[i2];
          concurrentQueues[i2++] = null;
          var queue = concurrentQueues[i2];
          concurrentQueues[i2++] = null;
          var update = concurrentQueues[i2];
          concurrentQueues[i2++] = null;
          var lane = concurrentQueues[i2];
          concurrentQueues[i2++] = null;
          if (null !== queue && null !== update) {
            var pending = queue.pending;
            null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
            queue.pending = update;
          }
          0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
        }
      }
      function enqueueUpdate$1(fiber, queue, update, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        enqueueUpdate$1(fiber, queue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
          parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
      }
      function getRootForUpdatedFiber(sourceFiber) {
        if (50 < nestedUpdateCount)
          throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
        for (var parent = sourceFiber.return; null !== parent; )
          sourceFiber = parent, parent = sourceFiber.return;
        return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
      }
      var emptyContextObject = {};
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function createFiberImplClass(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      }
      function shouldConstruct(Component) {
        Component = Component.prototype;
        return !(!Component || !Component.isReactComponent);
      }
      function createWorkInProgress(current, pendingProps) {
        var workInProgress2 = current.alternate;
        null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
          current.tag,
          pendingProps,
          current.key,
          current.mode
        ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
        workInProgress2.flags = current.flags & 65011712;
        workInProgress2.childLanes = current.childLanes;
        workInProgress2.lanes = current.lanes;
        workInProgress2.child = current.child;
        workInProgress2.memoizedProps = current.memoizedProps;
        workInProgress2.memoizedState = current.memoizedState;
        workInProgress2.updateQueue = current.updateQueue;
        pendingProps = current.dependencies;
        workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
        workInProgress2.sibling = current.sibling;
        workInProgress2.index = current.index;
        workInProgress2.ref = current.ref;
        workInProgress2.refCleanup = current.refCleanup;
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= 65011714;
        var current = workInProgress2.alternate;
        null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
          lanes: renderLanes2.lanes,
          firstContext: renderLanes2.firstContext
        });
        return workInProgress2;
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = 0;
        owner = type;
        if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
        else if ("string" === typeof type)
          fiberTag = isHostHoistableType(
            type,
            pendingProps,
            contextStackCursor.current
          ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
        else
          a: switch (type) {
            case REACT_ACTIVITY_TYPE:
              return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= 24;
              break;
            case REACT_PROFILER_TYPE:
              return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_TYPE:
              return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_LIST_TYPE:
              return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
            default:
              if ("object" === typeof type && null !== type)
                switch (type.$$typeof) {
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    owner = null;
                    break a;
                }
              fiberTag = 29;
              pendingProps = Error(
                formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
              );
              owner = null;
          }
        key = createFiberImplClass(fiberTag, pendingProps, key, mode);
        key.elementType = type;
        key.type = owner;
        key.lanes = lanes;
        return key;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        elements = createFiberImplClass(7, elements, key, mode);
        elements.lanes = lanes;
        return elements;
      }
      function createFiberFromText(content, mode, lanes) {
        content = createFiberImplClass(6, content, null, mode);
        content.lanes = lanes;
        return content;
      }
      function createFiberFromDehydratedFragment(dehydratedNode) {
        var fiber = createFiberImplClass(18, null, null, 0);
        fiber.stateNode = dehydratedNode;
        return fiber;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        mode = createFiberImplClass(
          4,
          null !== portal.children ? portal.children : [],
          portal.key,
          mode
        );
        mode.lanes = lanes;
        mode.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return mode;
      }
      var CapturedStacks = /* @__PURE__ */ new WeakMap();
      function createCapturedValueAtFiber(value, source) {
        if ("object" === typeof value && null !== value) {
          var existing = CapturedStacks.get(value);
          if (void 0 !== existing) return existing;
          source = {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
          CapturedStacks.set(value, source);
          return source;
        }
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }
      var forkStack = [];
      var forkStackIndex = 0;
      var treeForkProvider = null;
      var treeForkCount = 0;
      var idStack = [];
      var idStackIndex = 0;
      var treeContextProvider = null;
      var treeContextId = 1;
      var treeContextOverflow = "";
      function pushTreeFork(workInProgress2, totalChildren) {
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index2) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress2 = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index2 += 1;
        var length = 32 - clz32(totalChildren) + baseLength;
        if (30 < length) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
          treeContextOverflow = length + workInProgress2;
        } else
          treeContextId = 1 << length | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
      }
      function pushMaterializedTreeId(workInProgress2) {
        null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
      }
      function popTreeContext(workInProgress2) {
        for (; workInProgress2 === treeForkProvider; )
          treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for (; workInProgress2 === treeContextProvider; )
          treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
      }
      function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextId = suspendedContext.id;
        treeContextOverflow = suspendedContext.overflow;
        treeContextProvider = workInProgress2;
      }
      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;
      var hydrationErrors = null;
      var rootOrSingletonContext = false;
      var HydrationMismatchException = Error(formatProdErrorMessage(519));
      function throwOnHydrationMismatch(fiber) {
        var error = Error(
          formatProdErrorMessage(
            418,
            1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML",
            ""
          )
        );
        queueHydrationError(createCapturedValueAtFiber(error, fiber));
        throw HydrationMismatchException;
      }
      function prepareToHydrateHostInstance(fiber) {
        var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
        instance[internalInstanceKey] = fiber;
        instance[internalPropsKey] = props;
        switch (type) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", instance);
            listenToNonDelegatedEvent("close", instance);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", instance);
            break;
          case "video":
          case "audio":
            for (type = 0; type < mediaEventTypes.length; type++)
              listenToNonDelegatedEvent(mediaEventTypes[type], instance);
            break;
          case "source":
            listenToNonDelegatedEvent("error", instance);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", instance);
            listenToNonDelegatedEvent("load", instance);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", instance);
            break;
          case "input":
            listenToNonDelegatedEvent("invalid", instance);
            initInput(
              instance,
              props.value,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name,
              true
            );
            break;
          case "select":
            listenToNonDelegatedEvent("invalid", instance);
            break;
          case "textarea":
            listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children);
        }
        type = props.children;
        "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
        instance || throwOnHydrationMismatch(fiber, true);
      }
      function popToNextHostParent(fiber) {
        for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
          switch (hydrationParentFiber.tag) {
            case 5:
            case 31:
            case 13:
              rootOrSingletonContext = false;
              return;
            case 27:
            case 3:
              rootOrSingletonContext = true;
              return;
            default:
              hydrationParentFiber = hydrationParentFiber.return;
          }
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) return false;
        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
        var tag = fiber.tag, JSCompiler_temp;
        if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
          if (JSCompiler_temp = 5 === tag)
            JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
          JSCompiler_temp = !JSCompiler_temp;
        }
        JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
        popToNextHostParent(fiber);
        if (13 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
        } else if (31 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
        } else
          27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
        return true;
      }
      function resetHydrationState() {
        nextHydratableInstance = hydrationParentFiber = null;
        isHydrating = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        var queuedErrors = hydrationErrors;
        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ), hydrationErrors = null);
        return queuedErrors;
      }
      function queueHydrationError(error) {
        null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
      }
      var valueCursor = createCursor(null);
      var currentlyRenderingFiber$1 = null;
      var lastContextDependency = null;
      function pushProvider(providerFiber, context, nextValue) {
        push(valueCursor, context._currentValue);
        context._currentValue = nextValue;
      }
      function popProvider(context) {
        context._currentValue = valueCursor.current;
        pop(valueCursor);
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        for (; null !== parent; ) {
          var alternate = parent.alternate;
          (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
          if (parent === propagationRoot) break;
          parent = parent.return;
        }
      }
      function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
        var fiber = workInProgress2.child;
        null !== fiber && (fiber.return = workInProgress2);
        for (; null !== fiber; ) {
          var list = fiber.dependencies;
          if (null !== list) {
            var nextFiber = fiber.child;
            list = list.firstContext;
            a: for (; null !== list; ) {
              var dependency = list;
              list = fiber;
              for (var i2 = 0; i2 < contexts.length; i2++)
                if (dependency.context === contexts[i2]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(
                    list.return,
                    renderLanes2,
                    workInProgress2
                  );
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
          } else if (18 === fiber.tag) {
            nextFiber = fiber.return;
            if (null === nextFiber) throw Error(formatProdErrorMessage(341));
            nextFiber.lanes |= renderLanes2;
            list = nextFiber.alternate;
            null !== list && (list.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
            nextFiber = null;
          } else nextFiber = fiber.child;
          if (null !== nextFiber) nextFiber.return = fiber;
          else
            for (nextFiber = fiber; null !== nextFiber; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              fiber = nextFiber.sibling;
              if (null !== fiber) {
                fiber.return = nextFiber.return;
                nextFiber = fiber;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
        current = null;
        for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
          if (!isInsidePropagationBailout) {
            if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
            else if (0 !== (parent.flags & 262144)) break;
          }
          if (10 === parent.tag) {
            var currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent = currentParent.memoizedProps;
            if (null !== currentParent) {
              var context = parent.type;
              objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
            }
          } else if (parent === hostTransitionProviderCursor.current) {
            currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
          }
          parent = parent.return;
        }
        null !== current && propagateContextChanges(
          workInProgress2,
          current,
          renderLanes2,
          forcePropagateEntireTree
        );
        workInProgress2.flags |= 262144;
      }
      function checkIfContextChanged(currentDependencies) {
        for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
          if (!objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue
          ))
            return true;
          currentDependencies = currentDependencies.next;
        }
        return false;
      }
      function prepareToReadContext(workInProgress2) {
        currentlyRenderingFiber$1 = workInProgress2;
        lastContextDependency = null;
        workInProgress2 = workInProgress2.dependencies;
        null !== workInProgress2 && (workInProgress2.firstContext = null);
      }
      function readContext(context) {
        return readContextForConsumer(currentlyRenderingFiber$1, context);
      }
      function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
      }
      function readContextForConsumer(consumer, context) {
        var value = context._currentValue;
        context = { context, memoizedValue: value, next: null };
        if (null === lastContextDependency) {
          if (null === consumer) throw Error(formatProdErrorMessage(308));
          lastContextDependency = context;
          consumer.dependencies = { lanes: 0, firstContext: context };
          consumer.flags |= 524288;
        } else lastContextDependency = lastContextDependency.next = context;
        return value;
      }
      var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
        var listeners = [], signal = this.signal = {
          aborted: false,
          addEventListener: function(type, listener) {
            listeners.push(listener);
          }
        };
        this.abort = function() {
          signal.aborted = true;
          listeners.forEach(function(listener) {
            return listener();
          });
        };
      };
      var scheduleCallback$2 = Scheduler.unstable_scheduleCallback;
      var NormalPriority = Scheduler.unstable_NormalPriority;
      var CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      };
      function createCache() {
        return {
          controller: new AbortControllerLocal(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function releaseCache(cache) {
        cache.refCount--;
        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
          cache.controller.abort();
        });
      }
      var currentEntangledListeners = null;
      var currentEntangledPendingCount = 0;
      var currentEntangledLane = 0;
      var currentEntangledActionThenable = null;
      function entangleAsyncAction(transition2, thenable) {
        if (null === currentEntangledListeners) {
          var entangledListeners = currentEntangledListeners = [];
          currentEntangledPendingCount = 0;
          currentEntangledLane = requestTransitionLane();
          currentEntangledActionThenable = {
            status: "pending",
            value: void 0,
            then: function(resolve) {
              entangledListeners.push(resolve);
            }
          };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
      }
      function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
          null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
          var listeners = currentEntangledListeners;
          currentEntangledListeners = null;
          currentEntangledLane = 0;
          currentEntangledActionThenable = null;
          for (var i2 = 0; i2 < listeners.length; i2++) (0, listeners[i2])();
        }
      }
      function chainThenableValue(thenable, result) {
        var listeners = [], thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function(resolve) {
            listeners.push(resolve);
          }
        };
        thenable.then(
          function() {
            thenableWithOverride.status = "fulfilled";
            thenableWithOverride.value = result;
            for (var i2 = 0; i2 < listeners.length; i2++) (0, listeners[i2])(result);
          },
          function(error) {
            thenableWithOverride.status = "rejected";
            thenableWithOverride.reason = error;
            for (error = 0; error < listeners.length; error++)
              (0, listeners[error])(void 0);
          }
        );
        return thenableWithOverride;
      }
      var prevOnStartTransitionFinish = ReactSharedInternals.S;
      ReactSharedInternals.S = function(transition2, returnValue) {
        globalMostRecentTransitionTime = now2();
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition2, returnValue);
        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition2, returnValue);
      };
      var resumedCache = createCursor(null);
      function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
      }
      function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
      }
      function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
      }
      var SuspenseException = Error(formatProdErrorMessage(460));
      var SuspenseyCommitException = Error(formatProdErrorMessage(474));
      var SuspenseActionException = Error(formatProdErrorMessage(542));
      var noopSuspenseyCommitThenable = { then: function() {
      } };
      function isThenableResolved(thenable) {
        thenable = thenable.status;
        return "fulfilled" === thenable || "rejected" === thenable;
      }
      function trackUsedThenable(thenableState2, thenable, index2) {
        index2 = thenableState2[index2];
        void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$1, noop$1), thenable = index2);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          default:
            if ("string" === typeof thenable.status) thenable.then(noop$1, noop$1);
            else {
              thenableState2 = workInProgressRoot;
              if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                throw Error(formatProdErrorMessage(482));
              thenableState2 = thenable;
              thenableState2.status = "pending";
              thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error;
                  }
                }
              );
            }
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      function resolveLazy(lazyType) {
        try {
          var init2 = lazyType._init;
          return init2(lazyType._payload);
        } catch (x2) {
          if (null !== x2 && "object" === typeof x2 && "function" === typeof x2.then)
            throw suspendedThenable = x2, SuspenseException;
          throw x2;
        }
      }
      var suspendedThenable = null;
      function getSuspendedThenable() {
        if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
          throw Error(formatProdErrorMessage(483));
      }
      var thenableState$1 = null;
      var thenableIndexCounter$1 = 0;
      function unwrapThenable(thenable) {
        var index2 = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = []);
        return trackUsedThenable(thenableState$1, thenable, index2);
      }
      function coerceRef(workInProgress2, element) {
        element = element.props.ref;
        workInProgress2.ref = void 0 !== element ? element : null;
      }
      function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
          throw Error(formatProdErrorMessage(525));
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error(
          formatProdErrorMessage(
            31,
            "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
          )
        );
      }
      function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) return null;
          for (; null !== currentFirstChild; )
            deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return null;
        }
        function mapRemainingChildren(currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
            null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          fiber = createWorkInProgress(fiber, pendingProps);
          fiber.index = 0;
          fiber.sibling = null;
          return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects)
            return newFiber.flags |= 1048576, lastPlacedIndex;
          newIndex = newFiber.alternate;
          if (null !== newIndex)
            return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
          newFiber.flags |= 67108866;
          return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
          return newFiber;
        }
        function updateTextNode(returnFiber, current, textContent, lanes) {
          if (null === current || 6 !== current.tag)
            return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, textContent);
          current.return = returnFiber;
          return current;
        }
        function updateElement(returnFiber, current, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return updateFragment(
              returnFiber,
              current,
              element.props.children,
              lanes,
              element.key
            );
          if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
            return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
          current = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            null,
            returnFiber.mode,
            lanes
          );
          coerceRef(current, element);
          current.return = returnFiber;
          return current;
        }
        function updatePortal(returnFiber, current, portal, lanes) {
          if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
            return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, portal.children || []);
          current.return = returnFiber;
          return current;
        }
        function updateFragment(returnFiber, current, fragment, lanes, key) {
          if (null === current || 7 !== current.tag)
            return current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            ), current.return = returnFiber, current;
          current = useFiber(current, fragment);
          current.return = returnFiber;
          return current;
        }
        function createChild(returnFiber, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild;
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
              case REACT_PORTAL_TYPE:
                return newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), newChild.return = returnFiber, newChild;
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), createChild(returnFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return newChild = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              ), newChild.return = returnFiber, newChild;
            if ("function" === typeof newChild.then)
              return createChild(returnFiber, unwrapThenable(newChild), lanes);
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return createChild(
                returnFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = null !== oldFiber ? oldFiber.key : null;
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), updateSlot(returnFiber, oldFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateSlot(
                returnFiber,
                oldFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
              case REACT_PORTAL_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return null;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(
              returnFiber,
              oldFiber,
              newChildren[newIdx],
              lanes
            );
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; newIdx < newChildren.length; newIdx++)
              oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              newChildren[newIdx],
              lanes
            ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
          if (null == newChildren) throw Error(formatProdErrorMessage(151));
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; !step.done; newIdx++, step = newChildren.next())
              step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
            step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
          "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                a: {
                  for (var key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key) {
                      key = newChild.type;
                      if (key === REACT_FRAGMENT_TYPE) {
                        if (7 === currentFirstChild.tag) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            newChild.props.children
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        }
                      } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.props);
                        coerceRef(lanes, newChild);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    } else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    lanes,
                    newChild.key
                  ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                    newChild.type,
                    newChild.key,
                    newChild.props,
                    null,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
                }
                return placeSingleChild(returnFiber);
              case REACT_PORTAL_TYPE:
                a: {
                  for (key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key)
                      if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.children || []);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      } else {
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      }
                    else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                }
                return placeSingleChild(returnFiber);
              case REACT_LAZY_TYPE:
                return newChild = resolveLazy(newChild), reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild))
              return reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            if (getIteratorFn(newChild)) {
              key = getIteratorFn(newChild);
              if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
              newChild = key.call(newChild);
              return reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            }
            if ("function" === typeof newChild.then)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectTypeImpl(returnFiber, newChild);
          }
          return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function(returnFiber, currentFirstChild, newChild, lanes) {
          try {
            thenableIndexCounter$1 = 0;
            var firstChildFiber = reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
            thenableState$1 = null;
            return firstChildFiber;
          } catch (x2) {
            if (x2 === SuspenseException || x2 === SuspenseActionException) throw x2;
            var fiber = createFiberImplClass(29, x2, null, returnFiber.mode);
            fiber.lanes = lanes;
            fiber.return = returnFiber;
            return fiber;
          } finally {
          }
        };
      }
      var reconcileChildFibers = createChildReconciler(true);
      var mountChildFibers = createChildReconciler(false);
      var hasForceUpdate = false;
      function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function cloneUpdateQueue(current, workInProgress2) {
        current = current.updateQueue;
        workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null
        });
      }
      function createUpdate(lane) {
        return { lane, tag: 0, payload: null, callback: null, next: null };
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (null === updateQueue) return null;
        updateQueue = updateQueue.shared;
        if (0 !== (executionContext & 2)) {
          var pending = updateQueue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          updateQueue.pending = update;
          update = getRootForUpdatedFiber(fiber);
          markUpdateLaneFromFiberToRoot(fiber, null, lane);
          return update;
        }
        enqueueUpdate$1(fiber, updateQueue, update, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function entangleTransitions(root3, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
          var queueLanes = fiber.lanes;
          queueLanes &= root3.pendingLanes;
          lane |= queueLanes;
          fiber.lanes = lane;
          markRootEntangled(root3, lane);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
        if (null !== current && (current = current.updateQueue, queue === current)) {
          var newFirst = null, newLast = null;
          queue = queue.firstBaseUpdate;
          if (null !== queue) {
            do {
              var clone = {
                lane: queue.lane,
                tag: queue.tag,
                payload: queue.payload,
                callback: null,
                next: null
              };
              null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
              queue = queue.next;
            } while (null !== queue);
            null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
          } else newFirst = newLast = capturedUpdate;
          queue = {
            baseState: current.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: current.shared,
            callbacks: current.callbacks
          };
          workInProgress2.updateQueue = queue;
          return;
        }
        workInProgress2 = queue.lastBaseUpdate;
        null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
      }
      var didReadFromEntangledAsyncAction = false;
      function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
          var entangledActionThenable = currentEntangledActionThenable;
          if (null !== entangledActionThenable) throw entangledActionThenable;
        }
      }
      function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
        didReadFromEntangledAsyncAction = false;
        var queue = workInProgress$jscomp$0.updateQueue;
        hasForceUpdate = false;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
          lastBaseUpdate = lastPendingUpdate;
          var current = workInProgress$jscomp$0.alternate;
          null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
        }
        if (null !== firstBaseUpdate) {
          var newState = queue.baseState;
          lastBaseUpdate = 0;
          current = firstPendingUpdate = lastPendingUpdate = null;
          pendingQueue = firstBaseUpdate;
          do {
            var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
            if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
              0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
              null !== current && (current = current.next = {
                lane: 0,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: null,
                next: null
              });
              a: {
                var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
                updateLane = props;
                var instance = instance$jscomp$0;
                switch (update.tag) {
                  case 1:
                    workInProgress2 = update.payload;
                    if ("function" === typeof workInProgress2) {
                      newState = workInProgress2.call(instance, newState, updateLane);
                      break a;
                    }
                    newState = workInProgress2;
                    break a;
                  case 3:
                    workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                  case 0:
                    workInProgress2 = update.payload;
                    updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                    if (null === updateLane || void 0 === updateLane) break a;
                    newState = assign({}, newState, updateLane);
                    break a;
                  case 2:
                    hasForceUpdate = true;
                }
              }
              updateLane = pendingQueue.callback;
              null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
            } else
              isHiddenUpdate = {
                lane: updateLane,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: pendingQueue.callback,
                next: null
              }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
            pendingQueue = pendingQueue.next;
            if (null === pendingQueue)
              if (pendingQueue = queue.shared.pending, null === pendingQueue)
                break;
              else
                isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
          } while (1);
          null === current && (lastPendingUpdate = newState);
          queue.baseState = lastPendingUpdate;
          queue.firstBaseUpdate = firstPendingUpdate;
          queue.lastBaseUpdate = current;
          null === firstBaseUpdate && (queue.shared.lanes = 0);
          workInProgressRootSkippedLanes |= lastBaseUpdate;
          workInProgress$jscomp$0.lanes = lastBaseUpdate;
          workInProgress$jscomp$0.memoizedState = newState;
        }
      }
      function callCallback(callback, context) {
        if ("function" !== typeof callback)
          throw Error(formatProdErrorMessage(191, callback));
        callback.call(context);
      }
      function commitCallbacks(updateQueue, context) {
        var callbacks = updateQueue.callbacks;
        if (null !== callbacks)
          for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
            callCallback(callbacks[updateQueue], context);
      }
      var currentTreeHiddenStackCursor = createCursor(null);
      var prevEntangledRenderLanesCursor = createCursor(0);
      function pushHiddenContext(fiber, context) {
        fiber = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, fiber);
        push(currentTreeHiddenStackCursor, context);
        entangledRenderLanes = fiber | context.baseLanes;
      }
      function reuseHiddenContextOnStack() {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes);
        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
      }
      function popHiddenContext() {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor);
        pop(prevEntangledRenderLanesCursor);
      }
      var suspenseHandlerStackCursor = createCursor(null);
      var shellBoundary = null;
      function pushPrimaryTreeSuspenseHandler(handler) {
        var current = handler.alternate;
        push(suspenseStackCursor, suspenseStackCursor.current & 1);
        push(suspenseHandlerStackCursor, handler);
        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
      }
      function pushDehydratedActivitySuspenseHandler(fiber) {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, fiber);
        null === shellBoundary && (shellBoundary = fiber);
      }
      function pushOffscreenSuspenseHandler(fiber) {
        22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);
      }
      function reuseSuspenseHandlerOnStack() {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
      }
      function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor);
      }
      var suspenseStackCursor = createCursor(0);
      function findFirstSuspended(row2) {
        for (var node = row2; null !== node; ) {
          if (13 === node.tag) {
            var state = node.memoizedState;
            if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
              return node;
          } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
            if (0 !== (node.flags & 128)) return node;
          } else if (null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row2) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === row2) return null;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      var renderLanes = 0;
      var currentlyRenderingFiber = null;
      var currentHook = null;
      var workInProgressHook = null;
      var didScheduleRenderPhaseUpdate = false;
      var didScheduleRenderPhaseUpdateDuringThisPass = false;
      var shouldDoubleInvokeUserFnsInHooksDEV = false;
      var localIdCounter = 0;
      var thenableIndexCounter = 0;
      var thenableState = null;
      var globalClientIdCounter = 0;
      function throwInvalidHookError() {
        throw Error(formatProdErrorMessage(321));
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (null === prevDeps) return false;
        for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++)
          if (!objectIs(nextDeps[i2], prevDeps[i2])) return false;
        return true;
      }
      function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber = workInProgress2;
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = 0;
        ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        nextRenderLanes = Component(props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
          workInProgress2,
          Component,
          props,
          secondArg
        ));
        finishRenderingHooks(current);
        return nextRenderLanes;
      }
      function finishRenderingHooks(current) {
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdate = false;
        thenableIndexCounter = 0;
        thenableState = null;
        if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
      }
      function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
        currentlyRenderingFiber = workInProgress2;
        var numberOfReRenders = 0;
        do {
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
          thenableIndexCounter = 0;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
          numberOfReRenders += 1;
          workInProgressHook = currentHook = null;
          if (null != workInProgress2.updateQueue) {
            var children3 = workInProgress2.updateQueue;
            children3.lastEffect = null;
            children3.events = null;
            children3.stores = null;
            null != children3.memoCache && (children3.memoCache.index = 0);
          }
          ReactSharedInternals.H = HooksDispatcherOnRerender;
          children3 = Component(props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children3;
      }
      function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
        maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
        return maybeThenable;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current, workInProgress2, lanes) {
        workInProgress2.updateQueue = current.updateQueue;
        workInProgress2.flags &= -2053;
        current.lanes &= ~lanes;
      }
      function resetHooksOnUnwind(workInProgress2) {
        if (didScheduleRenderPhaseUpdate) {
          for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
            var queue = workInProgress2.queue;
            null !== queue && (queue.pending = null);
            workInProgress2 = workInProgress2.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        thenableIndexCounter = localIdCounter = 0;
        thenableState = null;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        if (null === currentHook) {
          var nextCurrentHook = currentlyRenderingFiber.alternate;
          nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
        if (null !== nextWorkInProgressHook)
          workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
        else {
          if (null === nextCurrentHook) {
            if (null === currentlyRenderingFiber.alternate)
              throw Error(formatProdErrorMessage(467));
            throw Error(formatProdErrorMessage(310));
          }
          currentHook = nextCurrentHook;
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }
      function useThenable(thenable) {
        var index2 = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        thenable = trackUsedThenable(thenableState, thenable, index2);
        index2 = currentlyRenderingFiber;
        null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
        return thenable;
      }
      function use(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then) return useThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
        }
        throw Error(formatProdErrorMessage(438, String(usable)));
      }
      function useMemoCache(size) {
        var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
        null !== updateQueue && (memoCache = updateQueue.memoCache);
        if (null == memoCache) {
          var current = currentlyRenderingFiber.alternate;
          null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
            data: current.data.map(function(array2) {
              return array2.slice();
            }),
            index: 0
          })));
        }
        null == memoCache && (memoCache = { data: [], index: 0 });
        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
        updateQueue.memoCache = memoCache;
        updateQueue = memoCache.data[memoCache.index];
        if (void 0 === updateQueue)
          for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
            updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
        memoCache.index++;
        return updateQueue;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function updateReducer(reducer) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer);
      }
      function updateReducerImpl(hook, current, reducer) {
        var queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
        if (null !== pendingQueue) {
          if (null !== baseQueue) {
            var baseFirst = baseQueue.next;
            baseQueue.next = pendingQueue.next;
            pendingQueue.next = baseFirst;
          }
          current.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue) hook.memoizedState = pendingQueue;
        else {
          current = baseQueue.next;
          var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$60 = false;
          do {
            var updateLane = update.lane & -536870913;
            if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
              var revertLane = update.revertLane;
              if (0 === revertLane)
                null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                  lane: 0,
                  revertLane: 0,
                  gesture: null,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
              else if ((renderLanes & revertLane) === revertLane) {
                update = update.next;
                revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
                continue;
              } else
                updateLane = {
                  lane: 0,
                  revertLane: update.revertLane,
                  gesture: null,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
              updateLane = update.action;
              shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
              pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
            } else
              revertLane = {
                lane: updateLane,
                revertLane: update.revertLane,
                gesture: update.gesture,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
            update = update.next;
          } while (null !== update && update !== current);
          null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
          if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$60 && (reducer = currentEntangledActionThenable, null !== reducer)))
            throw reducer;
          hook.memoizedState = pendingQueue;
          hook.baseState = baseFirst;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [hook.memoizedState, queue.dispatch];
      }
      function rerenderReducer(reducer) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var dispatch2 = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
          queue.pending = null;
          var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          do
            newState = reducer(newState, update.action), update = update.next;
          while (update !== lastRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
          hook.memoizedState = newState;
          null === hook.baseQueue && (hook.baseState = newState);
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch2];
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
          if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else getServerSnapshot = getSnapshot();
        var snapshotChanged = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        );
        snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
        hook = hook.queue;
        updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
          subscribe
        ]);
        if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              hook,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
          isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = { getSnapshot, value: renderedSnapshot };
        getSnapshot = currentlyRenderingFiber.updateQueue;
        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        });
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root3 = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2);
      }
      function mountStateImpl(initialState2) {
        var hook = mountWorkInProgressHook();
        if ("function" === typeof initialState2) {
          var initialStateInitializer = initialState2;
          initialState2 = initialStateInitializer();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              initialStateInitializer();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        hook.memoizedState = hook.baseState = initialState2;
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState2
        };
        return hook;
      }
      function updateOptimisticImpl(hook, current, passthrough, reducer) {
        hook.baseState = passthrough;
        return updateReducerImpl(
          hook,
          currentHook,
          "function" === typeof reducer ? reducer : basicStateReducer
        );
      }
      function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
        fiber = actionQueue.action;
        if (null !== fiber) {
          var actionNode = {
            payload,
            action: fiber,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(listener) {
              actionNode.listeners.push(listener);
            }
          };
          null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
          setState(actionNode);
          setPendingState = actionQueue.pending;
          null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
        }
      }
      function runActionStateAction(actionQueue, node) {
        var action = node.action, payload = node.payload, prevState = actionQueue.state;
        if (node.isTransition) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            handleActionReturnValue(actionQueue, node, returnValue);
          } catch (error) {
            onActionError(actionQueue, node, error);
          } finally {
            null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
          }
        } else
          try {
            prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
          } catch (error$66) {
            onActionError(actionQueue, node, error$66);
          }
      }
      function handleActionReturnValue(actionQueue, node, returnValue) {
        null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
          function(nextState) {
            onActionSuccess(actionQueue, node, nextState);
          },
          function(error) {
            return onActionError(actionQueue, node, error);
          }
        ) : onActionSuccess(actionQueue, node, returnValue);
      }
      function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = "fulfilled";
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
      }
      function onActionError(actionQueue, actionNode, error) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
          last = last.next;
          do
            actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
          while (actionNode !== last);
        }
        actionQueue.action = null;
      }
      function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for (var i2 = 0; i2 < actionNode.length; i2++) (0, actionNode[i2])();
      }
      function actionStateReducer(oldState, newState) {
        return newState;
      }
      function mountActionState(action, initialStateProp) {
        if (isHydrating) {
          var ssrFormState = workInProgressRoot.formState;
          if (null !== ssrFormState) {
            a: {
              var JSCompiler_inline_result = currentlyRenderingFiber;
              if (isHydrating) {
                if (nextHydratableInstance) {
                  b: {
                    var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                    for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                      if (!inRootOrSingleton) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                      JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                        JSCompiler_inline_result$jscomp$0.nextSibling
                      );
                      if (null === JSCompiler_inline_result$jscomp$0) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                    }
                    inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                    JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                  }
                  if (JSCompiler_inline_result$jscomp$0) {
                    nextHydratableInstance = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                    break a;
                  }
                }
                throwOnHydrationMismatch(JSCompiler_inline_result);
              }
              JSCompiler_inline_result = false;
            }
            JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
          }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        JSCompiler_inline_result = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp
        };
        ssrFormState.queue = JSCompiler_inline_result;
        ssrFormState = dispatchSetState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result
        );
        JSCompiler_inline_result.dispatch = ssrFormState;
        JSCompiler_inline_result = mountStateImpl(false);
        inRootOrSingleton = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          false,
          JSCompiler_inline_result.queue
        );
        JSCompiler_inline_result = mountWorkInProgressHook();
        JSCompiler_inline_result$jscomp$0 = {
          state: initialStateProp,
          dispatch: null,
          action,
          pending: null
        };
        JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result$jscomp$0,
          inRootOrSingleton,
          ssrFormState
        );
        JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
        JSCompiler_inline_result.memoizedState = action;
        return [initialStateProp, ssrFormState, false];
      }
      function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
      }
      function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(
          stateHook,
          currentStateHook,
          actionStateReducer
        )[0];
        stateHook = updateReducer(basicStateReducer)[0];
        if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
          try {
            var state = useThenable(currentStateHook);
          } catch (x2) {
            if (x2 === SuspenseException) throw SuspenseActionException;
            throw x2;
          }
        else state = currentStateHook;
        currentStateHook = updateWorkInProgressHook();
        var actionQueue = currentStateHook.queue, dispatch2 = actionQueue.dispatch;
        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
          9,
          { destroy: void 0 },
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
        return [state, dispatch2, stateHook];
      }
      function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
      }
      function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
        if (null !== currentStateHook)
          return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch2 = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [stateHook, dispatch2, false];
      }
      function pushSimpleEffect(tag, inst, create2, deps) {
        tag = { tag, create: create2, deps, inst, next: null };
        inst = currentlyRenderingFiber.updateQueue;
        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
        create2 = inst.lastEffect;
        null === create2 ? inst.lastEffect = tag.next = tag : (deps = create2.next, create2.next = tag, tag.next = deps, inst.lastEffect = tag);
        return tag;
      }
      function updateRef() {
        return updateWorkInProgressHook().memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create2, deps) {
        var hook = mountWorkInProgressHook();
        currentlyRenderingFiber.flags |= fiberFlags;
        hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          { destroy: void 0 },
          create2,
          void 0 === deps ? null : deps
        );
      }
      function updateEffectImpl(fiberFlags, hookFlags, create2, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create2, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          inst,
          create2,
          deps
        ));
      }
      function mountEffect(create2, deps) {
        mountEffectImpl(8390656, 8, create2, deps);
      }
      function updateEffect(create2, deps) {
        updateEffectImpl(2048, 8, create2, deps);
      }
      function useEffectEventImpl(payload) {
        currentlyRenderingFiber.flags |= 4;
        var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
        if (null === componentUpdateQueue)
          componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
        else {
          var events = componentUpdateQueue.events;
          null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
        }
      }
      function updateEvent(callback) {
        var ref = updateWorkInProgressHook().memoizedState;
        useEffectEventImpl({ ref, nextImpl: callback });
        return function() {
          if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
          return ref.impl.apply(void 0, arguments);
        };
      }
      function updateInsertionEffect(create2, deps) {
        return updateEffectImpl(4, 2, create2, deps);
      }
      function updateLayoutEffect(create2, deps) {
        return updateEffectImpl(4, 4, create2, deps);
      }
      function imperativeHandleEffect(create2, ref) {
        if ("function" === typeof ref) {
          create2 = create2();
          var refCleanup = ref(create2);
          return function() {
            "function" === typeof refCleanup ? refCleanup() : ref(null);
          };
        }
        if (null !== ref && void 0 !== ref)
          return create2 = create2(), ref.current = create2, function() {
            ref.current = null;
          };
      }
      function updateImperativeHandle(ref, create2, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create2, ref), deps);
      }
      function mountDebugValue() {
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        hook.memoizedState = [callback, deps];
        return callback;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [prevState, deps];
        return prevState;
      }
      function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
          return hook.memoizedState = value;
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
      }
      function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue)) return value;
        if (null !== currentTreeHiddenStackCursor.current)
          return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
        if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
          return didReceiveUpdate = true, hook.memoizedState = value;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
      }
      function startTransition(fiber, queue, pendingState, finishedState, callback) {
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, false, queue, pendingState);
        try {
          var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
            var thenableForFinishedState = chainThenableValue(
              returnValue,
              finishedState
            );
            dispatchSetStateInternal(
              fiber,
              queue,
              thenableForFinishedState,
              requestUpdateLane(fiber)
            );
          } else
            dispatchSetStateInternal(
              fiber,
              queue,
              finishedState,
              requestUpdateLane(fiber)
            );
        } catch (error) {
          dispatchSetStateInternal(
            fiber,
            queue,
            { then: function() {
            }, status: "rejected", reason: error },
            requestUpdateLane()
          );
        } finally {
          ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      }
      function noop3() {
      }
      function startHostTransition(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startTransition(
          formFiber,
          queue,
          pendingState,
          sharedNotPendingObject,
          null === action ? noop3 : function() {
            requestFormReset$1(formFiber);
            return action(formData);
          }
        );
      }
      function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook) return existingStateHook;
        existingStateHook = {
          memoizedState: sharedNotPendingObject,
          baseState: sharedNotPendingObject,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: sharedNotPendingObject
          },
          next: null
        };
        var initialResetState = {};
        existingStateHook.next = {
          memoizedState: initialResetState,
          baseState: initialResetState,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialResetState
          },
          next: null
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
      }
      function requestFormReset$1(formFiber) {
        var stateHook = ensureFormComponentIsStateful(formFiber);
        null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
        dispatchSetStateInternal(
          formFiber,
          stateHook.next.queue,
          {},
          requestUpdateLane()
        );
      }
      function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
      }
      function updateId() {
        return updateWorkInProgressHook().memoizedState;
      }
      function updateRefresh() {
        return updateWorkInProgressHook().memoizedState;
      }
      function refreshCache(fiber) {
        for (var provider = fiber.return; null !== provider; ) {
          switch (provider.tag) {
            case 24:
            case 3:
              var lane = requestUpdateLane();
              fiber = createUpdate(lane);
              var root$69 = enqueueUpdate(provider, fiber, lane);
              null !== root$69 && (scheduleUpdateOnFiber(root$69, provider, lane), entangleTransitions(root$69, provider, lane));
              provider = { cache: createCache() };
              fiber.payload = provider;
              return;
          }
          provider = provider.return;
        }
      }
      function dispatchReducerAction(fiber, queue, action) {
        var lane = requestUpdateLane();
        action = {
          lane,
          revertLane: 0,
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
      }
      function dispatchSetState(fiber, queue, action) {
        var lane = requestUpdateLane();
        dispatchSetStateInternal(fiber, queue, action, lane);
      }
      function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update = {
          lane,
          revertLane: 0,
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
        else {
          var alternate = fiber.alternate;
          if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
            try {
              var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
              update.hasEagerState = true;
              update.eagerState = eagerState;
              if (objectIs(eagerState, currentState))
                return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
            } catch (error) {
            } finally {
            }
          action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (null !== action)
            return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
        }
        return false;
      }
      function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          gesture: null,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
        } else
          throwIfDuringRender = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            2
          ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      function entangleTransitionUpdate(root3, queue, lane) {
        if (0 !== (lane & 4194048)) {
          var queueLanes = queue.lanes;
          queueLanes &= root3.pendingLanes;
          lane |= queueLanes;
          queue.lanes = lane;
          markRootEntangled(root3, lane);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      };
      ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
      var HooksDispatcherOnMount = {
        readContext,
        use,
        useCallback: function(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        },
        useContext: readContext,
        useEffect: mountEffect,
        useImperativeHandle: function(ref, create2, deps) {
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          mountEffectImpl(
            4194308,
            4,
            imperativeHandleEffect.bind(null, create2, ref),
            deps
          );
        },
        useLayoutEffect: function(create2, deps) {
          return mountEffectImpl(4194308, 4, create2, deps);
        },
        useInsertionEffect: function(create2, deps) {
          mountEffectImpl(4, 2, create2, deps);
        },
        useMemo: function(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        },
        useReducer: function(reducer, initialArg, init2) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init2) {
            var initialState2 = init2(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init2(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState2 = initialArg;
          hook.memoizedState = hook.baseState = initialState2;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState2
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        },
        useRef: function(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        },
        useState: function(initialState2) {
          initialState2 = mountStateImpl(initialState2);
          var queue = initialState2.queue, dispatch2 = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch2;
          return [initialState2.memoizedState, dispatch2];
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        },
        useTransition: function() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(formatProdErrorMessage(407));
            getServerSnapshot = getServerSnapshot();
          } else {
            getServerSnapshot = getSnapshot();
            if (null === workInProgressRoot)
              throw Error(formatProdErrorMessage(349));
            0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          hook.memoizedState = getServerSnapshot;
          var inst = { value: getServerSnapshot, getSnapshot };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
            subscribe
          ]);
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            { destroy: void 0 },
            updateStoreInstance.bind(
              null,
              fiber,
              inst,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          return getServerSnapshot;
        },
        useId: function() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var JSCompiler_inline_result = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
            identifierPrefix = "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
            JSCompiler_inline_result = localIdCounter++;
            0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
            identifierPrefix += "_";
          } else
            JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + JSCompiler_inline_result.toString(32) + "_";
          return hook.memoizedState = identifierPrefix;
        },
        useHostTransitionStatus,
        useFormState: mountActionState,
        useActionState: mountActionState,
        useOptimistic: function(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        },
        useMemoCache,
        useCacheRefresh: function() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        },
        useEffectEvent: function(callback) {
          var hook = mountWorkInProgressHook(), ref = { impl: callback };
          hook.memoizedState = ref;
          return function() {
            if (0 !== (executionContext & 2))
              throw Error(formatProdErrorMessage(440));
            return ref.impl.apply(void 0, arguments);
          };
        }
      };
      var HooksDispatcherOnUpdate = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: updateReducer,
        useRef: updateRef,
        useState: function() {
          return updateReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start2 = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start2
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: updateActionState,
        useActionState: updateActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
      var HooksDispatcherOnRerender = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: rerenderReducer,
        useRef: updateRef,
        useState: function() {
          return rerenderReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start2 = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start2
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: rerenderActionState,
        useActionState: rerenderActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      HooksDispatcherOnRerender.useEffectEvent = updateEvent;
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        ctor = workInProgress2.memoizedState;
        getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
        getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
        workInProgress2.memoizedState = getDerivedStateFromProps;
        0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
      }
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 1;
          update.payload = payload;
          void 0 !== callback && null !== callback && (update.callback = callback);
          payload = enqueueUpdate(inst, update, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueForceUpdate: function(inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update = createUpdate(lane);
          update.tag = 2;
          void 0 !== callback && null !== callback && (update.callback = callback);
          callback = enqueueUpdate(inst, update, lane);
          null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        workInProgress2 = workInProgress2.stateNode;
        return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        workInProgress2 = instance.state;
        "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
        "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
      function resolveClassComponentProps(Component, baseProps) {
        var newProps = baseProps;
        if ("ref" in baseProps) {
          newProps = {};
          for (var propName in baseProps)
            "ref" !== propName && (newProps[propName] = baseProps[propName]);
        }
        if (Component = Component.defaultProps) {
          newProps === baseProps && (newProps = assign({}, newProps));
          for (var propName$73 in Component)
            void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
        }
        return newProps;
      }
      function defaultOnUncaughtError(error) {
        reportGlobalError(error);
      }
      function defaultOnCaughtError(error) {
        console.error(error);
      }
      function defaultOnRecoverableError(error) {
        reportGlobalError(error);
      }
      function logUncaughtError(root3, errorInfo) {
        try {
          var onUncaughtError = root3.onUncaughtError;
          onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
        } catch (e$74) {
          setTimeout(function() {
            throw e$74;
          });
        }
      }
      function logCaughtError(root3, boundary, errorInfo) {
        try {
          var onCaughtError = root3.onCaughtError;
          onCaughtError(errorInfo.value, {
            componentStack: errorInfo.stack,
            errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
          });
        } catch (e$75) {
          setTimeout(function() {
            throw e$75;
          });
        }
      }
      function createRootErrorUpdate(root3, errorInfo, lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        lane.payload = { element: null };
        lane.callback = function() {
          logUncaughtError(root3, errorInfo);
        };
        return lane;
      }
      function createClassErrorUpdate(lane) {
        lane = createUpdate(lane);
        lane.tag = 3;
        return lane;
      }
      function initializeClassErrorUpdate(update, root3, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ("function" === typeof getDerivedStateFromError) {
          var error = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error);
          };
          update.callback = function() {
            logCaughtError(root3, fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
          logCaughtError(root3, fiber, errorInfo);
          "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
          var stack = errorInfo.stack;
          this.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        });
      }
      function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        if (null !== value && "object" === typeof value && "function" === typeof value.then) {
          returnFiber = sourceFiber.alternate;
          null !== returnFiber && propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            true
          );
          sourceFiber = suspenseHandlerStackCursor.current;
          if (null !== sourceFiber) {
            switch (sourceFiber.tag) {
              case 31:
              case 13:
                return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root3, value, rootRenderLanes)), false;
              case 22:
                return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([value])
                }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root3, value, rootRenderLanes)), false;
            }
            throw Error(formatProdErrorMessage(435, sourceFiber.tag));
          }
          attachPingListener(root3, value, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return false;
        }
        if (isHydrating)
          return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root3 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root3, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
            cause: value
          }), queueHydrationError(
            createCapturedValueAtFiber(returnFiber, sourceFiber)
          )), root3 = root3.current.alternate, root3.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root3.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
            root3.stateNode,
            value,
            rootRenderLanes
          ), enqueueCapturedUpdate(root3, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
        var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
        wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
        4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
        if (null === returnFiber) return true;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
          switch (sourceFiber.tag) {
            case 3:
              return sourceFiber.flags |= 65536, root3 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root3, root3 = createRootErrorUpdate(sourceFiber.stateNode, value, root3), enqueueCapturedUpdate(sourceFiber, root3), false;
            case 1:
              if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
                return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                  rootRenderLanes,
                  root3,
                  sourceFiber,
                  value
                ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
          }
          sourceFiber = sourceFiber.return;
        } while (null !== sourceFiber);
        return false;
      }
      var SelectiveHydrationException = Error(formatProdErrorMessage(461));
      var didReceiveUpdate = false;
      function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
          workInProgress2,
          current.child,
          nextChildren,
          renderLanes2
        );
      }
      function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
        Component = Component.render;
        var ref = workInProgress2.ref;
        if ("ref" in nextProps) {
          var propsWithoutRef = {};
          for (var key in nextProps)
            "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
        } else propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress2);
        nextProps = renderWithHooks(
          current,
          workInProgress2,
          Component,
          propsWithoutRef,
          ref,
          renderLanes2
        );
        key = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && key && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null === current) {
          var type = Component.type;
          if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
            return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
              current,
              workInProgress2,
              type,
              nextProps,
              renderLanes2
            );
          current = createFiberFromTypeAndProps(
            Component.type,
            null,
            nextProps,
            workInProgress2,
            workInProgress2.mode,
            renderLanes2
          );
          current.ref = workInProgress2.ref;
          current.return = workInProgress2;
          return workInProgress2.child = current;
        }
        type = current.child;
        if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
          var prevProps = type.memoizedProps;
          Component = Component.compare;
          Component = null !== Component ? Component : shallowEqual;
          if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        workInProgress2.flags |= 1;
        current = createWorkInProgress(type, nextProps);
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null !== current) {
          var prevProps = current.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
            if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
              0 !== (current.flags & 131072) && (didReceiveUpdate = true);
            else
              return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(
          current,
          workInProgress2,
          Component,
          nextProps,
          renderLanes2
        );
      }
      function updateOffscreenComponent(current, workInProgress2, renderLanes2, nextProps) {
        var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
        null === current && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        });
        if ("hidden" === nextProps.mode) {
          if (0 !== (workInProgress2.flags & 128)) {
            prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
            if (null !== current) {
              nextProps = workInProgress2.child = current.child;
              for (nextChildren = 0; null !== nextProps; )
                nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
              nextProps = nextChildren & ~prevState;
            } else nextProps = 0, workInProgress2.child = null;
            return deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              prevState,
              renderLanes2,
              nextProps
            );
          }
          if (0 !== (renderLanes2 & 536870912))
            workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
              workInProgress2,
              null !== prevState ? prevState.cachePool : null
            ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
          else
            return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
              renderLanes2,
              nextProps
            );
        } else
          null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress2));
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function bailoutOffscreenComponent(current, workInProgress2) {
        null !== current && 22 === current.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        });
        return workInProgress2.sibling;
      }
      function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
        workInProgress2.memoizedState = {
          baseLanes: nextBaseLanes,
          cachePool: JSCompiler_inline_result
        };
        null !== current && pushTransition(workInProgress2, null);
        reuseHiddenContextOnStack();
        pushOffscreenSuspenseHandler(workInProgress2);
        null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
        workInProgress2.childLanes = remainingChildLanes;
        return null;
      }
      function mountActivityChildren(workInProgress2, nextProps) {
        nextProps = mountWorkInProgressOffscreenFiber(
          { mode: nextProps.mode, children: nextProps.children },
          workInProgress2.mode
        );
        nextProps.ref = workInProgress2.ref;
        workInProgress2.child = nextProps;
        nextProps.return = workInProgress2;
        return nextProps;
      }
      function retryActivityComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
        current.flags |= 2;
        popSuspenseHandler(workInProgress2);
        workInProgress2.memoizedState = null;
        return current;
      }
      function updateActivityComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
        workInProgress2.flags &= -129;
        if (null === current) {
          if (isHydrating) {
            if ("hidden" === nextProps.mode)
              return current = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current);
            pushDehydratedActivitySuspenseHandler(workInProgress2);
            (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
              current,
              rootOrSingletonContext
            ), current = null !== current && "&" === current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
              dehydrated: current,
              treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
            if (null === current) throw throwOnHydrationMismatch(workInProgress2);
            workInProgress2.lanes = 536870912;
            return null;
          }
          return mountActivityChildren(workInProgress2, nextProps);
        }
        var prevState = current.memoizedState;
        if (null !== prevState) {
          var dehydrated = prevState.dehydrated;
          pushDehydratedActivitySuspenseHandler(workInProgress2);
          if (didSuspend)
            if (workInProgress2.flags & 256)
              workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
                current,
                workInProgress2,
                renderLanes2
              );
            else if (null !== workInProgress2.memoizedState)
              workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null;
            else throw Error(formatProdErrorMessage(558));
          else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), didSuspend = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || didSuspend) {
            nextProps = workInProgressRoot;
            if (null !== nextProps && (dehydrated = getBumpedLaneForHydration(nextProps, renderLanes2), 0 !== dehydrated && dehydrated !== prevState.retryLane))
              throw prevState.retryLane = dehydrated, enqueueConcurrentRenderForLane(current, dehydrated), scheduleUpdateOnFiber(nextProps, current, dehydrated), SelectiveHydrationException;
            renderDidSuspendDelayIfPossible();
            workInProgress2 = retryActivityComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            current = prevState.treeContext, nextHydratableInstance = getNextHydratable(dehydrated.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
          return workInProgress2;
        }
        current = createWorkInProgress(current.child, {
          mode: nextProps.mode,
          children: nextProps.children
        });
        current.ref = workInProgress2.ref;
        workInProgress2.child = current;
        current.return = workInProgress2;
        return current;
      }
      function markRef(current, workInProgress2) {
        var ref = workInProgress2.ref;
        if (null === ref)
          null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
        else {
          if ("function" !== typeof ref && "object" !== typeof ref)
            throw Error(formatProdErrorMessage(284));
          if (null === current || current.ref !== ref)
            workInProgress2.flags |= 4194816;
        }
      }
      function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        Component = renderWithHooks(
          current,
          workInProgress2,
          Component,
          nextProps,
          void 0,
          renderLanes2
        );
        nextProps = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, Component, renderLanes2);
        return workInProgress2.child;
      }
      function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
        prepareToReadContext(workInProgress2);
        workInProgress2.updateQueue = null;
        nextProps = renderWithHooksAgain(
          workInProgress2,
          Component,
          nextProps,
          secondArg
        );
        finishRenderingHooks(current);
        Component = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && Component && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        if (null === workInProgress2.stateNode) {
          var context = emptyContextObject, contextType = Component.contextType;
          "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
          context = new Component(nextProps, context);
          workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
          context.updater = classComponentUpdater;
          workInProgress2.stateNode = context;
          context._reactInternals = workInProgress2;
          context = workInProgress2.stateNode;
          context.props = nextProps;
          context.state = workInProgress2.memoizedState;
          context.refs = {};
          initializeUpdateQueue(workInProgress2);
          contextType = Component.contextType;
          context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
          context.state = workInProgress2.memoizedState;
          contextType = Component.getDerivedStateFromProps;
          "function" === typeof contextType && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            contextType,
            nextProps
          ), context.state = workInProgress2.memoizedState);
          "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
          "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
          nextProps = true;
        } else if (null === current) {
          context = workInProgress2.stateNode;
          var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
          context.props = oldProps;
          var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
          contextType = emptyContextObject;
          "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;
          contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
          unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
          contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            contextType
          );
          hasForceUpdate = false;
          var oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          oldContext = workInProgress2.memoizedState;
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            getDerivedStateFromProps,
            nextProps
          ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
        } else {
          context = workInProgress2.stateNode;
          cloneUpdateQueue(current, workInProgress2);
          contextType = workInProgress2.memoizedProps;
          contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
          context.props = contextType$jscomp$0;
          getDerivedStateFromProps = workInProgress2.pendingProps;
          oldState = context.context;
          oldContext = Component.contextType;
          oldProps = emptyContextObject;
          "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
          unresolvedOldProps = Component.getDerivedStateFromProps;
          (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            oldProps
          );
          hasForceUpdate = false;
          oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          var newState = workInProgress2.memoizedState;
          contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            unresolvedOldProps,
            nextProps
          ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
            nextProps,
            newState,
            oldProps
          )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
        }
        context = nextProps;
        markRef(current, workInProgress2);
        nextProps = 0 !== (workInProgress2.flags & 128);
        context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          current.child,
          null,
          renderLanes2
        ), workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          null,
          Component,
          renderLanes2
        )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress2,
          renderLanes2
        );
        return current;
      }
      function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
        resetHydrationState();
        workInProgress2.flags |= 256;
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
      }
      function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
        current = null !== current ? current.childLanes & ~renderLanes2 : 0;
        primaryTreeDidDefer && (current |= workInProgressDeferredLane);
        return current;
      }
      function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
        JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
        JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
        workInProgress2.flags &= -33;
        if (null === current) {
          if (isHydrating) {
            showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
            (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
              current,
              rootOrSingletonContext
            ), current = null !== current && "&" !== current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
              dehydrated: current,
              treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
            if (null === current) throw throwOnHydrationMismatch(workInProgress2);
            isSuspenseInstanceFallback(current) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
            return null;
          }
          var nextPrimaryChildren = nextProps.children;
          nextProps = nextProps.fallback;
          if (showFallback)
            return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = workInProgress2.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
              { mode: "hidden", children: nextPrimaryChildren },
              showFallback
            ), nextProps = createFiberFromFragment(
              nextProps,
              showFallback,
              renderLanes2,
              null
            ), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextPrimaryChildren.sibling = nextProps, workInProgress2.child = nextPrimaryChildren, nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
        }
        var prevState = current.memoizedState;
        if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {
          if (didSuspend)
            workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              showFallback
            ), nextPrimaryChildren = createFiberFromFragment(
              nextPrimaryChildren,
              showFallback,
              renderLanes2,
              null
            ), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, reconcileChildFibers(
              workInProgress2,
              current.child,
              null,
              renderLanes2
            ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, nextProps));
          else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextPrimaryChildren)) {
            JSCompiler_temp = nextPrimaryChildren.nextSibling && nextPrimaryChildren.nextSibling.dataset;
            if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
            JSCompiler_temp = digest;
            nextProps = Error(formatProdErrorMessage(419));
            nextProps.stack = "";
            nextProps.digest = JSCompiler_temp;
            queueHydrationError({ value: nextProps, source: null, stack: null });
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
            JSCompiler_temp = workInProgressRoot;
            if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes2), 0 !== nextProps && nextProps !== prevState.retryLane))
              throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
            isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(
              nextPrimaryChildren.nextSibling
            ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountSuspensePrimaryChildren(
              workInProgress2,
              nextProps.children
            ), workInProgress2.flags |= 4096);
          return workInProgress2;
        }
        if (showFallback)
          return reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, prevState = current.child, digest = prevState.sibling, nextProps = createWorkInProgress(prevState, {
            mode: "hidden",
            children: nextProps.children
          }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== digest ? nextPrimaryChildren = createWorkInProgress(
            digest,
            nextPrimaryChildren
          ) : (nextPrimaryChildren = createFiberFromFragment(
            nextPrimaryChildren,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress2.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = CacheContext._currentValue, showFallback = showFallback.parent !== prevState ? { parent: prevState, pool: prevState } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
            baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
            cachePool: showFallback
          }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        renderLanes2 = current.child;
        current = renderLanes2.sibling;
        renderLanes2 = createWorkInProgress(renderLanes2, {
          mode: "visible",
          children: nextProps.children
        });
        renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
        null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
        workInProgress2.child = renderLanes2;
        workInProgress2.memoizedState = null;
        return renderLanes2;
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: primaryChildren },
          workInProgress2.mode
        );
        primaryChildren.return = workInProgress2;
        return workInProgress2.child = primaryChildren;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
        offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
        offscreenProps.lanes = 0;
        return offscreenProps;
      }
      function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountSuspensePrimaryChildren(
          workInProgress2,
          workInProgress2.pendingProps.children
        );
        current.flags |= 2;
        workInProgress2.memoizedState = null;
        return current;
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes |= renderLanes2;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
        var renderState = workInProgress2.memoizedState;
        null === renderState ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode,
          treeForkCount: treeForkCount2
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
      }
      function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
        nextProps = nextProps.children;
        var suspenseContext = suspenseStackCursor.current, shouldForceFallback = 0 !== (suspenseContext & 2);
        shouldForceFallback ? (suspenseContext = suspenseContext & 1 | 2, workInProgress2.flags |= 128) : suspenseContext &= 1;
        push(suspenseStackCursor, suspenseContext);
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        nextProps = isHydrating ? treeForkCount : 0;
        if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
          a: for (current = workInProgress2.child; null !== current; ) {
            if (13 === current.tag)
              null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
            else if (19 === current.tag)
              scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
            else if (null !== current.child) {
              current.child.return = current;
              current = current.child;
              continue;
            }
            if (current === workInProgress2) break a;
            for (; null === current.sibling; ) {
              if (null === current.return || current.return === workInProgress2)
                break a;
              current = current.return;
            }
            current.sibling.return = current.return;
            current = current.sibling;
          }
        switch (revealOrder) {
          case "forwards":
            renderLanes2 = workInProgress2.child;
            for (revealOrder = null; null !== renderLanes2; )
              current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
            renderLanes2 = revealOrder;
            null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
            initSuspenseListRenderState(
              workInProgress2,
              false,
              revealOrder,
              renderLanes2,
              tailMode,
              nextProps
            );
            break;
          case "backwards":
          case "unstable_legacy-backwards":
            renderLanes2 = null;
            revealOrder = workInProgress2.child;
            for (workInProgress2.child = null; null !== revealOrder; ) {
              current = revealOrder.alternate;
              if (null !== current && null === findFirstSuspended(current)) {
                workInProgress2.child = revealOrder;
                break;
              }
              current = revealOrder.sibling;
              revealOrder.sibling = renderLanes2;
              renderLanes2 = revealOrder;
              revealOrder = current;
            }
            initSuspenseListRenderState(
              workInProgress2,
              true,
              renderLanes2,
              null,
              tailMode,
              nextProps
            );
            break;
          case "together":
            initSuspenseListRenderState(
              workInProgress2,
              false,
              null,
              null,
              void 0,
              nextProps
            );
            break;
          default:
            workInProgress2.memoizedState = null;
        }
        return workInProgress2.child;
      }
      function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
        null !== current && (workInProgress2.dependencies = current.dependencies);
        workInProgressRootSkippedLanes |= workInProgress2.lanes;
        if (0 === (renderLanes2 & workInProgress2.childLanes))
          if (null !== current) {
            if (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), 0 === (renderLanes2 & workInProgress2.childLanes))
              return null;
          } else return null;
        if (null !== current && workInProgress2.child !== current.child)
          throw Error(formatProdErrorMessage(153));
        if (null !== workInProgress2.child) {
          current = workInProgress2.child;
          renderLanes2 = createWorkInProgress(current, current.pendingProps);
          workInProgress2.child = renderLanes2;
          for (renderLanes2.return = workInProgress2; null !== current.sibling; )
            current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
        }
        return workInProgress2.child;
      }
      function checkScheduledUpdateOrContext(current, renderLanes2) {
        if (0 !== (current.lanes & renderLanes2)) return true;
        current = current.dependencies;
        return null !== current && checkIfContextChanged(current) ? true : false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case 3:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
            resetHydrationState();
            break;
          case 27:
          case 5:
            pushHostContext(workInProgress2);
            break;
          case 4:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case 10:
            pushProvider(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.memoizedProps.value
            );
            break;
          case 31:
            if (null !== workInProgress2.memoizedState)
              return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
            break;
          case 13:
            var state$102 = workInProgress2.memoizedState;
            if (null !== state$102) {
              if (null !== state$102.dehydrated)
                return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
              if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                return updateSuspenseComponent(current, workInProgress2, renderLanes2);
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              current = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              return null !== current ? current.sibling : null;
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            break;
          case 19:
            var didSuspendBefore = 0 !== (current.flags & 128);
            state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes);
            state$102 || (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes));
            if (didSuspendBefore) {
              if (state$102)
                return updateSuspenseListComponent(
                  current,
                  workInProgress2,
                  renderLanes2
                );
              workInProgress2.flags |= 128;
            }
            didSuspendBefore = workInProgress2.memoizedState;
            null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
            push(suspenseStackCursor, suspenseStackCursor.current);
            if (state$102) break;
            else return null;
          case 22:
            return workInProgress2.lanes = 0, updateOffscreenComponent(
              current,
              workInProgress2,
              renderLanes2,
              workInProgress2.pendingProps
            );
          case 24:
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
        }
        return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      function beginWork(current, workInProgress2, renderLanes2) {
        if (null !== current)
          if (current.memoizedProps !== workInProgress2.pendingProps)
            didReceiveUpdate = true;
          else {
            if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
              return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress2,
                renderLanes2
              );
            didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
          }
        else
          didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
        workInProgress2.lanes = 0;
        switch (workInProgress2.tag) {
          case 16:
            a: {
              var props = workInProgress2.pendingProps;
              current = resolveLazy(workInProgress2.elementType);
              workInProgress2.type = current;
              if ("function" === typeof current)
                shouldConstruct(current) ? (props = resolveClassComponentProps(current, props), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  current,
                  props,
                  renderLanes2
                )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  current,
                  props,
                  renderLanes2
                ));
              else {
                if (void 0 !== current && null !== current) {
                  var $$typeof = current.$$typeof;
                  if ($$typeof === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      current,
                      props,
                      renderLanes2
                    );
                    break a;
                  } else if ($$typeof === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      current,
                      props,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = getComponentNameFromType(current) || current;
                throw Error(formatProdErrorMessage(306, workInProgress2, ""));
              }
            }
            return workInProgress2;
          case 0:
            return updateFunctionComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 1:
            return props = workInProgress2.type, $$typeof = resolveClassComponentProps(
              props,
              workInProgress2.pendingProps
            ), updateClassComponent(
              current,
              workInProgress2,
              props,
              $$typeof,
              renderLanes2
            );
          case 3:
            a: {
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              if (null === current) throw Error(formatProdErrorMessage(387));
              props = workInProgress2.pendingProps;
              var prevState = workInProgress2.memoizedState;
              $$typeof = prevState.element;
              cloneUpdateQueue(current, workInProgress2);
              processUpdateQueue(workInProgress2, props, null, renderLanes2);
              var nextState = workInProgress2.memoizedState;
              props = nextState.cache;
              pushProvider(workInProgress2, CacheContext, props);
              props !== prevState.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              );
              suspendIfUpdateReadFromEntangledAsyncAction();
              props = nextState.element;
              if (prevState.isDehydrated)
                if (prevState = {
                  element: props,
                  isDehydrated: false,
                  cache: nextState.cache
                }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    props,
                    renderLanes2
                  );
                  break a;
                } else if (props !== $$typeof) {
                  $$typeof = createCapturedValueAtFiber(
                    Error(formatProdErrorMessage(424)),
                    workInProgress2
                  );
                  queueHydrationError($$typeof);
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    props,
                    renderLanes2
                  );
                  break a;
                } else {
                  current = workInProgress2.stateNode.containerInfo;
                  switch (current.nodeType) {
                    case 9:
                      current = current.body;
                      break;
                    default:
                      current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                  }
                  nextHydratableInstance = getNextHydratable(current.firstChild);
                  hydrationParentFiber = workInProgress2;
                  isHydrating = true;
                  hydrationErrors = null;
                  rootOrSingletonContext = true;
                  renderLanes2 = mountChildFibers(
                    workInProgress2,
                    null,
                    props,
                    renderLanes2
                  );
                  for (workInProgress2.child = renderLanes2; renderLanes2; )
                    renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                }
              else {
                resetHydrationState();
                if (props === $$typeof) {
                  workInProgress2 = bailoutOnAlreadyFinishedWork(
                    current,
                    workInProgress2,
                    renderLanes2
                  );
                  break a;
                }
                reconcileChildren(current, workInProgress2, props, renderLanes2);
              }
              workInProgress2 = workInProgress2.child;
            }
            return workInProgress2;
          case 26:
            return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
              workInProgress2.type,
              null,
              workInProgress2.pendingProps,
              null
            )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, props = getOwnerDocumentFromRootContainer(
              rootInstanceStackCursor.current
            ).createElement(renderLanes2), props[internalInstanceKey] = workInProgress2, props[internalPropsKey] = current, setInitialProperties(props, renderLanes2, current), markNodeAsHoistable(props), workInProgress2.stateNode = props) : workInProgress2.memoizedState = getResource(
              workInProgress2.type,
              current.memoizedProps,
              workInProgress2.pendingProps,
              current.memoizedState
            ), null;
          case 27:
            return pushHostContext(workInProgress2), null === current && isHydrating && (props = workInProgress2.stateNode = resolveSingletonInstance(
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootInstanceStackCursor.current
            ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, $$typeof = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = $$typeof, nextHydratableInstance = getNextHydratable(props.firstChild)) : nextHydratableInstance = $$typeof), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
          case 5:
            if (null === current && isHydrating) {
              if ($$typeof = props = nextHydratableInstance)
                props = canHydrateInstance(
                  props,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== props ? (workInProgress2.stateNode = props, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(props.firstChild), rootOrSingletonContext = false, $$typeof = true) : $$typeof = false;
              $$typeof || throwOnHydrationMismatch(workInProgress2);
            }
            pushHostContext(workInProgress2);
            $$typeof = workInProgress2.type;
            prevState = workInProgress2.pendingProps;
            nextState = null !== current ? current.memoizedProps : null;
            props = prevState.children;
            shouldSetTextContent($$typeof, prevState) ? props = null : null !== nextState && shouldSetTextContent($$typeof, nextState) && (workInProgress2.flags |= 32);
            null !== workInProgress2.memoizedState && ($$typeof = renderWithHooks(
              current,
              workInProgress2,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes2
            ), HostTransitionContext._currentValue = $$typeof);
            markRef(current, workInProgress2);
            reconcileChildren(current, workInProgress2, props, renderLanes2);
            return workInProgress2.child;
          case 6:
            if (null === current && isHydrating) {
              if (current = renderLanes2 = nextHydratableInstance)
                renderLanes2 = canHydrateTextInstance(
                  renderLanes2,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
              current || throwOnHydrationMismatch(workInProgress2);
            }
            return null;
          case 13:
            return updateSuspenseComponent(current, workInProgress2, renderLanes2);
          case 4:
            return pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            ), props = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              props,
              renderLanes2
            ) : reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
          case 11:
            return updateForwardRef(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 7:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps,
              renderLanes2
            ), workInProgress2.child;
          case 8:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 12:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 10:
            return props = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, props.value), reconcileChildren(current, workInProgress2, props.children, renderLanes2), workInProgress2.child;
          case 9:
            return $$typeof = workInProgress2.type._context, props = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), $$typeof = readContext($$typeof), props = props($$typeof), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
          case 14:
            return updateMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 15:
            return updateSimpleMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 19:
            return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
          case 31:
            return updateActivityComponent(current, workInProgress2, renderLanes2);
          case 22:
            return updateOffscreenComponent(
              current,
              workInProgress2,
              renderLanes2,
              workInProgress2.pendingProps
            );
          case 24:
            return prepareToReadContext(workInProgress2), props = readContext(CacheContext), null === current ? ($$typeof = peekCacheFromPool(), null === $$typeof && ($$typeof = workInProgressRoot, prevState = createCache(), $$typeof.pooledCache = prevState, prevState.refCount++, null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes2), $$typeof = prevState), workInProgress2.memoizedState = { parent: props, cache: $$typeof }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, $$typeof)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), $$typeof = current.memoizedState, prevState = workInProgress2.memoizedState, $$typeof.parent !== props ? ($$typeof = { parent: props, cache: props }, workInProgress2.memoizedState = $$typeof, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = $$typeof), pushProvider(workInProgress2, CacheContext, props)) : (props = prevState.cache, pushProvider(workInProgress2, CacheContext, props), props !== $$typeof.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            ))), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 29:
            throw workInProgress2.pendingProps;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= 4;
      }
      function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
        if (type = 0 !== (workInProgress2.mode & 32)) type = false;
        if (type) {
          if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
            if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
            else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
            else
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
        } else workInProgress2.flags &= -16777217;
      }
      function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
        if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
          workInProgress2.flags &= -16777217;
        else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
          if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      }
      function scheduleRetryEffect(workInProgress2, retryQueue) {
        null !== retryQueue && (workInProgress2.flags |= 4);
        workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating)
          switch (renderState.tailMode) {
            case "hidden":
              hasRenderedATailFallback = renderState.tail;
              for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
              null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            case "collapsed":
              lastTailNode = renderState.tail;
              for (var lastTailNode$106 = null; null !== lastTailNode; )
                null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode), lastTailNode = lastTailNode.sibling;
              null === lastTailNode$106 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$106.sibling = null;
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
        if (didBailout)
          for (var child$107 = completedWork.child; null !== child$107; )
            newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags & 65011712, subtreeFlags |= child$107.flags & 65011712, child$107.return = completedWork, child$107 = child$107.sibling;
        else
          for (child$107 = completedWork.child; null !== child$107; )
            newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags, subtreeFlags |= child$107.flags, child$107.return = completedWork, child$107 = child$107.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeWork(current, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return bubbleProperties(workInProgress2), null;
          case 1:
            return bubbleProperties(workInProgress2), null;
          case 3:
            renderLanes2 = workInProgress2.stateNode;
            newProps = null;
            null !== current && (newProps = current.memoizedState.cache);
            workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
            popProvider(CacheContext);
            popHostContainer();
            renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
            if (null === current || null === current.child)
              popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
            bubbleProperties(workInProgress2);
            return null;
          case 26:
            var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
            null === current ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              type,
              null,
              newProps,
              renderLanes2
            ))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              type,
              current,
              newProps,
              renderLanes2
            ));
            return null;
          case 27:
            popHostContext(workInProgress2);
            renderLanes2 = rootInstanceStackCursor.current;
            type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 5:
            popHostContext(workInProgress2);
            type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              nextResource = contextStackCursor.current;
              if (popHydrationState(workInProgress2))
                prepareToHydrateHostInstance(workInProgress2, nextResource);
              else {
                var ownerDocument = getOwnerDocumentFromRootContainer(
                  rootInstanceStackCursor.current
                );
                switch (nextResource) {
                  case 1:
                    nextResource = ownerDocument.createElementNS(
                      "http://www.w3.org/2000/svg",
                      type
                    );
                    break;
                  case 2:
                    nextResource = ownerDocument.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      type
                    );
                    break;
                  default:
                    switch (type) {
                      case "svg":
                        nextResource = ownerDocument.createElementNS(
                          "http://www.w3.org/2000/svg",
                          type
                        );
                        break;
                      case "math":
                        nextResource = ownerDocument.createElementNS(
                          "http://www.w3.org/1998/Math/MathML",
                          type
                        );
                        break;
                      case "script":
                        nextResource = ownerDocument.createElement("div");
                        nextResource.innerHTML = "<script><\/script>";
                        nextResource = nextResource.removeChild(
                          nextResource.firstChild
                        );
                        break;
                      case "select":
                        nextResource = "string" === typeof newProps.is ? ownerDocument.createElement("select", {
                          is: newProps.is
                        }) : ownerDocument.createElement("select");
                        newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                        break;
                      default:
                        nextResource = "string" === typeof newProps.is ? ownerDocument.createElement(type, { is: newProps.is }) : ownerDocument.createElement(type);
                    }
                }
                nextResource[internalInstanceKey] = workInProgress2;
                nextResource[internalPropsKey] = newProps;
                a: for (ownerDocument = workInProgress2.child; null !== ownerDocument; ) {
                  if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
                    nextResource.appendChild(ownerDocument.stateNode);
                  else if (4 !== ownerDocument.tag && 27 !== ownerDocument.tag && null !== ownerDocument.child) {
                    ownerDocument.child.return = ownerDocument;
                    ownerDocument = ownerDocument.child;
                    continue;
                  }
                  if (ownerDocument === workInProgress2) break a;
                  for (; null === ownerDocument.sibling; ) {
                    if (null === ownerDocument.return || ownerDocument.return === workInProgress2)
                      break a;
                    ownerDocument = ownerDocument.return;
                  }
                  ownerDocument.sibling.return = ownerDocument.return;
                  ownerDocument = ownerDocument.sibling;
                }
                workInProgress2.stateNode = nextResource;
                a: switch (setInitialProperties(nextResource, type, newProps), type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    newProps = !!newProps.autoFocus;
                    break a;
                  case "img":
                    newProps = true;
                    break a;
                  default:
                    newProps = false;
                }
                newProps && markUpdate(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            preloadInstanceAndSuspendIfNeeded(
              workInProgress2,
              workInProgress2.type,
              null === current ? null : current.memoizedProps,
              workInProgress2.pendingProps,
              renderLanes2
            );
            return null;
          case 6:
            if (current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              current = rootInstanceStackCursor.current;
              if (popHydrationState(workInProgress2)) {
                current = workInProgress2.stateNode;
                renderLanes2 = workInProgress2.memoizedProps;
                newProps = null;
                type = hydrationParentFiber;
                if (null !== type)
                  switch (type.tag) {
                    case 27:
                    case 5:
                      newProps = type.memoizedProps;
                  }
                current[internalInstanceKey] = workInProgress2;
                current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
                current || throwOnHydrationMismatch(workInProgress2, true);
              } else
                current = getOwnerDocumentFromRootContainer(current).createTextNode(
                  newProps
                ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
            }
            bubbleProperties(workInProgress2);
            return null;
          case 31:
            renderLanes2 = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState) {
              newProps = popHydrationState(workInProgress2);
              if (null !== renderLanes2) {
                if (null === current) {
                  if (!newProps) throw Error(formatProdErrorMessage(318));
                  current = workInProgress2.memoizedState;
                  current = null !== current ? current.dehydrated : null;
                  if (!current) throw Error(formatProdErrorMessage(557));
                  current[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                current = false;
              } else
                renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes2), current = true;
              if (!current) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
              if (0 !== (workInProgress2.flags & 128))
                throw Error(formatProdErrorMessage(558));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 13:
            newProps = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
              type = popHydrationState(workInProgress2);
              if (null !== newProps && null !== newProps.dehydrated) {
                if (null === current) {
                  if (!type) throw Error(formatProdErrorMessage(318));
                  type = workInProgress2.memoizedState;
                  type = null !== type ? type.dehydrated : null;
                  if (!type) throw Error(formatProdErrorMessage(317));
                  type[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                type = false;
              } else
                type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
              if (!type) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
            }
            popSuspenseHandler(workInProgress2);
            if (0 !== (workInProgress2.flags & 128))
              return workInProgress2.lanes = renderLanes2, workInProgress2;
            renderLanes2 = null !== newProps;
            current = null !== current && null !== current.memoizedState;
            renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
            renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
            scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
            bubbleProperties(workInProgress2);
            return null;
          case 4:
            return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
          case 19:
            pop(suspenseStackCursor);
            newProps = workInProgress2.memoizedState;
            if (null === newProps) return bubbleProperties(workInProgress2), null;
            type = 0 !== (workInProgress2.flags & 128);
            nextResource = newProps.rendering;
            if (null === nextResource)
              if (type) cutOffTailIfNeeded(newProps, false);
              else {
                if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                  for (current = workInProgress2.child; null !== current; ) {
                    nextResource = findFirstSuspended(current);
                    if (null !== nextResource) {
                      workInProgress2.flags |= 128;
                      cutOffTailIfNeeded(newProps, false);
                      current = nextResource.updateQueue;
                      workInProgress2.updateQueue = current;
                      scheduleRetryEffect(workInProgress2, current);
                      workInProgress2.subtreeFlags = 0;
                      current = renderLanes2;
                      for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                        resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                      push(
                        suspenseStackCursor,
                        suspenseStackCursor.current & 1 | 2
                      );
                      isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                      return workInProgress2.child;
                    }
                    current = current.sibling;
                  }
                null !== newProps.tail && now2() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
              }
            else {
              if (!type)
                if (current = findFirstSuspended(nextResource), null !== current) {
                  if (workInProgress2.flags |= 128, type = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                    return bubbleProperties(workInProgress2), null;
                } else
                  2 * now2() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
              newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
            }
            if (null !== newProps.tail)
              return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now2(), current.sibling = null, renderLanes2 = suspenseStackCursor.current, push(
                suspenseStackCursor,
                type ? renderLanes2 & 1 | 2 : renderLanes2 & 1
              ), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current;
            bubbleProperties(workInProgress2);
            return null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
          case 24:
            return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
          case 25:
            return null;
          case 30:
            return null;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function unwindWork(current, workInProgress2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 1:
            return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 3:
            return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 26:
          case 27:
          case 5:
            return popHostContext(workInProgress2), null;
          case 31:
            if (null !== workInProgress2.memoizedState) {
              popSuspenseHandler(workInProgress2);
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 13:
            popSuspenseHandler(workInProgress2);
            current = workInProgress2.memoizedState;
            if (null !== current && null !== current.dehydrated) {
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 19:
            return pop(suspenseStackCursor), null;
          case 4:
            return popHostContainer(), null;
          case 10:
            return popProvider(workInProgress2.type), null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 24:
            return popProvider(CacheContext), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current, interruptedWork) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case 3:
            popProvider(CacheContext);
            popHostContainer();
            break;
          case 26:
          case 27:
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer();
            break;
          case 31:
            null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
            break;
          case 13:
            popSuspenseHandler(interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor);
            break;
          case 10:
            popProvider(interruptedWork.type);
            break;
          case 22:
          case 23:
            popSuspenseHandler(interruptedWork);
            popHiddenContext();
            null !== current && pop(resumedCache);
            break;
          case 24:
            popProvider(CacheContext);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                lastEffect = void 0;
                var create2 = updateQueue.create, inst = updateQueue.inst;
                lastEffect = create2();
                inst.destroy = lastEffect;
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
        try {
          var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue = firstEffect;
            do {
              if ((updateQueue.tag & flags) === flags) {
                var inst = updateQueue.inst, destroy = inst.destroy;
                if (void 0 !== destroy) {
                  inst.destroy = void 0;
                  lastEffect = finishedWork;
                  var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                  try {
                    destroy_();
                  } catch (error) {
                    captureCommitPhaseError(
                      lastEffect,
                      nearestMountedAncestor,
                      error
                    );
                  }
                }
              }
              updateQueue = updateQueue.next;
            } while (updateQueue !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitClassCallbacks(finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        if (null !== updateQueue) {
          var instance = finishedWork.stateNode;
          try {
            commitCallbacks(updateQueue, instance);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
        instance.props = resolveClassComponentProps(
          current.type,
          current.memoizedProps
        );
        instance.state = current.memoizedState;
        try {
          instance.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyAttachRef(current, nearestMountedAncestor) {
        try {
          var ref = current.ref;
          if (null !== ref) {
            switch (current.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = current.stateNode;
                break;
              case 30:
                instanceToUse = current.stateNode;
                break;
              default:
                instanceToUse = current.stateNode;
            }
            "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
          }
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyDetachRef(current, nearestMountedAncestor) {
        var ref = current.ref, refCleanup = current.refCleanup;
        if (null !== ref)
          if ("function" === typeof refCleanup)
            try {
              refCleanup();
            } catch (error) {
              captureCommitPhaseError(current, nearestMountedAncestor, error);
            } finally {
              current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
            }
          else if ("function" === typeof ref)
            try {
              ref(null);
            } catch (error$140) {
              captureCommitPhaseError(current, nearestMountedAncestor, error$140);
            }
          else ref.current = null;
      }
      function commitHostMount(finishedWork) {
        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
        try {
          a: switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              props.autoFocus && instance.focus();
              break a;
            case "img":
              props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
          var domElement = finishedWork.stateNode;
          updateProperties(domElement, finishedWork.type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function isHostParent(fiber) {
        return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
      }
      function getHostSibling(fiber) {
        a: for (; ; ) {
          for (; null === fiber.sibling; ) {
            if (null === fiber.return || isHostParent(fiber.return)) return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
            if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
            if (fiber.flags & 2) continue a;
            if (null === fiber.child || 4 === fiber.tag) continue a;
            else fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2)) return fiber.stateNode;
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
          for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        if (5 === tag || 6 === tag)
          node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
        else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
          for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
            insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      }
      function commitHostSingletonAcquisition(finishedWork) {
        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
        try {
          for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
            singleton.removeAttributeNode(attributes[0]);
          setInitialProperties(singleton, type, props);
          singleton[internalInstanceKey] = finishedWork;
          singleton[internalPropsKey] = props;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      var offscreenSubtreeIsHidden = false;
      var offscreenSubtreeWasHidden = false;
      var needsFormReset = false;
      var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set;
      var nextEffect = null;
      function commitBeforeMutationEffects(root3, firstChild) {
        root3 = root3.containerInfo;
        eventsEnabled = _enabled;
        root3 = getActiveElementDeep(root3);
        if (hasSelectionCapabilities(root3)) {
          if ("selectionStart" in root3)
            var JSCompiler_temp = {
              start: root3.selectionStart,
              end: root3.selectionEnd
            };
          else
            a: {
              JSCompiler_temp = (JSCompiler_temp = root3.ownerDocument) && JSCompiler_temp.defaultView || window;
              var selection2 = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
              if (selection2 && 0 !== selection2.rangeCount) {
                JSCompiler_temp = selection2.anchorNode;
                var anchorOffset = selection2.anchorOffset, focusNode = selection2.focusNode;
                selection2 = selection2.focusOffset;
                try {
                  JSCompiler_temp.nodeType, focusNode.nodeType;
                } catch (e$20) {
                  JSCompiler_temp = null;
                  break a;
                }
                var length = 0, start2 = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root3, parentNode = null;
                b: for (; ; ) {
                  for (var next; ; ) {
                    node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start2 = length + anchorOffset);
                    node !== focusNode || 0 !== selection2 && 3 !== node.nodeType || (end = length + selection2);
                    3 === node.nodeType && (length += node.nodeValue.length);
                    if (null === (next = node.firstChild)) break;
                    parentNode = node;
                    node = next;
                  }
                  for (; ; ) {
                    if (node === root3) break b;
                    parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start2 = length);
                    parentNode === focusNode && ++indexWithinFocus === selection2 && (end = length);
                    if (null !== (next = node.nextSibling)) break;
                    node = parentNode;
                    parentNode = node.parentNode;
                  }
                  node = next;
                }
                JSCompiler_temp = -1 === start2 || -1 === end ? null : { start: start2, end };
              } else JSCompiler_temp = null;
            }
          JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
        } else JSCompiler_temp = null;
        selectionInformation = { focusedElem: root3, selectionRange: JSCompiler_temp };
        _enabled = false;
        for (nextEffect = firstChild; null !== nextEffect; )
          if (firstChild = nextEffect, root3 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root3)
            root3.return = firstChild, nextEffect = root3;
          else
            for (; null !== nextEffect; ) {
              firstChild = nextEffect;
              focusNode = firstChild.alternate;
              root3 = firstChild.flags;
              switch (firstChild.tag) {
                case 0:
                  if (0 !== (root3 & 4) && (root3 = firstChild.updateQueue, root3 = null !== root3 ? root3.events : null, null !== root3))
                    for (JSCompiler_temp = 0; JSCompiler_temp < root3.length; JSCompiler_temp++)
                      anchorOffset = root3[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if (0 !== (root3 & 1024) && null !== focusNode) {
                    root3 = void 0;
                    JSCompiler_temp = firstChild;
                    anchorOffset = focusNode.memoizedProps;
                    focusNode = focusNode.memoizedState;
                    selection2 = JSCompiler_temp.stateNode;
                    try {
                      var resolvedPrevProps = resolveClassComponentProps(
                        JSCompiler_temp.type,
                        anchorOffset
                      );
                      root3 = selection2.getSnapshotBeforeUpdate(
                        resolvedPrevProps,
                        focusNode
                      );
                      selection2.__reactInternalSnapshotBeforeUpdate = root3;
                    } catch (error) {
                      captureCommitPhaseError(
                        JSCompiler_temp,
                        JSCompiler_temp.return,
                        error
                      );
                    }
                  }
                  break;
                case 3:
                  if (0 !== (root3 & 1024)) {
                    if (root3 = firstChild.stateNode.containerInfo, JSCompiler_temp = root3.nodeType, 9 === JSCompiler_temp)
                      clearContainerSparingly(root3);
                    else if (1 === JSCompiler_temp)
                      switch (root3.nodeName) {
                        case "HEAD":
                        case "HTML":
                        case "BODY":
                          clearContainerSparingly(root3);
                          break;
                        default:
                          root3.textContent = "";
                      }
                  }
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if (0 !== (root3 & 1024)) throw Error(formatProdErrorMessage(163));
              }
              root3 = firstChild.sibling;
              if (null !== root3) {
                root3.return = firstChild.return;
                nextEffect = root3;
                break;
              }
              nextEffect = firstChild.return;
            }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitHookEffectListMount(5, finishedWork);
            break;
          case 1:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 4)
              if (finishedRoot = finishedWork.stateNode, null === current)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              else {
                var prevProps = resolveClassComponentProps(
                  finishedWork.type,
                  current.memoizedProps
                );
                current = current.memoizedState;
                try {
                  finishedRoot.componentDidUpdate(
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (error$139) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error$139
                  );
                }
              }
            flags & 64 && commitClassCallbacks(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
              current = null;
              if (null !== finishedWork.child)
                switch (finishedWork.child.tag) {
                  case 27:
                  case 5:
                    current = finishedWork.child.stateNode;
                    break;
                  case 1:
                    current = finishedWork.child.stateNode;
                }
              try {
                commitCallbacks(finishedRoot, current);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 27:
            null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            null === current && flags & 4 && commitHostMount(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            break;
          case 31:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
            break;
          case 22:
            flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
            if (!flags) {
              current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
              prevProps = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = flags;
              (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                0 !== (finishedWork.subtreeFlags & 8772)
              ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              offscreenSubtreeIsHidden = prevProps;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            }
            break;
          case 30:
            break;
          default:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
      }
      var hostParent = null;
      var hostParentIsContainer = false;
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (parent = parent.child; null !== parent; )
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
          try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
          } catch (err) {
          }
        switch (deletedFiber.tag) {
          case 26:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
            break;
          case 27:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
            isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            releaseSingletonInstance(deletedFiber.stateNode);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 5:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          case 6:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = null;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            if (null !== hostParent)
              if (hostParentIsContainer)
                try {
                  (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
              else
                try {
                  hostParent.removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
            break;
          case 18:
            null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
              9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
              deletedFiber.stateNode
            ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
            break;
          case 4:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = deletedFiber.stateNode.containerInfo;
            hostParentIsContainer = true;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 1:
            offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
              deletedFiber,
              nearestMountedAncestor,
              prevHostParent
            ));
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 21:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 22:
            offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            offscreenSubtreeWasHidden = prevHostParent;
            break;
          default:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
        }
      }
      function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
          finishedRoot = finishedRoot.dehydrated;
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
      }
      function getRetryCache(finishedWork) {
        switch (finishedWork.tag) {
          case 31:
          case 13:
          case 19:
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
            return retryCache;
          case 22:
            return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
          default:
            throw Error(formatProdErrorMessage(435, finishedWork.tag));
        }
      }
      function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function(wakeable) {
          if (!retryCache.has(wakeable)) {
            retryCache.add(wakeable);
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            wakeable.then(retry, retry);
          }
        });
      }
      function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions)
          for (var i2 = 0; i2 < deletions.length; i2++) {
            var childToDelete = deletions[i2], root3 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
            a: for (; null !== parent; ) {
              switch (parent.tag) {
                case 27:
                  if (isSingletonScope(parent.type)) {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  }
                  break;
                case 5:
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                case 3:
                case 4:
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break a;
              }
              parent = parent.return;
            }
            if (null === hostParent) throw Error(formatProdErrorMessage(160));
            commitDeletionEffectsOnFiber(root3, returnFiber, childToDelete);
            hostParent = null;
            hostParentIsContainer = false;
            root3 = childToDelete.alternate;
            null !== root3 && (root3.return = null);
            childToDelete.return = null;
          }
        if (parentFiber.subtreeFlags & 13886)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
      }
      var currentHoistableRoot = null;
      function commitMutationEffectsOnFiber(finishedWork, root3) {
        var current = finishedWork.alternate, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
            break;
          case 1:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
            break;
          case 26:
            var hoistableRoot = currentHoistableRoot;
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (flags & 4) {
              var currentResource = null !== current ? current.memoizedState : null;
              flags = finishedWork.memoizedState;
              if (null === current)
                if (null === flags)
                  if (null === finishedWork.stateNode) {
                    a: {
                      flags = finishedWork.type;
                      current = finishedWork.memoizedProps;
                      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                      b: switch (flags) {
                        case "title":
                          currentResource = hoistableRoot.getElementsByTagName("title")[0];
                          if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                            currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                              currentResource,
                              hoistableRoot.querySelector("head > title")
                            );
                          setInitialProperties(currentResource, flags, current);
                          currentResource[internalInstanceKey] = finishedWork;
                          markNodeAsHoistable(currentResource);
                          flags = currentResource;
                          break a;
                        case "link":
                          var maybeNodes = getHydratableHoistableCache(
                            "link",
                            "href",
                            hoistableRoot
                          ).get(flags + (current.href || ""));
                          if (maybeNodes) {
                            for (var i2 = 0; i2 < maybeNodes.length; i2++)
                              if (currentResource = maybeNodes[i2], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                                maybeNodes.splice(i2, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        case "meta":
                          if (maybeNodes = getHydratableHoistableCache(
                            "meta",
                            "content",
                            hoistableRoot
                          ).get(flags + (current.content || ""))) {
                            for (i2 = 0; i2 < maybeNodes.length; i2++)
                              if (currentResource = maybeNodes[i2], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                                maybeNodes.splice(i2, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        default:
                          throw Error(formatProdErrorMessage(468, flags));
                      }
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                    }
                    finishedWork.stateNode = flags;
                  } else
                    mountHoistable(
                      hoistableRoot,
                      finishedWork.type,
                      finishedWork.stateNode
                    );
                else
                  finishedWork.stateNode = acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  );
              else
                currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                ) : acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                  finishedWork,
                  finishedWork.memoizedProps,
                  current.memoizedProps
                );
            }
            break;
          case 27:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            null !== current && flags & 4 && commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
            break;
          case 5:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (finishedWork.flags & 32) {
              hoistableRoot = finishedWork.stateNode;
              try {
                setTextContent(hoistableRoot, "");
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
              finishedWork,
              hoistableRoot,
              null !== current ? current.memoizedProps : hoistableRoot
            ));
            flags & 1024 && (needsFormReset = true);
            break;
          case 6:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4) {
              if (null === finishedWork.stateNode)
                throw Error(formatProdErrorMessage(162));
              flags = finishedWork.memoizedProps;
              current = finishedWork.stateNode;
              try {
                current.nodeValue = flags;
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 3:
            tagCaches = null;
            hoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(root3.containerInfo);
            recursivelyTraverseMutationEffects(root3, finishedWork);
            currentHoistableRoot = hoistableRoot;
            commitReconciliationEffects(finishedWork);
            if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
              try {
                retryIfBlockedOn(root3.containerInfo);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
            break;
          case 4:
            flags = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(
              finishedWork.stateNode.containerInfo
            );
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            currentHoistableRoot = flags;
            break;
          case 12:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            break;
          case 31:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 13:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now2());
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 22:
            hoistableRoot = null !== finishedWork.memoizedState;
            var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
            recursivelyTraverseMutationEffects(root3, finishedWork);
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            commitReconciliationEffects(finishedWork);
            if (flags & 8192)
              a: for (root3 = finishedWork.stateNode, root3._visibility = hoistableRoot ? root3._visibility & -2 : root3._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root3 = finishedWork; ; ) {
                if (5 === root3.tag || 26 === root3.tag) {
                  if (null === current) {
                    wasHidden = current = root3;
                    try {
                      if (currentResource = wasHidden.stateNode, hoistableRoot)
                        maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                      else {
                        i2 = wasHidden.stateNode;
                        var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                        i2.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                      }
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (6 === root3.tag) {
                  if (null === current) {
                    wasHidden = root3;
                    try {
                      wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (18 === root3.tag) {
                  if (null === current) {
                    wasHidden = root3;
                    try {
                      var instance = wasHidden.stateNode;
                      hoistableRoot ? hideOrUnhideDehydratedBoundary(instance, true) : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, false);
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if ((22 !== root3.tag && 23 !== root3.tag || null === root3.memoizedState || root3 === finishedWork) && null !== root3.child) {
                  root3.child.return = root3;
                  root3 = root3.child;
                  continue;
                }
                if (root3 === finishedWork) break a;
                for (; null === root3.sibling; ) {
                  if (null === root3.return || root3.return === finishedWork) break a;
                  current === root3 && (current = null);
                  root3 = root3.return;
                }
                current === root3 && (current = null);
                root3.sibling.return = root3.return;
                root3 = root3.sibling;
              }
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
            break;
          case 19:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 30:
            break;
          case 21:
            break;
          default:
            recursivelyTraverseMutationEffects(root3, finishedWork), commitReconciliationEffects(finishedWork);
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
          try {
            for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
              if (isHostParent(parentFiber)) {
                hostParentFiber = parentFiber;
                break;
              }
              parentFiber = parentFiber.return;
            }
            if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
            switch (hostParentFiber.tag) {
              case 27:
                var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              case 5:
                var parent$141 = hostParentFiber.stateNode;
                hostParentFiber.flags & 32 && (setTextContent(parent$141, ""), hostParentFiber.flags &= -33);
                var before$142 = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
                break;
              case 3:
              case 4:
                var parent$143 = hostParentFiber.stateNode.containerInfo, before$144 = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(
                  finishedWork,
                  before$144,
                  parent$143
                );
                break;
              default:
                throw Error(formatProdErrorMessage(161));
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
      }
      function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyTraverseLayoutEffects(root3, parentFiber) {
        if (parentFiber.subtreeFlags & 8772)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitLayoutEffectOnFiber(root3, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
      }
      function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedWork = parentFiber;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              releaseSingletonInstance(finishedWork.stateNode);
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(4, finishedWork);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current = finishedWork;
              finishedRoot = current.stateNode;
              if ("function" === typeof finishedRoot.componentDidMount)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              current = finishedWork;
              finishedRoot = current.updateQueue;
              if (null !== finishedRoot) {
                var instance = current.stateNode;
                try {
                  var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                  if (null !== hiddenCallbacks)
                    for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                      callCallback(hiddenCallbacks[finishedRoot], instance);
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              break;
            case 31:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitOffscreenPassiveMountEffects(current, finishedWork) {
        var previousCache = null;
        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
        current = null;
        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
        current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
      }
      function commitCachePassiveMountEffect(current, finishedWork) {
        current = null;
        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
      }
      function recursivelyTraversePassiveMountEffects(root3, parentFiber, committedLanes, committedTransitions) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveMountOnFiber(
              root3,
              parentFiber,
              committedLanes,
              committedTransitions
            ), parentFiber = parentFiber.sibling;
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitHookEffectListMount(9, finishedWork);
            break;
          case 1:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 3:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
            break;
          case 12:
            if (flags & 2048) {
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              finishedRoot = finishedWork.stateNode;
              try {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, id2 = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
                "function" === typeof onPostCommit && onPostCommit(
                  id2,
                  null === finishedWork.alternate ? "mount" : "update",
                  finishedRoot.passiveEffectDuration,
                  -0
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
            break;
          case 31:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 13:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 23:
            break;
          case 22:
            _finishedWork$memoize2 = finishedWork.stateNode;
            id2 = finishedWork.alternate;
            null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256) || false
            ));
            flags & 2048 && commitOffscreenPassiveMountEffects(id2, finishedWork);
            break;
          case 24:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
        }
      }
      function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || false);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(8, finishedWork);
              break;
            case 23:
              break;
            case 22:
              var instance = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 22:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              case 24:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
              default:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            }
            parentFiber = parentFiber.sibling;
          }
      }
      var suspenseyCommitFlag = 8192;
      function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            accumulateSuspenseyCommitOnFiber(
              parentFiber,
              committedLanes,
              suspendedState
            ), parentFiber = parentFiber.sibling;
      }
      function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
        switch (fiber.tag) {
          case 26:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
              suspendedState,
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            );
            break;
          case 5:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            break;
          case 3:
          case 4:
            var previousHoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
            currentHoistableRoot = previousHoistableRoot;
            break;
          case 22:
            null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ));
            break;
          default:
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            );
        }
      }
      function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
          previousFiber.child = null;
          do
            previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
          while (null !== parentFiber);
        }
      }
      function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i2 = 0; i2 < deletions.length; i2++) {
              var childToDelete = deletions[i2];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 12:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          default:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
      }
      function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i2 = 0; i2 < deletions.length; i2++) {
              var childToDelete = deletions[i2];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          deletions = parentFiber;
          switch (deletions.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, deletions, deletions.return);
              recursivelyTraverseDisconnectPassiveEffects(deletions);
              break;
            case 22:
              i2 = deletions.stateNode;
              i2._visibility & 2 && (i2._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(deletions);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        for (; null !== nextEffect; ) {
          var fiber = nextEffect;
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
              break;
            case 23:
            case 22:
              if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
                var cache = fiber.memoizedState.cachePool.pool;
                null != cache && cache.refCount++;
              }
              break;
            case 24:
              releaseCache(fiber.memoizedState.cache);
          }
          cache = fiber.child;
          if (null !== cache) cache.return = fiber, nextEffect = cache;
          else
            a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
              cache = nextEffect;
              var sibling = cache.sibling, returnFiber = cache.return;
              detachFiberAfterEffects(cache);
              if (cache === fiber) {
                nextEffect = null;
                break a;
              }
              if (null !== sibling) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                break a;
              }
              nextEffect = returnFiber;
            }
        }
      }
      var DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
          var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
          return cacheForType;
        },
        cacheSignal: function() {
          return readContext(CacheContext).controller.signal;
        }
      };
      var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
      var executionContext = 0;
      var workInProgressRoot = null;
      var workInProgress = null;
      var workInProgressRootRenderLanes = 0;
      var workInProgressSuspendedReason = 0;
      var workInProgressThrownValue = null;
      var workInProgressRootDidSkipSuspendedSiblings = false;
      var workInProgressRootIsPrerendering = false;
      var workInProgressRootDidAttachPingListener = false;
      var entangledRenderLanes = 0;
      var workInProgressRootExitStatus = 0;
      var workInProgressRootSkippedLanes = 0;
      var workInProgressRootInterleavedUpdatedLanes = 0;
      var workInProgressRootPingedLanes = 0;
      var workInProgressDeferredLane = 0;
      var workInProgressSuspendedRetryLanes = 0;
      var workInProgressRootConcurrentErrors = null;
      var workInProgressRootRecoverableErrors = null;
      var workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      var globalMostRecentFallbackTime = 0;
      var globalMostRecentTransitionTime = 0;
      var workInProgressRootRenderTargetTime = Infinity;
      var workInProgressTransitions = null;
      var legacyErrorBoundariesThatAlreadyFailed = null;
      var pendingEffectsStatus = 0;
      var pendingEffectsRoot = null;
      var pendingFinishedWork = null;
      var pendingEffectsLanes = 0;
      var pendingEffectsRemainingLanes = 0;
      var pendingPassiveTransitions = null;
      var pendingRecoverableErrors = null;
      var nestedUpdateCount = 0;
      var rootWithNestedUpdates = null;
      function requestUpdateLane() {
        return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes : null !== ReactSharedInternals.T ? requestTransitionLane() : resolveUpdatePriority();
      }
      function requestDeferredLane() {
        if (0 === workInProgressDeferredLane)
          if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
            var lane = nextTransitionDeferredLane;
            nextTransitionDeferredLane <<= 1;
            0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
            workInProgressDeferredLane = lane;
          } else workInProgressDeferredLane = 536870912;
        lane = suspenseHandlerStackCursor.current;
        null !== lane && (lane.flags |= 32);
        return workInProgressDeferredLane;
      }
      function scheduleUpdateOnFiber(root3, fiber, lane) {
        if (root3 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root3.cancelPendingCommit)
          prepareFreshStack(root3, 0), markRootSuspended(
            root3,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        markRootUpdated$1(root3, lane);
        if (0 === (executionContext & 2) || root3 !== workInProgressRoot)
          root3 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
            root3,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          )), ensureRootIsScheduled(root3);
      }
      function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        var shouldTimeSlice = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
        do {
          if (0 === exitStatus) {
            workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
            break;
          } else {
            forceSync = root$jscomp$0.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
              exitStatus = renderRootSync(root$jscomp$0, lanes, false);
              renderWasConcurrent = false;
              continue;
            }
            if (2 === exitStatus) {
              renderWasConcurrent = lanes;
              if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
                var JSCompiler_inline_result = 0;
              else
                JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
              if (0 !== JSCompiler_inline_result) {
                lanes = JSCompiler_inline_result;
                a: {
                  var root3 = root$jscomp$0;
                  exitStatus = workInProgressRootConcurrentErrors;
                  var wasRootDehydrated = root3.current.memoizedState.isDehydrated;
                  wasRootDehydrated && (prepareFreshStack(root3, JSCompiler_inline_result).flags |= 256);
                  JSCompiler_inline_result = renderRootSync(
                    root3,
                    JSCompiler_inline_result,
                    false
                  );
                  if (2 !== JSCompiler_inline_result) {
                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                      root3.errorRecoveryDisabledLanes |= renderWasConcurrent;
                      workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                      exitStatus = 4;
                      break a;
                    }
                    renderWasConcurrent = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = exitStatus;
                    null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      renderWasConcurrent
                    ));
                  }
                  exitStatus = JSCompiler_inline_result;
                }
                renderWasConcurrent = false;
                if (2 !== exitStatus) continue;
              }
            }
            if (1 === exitStatus) {
              prepareFreshStack(root$jscomp$0, 0);
              markRootSuspended(root$jscomp$0, lanes, 0, true);
              break;
            }
            a: {
              shouldTimeSlice = root$jscomp$0;
              renderWasConcurrent = exitStatus;
              switch (renderWasConcurrent) {
                case 0:
                case 1:
                  throw Error(formatProdErrorMessage(345));
                case 4:
                  if ((lanes & 4194048) !== lanes) break;
                case 6:
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                case 2:
                  workInProgressRootRecoverableErrors = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(formatProdErrorMessage(329));
              }
              if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now2(), 10 < exitStatus)) {
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                pendingEffectsLanes = lanes;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    renderWasConcurrent,
                    "Throttled",
                    -0,
                    0
                  ),
                  exitStatus
                );
                break a;
              }
              commitRootWhenReady(
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                null,
                -0,
                0
              );
            }
          }
          break;
        } while (1);
        ensureRootIsScheduled(root$jscomp$0);
      }
      function commitRootWhenReady(root3, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        root3.timeoutHandle = -1;
        suspendedCommitReason = finishedWork.subtreeFlags;
        if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
          suspendedCommitReason = {
            stylesheets: null,
            count: 0,
            imgCount: 0,
            imgBytes: 0,
            suspenseyImages: [],
            waitingForImages: true,
            waitingForViewTransition: false,
            unsuspend: noop$1
          };
          accumulateSuspenseyCommitOnFiber(
            finishedWork,
            lanes,
            suspendedCommitReason
          );
          var timeoutOffset = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now2() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now2() : 0;
          timeoutOffset = waitForCommitToBeReady(
            suspendedCommitReason,
            timeoutOffset
          );
          if (null !== timeoutOffset) {
            pendingEffectsLanes = lanes;
            root3.cancelPendingCommit = timeoutOffset(
              commitRoot.bind(
                null,
                root3,
                finishedWork,
                lanes,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                exitStatus,
                suspendedCommitReason,
                null,
                completedRenderStartTime,
                completedRenderEndTime
              )
            );
            markRootSuspended(root3, lanes, spawnedLane, !didSkipSuspendedSiblings);
            return;
          }
        }
        commitRoot(
          root3,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node = finishedWork; ; ) {
          var tag = node.tag;
          if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
            for (var i2 = 0; i2 < tag.length; i2++) {
              var check = tag[i2], getSnapshot = check.getSnapshot;
              check = check.value;
              try {
                if (!objectIs(getSnapshot(), check)) return false;
              } catch (error) {
                return false;
              }
            }
          tag = node.child;
          if (node.subtreeFlags & 16384 && null !== tag)
            tag.return = node, node = tag;
          else {
            if (node === finishedWork) break;
            for (; null === node.sibling; ) {
              if (null === node.return || node.return === finishedWork) return true;
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return true;
      }
      function markRootSuspended(root3, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root3.suspendedLanes |= suspendedLanes;
        root3.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root3.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root3.expirationTimes;
        for (var lanes = suspendedLanes; 0 < lanes; ) {
          var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
          didAttemptEntireTree[index$6] = -1;
          lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, suspendedLanes);
      }
      function flushSyncWork$1() {
        return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
      }
      function resetWorkInProgressStack() {
        if (null !== workInProgress) {
          if (0 === workInProgressSuspendedReason)
            var interruptedWork = workInProgress.return;
          else
            interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
          for (; null !== interruptedWork; )
            unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
          workInProgress = null;
        }
      }
      function prepareFreshStack(root3, lanes) {
        var timeoutHandle = root3.timeoutHandle;
        -1 !== timeoutHandle && (root3.timeoutHandle = -1, cancelTimeout(timeoutHandle));
        timeoutHandle = root3.cancelPendingCommit;
        null !== timeoutHandle && (root3.cancelPendingCommit = null, timeoutHandle());
        pendingEffectsLanes = 0;
        resetWorkInProgressStack();
        workInProgressRoot = root3;
        workInProgress = timeoutHandle = createWorkInProgress(root3.current, null);
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = 0;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = false;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root3, lanes);
        workInProgressRootDidAttachPingListener = false;
        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = false;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        var allEntangledLanes = root3.entangledLanes;
        if (0 !== allEntangledLanes)
          for (root3 = root3.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
            var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
            lanes |= root3[index$4];
            allEntangledLanes &= ~lane;
          }
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        return timeoutHandle;
      }
      function handleThrow(root3, thrownValue) {
        currentlyRenderingFiber = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
        workInProgressThrownValue = thrownValue;
        null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
          root3,
          createCapturedValueAtFiber(thrownValue, root3.current)
        ));
      }
      function shouldRemainOnPreviousScreen() {
        var handler = suspenseHandlerStackCursor.current;
        return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
      }
      function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
      }
      function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
      }
      function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = 4;
        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      }
      function renderRootSync(root3, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes)
          workInProgressTransitions = null, prepareFreshStack(root3, lanes);
        lanes = false;
        var exitStatus = workInProgressRootExitStatus;
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case 8:
                  resetWorkInProgressStack();
                  exitStatus = 6;
                  break a;
                case 3:
                case 2:
                case 9:
                case 6:
                  null === suspenseHandlerStackCursor.current && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    exitStatus = 0;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            exitStatus = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$165) {
            handleThrow(root3, thrownValue$165);
          }
        while (1);
        lanes && root3.shellSuspendCounter++;
        lastContextDependency = currentlyRenderingFiber$1 = null;
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
        return exitStatus;
      }
      function workLoopSync() {
        for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root3, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now2() + 500, prepareFreshStack(root3, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
          root3,
          lanes
        );
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              lanes = workInProgress;
              var thrownValue = workInProgressThrownValue;
              b: switch (workInProgressSuspendedReason) {
                case 1:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root3, lanes, thrownValue, 1);
                  break;
                case 2:
                case 9:
                  if (isThenableResolved(thrownValue)) {
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    replaySuspendedUnitOfWork(lanes);
                    break;
                  }
                  lanes = function() {
                    2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root3 || (workInProgressSuspendedReason = 7);
                    ensureRootIsScheduled(root3);
                  };
                  thrownValue.then(lanes, lanes);
                  break a;
                case 3:
                  workInProgressSuspendedReason = 7;
                  break a;
                case 4:
                  workInProgressSuspendedReason = 5;
                  break a;
                case 7:
                  isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, lanes, thrownValue, 7));
                  break;
                case 5:
                  var resource = null;
                  switch (workInProgress.tag) {
                    case 26:
                      resource = workInProgress.memoizedState;
                    case 5:
                    case 27:
                      var hostFiber = workInProgress;
                      if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                        workInProgressSuspendedReason = 0;
                        workInProgressThrownValue = null;
                        var sibling = hostFiber.sibling;
                        if (null !== sibling) workInProgress = sibling;
                        else {
                          var returnFiber = hostFiber.return;
                          null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                        }
                        break b;
                      }
                  }
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root3, lanes, thrownValue, 5);
                  break;
                case 6:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root3, lanes, thrownValue, 6);
                  break;
                case 8:
                  resetWorkInProgressStack();
                  workInProgressRootExitStatus = 6;
                  break a;
                default:
                  throw Error(formatProdErrorMessage(462));
              }
            }
            workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$167) {
            handleThrow(root3, thrownValue$167);
          }
        while (1);
        lastContextDependency = currentlyRenderingFiber$1 = null;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress) return 0;
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
      }
      function workLoopConcurrentByScheduler() {
        for (; null !== workInProgress && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function replaySuspendedUnitOfWork(unitOfWork) {
        var next = unitOfWork;
        var current = next.alternate;
        switch (next.tag) {
          case 15:
          case 0:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type,
              void 0,
              workInProgressRootRenderLanes
            );
            break;
          case 11:
            next = replayFunctionComponent(
              current,
              next,
              next.pendingProps,
              next.type.render,
              next.ref,
              workInProgressRootRenderLanes
            );
            break;
          case 5:
            resetHooksOnUnwind(next);
          default:
            unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
        }
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
      }
      function throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, suspendedReason) {
        lastContextDependency = currentlyRenderingFiber$1 = null;
        resetHooksOnUnwind(unitOfWork);
        thenableState$1 = null;
        thenableIndexCounter$1 = 0;
        var returnFiber = unitOfWork.return;
        try {
          if (throwException(
            root3,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )) {
            workInProgressRootExitStatus = 1;
            logUncaughtError(
              root3,
              createCapturedValueAtFiber(thrownValue, root3.current)
            );
            workInProgress = null;
            return;
          }
        } catch (error) {
          if (null !== returnFiber) throw workInProgress = returnFiber, error;
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root3,
            createCapturedValueAtFiber(thrownValue, root3.current)
          );
          workInProgress = null;
          return;
        }
        if (unitOfWork.flags & 32768) {
          if (isHydrating || 1 === suspendedReason) root3 = true;
          else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
            root3 = false;
          else if (workInProgressRootDidSkipSuspendedSiblings = root3 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
            suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
          unwindUnitOfWork(unitOfWork, root3);
        } else completeUnitOfWork(unitOfWork);
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          if (0 !== (completedWork.flags & 32768)) {
            unwindUnitOfWork(
              completedWork,
              workInProgressRootDidSkipSuspendedSiblings
            );
            return;
          }
          unitOfWork = completedWork.return;
          var next = completeWork(
            completedWork.alternate,
            completedWork,
            entangledRenderLanes
          );
          if (null !== next) {
            workInProgress = next;
            return;
          }
          completedWork = completedWork.sibling;
          if (null !== completedWork) {
            workInProgress = completedWork;
            return;
          }
          workInProgress = completedWork = unitOfWork;
        } while (null !== completedWork);
        0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
      }
      function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
          var next = unwindWork(unitOfWork.alternate, unitOfWork);
          if (null !== next) {
            next.flags &= 32767;
            workInProgress = next;
            return;
          }
          next = unitOfWork.return;
          null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
          if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
            workInProgress = unitOfWork;
            return;
          }
          workInProgress = unitOfWork = next;
        } while (null !== unitOfWork);
        workInProgressRootExitStatus = 6;
        workInProgress = null;
      }
      function commitRoot(root3, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
        root3.cancelPendingCommit = null;
        do
          flushPendingEffects();
        while (0 !== pendingEffectsStatus);
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        if (null !== finishedWork) {
          if (finishedWork === root3.current) throw Error(formatProdErrorMessage(177));
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
          didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
          markRootFinished(
            root3,
            lanes,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root3 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
          pendingFinishedWork = finishedWork;
          pendingEffectsRoot = root3;
          pendingEffectsLanes = lanes;
          pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
          pendingPassiveTransitions = transitions;
          pendingRecoverableErrors = recoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root3.callbackNode = null, root3.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
            flushPassiveEffects();
            return null;
          })) : (root3.callbackNode = null, root3.callbackPriority = 0);
          recoverableErrors = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
            recoverableErrors = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            transitions = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            spawnedLane = executionContext;
            executionContext |= 4;
            try {
              commitBeforeMutationEffects(root3, finishedWork, lanes);
            } finally {
              executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
            }
          }
          pendingEffectsStatus = 1;
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
        }
      }
      function flushMutationEffects() {
        if (1 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
            rootMutationHasEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitMutationEffectsOnFiber(finishedWork, root3);
              var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root3.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
              if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                priorFocusedElem.ownerDocument.documentElement,
                priorFocusedElem
              )) {
                if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                  var start2 = priorSelectionRange.start, end = priorSelectionRange.end;
                  void 0 === end && (end = start2);
                  if ("selectionStart" in priorFocusedElem)
                    priorFocusedElem.selectionStart = start2, priorFocusedElem.selectionEnd = Math.min(
                      end,
                      priorFocusedElem.value.length
                    );
                  else {
                    var doc2 = priorFocusedElem.ownerDocument || document, win = doc2 && doc2.defaultView || window;
                    if (win.getSelection) {
                      var selection2 = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                      !selection2.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                      var startMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        start$jscomp$0
                      ), endMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        end$jscomp$0
                      );
                      if (startMarker && endMarker && (1 !== selection2.rangeCount || selection2.anchorNode !== startMarker.node || selection2.anchorOffset !== startMarker.offset || selection2.focusNode !== endMarker.node || selection2.focusOffset !== endMarker.offset)) {
                        var range = doc2.createRange();
                        range.setStart(startMarker.node, startMarker.offset);
                        selection2.removeAllRanges();
                        start$jscomp$0 > end$jscomp$0 ? (selection2.addRange(range), selection2.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection2.addRange(range));
                      }
                    }
                  }
                }
                doc2 = [];
                for (selection2 = priorFocusedElem; selection2 = selection2.parentNode; )
                  1 === selection2.nodeType && doc2.push({
                    element: selection2,
                    left: selection2.scrollLeft,
                    top: selection2.scrollTop
                  });
                "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                for (priorFocusedElem = 0; priorFocusedElem < doc2.length; priorFocusedElem++) {
                  var info = doc2[priorFocusedElem];
                  info.element.scrollLeft = info.left;
                  info.element.scrollTop = info.top;
                }
              }
              _enabled = !!eventsEnabled;
              selectionInformation = eventsEnabled = null;
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
            }
          }
          root3.current = finishedWork;
          pendingEffectsStatus = 2;
        }
      }
      function flushLayoutEffects() {
        if (2 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
          if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
            rootHasLayoutEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitLayoutEffectOnFiber(root3, finishedWork.alternate, finishedWork);
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
            }
          }
          pendingEffectsStatus = 3;
        }
      }
      function flushSpawnedWork() {
        if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          requestPaint();
          var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root3, root3.pendingLanes));
          var remainingLanes = root3.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          lanesToEventPriority(lanes);
          finishedWork = finishedWork.stateNode;
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
            try {
              injectedHook.onCommitFiberRoot(
                rendererID,
                finishedWork,
                void 0,
                128 === (finishedWork.current.flags & 128)
              );
            } catch (err) {
            }
          if (null !== recoverableErrors) {
            finishedWork = ReactSharedInternals.T;
            remainingLanes = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            ReactSharedInternals.T = null;
            try {
              for (var onRecoverableError = root3.onRecoverableError, i2 = 0; i2 < recoverableErrors.length; i2++) {
                var recoverableError = recoverableErrors[i2];
                onRecoverableError(recoverableError.value, {
                  componentStack: recoverableError.stack
                });
              }
            } finally {
              ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
            }
          }
          0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
          ensureRootIsScheduled(root3);
          remainingLanes = root3.pendingLanes;
          0 !== (lanes & 261930) && 0 !== (remainingLanes & 42) ? root3 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root3) : nestedUpdateCount = 0;
          flushSyncWorkAcrossRoots_impl(0, false);
        }
      }
      function releaseRootPooledCache(root3, remainingLanes) {
        0 === (root3.pooledCacheLanes &= remainingLanes) && (remainingLanes = root3.pooledCache, null != remainingLanes && (root3.pooledCache = null, releaseCache(remainingLanes)));
      }
      function flushPendingEffects() {
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
        return flushPassiveEffects();
      }
      function flushPassiveEffects() {
        if (5 !== pendingEffectsStatus) return false;
        var root3 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
        pendingEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
          ReactSharedInternals.T = null;
          renderPriority = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
          pendingEffectsStatus = 0;
          pendingFinishedWork = pendingEffectsRoot = null;
          pendingEffectsLanes = 0;
          if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          commitPassiveUnmountOnFiber(root$jscomp$0.current);
          commitPassiveMountOnFiber(
            root$jscomp$0,
            root$jscomp$0.current,
            lanes,
            renderPriority
          );
          executionContext = prevExecutionContext;
          flushSyncWorkAcrossRoots_impl(0, false);
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
            } catch (err) {
            }
          return true;
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root3, remainingLanes);
        }
      }
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
        if (3 === sourceFiber.tag)
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        else
          for (; null !== nearestMountedAncestor; ) {
            if (3 === nearestMountedAncestor.tag) {
              captureCommitPhaseErrorOnRoot(
                nearestMountedAncestor,
                sourceFiber,
                error
              );
              break;
            } else if (1 === nearestMountedAncestor.tag) {
              var instance = nearestMountedAncestor.stateNode;
              if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                error = createClassErrorUpdate(2);
                instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                null !== instance && (initializeClassErrorUpdate(
                  error,
                  instance,
                  nearestMountedAncestor,
                  sourceFiber
                ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                break;
              }
            }
            nearestMountedAncestor = nearestMountedAncestor.return;
          }
      }
      function attachPingListener(root3, wakeable, lanes) {
        var pingCache = root3.pingCache;
        if (null === pingCache) {
          pingCache = root3.pingCache = new PossiblyWeakMap();
          var threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else
          threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root3 = pingSuspendedRoot.bind(null, root3, wakeable, lanes), wakeable.then(root3, root3));
      }
      function pingSuspendedRoot(root3, wakeable, pingedLanes) {
        var pingCache = root3.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
        root3.warmLanes &= ~pingedLanes;
        workInProgressRoot === root3 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now2() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root3, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root3);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch (boundaryFiber.tag) {
          case 31:
          case 13:
            var retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            break;
          case 19:
            retryCache = boundaryFiber.stateNode;
            break;
          case 22:
            retryCache = boundaryFiber.stateNode._retryCache;
            break;
          default:
            throw Error(formatProdErrorMessage(314));
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function scheduleCallback$1(priorityLevel, callback) {
        return scheduleCallback$3(priorityLevel, callback);
      }
      var firstScheduledRoot = null;
      var lastScheduledRoot = null;
      var didScheduleMicrotask = false;
      var mightHavePendingSyncWork = false;
      var isFlushingWork = false;
      var currentEventTransitionLane = 0;
      function ensureRootIsScheduled(root3) {
        root3 !== lastScheduledRoot && null === root3.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root3 : lastScheduledRoot = lastScheduledRoot.next = root3);
        mightHavePendingSyncWork = true;
        didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
      }
      function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
          isFlushingWork = true;
          do {
            var didPerformSomeWork = false;
            for (var root$170 = firstScheduledRoot; null !== root$170; ) {
              if (!onlyLegacy)
                if (0 !== syncTransitionLanes) {
                  var pendingLanes = root$170.pendingLanes;
                  if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                  else {
                    var suspendedLanes = root$170.suspendedLanes, pingedLanes = root$170.pingedLanes;
                    JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                    JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                    JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                  }
                  0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
                } else
                  JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                    root$170,
                    root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
                    null !== root$170.cancelPendingCommit || -1 !== root$170.timeoutHandle
                  ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
              root$170 = root$170.next;
            }
          } while (didPerformSomeWork);
          isFlushingWork = false;
        }
      }
      function processRootScheduleInImmediateTask() {
        processRootScheduleInMicrotask();
      }
      function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask = false;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
        for (var currentTime = now2(), prev = null, root3 = firstScheduledRoot; null !== root3; ) {
          var next = root3.next, nextLanes = scheduleTaskForRootDuringMicrotask(root3, currentTime);
          if (0 === nextLanes)
            root3.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
          else if (prev = root3, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
            mightHavePendingSyncWork = true;
          root3 = next;
        }
        0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
        0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
      }
      function scheduleTaskForRootDuringMicrotask(root3, currentTime) {
        for (var suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes, expirationTimes = root3.expirationTimes, lanes = root3.pendingLanes & -62914561; 0 < lanes; ) {
          var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
          if (-1 === expirationTime) {
            if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
              expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
          } else expirationTime <= currentTime && (root3.expiredLanes |= lane);
          lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(
          root3,
          root3 === currentTime ? suspendedLanes : 0,
          null !== root3.cancelPendingCommit || -1 !== root3.timeoutHandle
        );
        pingedLanes = root3.callbackNode;
        if (0 === suspendedLanes || root3 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root3.cancelPendingCommit)
          return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root3.callbackNode = null, root3.callbackPriority = 0;
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root3, suspendedLanes)) {
          currentTime = suspendedLanes & -suspendedLanes;
          if (currentTime === root3.callbackPriority) return currentTime;
          null !== pingedLanes && cancelCallback$1(pingedLanes);
          switch (lanesToEventPriority(suspendedLanes)) {
            case 2:
            case 8:
              suspendedLanes = UserBlockingPriority;
              break;
            case 32:
              suspendedLanes = NormalPriority$1;
              break;
            case 268435456:
              suspendedLanes = IdlePriority;
              break;
            default:
              suspendedLanes = NormalPriority$1;
          }
          pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root3);
          suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
          root3.callbackPriority = currentTime;
          root3.callbackNode = suspendedLanes;
          return currentTime;
        }
        null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
        root3.callbackPriority = 2;
        root3.callbackNode = null;
        return 2;
      }
      function performWorkOnRootViaSchedulerTask(root3, didTimeout) {
        if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
          return root3.callbackNode = null, root3.callbackPriority = 0, null;
        var originalCallbackNode = root3.callbackNode;
        if (flushPendingEffects() && root3.callbackNode !== originalCallbackNode)
          return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
          root3,
          root3 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
          null !== root3.cancelPendingCommit || -1 !== root3.timeoutHandle
        );
        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
        performWorkOnRoot(root3, workInProgressRootRenderLanes$jscomp$0, didTimeout);
        scheduleTaskForRootDuringMicrotask(root3, now2());
        return null != root3.callbackNode && root3.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root3) : null;
      }
      function performSyncWorkOnRoot(root3, lanes) {
        if (flushPendingEffects()) return null;
        performWorkOnRoot(root3, lanes, true);
      }
      function scheduleImmediateRootScheduleTask() {
        scheduleMicrotask(function() {
          0 !== (executionContext & 6) ? scheduleCallback$3(
            ImmediatePriority,
            processRootScheduleInImmediateTask
          ) : processRootScheduleInMicrotask();
        });
      }
      function requestTransitionLane() {
        if (0 === currentEventTransitionLane) {
          var actionScopeLane = currentEntangledLane;
          0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
          currentEventTransitionLane = actionScopeLane;
        }
        return currentEventTransitionLane;
      }
      function coerceFormActionProp(actionProp) {
        return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
      }
      function createFormDataWithSubmitter(form, submitter) {
        var temp = submitter.ownerDocument.createElement("input");
        temp.name = submitter.name;
        temp.value = submitter.value;
        form.id && temp.setAttribute("form", form.id);
        submitter.parentNode.insertBefore(temp, submitter);
        form = new FormData(form);
        temp.parentNode.removeChild(temp);
        return form;
      }
      function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
        if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
          var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action
          ), submitter = nativeEvent.submitter;
          submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
          var event = new SyntheticEvent(
            "action",
            "action",
            null,
            nativeEvent,
            nativeEventTarget
          );
          dispatchQueue.push({
            event,
            listeners: [
              {
                instance: null,
                listener: function() {
                  if (nativeEvent.defaultPrevented) {
                    if (0 !== currentEventTransitionLane) {
                      var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                      startHostTransition(
                        maybeTargetInst,
                        {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        },
                        null,
                        formData
                      );
                    }
                  } else
                    "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      action,
                      formData
                    ));
                },
                currentTarget: nativeEventTarget
              }
            ]
          });
        }
      }
      for (i$jscomp$inline_1577 = 0; i$jscomp$inline_1577 < simpleEventPluginEvents.length; i$jscomp$inline_1577++) {
        eventName$jscomp$inline_1578 = simpleEventPluginEvents[i$jscomp$inline_1577], domEventName$jscomp$inline_1579 = eventName$jscomp$inline_1578.toLowerCase(), capitalizedEvent$jscomp$inline_1580 = eventName$jscomp$inline_1578[0].toUpperCase() + eventName$jscomp$inline_1578.slice(1);
        registerSimpleEvent(
          domEventName$jscomp$inline_1579,
          "on" + capitalizedEvent$jscomp$inline_1580
        );
      }
      var eventName$jscomp$inline_1578;
      var domEventName$jscomp$inline_1579;
      var capitalizedEvent$jscomp$inline_1580;
      var i$jscomp$inline_1577;
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
      registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
      registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
      registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      registerTwoPhaseEvent(
        "onChange",
        "change click focusin focusout input keydown keyup selectionchange".split(" ")
      );
      registerTwoPhaseEvent(
        "onSelect",
        "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
          " "
        )
      );
      registerTwoPhaseEvent("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
      ]);
      registerTwoPhaseEvent(
        "onCompositionEnd",
        "compositionend focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionStart",
        "compositionstart focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionUpdate",
        "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
      );
      var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      );
      var nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
      );
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        eventSystemFlags = 0 !== (eventSystemFlags & 4);
        for (var i2 = 0; i2 < dispatchQueue.length; i2++) {
          var _dispatchQueue$i = dispatchQueue[i2], event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          a: {
            var previousInstance = void 0;
            if (eventSystemFlags)
              for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
            else
              for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                instance = _dispatchListeners$i.instance;
                currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance;
              }
          }
        }
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
        void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
        var listenerSetKey = domEventName + "__bubble";
        JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        var eventSystemFlags = 0;
        isCapturePhaseListener && (eventSystemFlags |= 4);
        addTrappedEventListener(
          target,
          domEventName,
          eventSystemFlags,
          isCapturePhaseListener
        );
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
          });
          var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
          null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
        switch (getEventPriority(domEventName)) {
          case 2:
            var listenerWrapper = dispatchDiscreteEvent;
            break;
          case 8:
            listenerWrapper = dispatchContinuousEvent;
            break;
          default:
            listenerWrapper = dispatchEvent2;
        }
        eventSystemFlags = listenerWrapper.bind(
          null,
          domEventName,
          eventSystemFlags,
          targetContainer
        );
        listenerWrapper = void 0;
        !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
        isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: true,
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
        var ancestorInst = targetInst$jscomp$0;
        if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
          a: for (; ; ) {
            if (null === targetInst$jscomp$0) return;
            var nodeTag = targetInst$jscomp$0.tag;
            if (3 === nodeTag || 4 === nodeTag) {
              var container2 = targetInst$jscomp$0.stateNode.containerInfo;
              if (container2 === targetContainer) break;
              if (4 === nodeTag)
                for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                  var grandTag = nodeTag.tag;
                  if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                    return;
                  nodeTag = nodeTag.return;
                }
              for (; null !== container2; ) {
                nodeTag = getClosestInstanceFromNode(container2);
                if (null === nodeTag) return;
                grandTag = nodeTag.tag;
                if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                  targetInst$jscomp$0 = ancestorInst = nodeTag;
                  continue a;
                }
                container2 = container2.parentNode;
              }
            }
            targetInst$jscomp$0 = targetInst$jscomp$0.return;
          }
        batchedUpdates$1(function() {
          var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
          a: {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (void 0 !== reactName) {
              var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
              switch (domEventName) {
                case "keypress":
                  if (0 === getEventCharCode(nativeEvent)) break a;
                case "keydown":
                case "keyup":
                  SyntheticEventCtor = SyntheticKeyboardEvent;
                  break;
                case "focusin":
                  reactEventType = "focus";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "focusout":
                  reactEventType = "blur";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "beforeblur":
                case "afterblur":
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "click":
                  if (2 === nativeEvent.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  SyntheticEventCtor = SyntheticMouseEvent;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  SyntheticEventCtor = SyntheticDragEvent;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  SyntheticEventCtor = SyntheticTouchEvent;
                  break;
                case ANIMATION_END:
                case ANIMATION_ITERATION:
                case ANIMATION_START:
                  SyntheticEventCtor = SyntheticAnimationEvent;
                  break;
                case TRANSITION_END:
                  SyntheticEventCtor = SyntheticTransitionEvent;
                  break;
                case "scroll":
                case "scrollend":
                  SyntheticEventCtor = SyntheticUIEvent;
                  break;
                case "wheel":
                  SyntheticEventCtor = SyntheticWheelEvent;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  SyntheticEventCtor = SyntheticClipboardEvent;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  SyntheticEventCtor = SyntheticPointerEvent;
                  break;
                case "toggle":
                case "beforetoggle":
                  SyntheticEventCtor = SyntheticToggleEvent;
              }
              var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
              inCapturePhase = [];
              for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                var _instance = instance;
                lastHostComponent = _instance.stateNode;
                _instance = _instance.tag;
                5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                  createDispatchListener(instance, _instance, lastHostComponent)
                ));
                if (accumulateTargetOnly) break;
                instance = instance.return;
              }
              0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
            }
          }
          if (0 === (eventSystemFlags & 7)) {
            a: {
              reactName = "mouseover" === domEventName || "pointerover" === domEventName;
              SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
              if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                break a;
              if (SyntheticEventCtor || reactName) {
                reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                if (SyntheticEventCtor) {
                  if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                    reactEventType = null;
                } else SyntheticEventCtor = null, reactEventType = targetInst;
                if (SyntheticEventCtor !== reactEventType) {
                  inCapturePhase = SyntheticMouseEvent;
                  _instance = "onMouseLeave";
                  reactEventName = "onMouseEnter";
                  instance = "mouse";
                  if ("pointerout" === domEventName || "pointerover" === domEventName)
                    inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                  accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                  lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                  reactName = new inCapturePhase(
                    _instance,
                    instance + "leave",
                    SyntheticEventCtor,
                    nativeEvent,
                    nativeEventTarget
                  );
                  reactName.target = accumulateTargetOnly;
                  reactName.relatedTarget = lastHostComponent;
                  _instance = null;
                  getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget
                  ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                  accumulateTargetOnly = _instance;
                  if (SyntheticEventCtor && reactEventType)
                    b: {
                      inCapturePhase = getParent;
                      reactEventName = SyntheticEventCtor;
                      instance = reactEventType;
                      lastHostComponent = 0;
                      for (_instance = reactEventName; _instance; _instance = inCapturePhase(_instance))
                        lastHostComponent++;
                      _instance = 0;
                      for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                        _instance++;
                      for (; 0 < lastHostComponent - _instance; )
                        reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                      for (; 0 < _instance - lastHostComponent; )
                        instance = inCapturePhase(instance), _instance--;
                      for (; lastHostComponent--; ) {
                        if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                          inCapturePhase = reactEventName;
                          break b;
                        }
                        reactEventName = inCapturePhase(reactEventName);
                        instance = inCapturePhase(instance);
                      }
                      inCapturePhase = null;
                    }
                  else inCapturePhase = null;
                  null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    false
                  );
                  null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    true
                  );
                }
              }
            }
            a: {
              reactName = targetInst ? getNodeFromInstance(targetInst) : window;
              SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
              if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                var getTargetInstFunc = getTargetInstForChangeEvent;
              else if (isTextInputElement(reactName))
                if (isInputEventSupported)
                  getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                else {
                  getTargetInstFunc = getTargetInstForInputEventPolyfill;
                  var handleEventFunc = handleEventsForInputEventPolyfill;
                }
              else
                SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
              if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                createAndAccumulateChangeEvent(
                  dispatchQueue,
                  getTargetInstFunc,
                  nativeEvent,
                  nativeEventTarget
                );
                break a;
              }
              handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
              "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
            }
            handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                  activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                break;
              case "focusout":
                lastSelection = activeElementInst = activeElement = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) break;
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
            var fallbackData;
            if (canUseCompositionEvent)
              b: {
                switch (domEventName) {
                  case "compositionstart":
                    var eventType = "onCompositionStart";
                    break b;
                  case "compositionend":
                    eventType = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    eventType = "onCompositionUpdate";
                    break b;
                }
                eventType = void 0;
              }
            else
              isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
            eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root2 = nativeEventTarget, startText = "value" in root2 ? root2.value : root2.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
              eventType,
              domEventName,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
            if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
              eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
                "onBeforeInput",
                "beforeinput",
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: handleEventFunc,
                listeners: eventType
              }), handleEventFunc.data = fallbackData);
            extractEvents$1(
              dispatchQueue,
              domEventName,
              targetInst,
              nativeEvent,
              nativeEventTarget
            );
          }
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        });
      }
      function createDispatchListener(instance, listener, currentTarget) {
        return {
          instance,
          listener,
          currentTarget
        };
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
          var _instance2 = targetFiber, stateNode = _instance2.stateNode;
          _instance2 = _instance2.tag;
          5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ));
          if (3 === targetFiber.tag) return listeners;
          targetFiber = targetFiber.return;
        }
        return [];
      }
      function getParent(inst) {
        if (null === inst) return null;
        do
          inst = inst.return;
        while (inst && 5 !== inst.tag && 27 !== inst.tag);
        return inst ? inst : null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
          var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
          _instance3 = _instance3.tag;
          if (null !== alternate && alternate === common) break;
          5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
            createDispatchListener(target, stateNode, alternate)
          )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
            createDispatchListener(target, stateNode, alternate)
          )));
          target = target.return;
        }
        0 !== listeners.length && dispatchQueue.push({ event, listeners });
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
      var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText) {
        clientText = normalizeMarkupForTextOrAttribute(clientText);
        return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
      }
      function setProp(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "children":
            "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
            break;
          case "className":
            setValueForKnownAttribute(domElement, "class", value);
            break;
          case "tabIndex":
            setValueForKnownAttribute(domElement, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            setValueForKnownAttribute(domElement, key, value);
            break;
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "data":
            if ("object" !== tag) {
              setValueForKnownAttribute(domElement, "data", value);
              break;
            }
          case "src":
          case "href":
            if ("" === value && ("a" !== tag || "href" !== key)) {
              domElement.removeAttribute(key);
              break;
            }
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "action":
          case "formAction":
            if ("function" === typeof value) {
              domElement.setAttribute(
                key,
                "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
              );
              break;
            } else
              "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
            if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "multiple":
            domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "muted":
            domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            break;
          case "autoFocus":
            break;
          case "xlinkHref":
            if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
              domElement.removeAttribute("xlink:href");
              break;
            }
            key = sanitizeURL("" + value);
            domElement.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              key
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
            break;
          case "inert":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
            break;
          case "capture":
          case "download":
            true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "rowSpan":
          case "start":
            null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
            break;
          case "popover":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            setValueForAttribute(domElement, "popover", value);
            break;
          case "xlinkActuate":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:actuate",
              value
            );
            break;
          case "xlinkArcrole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:arcrole",
              value
            );
            break;
          case "xlinkRole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:role",
              value
            );
            break;
          case "xlinkShow":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:show",
              value
            );
            break;
          case "xlinkTitle":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:title",
              value
            );
            break;
          case "xlinkType":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:type",
              value
            );
            break;
          case "xmlBase":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:base",
              value
            );
            break;
          case "xmlLang":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:lang",
              value
            );
            break;
          case "xmlSpace":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:space",
              value
            );
            break;
          case "is":
            setValueForAttribute(domElement, "is", value);
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
              key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
        }
      }
      function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "children":
            "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "innerHTML":
          case "ref":
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!registrationNameDependencies.hasOwnProperty(key))
              a: {
                if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                  "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                  domElement.addEventListener(tag, value, props);
                  break a;
                }
                key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
              }
        }
      }
      function setInitialProperties(domElement, tag, props) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "img":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            var hasSrc = false, hasSrcSet = false, propKey;
            for (propKey in props)
              if (props.hasOwnProperty(propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "src":
                      hasSrc = true;
                      break;
                    case "srcSet":
                      hasSrcSet = true;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(formatProdErrorMessage(137, tag));
                    default:
                      setProp(domElement, tag, propKey, propValue, props, null);
                  }
              }
            hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
            hasSrc && setProp(domElement, tag, "src", props.src, props, null);
            return;
          case "input":
            listenToNonDelegatedEvent("invalid", domElement);
            var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
            for (hasSrc in props)
              if (props.hasOwnProperty(hasSrc)) {
                var propValue$184 = props[hasSrc];
                if (null != propValue$184)
                  switch (hasSrc) {
                    case "name":
                      hasSrcSet = propValue$184;
                      break;
                    case "type":
                      propValue = propValue$184;
                      break;
                    case "checked":
                      checked = propValue$184;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$184;
                      break;
                    case "value":
                      propKey = propValue$184;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$184;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propValue$184)
                        throw Error(formatProdErrorMessage(137, tag));
                      break;
                    default:
                      setProp(domElement, tag, hasSrc, propValue$184, props, null);
                  }
              }
            initInput(
              domElement,
              propKey,
              defaultValue,
              checked,
              defaultChecked,
              propValue,
              hasSrcSet,
              false
            );
            return;
          case "select":
            listenToNonDelegatedEvent("invalid", domElement);
            hasSrc = propValue = propKey = null;
            for (hasSrcSet in props)
              if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                switch (hasSrcSet) {
                  case "value":
                    propKey = defaultValue;
                    break;
                  case "defaultValue":
                    propValue = defaultValue;
                    break;
                  case "multiple":
                    hasSrc = defaultValue;
                  default:
                    setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                }
            tag = propKey;
            props = propValue;
            domElement.multiple = !!hasSrc;
            null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
            return;
          case "textarea":
            listenToNonDelegatedEvent("invalid", domElement);
            propKey = hasSrcSet = hasSrc = null;
            for (propValue in props)
              if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                switch (propValue) {
                  case "value":
                    hasSrc = defaultValue;
                    break;
                  case "defaultValue":
                    hasSrcSet = defaultValue;
                    break;
                  case "children":
                    propKey = defaultValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    setProp(domElement, tag, propValue, defaultValue, props, null);
                }
            initTextarea(domElement, hasSrc, hasSrcSet, propKey);
            return;
          case "option":
            for (checked in props)
              if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                switch (checked) {
                  case "selected":
                    domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                    break;
                  default:
                    setProp(domElement, tag, checked, hasSrc, props, null);
                }
            return;
          case "dialog":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
              listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
            break;
          case "image":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "embed":
          case "source":
          case "link":
            listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
          case "area":
          case "base":
          case "br":
          case "col":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "track":
          case "wbr":
          case "menuitem":
            for (defaultChecked in props)
              if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                switch (defaultChecked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (propValue$184 in props)
                props.hasOwnProperty(propValue$184) && (hasSrc = props[propValue$184], void 0 !== hasSrc && setPropOnCustomElement(
                  domElement,
                  tag,
                  propValue$184,
                  hasSrc,
                  props,
                  void 0
                ));
              return;
            }
        }
        for (defaultValue in props)
          props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
      }
      function updateProperties(domElement, tag, lastProps, nextProps) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "input":
            var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
            for (propKey in lastProps) {
              var lastProp = lastProps[propKey];
              if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                switch (propKey) {
                  case "checked":
                    break;
                  case "value":
                    break;
                  case "defaultValue":
                    lastDefaultValue = lastProp;
                  default:
                    nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
                }
            }
            for (var propKey$201 in nextProps) {
              var propKey = nextProps[propKey$201];
              lastProp = lastProps[propKey$201];
              if (nextProps.hasOwnProperty(propKey$201) && (null != propKey || null != lastProp))
                switch (propKey$201) {
                  case "type":
                    type = propKey;
                    break;
                  case "name":
                    name = propKey;
                    break;
                  case "checked":
                    checked = propKey;
                    break;
                  case "defaultChecked":
                    defaultChecked = propKey;
                    break;
                  case "value":
                    value = propKey;
                    break;
                  case "defaultValue":
                    defaultValue = propKey;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    propKey !== lastProp && setProp(
                      domElement,
                      tag,
                      propKey$201,
                      propKey,
                      nextProps,
                      lastProp
                    );
                }
            }
            updateInput(
              domElement,
              value,
              defaultValue,
              lastDefaultValue,
              checked,
              defaultChecked,
              type,
              name
            );
            return;
          case "select":
            propKey = value = defaultValue = propKey$201 = null;
            for (type in lastProps)
              if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                switch (type) {
                  case "value":
                    break;
                  case "multiple":
                    propKey = lastDefaultValue;
                  default:
                    nextProps.hasOwnProperty(type) || setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue
                    );
                }
            for (name in nextProps)
              if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                switch (name) {
                  case "value":
                    propKey$201 = type;
                    break;
                  case "defaultValue":
                    defaultValue = type;
                    break;
                  case "multiple":
                    value = type;
                  default:
                    type !== lastDefaultValue && setProp(
                      domElement,
                      tag,
                      name,
                      type,
                      nextProps,
                      lastDefaultValue
                    );
                }
            tag = defaultValue;
            lastProps = value;
            nextProps = propKey;
            null != propKey$201 ? updateOptions(domElement, !!lastProps, propKey$201, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
            return;
          case "textarea":
            propKey = propKey$201 = null;
            for (defaultValue in lastProps)
              if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                switch (defaultValue) {
                  case "value":
                    break;
                  case "children":
                    break;
                  default:
                    setProp(domElement, tag, defaultValue, null, nextProps, name);
                }
            for (value in nextProps)
              if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                switch (value) {
                  case "value":
                    propKey$201 = name;
                    break;
                  case "defaultValue":
                    propKey = name;
                    break;
                  case "children":
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != name) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    name !== type && setProp(domElement, tag, value, name, nextProps, type);
                }
            updateTextarea(domElement, propKey$201, propKey);
            return;
          case "option":
            for (var propKey$217 in lastProps)
              if (propKey$201 = lastProps[propKey$217], lastProps.hasOwnProperty(propKey$217) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$217))
                switch (propKey$217) {
                  case "selected":
                    domElement.selected = false;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      propKey$217,
                      null,
                      nextProps,
                      propKey$201
                    );
                }
            for (lastDefaultValue in nextProps)
              if (propKey$201 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
                switch (lastDefaultValue) {
                  case "selected":
                    domElement.selected = propKey$201 && "function" !== typeof propKey$201 && "symbol" !== typeof propKey$201;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      lastDefaultValue,
                      propKey$201,
                      nextProps,
                      propKey
                    );
                }
            return;
          case "img":
          case "link":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
          case "menuitem":
            for (var propKey$222 in lastProps)
              propKey$201 = lastProps[propKey$222], lastProps.hasOwnProperty(propKey$222) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$222) && setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
            for (checked in nextProps)
              if (propKey$201 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
                switch (checked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey$201)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      checked,
                      propKey$201,
                      nextProps,
                      propKey
                    );
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (var propKey$227 in lastProps)
                propKey$201 = lastProps[propKey$227], lastProps.hasOwnProperty(propKey$227) && void 0 !== propKey$201 && !nextProps.hasOwnProperty(propKey$227) && setPropOnCustomElement(
                  domElement,
                  tag,
                  propKey$227,
                  void 0,
                  nextProps,
                  propKey$201
                );
              for (defaultChecked in nextProps)
                propKey$201 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$201 === propKey || void 0 === propKey$201 && void 0 === propKey || setPropOnCustomElement(
                  domElement,
                  tag,
                  defaultChecked,
                  propKey$201,
                  nextProps,
                  propKey
                );
              return;
            }
        }
        for (var propKey$232 in lastProps)
          propKey$201 = lastProps[propKey$232], lastProps.hasOwnProperty(propKey$232) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$232) && setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
        for (lastProp in nextProps)
          propKey$201 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$201 === propKey || null == propKey$201 && null == propKey || setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
      }
      function isLikelyStaticResource(initiatorType) {
        switch (initiatorType) {
          case "css":
          case "script":
          case "font":
          case "img":
          case "image":
          case "input":
          case "link":
            return true;
          default:
            return false;
        }
      }
      function estimateBandwidth() {
        if ("function" === typeof performance.getEntriesByType) {
          for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i2 = 0; i2 < resourceEntries.length; i2++) {
            var entry = resourceEntries[i2], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
            if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
              initiatorType = 0;
              duration = entry.responseEnd;
              for (i2 += 1; i2 < resourceEntries.length; i2++) {
                var overlapEntry = resourceEntries[i2], overlapStartTime = overlapEntry.startTime;
                if (overlapStartTime > duration) break;
                var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
                overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
              }
              --i2;
              bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
              count++;
              if (10 < count) break;
            }
          }
          if (0 < count) return bits / count / 1e6;
        }
        return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
      }
      var eventsEnabled = null;
      var selectionInformation = null;
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function getOwnHostContext(namespaceURI) {
        switch (namespaceURI) {
          case "http://www.w3.org/2000/svg":
            return 1;
          case "http://www.w3.org/1998/Math/MathML":
            return 2;
          default:
            return 0;
        }
      }
      function getChildHostContextProd(parentNamespace, type) {
        if (0 === parentNamespace)
          switch (type) {
            case "svg":
              return 1;
            case "math":
              return 2;
            default:
              return 0;
          }
        return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
      }
      function shouldSetTextContent(type, props) {
        return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
      }
      var currentPopstateTransitionEvent = null;
      function shouldAttemptEagerTransition() {
        var event = window.event;
        if (event && "popstate" === event.type) {
          if (event === currentPopstateTransitionEvent) return false;
          currentPopstateTransitionEvent = event;
          return true;
        }
        currentPopstateTransitionEvent = null;
        return false;
      }
      var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0;
      var cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0;
      var localPromise = "function" === typeof Promise ? Promise : void 0;
      var scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout;
      function handleErrorInNextTick(error) {
        setTimeout(function() {
          throw error;
        });
      }
      function isSingletonScope(type) {
        return "head" === type;
      }
      function clearHydrationBoundary(parentInstance, hydrationInstance) {
        var node = hydrationInstance, depth = 0;
        do {
          var nextNode = node.nextSibling;
          parentInstance.removeChild(node);
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, "/$" === node || "/&" === node) {
              if (0 === depth) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(hydrationInstance);
                return;
              }
              depth--;
            } else if ("$" === node || "$?" === node || "$~" === node || "$!" === node || "&" === node)
              depth++;
            else if ("html" === node)
              releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
            else if ("head" === node) {
              node = parentInstance.ownerDocument.head;
              releaseSingletonInstance(node);
              for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
                var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
                node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
                node$jscomp$0 = nextNode$jscomp$0;
              }
            } else
              "body" === node && releaseSingletonInstance(parentInstance.ownerDocument.body);
          node = nextNode;
        } while (node);
        retryIfBlockedOn(hydrationInstance);
      }
      function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
        var node = suspenseInstance;
        suspenseInstance = 0;
        do {
          var nextNode = node.nextSibling;
          1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
          if (nextNode && 8 === nextNode.nodeType)
            if (node = nextNode.data, "/$" === node)
              if (0 === suspenseInstance) break;
              else suspenseInstance--;
            else
              "$" !== node && "$?" !== node && "$~" !== node && "$!" !== node || suspenseInstance++;
          node = nextNode;
        } while (node);
      }
      function clearContainerSparingly(container2) {
        var nextNode = container2.firstChild;
        nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
        for (; nextNode; ) {
          var node = nextNode;
          nextNode = nextNode.nextSibling;
          switch (node.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
              clearContainerSparingly(node);
              detachDeletedInstance(node);
              continue;
            case "SCRIPT":
            case "STYLE":
              continue;
            case "LINK":
              if ("stylesheet" === node.rel.toLowerCase()) continue;
          }
          container2.removeChild(node);
        }
      }
      function canHydrateInstance(instance, type, props, inRootOrSingleton) {
        for (; 1 === instance.nodeType; ) {
          var anyProps = props;
          if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
            if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
              break;
          } else if (!inRootOrSingleton)
            if ("input" === type && "hidden" === instance.type) {
              var name = null == anyProps.name ? null : "" + anyProps.name;
              if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                return instance;
            } else return instance;
          else if (!instance[internalHoistableMarker])
            switch (type) {
              case "meta":
                if (!instance.hasAttribute("itemprop")) break;
                return instance;
              case "link":
                name = instance.getAttribute("rel");
                if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                  break;
                else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                  break;
                return instance;
              case "style":
                if (instance.hasAttribute("data-precedence")) break;
                return instance;
              case "script":
                name = instance.getAttribute("src");
                if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                  break;
                return instance;
              default:
                return instance;
            }
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) break;
        }
        return null;
      }
      function canHydrateTextInstance(instance, text, inRootOrSingleton) {
        if ("" === text) return null;
        for (; 3 !== instance.nodeType; ) {
          if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) return null;
        }
        return instance;
      }
      function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
        for (; 8 !== instance.nodeType; ) {
          if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
            return null;
          instance = getNextHydratable(instance.nextSibling);
          if (null === instance) return null;
        }
        return instance;
      }
      function isSuspenseInstancePending(instance) {
        return "$?" === instance.data || "$~" === instance.data;
      }
      function isSuspenseInstanceFallback(instance) {
        return "$!" === instance.data || "$?" === instance.data && "loading" !== instance.ownerDocument.readyState;
      }
      function registerSuspenseInstanceRetry(instance, callback) {
        var ownerDocument = instance.ownerDocument;
        if ("$~" === instance.data) instance._reactRetry = callback;
        else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
          callback();
        else {
          var listener = function() {
            callback();
            ownerDocument.removeEventListener("DOMContentLoaded", listener);
          };
          ownerDocument.addEventListener("DOMContentLoaded", listener);
          instance._reactRetry = listener;
        }
      }
      function getNextHydratable(node) {
        for (; null != node; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (1 === nodeType || 3 === nodeType) break;
          if (8 === nodeType) {
            nodeType = node.data;
            if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "$~" === nodeType || "&" === nodeType || "F!" === nodeType || "F" === nodeType)
              break;
            if ("/$" === nodeType || "/&" === nodeType) return null;
          }
        }
        return node;
      }
      var previousHydratableOnEnteringScopedSingleton = null;
      function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
        hydrationInstance = hydrationInstance.nextSibling;
        for (var depth = 0; hydrationInstance; ) {
          if (8 === hydrationInstance.nodeType) {
            var data = hydrationInstance.data;
            if ("/$" === data || "/&" === data) {
              if (0 === depth)
                return getNextHydratable(hydrationInstance.nextSibling);
              depth--;
            } else
              "$" !== data && "$!" !== data && "$?" !== data && "$~" !== data && "&" !== data || depth++;
          }
          hydrationInstance = hydrationInstance.nextSibling;
        }
        return null;
      }
      function getParentHydrationBoundary(targetInstance) {
        targetInstance = targetInstance.previousSibling;
        for (var depth = 0; targetInstance; ) {
          if (8 === targetInstance.nodeType) {
            var data = targetInstance.data;
            if ("$" === data || "$!" === data || "$?" === data || "$~" === data || "&" === data) {
              if (0 === depth) return targetInstance;
              depth--;
            } else "/$" !== data && "/&" !== data || depth++;
          }
          targetInstance = targetInstance.previousSibling;
        }
        return null;
      }
      function resolveSingletonInstance(type, props, rootContainerInstance) {
        props = getOwnerDocumentFromRootContainer(rootContainerInstance);
        switch (type) {
          case "html":
            type = props.documentElement;
            if (!type) throw Error(formatProdErrorMessage(452));
            return type;
          case "head":
            type = props.head;
            if (!type) throw Error(formatProdErrorMessage(453));
            return type;
          case "body":
            type = props.body;
            if (!type) throw Error(formatProdErrorMessage(454));
            return type;
          default:
            throw Error(formatProdErrorMessage(451));
        }
      }
      function releaseSingletonInstance(instance) {
        for (var attributes = instance.attributes; attributes.length; )
          instance.removeAttributeNode(attributes[0]);
        detachDeletedInstance(instance);
      }
      var preloadPropsMap = /* @__PURE__ */ new Map();
      var preconnectsSet = /* @__PURE__ */ new Set();
      function getHoistableRoot(container2) {
        return "function" === typeof container2.getRootNode ? container2.getRootNode() : 9 === container2.nodeType ? container2 : container2.ownerDocument;
      }
      var previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: flushSyncWork,
        r: requestFormReset,
        D: prefetchDNS,
        C: preconnect,
        L: preload,
        m: preloadModule,
        X: preinitScript,
        S: preinitStyle,
        M: preinitModuleScript
      };
      function flushSyncWork() {
        var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      }
      function requestFormReset(form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
      }
      var globalDocument = "undefined" === typeof document ? null : document;
      function preconnectAs(rel, href, crossOrigin) {
        var ownerDocument = globalDocument;
        if (ownerDocument && "string" === typeof href && href) {
          var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
          limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
          "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
          preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
        }
      }
      function prefetchDNS(href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      }
      function preconnect(href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      }
      function preload(href, as, options2) {
        previousDispatcher.L(href, as, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href && as) {
          var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSrcSet
          ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSizes
          ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) || (href = assign(
            {
              rel: "preload",
              href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
              as
            },
            options2
          ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
        }
      }
      function preloadModule(href, options2) {
        previousDispatcher.m(href, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                  return;
            }
            as = ownerDocument.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument.head.appendChild(as);
          }
        }
      }
      function preinitStyle(href, precedence, options2) {
        previousDispatcher.S(href, precedence, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && href) {
          var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles.get(key);
          if (!resource) {
            var state = { loading: 0, preload: null };
            if (resource = ownerDocument.querySelector(
              getStylesheetSelectorFromKey(key)
            ))
              state.loading = 5;
            else {
              href = assign(
                { rel: "stylesheet", href, "data-precedence": precedence },
                options2
              );
              (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
              var link = resource = ownerDocument.createElement("link");
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function(resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function() {
                state.loading |= 1;
              });
              link.addEventListener("error", function() {
                state.loading |= 2;
              });
              state.loading |= 4;
              insertStylesheet(resource, precedence, ownerDocument);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state
            };
            styles.set(key, resource);
          }
        }
      }
      function preinitScript(src, options2) {
        previousDispatcher.X(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function preinitModuleScript(src, options2) {
        previousDispatcher.M(src, options2);
        var ownerDocument = globalDocument;
        if (ownerDocument && src) {
          var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function getResource(type, currentProps, pendingProps, currentResource) {
        var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
        if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
        switch (type) {
          case "meta":
          case "title":
            return null;
          case "style":
            return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          case "link":
            if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
              type = getStyleKey(pendingProps.href);
              var styles$243 = getResourcesFromRoot(
                JSCompiler_inline_result
              ).hoistableStyles, resource$244 = styles$243.get(type);
              resource$244 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$244 = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null }
              }, styles$243.set(type, resource$244), (styles$243 = JSCompiler_inline_result.querySelector(
                getStylesheetSelectorFromKey(type)
              )) && !styles$243._p && (resource$244.instance = styles$243, resource$244.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              }, preloadPropsMap.set(type, pendingProps), styles$243 || preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$244.state
              )));
              if (currentProps && null === currentResource)
                throw Error(formatProdErrorMessage(528, ""));
              return resource$244;
            }
            if (currentProps && null !== currentResource)
              throw Error(formatProdErrorMessage(529, ""));
            return null;
          case "script":
            return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "script",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          default:
            throw Error(formatProdErrorMessage(444, type));
        }
      }
      function getStyleKey(href) {
        return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
      }
      function getStylesheetSelectorFromKey(key) {
        return 'link[rel="stylesheet"][' + key + "]";
      }
      function stylesheetPropsFromRawProps(rawProps) {
        return assign({}, rawProps, {
          "data-precedence": rawProps.precedence,
          precedence: null
        });
      }
      function preloadStylesheet(ownerDocument, key, preloadProps, state) {
        ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
          return state.loading |= 1;
        }), key.addEventListener("error", function() {
          return state.loading |= 2;
        }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
      }
      function getScriptKey(src) {
        return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
      }
      function getScriptSelectorFromKey(key) {
        return "script[async]" + key;
      }
      function acquireResource(hoistableRoot, resource, props) {
        resource.count++;
        if (null === resource.instance)
          switch (resource.type) {
            case "style":
              var instance = hoistableRoot.querySelector(
                'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
              );
              if (instance)
                return resource.instance = instance, markNodeAsHoistable(instance), instance;
              var styleProps = assign({}, props, {
                "data-href": props.href,
                "data-precedence": props.precedence,
                href: null,
                precedence: null
              });
              instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
                "style"
              );
              markNodeAsHoistable(instance);
              setInitialProperties(instance, "style", styleProps);
              insertStylesheet(instance, props.precedence, hoistableRoot);
              return resource.instance = instance;
            case "stylesheet":
              styleProps = getStyleKey(props.href);
              var instance$249 = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(styleProps)
              );
              if (instance$249)
                return resource.state.loading |= 4, resource.instance = instance$249, markNodeAsHoistable(instance$249), instance$249;
              instance = stylesheetPropsFromRawProps(props);
              (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
              instance$249 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
              markNodeAsHoistable(instance$249);
              var linkInstance = instance$249;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance$249, "link", instance);
              resource.state.loading |= 4;
              insertStylesheet(instance$249, props.precedence, hoistableRoot);
              return resource.instance = instance$249;
            case "script":
              instance$249 = getScriptKey(props.src);
              if (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(instance$249)
              ))
                return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
              instance = props;
              if (styleProps = preloadPropsMap.get(instance$249))
                instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
              hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
              styleProps = hoistableRoot.createElement("script");
              markNodeAsHoistable(styleProps);
              setInitialProperties(styleProps, "link", instance);
              hoistableRoot.head.appendChild(styleProps);
              return resource.instance = styleProps;
            case "void":
              return null;
            default:
              throw Error(formatProdErrorMessage(443, resource.type));
          }
        else
          "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
        return resource.instance;
      }
      function insertStylesheet(instance, precedence, root3) {
        for (var nodes = root3.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]'
        ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i2 = 0; i2 < nodes.length; i2++) {
          var node = nodes[i2];
          if (node.dataset.precedence === precedence) prior = node;
          else if (prior !== last) break;
        }
        prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root3.nodeType ? root3.head : root3, precedence.insertBefore(instance, precedence.firstChild));
      }
      function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
        null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
        null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
        null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
      }
      function adoptPreloadPropsForScript(scriptProps, preloadProps) {
        null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
        null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
        null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
      }
      var tagCaches = null;
      function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
        if (null === tagCaches) {
          var cache = /* @__PURE__ */ new Map();
          var caches = tagCaches = /* @__PURE__ */ new Map();
          caches.set(ownerDocument, cache);
        } else
          caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
        if (cache.has(type)) return cache;
        cache.set(type, null);
        ownerDocument = ownerDocument.getElementsByTagName(type);
        for (caches = 0; caches < ownerDocument.length; caches++) {
          var node = ownerDocument[caches];
          if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
            var nodeKey = node.getAttribute(keyAttribute) || "";
            nodeKey = type + nodeKey;
            var existing = cache.get(nodeKey);
            existing ? existing.push(node) : cache.set(nodeKey, [node]);
          }
        }
        return cache;
      }
      function mountHoistable(hoistableRoot, type, instance) {
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        hoistableRoot.head.insertBefore(
          instance,
          "title" === type ? hoistableRoot.querySelector("head > title") : null
        );
      }
      function isHostHoistableType(type, props, hostContext) {
        if (1 === hostContext || null != props.itemProp) return false;
        switch (type) {
          case "meta":
          case "title":
            return true;
          case "style":
            if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
              break;
            return true;
          case "link":
            if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
              break;
            switch (props.rel) {
              case "stylesheet":
                return type = props.disabled, "string" === typeof props.precedence && null == type;
              default:
                return true;
            }
          case "script":
            if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
              return true;
        }
        return false;
      }
      function preloadResource(resource) {
        return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
      }
      function suspendResource(state, hoistableRoot, resource, props) {
        if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
          if (null === resource.instance) {
            var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key)
            );
            if (instance) {
              hoistableRoot = instance._p;
              null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
              resource.state.loading |= 4;
              resource.instance = instance;
              markNodeAsHoistable(instance);
              return;
            }
            instance = hoistableRoot.ownerDocument || hoistableRoot;
            props = stylesheetPropsFromRawProps(props);
            (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
            instance = instance.createElement("link");
            markNodeAsHoistable(instance);
            var linkInstance = instance;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance, "link", props);
            resource.instance = instance;
          }
          null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
          state.stylesheets.set(resource, hoistableRoot);
          (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
        }
      }
      var estimatedBytesWithinLimit = 0;
      function waitForCommitToBeReady(state, timeoutOffset) {
        state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
        return 0 < state.count || 0 < state.imgCount ? function(commit) {
          var stylesheetTimer = setTimeout(function() {
            state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
            if (state.unsuspend) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          }, 6e4 + timeoutOffset);
          0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
          var imgTimer = setTimeout(
            function() {
              state.waitingForImages = false;
              if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            },
            (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) + timeoutOffset
          );
          state.unsuspend = commit;
          return function() {
            state.unsuspend = null;
            clearTimeout(stylesheetTimer);
            clearTimeout(imgTimer);
          };
        } : null;
      }
      function onUnsuspend() {
        this.count--;
        if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
          if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
          else if (this.unsuspend) {
            var unsuspend = this.unsuspend;
            this.unsuspend = null;
            unsuspend();
          }
        }
      }
      var precedencesByRoot = null;
      function insertSuspendedStylesheets(state, resources) {
        state.stylesheets = null;
        null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
      }
      function insertStylesheetIntoRoot(root3, resource) {
        if (!(resource.state.loading & 4)) {
          var precedences = precedencesByRoot.get(root3);
          if (precedences) var last = precedences.get(null);
          else {
            precedences = /* @__PURE__ */ new Map();
            precedencesByRoot.set(root3, precedences);
            for (var nodes = root3.querySelectorAll(
              "link[data-precedence],style[data-precedence]"
            ), i2 = 0; i2 < nodes.length; i2++) {
              var node = nodes[i2];
              if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
                precedences.set(node.dataset.precedence, node), last = node;
            }
            last && precedences.set(null, last);
          }
          nodes = resource.instance;
          node = nodes.getAttribute("data-precedence");
          i2 = precedences.get(node) || last;
          i2 === last && precedences.set(null, nodes);
          precedences.set(node, nodes);
          this.count++;
          last = onUnsuspend.bind(this);
          nodes.addEventListener("load", last);
          nodes.addEventListener("error", last);
          i2 ? i2.parentNode.insertBefore(nodes, i2.nextSibling) : (root3 = 9 === root3.nodeType ? root3.head : root3, root3.insertBefore(nodes, root3.firstChild));
          resource.state.loading |= 4;
        }
      }
      var HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: sharedNotPendingObject,
        _currentValue2: sharedNotPendingObject,
        _threadCount: 0
      };
      function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
        containerInfo = new FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          onDefaultTransitionIndicator,
          formState
        );
        tag = 1;
        true === isStrictMode && (tag |= 24);
        isStrictMode = createFiberImplClass(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache();
        tag.refCount++;
        containerInfo.pooledCache = tag;
        tag.refCount++;
        isStrictMode.memoizedState = {
          element: initialChildren,
          isDehydrated: hydrate,
          cache: tag
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
      }
      function updateContainerImpl(rootFiber, lane, element, container2, parentComponent, callback) {
        parentComponent = getContextForSubtree(parentComponent);
        null === container2.context ? container2.context = parentComponent : container2.pendingContext = parentComponent;
        container2 = createUpdate(lane);
        container2.payload = { element };
        callback = void 0 === callback ? null : callback;
        null !== callback && (container2.callback = callback);
        element = enqueueUpdate(rootFiber, container2, lane);
        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
      }
      function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
          var a2 = fiber.retryLane;
          fiber.retryLane = 0 !== a2 && a2 < retryLane ? a2 : retryLane;
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
      }
      function attemptContinuousHydration(fiber) {
        if (13 === fiber.tag || 31 === fiber.tag) {
          var root3 = enqueueConcurrentRenderForLane(fiber, 67108864);
          null !== root3 && scheduleUpdateOnFiber(root3, fiber, 67108864);
          markRetryLaneIfNotHydrated(fiber, 67108864);
        }
      }
      function attemptHydrationAtCurrentPriority(fiber) {
        if (13 === fiber.tag || 31 === fiber.tag) {
          var lane = requestUpdateLane();
          lane = getBumpedLaneForHydrationByLane(lane);
          var root3 = enqueueConcurrentRenderForLane(fiber, lane);
          null !== root3 && scheduleUpdateOnFiber(root3, fiber, lane);
          markRetryLaneIfNotHydrated(fiber, lane);
        }
      }
      var _enabled = true;
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 2, dispatchEvent2(domEventName, eventSystemFlags, container2, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 8, dispatchEvent2(domEventName, eventSystemFlags, container2, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchEvent2(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (_enabled) {
          var blockedOn = findInstanceBlockingEvent(nativeEvent);
          if (null === blockedOn)
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            ), clearIfContinuousEvent(domEventName, nativeEvent);
          else if (queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ))
            nativeEvent.stopPropagation();
          else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
            for (; null !== blockedOn; ) {
              var fiber = getInstanceFromNode(blockedOn);
              if (null !== fiber)
                switch (fiber.tag) {
                  case 3:
                    fiber = fiber.stateNode;
                    if (fiber.current.memoizedState.isDehydrated) {
                      var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                      if (0 !== lanes) {
                        var root3 = fiber;
                        root3.pendingLanes |= 2;
                        for (root3.entangledLanes |= 2; lanes; ) {
                          var lane = 1 << 31 - clz32(lanes);
                          root3.entanglements[1] |= lane;
                          lanes &= ~lane;
                        }
                        ensureRootIsScheduled(fiber);
                        0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now2() + 500, flushSyncWorkAcrossRoots_impl(0, false));
                      }
                    }
                    break;
                  case 31:
                  case 13:
                    root3 = enqueueConcurrentRenderForLane(fiber, 2), null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                }
              fiber = findInstanceBlockingEvent(nativeEvent);
              null === fiber && dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              );
              if (fiber === blockedOn) break;
              blockedOn = fiber;
            }
            null !== blockedOn && nativeEvent.stopPropagation();
          } else
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              null,
              targetContainer
            );
        }
      }
      function findInstanceBlockingEvent(nativeEvent) {
        nativeEvent = getEventTarget(nativeEvent);
        return findInstanceBlockingTarget(nativeEvent);
      }
      var return_targetInst = null;
      function findInstanceBlockingTarget(targetNode) {
        return_targetInst = null;
        targetNode = getClosestInstanceFromNode(targetNode);
        if (null !== targetNode) {
          var nearestMounted = getNearestMountedFiber(targetNode);
          if (null === nearestMounted) targetNode = null;
          else {
            var tag = nearestMounted.tag;
            if (13 === tag) {
              targetNode = getSuspenseInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (31 === tag) {
              targetNode = getActivityInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (3 === tag) {
              if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              targetNode = null;
            } else nearestMounted !== targetNode && (targetNode = null);
          }
        }
        return_targetInst = targetNode;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "beforetoggle":
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "toggle":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 2;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 8;
          case "message":
            switch (getCurrentPriorityLevel()) {
              case ImmediatePriority:
                return 2;
              case UserBlockingPriority:
                return 8;
              case NormalPriority$1:
              case LowPriority:
                return 32;
              case IdlePriority:
                return 268435456;
              default:
                return 32;
            }
          default:
            return 32;
        }
      }
      var hasScheduledReplayAttempt = false;
      var queuedFocus = null;
      var queuedDrag = null;
      var queuedMouse = null;
      var queuedPointers = /* @__PURE__ */ new Map();
      var queuedPointerCaptures = /* @__PURE__ */ new Map();
      var queuedExplicitHydrationTargets = [];
      var discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " "
      );
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout":
            queuedPointers.delete(nativeEvent.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            queuedPointerCaptures.delete(nativeEvent.pointerId);
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
          return existingQueuedEvent = {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        blockedOn = existingQueuedEvent.targetContainers;
        null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin":
            return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "dragenter":
            return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "mouseover":
            return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "pointerover":
            var pointerId = nativeEvent.pointerId;
            queuedPointers.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointers.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            );
            return true;
          case "gotpointercapture":
            return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            ), true;
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (null !== targetInst) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (null !== nearestMounted) {
            if (targetInst = nearestMounted.tag, 13 === targetInst) {
              if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (31 === targetInst) {
              if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
              queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              return;
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (null !== queuedEvent.blockedOn) return false;
        for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
          if (null === nextBlockedOn) {
            nextBlockedOn = queuedEvent.nativeEvent;
            var nativeEventClone = new nextBlockedOn.constructor(
              nextBlockedOn.type,
              nextBlockedOn
            );
            currentReplayingEvent = nativeEventClone;
            nextBlockedOn.target.dispatchEvent(nativeEventClone);
            currentReplayingEvent = null;
          } else
            return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
        null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
        null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          replayUnblockedEvents
        )));
      }
      var lastScheduledReplayQueue = null;
      function scheduleReplayQueueIfNeeded(formReplayingQueue) {
        lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          function() {
            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
            for (var i2 = 0; i2 < formReplayingQueue.length; i2 += 3) {
              var form = formReplayingQueue[i2], submitterOrAction = formReplayingQueue[i2 + 1], formData = formReplayingQueue[i2 + 2];
              if ("function" !== typeof submitterOrAction)
                if (null === findInstanceBlockingTarget(submitterOrAction || form))
                  continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst && (formReplayingQueue.splice(i2, 3), i2 -= 3, startHostTransition(
                formInst,
                {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                },
                submitterOrAction,
                formData
              ));
            }
          }
        ));
      }
      function retryIfBlockedOn(unblocked) {
        function unblock(queuedEvent) {
          return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        }
        null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var i2 = 0; i2 < queuedExplicitHydrationTargets.length; i2++) {
          var queuedTarget = queuedExplicitHydrationTargets[i2];
          queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
        }
        for (; 0 < queuedExplicitHydrationTargets.length && (i2 = queuedExplicitHydrationTargets[0], null === i2.blockedOn); )
          attemptExplicitHydrationTarget(i2), null === i2.blockedOn && queuedExplicitHydrationTargets.shift();
        i2 = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
        if (null != i2)
          for (queuedTarget = 0; queuedTarget < i2.length; queuedTarget += 3) {
            var form = i2[queuedTarget], submitterOrAction = i2[queuedTarget + 1], formProps = form[internalPropsKey] || null;
            if ("function" === typeof submitterOrAction)
              formProps || scheduleReplayQueueIfNeeded(i2);
            else if (formProps) {
              var action = null;
              if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                  action = formProps.formAction;
                else {
                  if (null !== findInstanceBlockingTarget(form)) continue;
                }
              else action = formProps.action;
              "function" === typeof action ? i2[queuedTarget + 1] = action : (i2.splice(queuedTarget, 3), queuedTarget -= 3);
              scheduleReplayQueueIfNeeded(i2);
            }
          }
      }
      function defaultOnDefaultTransitionIndicator() {
        function handleNavigate(event) {
          event.canIntercept && "react-transition" === event.info && event.intercept({
            handler: function() {
              return new Promise(function(resolve) {
                return pendingResolve = resolve;
              });
            },
            focusReset: "manual",
            scroll: "manual"
          });
        }
        function handleNavigateComplete() {
          null !== pendingResolve && (pendingResolve(), pendingResolve = null);
          isCancelled || setTimeout(startFakeNavigation, 20);
        }
        function startFakeNavigation() {
          if (!isCancelled && !navigation.transition) {
            var currentEntry = navigation.currentEntry;
            currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
              state: currentEntry.getState(),
              info: "react-transition",
              history: "replace"
            });
          }
        }
        if ("object" === typeof navigation) {
          var isCancelled = false, pendingResolve = null;
          navigation.addEventListener("navigate", handleNavigate);
          navigation.addEventListener("navigatesuccess", handleNavigateComplete);
          navigation.addEventListener("navigateerror", handleNavigateComplete);
          setTimeout(startFakeNavigation, 100);
          return function() {
            isCancelled = true;
            navigation.removeEventListener("navigate", handleNavigate);
            navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
            navigation.removeEventListener("navigateerror", handleNavigateComplete);
            null !== pendingResolve && (pendingResolve(), pendingResolve = null);
          };
        }
      }
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children3) {
        var root3 = this._internalRoot;
        if (null === root3) throw Error(formatProdErrorMessage(409));
        var current = root3.current, lane = requestUpdateLane();
        updateContainerImpl(current, lane, children3, root3, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        var root3 = this._internalRoot;
        if (null !== root3) {
          this._internalRoot = null;
          var container2 = root3.containerInfo;
          updateContainerImpl(root3.current, 2, null, root3, null, null);
          flushSyncWork$1();
          container2[internalContainerInstanceKey] = null;
        }
      };
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
        if (target) {
          var updatePriority = resolveUpdatePriority();
          target = { blockedOn: null, target, priority: updatePriority };
          for (var i2 = 0; i2 < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i2].priority; i2++) ;
          queuedExplicitHydrationTargets.splice(i2, 0, target);
          0 === i2 && attemptExplicitHydrationTarget(target);
        }
      };
      var isomorphicReactPackageVersion$jscomp$inline_1840 = React6.version;
      if ("19.2.3" !== isomorphicReactPackageVersion$jscomp$inline_1840)
        throw Error(
          formatProdErrorMessage(
            527,
            isomorphicReactPackageVersion$jscomp$inline_1840,
            "19.2.3"
          )
        );
      ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
        var fiber = componentOrElement._reactInternals;
        if (void 0 === fiber) {
          if ("function" === typeof componentOrElement.render)
            throw Error(formatProdErrorMessage(188));
          componentOrElement = Object.keys(componentOrElement).join(",");
          throw Error(formatProdErrorMessage(268, componentOrElement));
        }
        componentOrElement = findCurrentFiberUsingSlowPath(fiber);
        componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
        componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
        return componentOrElement;
      };
      var internals$jscomp$inline_2347 = {
        bundleType: 0,
        version: "19.2.3",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.2.3"
      };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!hook$jscomp$inline_2348.isDisabled && hook$jscomp$inline_2348.supportsFiber)
          try {
            rendererID = hook$jscomp$inline_2348.inject(
              internals$jscomp$inline_2347
            ), injectedHook = hook$jscomp$inline_2348;
          } catch (err) {
          }
      }
      var hook$jscomp$inline_2348;
      exports.createRoot = function(container2, options2) {
        if (!isValidContainer(container2)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError));
        options2 = createFiberRoot(
          container2,
          1,
          false,
          null,
          null,
          isStrictMode,
          identifierPrefix,
          null,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          defaultOnDefaultTransitionIndicator
        );
        container2[internalContainerInstanceKey] = options2.current;
        listenToAllSupportedEvents(container2);
        return new ReactDOMRoot(options2);
      };
      exports.hydrateRoot = function(container2, initialChildren, options2) {
        if (!isValidContainer(container2)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.formState && (formState = options2.formState));
        initialChildren = createFiberRoot(
          container2,
          1,
          true,
          initialChildren,
          null != options2 ? options2 : null,
          isStrictMode,
          identifierPrefix,
          formState,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          defaultOnDefaultTransitionIndicator
        );
        initialChildren.context = getContextForSubtree(null);
        options2 = initialChildren.current;
        isStrictMode = requestUpdateLane();
        isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
        identifierPrefix = createUpdate(isStrictMode);
        identifierPrefix.callback = null;
        enqueueUpdate(options2, identifierPrefix, isStrictMode);
        options2 = isStrictMode;
        initialChildren.current.lanes = options2;
        markRootUpdated$1(initialChildren, options2);
        ensureRootIsScheduled(initialChildren);
        container2[internalContainerInstanceKey] = initialChildren.current;
        listenToAllSupportedEvents(container2);
        return new ReactDOMHydrationRoot(initialChildren);
      };
      exports.version = "19.2.3";
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_client_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js
  var require_use_sync_external_store_shim_production = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.js"(exports) {
      "use strict";
      var React6 = require_react();
      function is(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is;
      var useState12 = React6.useState;
      var useEffect9 = React6.useEffect;
      var useLayoutEffect = React6.useLayoutEffect;
      var useDebugValue2 = React6.useDebugValue;
      function useSyncExternalStore$2(subscribe, getSnapshot) {
        var value = getSnapshot(), _useState = useState12({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
        useLayoutEffect(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe, value, getSnapshot]
        );
        useEffect9(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe]
        );
        useDebugValue2(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
      }
      var shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React6.useSyncExternalStore ? React6.useSyncExternalStore : shim;
    }
  });

  // node_modules/use-sync-external-store/shim/index.js
  var require_shim = __commonJS({
    "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_use_sync_external_store_shim_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js
  var require_with_selector_production = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js"(exports) {
      "use strict";
      var React6 = require_react();
      var shim = require_shim();
      function is(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is;
      var useSyncExternalStore = shim.useSyncExternalStore;
      var useRef6 = React6.useRef;
      var useEffect9 = React6.useEffect;
      var useMemo6 = React6.useMemo;
      var useDebugValue2 = React6.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector3, isEqual) {
        var instRef = useRef6(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo6(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector3(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
              var nextSelection = selector3(nextSnapshot);
              if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector3, isEqual]
        );
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect9(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue2(value);
        return value;
      };
    }
  });

  // node_modules/use-sync-external-store/shim/with-selector.js
  var require_with_selector = __commonJS({
    "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_with_selector_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.production.js
  var require_react_jsx_runtime_production = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element");
      var REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment");
      function jsxProd(type, config, maybeKey) {
        var key = null;
        void 0 !== maybeKey && (key = "" + maybeKey);
        void 0 !== config.key && (key = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        config = maybeKey.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== config ? config : null,
          props: maybeKey
        };
      }
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = jsxProd;
      exports.jsxs = jsxProd;
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_jsx_runtime_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/xml2js/lib/defaults.js
  var require_defaults = __commonJS({
    "node_modules/xml2js/lib/defaults.js"(exports) {
      (function() {
        exports.defaults = {
          "0.1": {
            explicitCharkey: false,
            trim: true,
            normalize: true,
            normalizeTags: false,
            attrkey: "@",
            charkey: "#",
            explicitArray: false,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: false,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            childkey: "@@",
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            emptyTag: ""
          },
          "0.2": {
            explicitCharkey: false,
            trim: false,
            normalize: false,
            normalizeTags: false,
            attrkey: "$",
            charkey: "_",
            explicitArray: true,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: true,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            preserveChildrenOrder: false,
            childkey: "$$",
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            rootName: "root",
            xmldec: {
              "version": "1.0",
              "encoding": "UTF-8",
              "standalone": true
            },
            doctype: null,
            renderOpts: {
              "pretty": true,
              "indent": "  ",
              "newline": "\n"
            },
            headless: false,
            chunkSize: 1e4,
            emptyTag: "",
            cdata: false
          }
        };
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/Utility.js
  var require_Utility = __commonJS({
    "node_modules/xmlbuilder/lib/Utility.js"(exports, module) {
      (function() {
        var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
        assign = function() {
          var i2, key, len, source, sources, target;
          target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (isFunction(Object.assign)) {
            Object.assign.apply(null, arguments);
          } else {
            for (i2 = 0, len = sources.length; i2 < len; i2++) {
              source = sources[i2];
              if (source != null) {
                for (key in source) {
                  if (!hasProp.call(source, key)) continue;
                  target[key] = source[key];
                }
              }
            }
          }
          return target;
        };
        isFunction = function(val) {
          return !!val && Object.prototype.toString.call(val) === "[object Function]";
        };
        isObject = function(val) {
          var ref;
          return !!val && ((ref = typeof val) === "function" || ref === "object");
        };
        isArray = function(val) {
          if (isFunction(Array.isArray)) {
            return Array.isArray(val);
          } else {
            return Object.prototype.toString.call(val) === "[object Array]";
          }
        };
        isEmpty = function(val) {
          var key;
          if (isArray(val)) {
            return !val.length;
          } else {
            for (key in val) {
              if (!hasProp.call(val, key)) continue;
              return false;
            }
            return true;
          }
        };
        isPlainObject = function(val) {
          var ctor, proto;
          return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
        };
        getValue = function(obj) {
          if (isFunction(obj.valueOf)) {
            return obj.valueOf();
          } else {
            return obj;
          }
        };
        module.exports.assign = assign;
        module.exports.isFunction = isFunction;
        module.exports.isObject = isObject;
        module.exports.isArray = isArray;
        module.exports.isEmpty = isEmpty;
        module.exports.isPlainObject = isPlainObject;
        module.exports.getValue = getValue;
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDOMImplementation.js
  var require_XMLDOMImplementation = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDOMImplementation.js"(exports, module) {
      (function() {
        var XMLDOMImplementation;
        module.exports = XMLDOMImplementation = (function() {
          function XMLDOMImplementation2() {
          }
          XMLDOMImplementation2.prototype.hasFeature = function(feature, version) {
            return true;
          };
          XMLDOMImplementation2.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
            throw new Error("This DOM method is not implemented.");
          };
          XMLDOMImplementation2.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
            throw new Error("This DOM method is not implemented.");
          };
          XMLDOMImplementation2.prototype.createHTMLDocument = function(title) {
            throw new Error("This DOM method is not implemented.");
          };
          XMLDOMImplementation2.prototype.getFeature = function(feature, version) {
            throw new Error("This DOM method is not implemented.");
          };
          return XMLDOMImplementation2;
        })();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
  var require_XMLDOMErrorHandler = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js"(exports, module) {
      (function() {
        var XMLDOMErrorHandler;
        module.exports = XMLDOMErrorHandler = (function() {
          function XMLDOMErrorHandler2() {
          }
          XMLDOMErrorHandler2.prototype.handleError = function(error) {
            throw new Error(error);
          };
          return XMLDOMErrorHandler2;
        })();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDOMStringList.js
  var require_XMLDOMStringList = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDOMStringList.js"(exports, module) {
      (function() {
        var XMLDOMStringList;
        module.exports = XMLDOMStringList = (function() {
          function XMLDOMStringList2(arr) {
            this.arr = arr || [];
          }
          Object.defineProperty(XMLDOMStringList2.prototype, "length", {
            get: function() {
              return this.arr.length;
            }
          });
          XMLDOMStringList2.prototype.item = function(index) {
            return this.arr[index] || null;
          };
          XMLDOMStringList2.prototype.contains = function(str) {
            return this.arr.indexOf(str) !== -1;
          };
          return XMLDOMStringList2;
        })();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
  var require_XMLDOMConfiguration = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDOMConfiguration.js"(exports, module) {
      (function() {
        var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
        XMLDOMErrorHandler = require_XMLDOMErrorHandler();
        XMLDOMStringList = require_XMLDOMStringList();
        module.exports = XMLDOMConfiguration = (function() {
          function XMLDOMConfiguration2() {
            var clonedSelf;
            this.defaultParams = {
              "canonical-form": false,
              "cdata-sections": false,
              "comments": false,
              "datatype-normalization": false,
              "element-content-whitespace": true,
              "entities": true,
              "error-handler": new XMLDOMErrorHandler(),
              "infoset": true,
              "validate-if-schema": false,
              "namespaces": true,
              "namespace-declarations": true,
              "normalize-characters": false,
              "schema-location": "",
              "schema-type": "",
              "split-cdata-sections": true,
              "validate": false,
              "well-formed": true
            };
            this.params = clonedSelf = Object.create(this.defaultParams);
          }
          Object.defineProperty(XMLDOMConfiguration2.prototype, "parameterNames", {
            get: function() {
              return new XMLDOMStringList(Object.keys(this.defaultParams));
            }
          });
          XMLDOMConfiguration2.prototype.getParameter = function(name) {
            if (this.params.hasOwnProperty(name)) {
              return this.params[name];
            } else {
              return null;
            }
          };
          XMLDOMConfiguration2.prototype.canSetParameter = function(name, value) {
            return true;
          };
          XMLDOMConfiguration2.prototype.setParameter = function(name, value) {
            if (value != null) {
              return this.params[name] = value;
            } else {
              return delete this.params[name];
            }
          };
          return XMLDOMConfiguration2;
        })();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/NodeType.js
  var require_NodeType = __commonJS({
    "node_modules/xmlbuilder/lib/NodeType.js"(exports, module) {
      (function() {
        module.exports = {
          Element: 1,
          Attribute: 2,
          Text: 3,
          CData: 4,
          EntityReference: 5,
          EntityDeclaration: 6,
          ProcessingInstruction: 7,
          Comment: 8,
          Document: 9,
          DocType: 10,
          DocumentFragment: 11,
          NotationDeclaration: 12,
          Declaration: 201,
          Raw: 202,
          AttributeDeclaration: 203,
          ElementDeclaration: 204,
          Dummy: 205
        };
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLAttribute.js
  var require_XMLAttribute = __commonJS({
    "node_modules/xmlbuilder/lib/XMLAttribute.js"(exports, module) {
      (function() {
        var NodeType2, XMLAttribute, XMLNode;
        NodeType2 = require_NodeType();
        XMLNode = require_XMLNode();
        module.exports = XMLAttribute = (function() {
          function XMLAttribute2(parent, name, value) {
            this.parent = parent;
            if (this.parent) {
              this.options = this.parent.options;
              this.stringify = this.parent.stringify;
            }
            if (name == null) {
              throw new Error("Missing attribute name. " + this.debugInfo(name));
            }
            this.name = this.stringify.name(name);
            this.value = this.stringify.attValue(value);
            this.type = NodeType2.Attribute;
            this.isId = false;
            this.schemaTypeInfo = null;
          }
          Object.defineProperty(XMLAttribute2.prototype, "nodeType", {
            get: function() {
              return this.type;
            }
          });
          Object.defineProperty(XMLAttribute2.prototype, "ownerElement", {
            get: function() {
              return this.parent;
            }
          });
          Object.defineProperty(XMLAttribute2.prototype, "textContent", {
            get: function() {
              return this.value;
            },
            set: function(value) {
              return this.value = value || "";
            }
          });
          Object.defineProperty(XMLAttribute2.prototype, "namespaceURI", {
            get: function() {
              return "";
            }
          });
          Object.defineProperty(XMLAttribute2.prototype, "prefix", {
            get: function() {
              return "";
            }
          });
          Object.defineProperty(XMLAttribute2.prototype, "localName", {
            get: function() {
              return this.name;
            }
          });
          Object.defineProperty(XMLAttribute2.prototype, "specified", {
            get: function() {
              return true;
            }
          });
          XMLAttribute2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLAttribute2.prototype.toString = function(options) {
            return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
          };
          XMLAttribute2.prototype.debugInfo = function(name) {
            name = name || this.name;
            if (name == null) {
              return "parent: <" + this.parent.name + ">";
            } else {
              return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
            }
          };
          XMLAttribute2.prototype.isEqualNode = function(node) {
            if (node.namespaceURI !== this.namespaceURI) {
              return false;
            }
            if (node.prefix !== this.prefix) {
              return false;
            }
            if (node.localName !== this.localName) {
              return false;
            }
            if (node.value !== this.value) {
              return false;
            }
            return true;
          };
          return XMLAttribute2;
        })();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
  var require_XMLNamedNodeMap = __commonJS({
    "node_modules/xmlbuilder/lib/XMLNamedNodeMap.js"(exports, module) {
      (function() {
        var XMLNamedNodeMap;
        module.exports = XMLNamedNodeMap = (function() {
          function XMLNamedNodeMap2(nodes) {
            this.nodes = nodes;
          }
          Object.defineProperty(XMLNamedNodeMap2.prototype, "length", {
            get: function() {
              return Object.keys(this.nodes).length || 0;
            }
          });
          XMLNamedNodeMap2.prototype.clone = function() {
            return this.nodes = null;
          };
          XMLNamedNodeMap2.prototype.getNamedItem = function(name) {
            return this.nodes[name];
          };
          XMLNamedNodeMap2.prototype.setNamedItem = function(node) {
            var oldNode;
            oldNode = this.nodes[node.nodeName];
            this.nodes[node.nodeName] = node;
            return oldNode || null;
          };
          XMLNamedNodeMap2.prototype.removeNamedItem = function(name) {
            var oldNode;
            oldNode = this.nodes[name];
            delete this.nodes[name];
            return oldNode || null;
          };
          XMLNamedNodeMap2.prototype.item = function(index) {
            return this.nodes[Object.keys(this.nodes)[index]] || null;
          };
          XMLNamedNodeMap2.prototype.getNamedItemNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
          };
          XMLNamedNodeMap2.prototype.setNamedItemNS = function(node) {
            throw new Error("This DOM method is not implemented.");
          };
          XMLNamedNodeMap2.prototype.removeNamedItemNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented.");
          };
          return XMLNamedNodeMap2;
        })();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLElement.js
  var require_XMLElement = __commonJS({
    "node_modules/xmlbuilder/lib/XMLElement.js"(exports, module) {
      (function() {
        var NodeType2, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
        XMLNode = require_XMLNode();
        NodeType2 = require_NodeType();
        XMLAttribute = require_XMLAttribute();
        XMLNamedNodeMap = require_XMLNamedNodeMap();
        module.exports = XMLElement = (function(superClass) {
          extend2(XMLElement2, superClass);
          function XMLElement2(parent, name, attributes) {
            var child, j, len, ref1;
            XMLElement2.__super__.constructor.call(this, parent);
            if (name == null) {
              throw new Error("Missing element name. " + this.debugInfo());
            }
            this.name = this.stringify.name(name);
            this.type = NodeType2.Element;
            this.attribs = {};
            this.schemaTypeInfo = null;
            if (attributes != null) {
              this.attribute(attributes);
            }
            if (parent.type === NodeType2.Document) {
              this.isRoot = true;
              this.documentObject = parent;
              parent.rootObject = this;
              if (parent.children) {
                ref1 = parent.children;
                for (j = 0, len = ref1.length; j < len; j++) {
                  child = ref1[j];
                  if (child.type === NodeType2.DocType) {
                    child.name = this.name;
                    break;
                  }
                }
              }
            }
          }
          Object.defineProperty(XMLElement2.prototype, "tagName", {
            get: function() {
              return this.name;
            }
          });
          Object.defineProperty(XMLElement2.prototype, "namespaceURI", {
            get: function() {
              return "";
            }
          });
          Object.defineProperty(XMLElement2.prototype, "prefix", {
            get: function() {
              return "";
            }
          });
          Object.defineProperty(XMLElement2.prototype, "localName", {
            get: function() {
              return this.name;
            }
          });
          Object.defineProperty(XMLElement2.prototype, "id", {
            get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });
          Object.defineProperty(XMLElement2.prototype, "className", {
            get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });
          Object.defineProperty(XMLElement2.prototype, "classList", {
            get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });
          Object.defineProperty(XMLElement2.prototype, "attributes", {
            get: function() {
              if (!this.attributeMap || !this.attributeMap.nodes) {
                this.attributeMap = new XMLNamedNodeMap(this.attribs);
              }
              return this.attributeMap;
            }
          });
          XMLElement2.prototype.clone = function() {
            var att, attName, clonedSelf, ref1;
            clonedSelf = Object.create(this);
            if (clonedSelf.isRoot) {
              clonedSelf.documentObject = null;
            }
            clonedSelf.attribs = {};
            ref1 = this.attribs;
            for (attName in ref1) {
              if (!hasProp.call(ref1, attName)) continue;
              att = ref1[attName];
              clonedSelf.attribs[attName] = att.clone();
            }
            clonedSelf.children = [];
            this.children.forEach(function(child) {
              var clonedChild;
              clonedChild = child.clone();
              clonedChild.parent = clonedSelf;
              return clonedSelf.children.push(clonedChild);
            });
            return clonedSelf;
          };
          XMLElement2.prototype.attribute = function(name, value) {
            var attName, attValue;
            if (name != null) {
              name = getValue(name);
            }
            if (isObject(name)) {
              for (attName in name) {
                if (!hasProp.call(name, attName)) continue;
                attValue = name[attName];
                this.attribute(attName, attValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              if (this.options.keepNullAttributes && value == null) {
                this.attribs[name] = new XMLAttribute(this, name, "");
              } else if (value != null) {
                this.attribs[name] = new XMLAttribute(this, name, value);
              }
            }
            return this;
          };
          XMLElement2.prototype.removeAttribute = function(name) {
            var attName, j, len;
            if (name == null) {
              throw new Error("Missing attribute name. " + this.debugInfo());
            }
            name = getValue(name);
            if (Array.isArray(name)) {
              for (j = 0, len = name.length; j < len; j++) {
                attName = name[j];
                delete this.attribs[attName];
              }
            } else {
              delete this.attribs[name];
            }
            return this;
          };
          XMLElement2.prototype.toString = function(options) {
            return this.options.writer.element(this, this.options.writer.filterOptions(options));
          };
          XMLElement2.prototype.att = function(name, value) {
            return this.attribute(name, value);
          };
          XMLElement2.prototype.a = function(name, value) {
            return this.attribute(name, value);
          };
          XMLElement2.prototype.getAttribute = function(name) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name].value;
            } else {
              return null;
            }
          };
          XMLElement2.prototype.setAttribute = function(name, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getAttributeNode = function(name) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name];
            } else {
              return null;
            }
          };
          XMLElement2.prototype.setAttributeNode = function(newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.removeAttributeNode = function(oldAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getElementsByTagName = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.removeAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.setAttributeNodeNS = function(newAttr) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.hasAttribute = function(name) {
            return this.attribs.hasOwnProperty(name);
          };
          XMLElement2.prototype.hasAttributeNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.setIdAttribute = function(name, isId) {
            if (this.attribs.hasOwnProperty(name)) {
              return this.attribs[name].isId;
            } else {
              return isId;
            }
          };
          XMLElement2.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.setIdAttributeNode = function(idAttr, isId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getElementsByTagName = function(tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.getElementsByClassName = function(classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLElement2.prototype.isEqualNode = function(node) {
            var i2, j, ref1;
            if (!XMLElement2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
              return false;
            }
            if (node.namespaceURI !== this.namespaceURI) {
              return false;
            }
            if (node.prefix !== this.prefix) {
              return false;
            }
            if (node.localName !== this.localName) {
              return false;
            }
            if (node.attribs.length !== this.attribs.length) {
              return false;
            }
            for (i2 = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i2 = 0 <= ref1 ? ++j : --j) {
              if (!this.attribs[i2].isEqualNode(node.attribs[i2])) {
                return false;
              }
            }
            return true;
          };
          return XMLElement2;
        })(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLCharacterData.js
  var require_XMLCharacterData = __commonJS({
    "node_modules/xmlbuilder/lib/XMLCharacterData.js"(exports, module) {
      (function() {
        var XMLCharacterData, XMLNode, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode = require_XMLNode();
        module.exports = XMLCharacterData = (function(superClass) {
          extend2(XMLCharacterData2, superClass);
          function XMLCharacterData2(parent) {
            XMLCharacterData2.__super__.constructor.call(this, parent);
            this.value = "";
          }
          Object.defineProperty(XMLCharacterData2.prototype, "data", {
            get: function() {
              return this.value;
            },
            set: function(value) {
              return this.value = value || "";
            }
          });
          Object.defineProperty(XMLCharacterData2.prototype, "length", {
            get: function() {
              return this.value.length;
            }
          });
          Object.defineProperty(XMLCharacterData2.prototype, "textContent", {
            get: function() {
              return this.value;
            },
            set: function(value) {
              return this.value = value || "";
            }
          });
          XMLCharacterData2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLCharacterData2.prototype.substringData = function(offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLCharacterData2.prototype.appendData = function(arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLCharacterData2.prototype.insertData = function(offset, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLCharacterData2.prototype.deleteData = function(offset, count) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLCharacterData2.prototype.replaceData = function(offset, count, arg) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLCharacterData2.prototype.isEqualNode = function(node) {
            if (!XMLCharacterData2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
              return false;
            }
            if (node.data !== this.data) {
              return false;
            }
            return true;
          };
          return XMLCharacterData2;
        })(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLCData.js
  var require_XMLCData = __commonJS({
    "node_modules/xmlbuilder/lib/XMLCData.js"(exports, module) {
      (function() {
        var NodeType2, XMLCData, XMLCharacterData, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType2 = require_NodeType();
        XMLCharacterData = require_XMLCharacterData();
        module.exports = XMLCData = (function(superClass) {
          extend2(XMLCData2, superClass);
          function XMLCData2(parent, text) {
            XMLCData2.__super__.constructor.call(this, parent);
            if (text == null) {
              throw new Error("Missing CDATA text. " + this.debugInfo());
            }
            this.name = "#cdata-section";
            this.type = NodeType2.CData;
            this.value = this.stringify.cdata(text);
          }
          XMLCData2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLCData2.prototype.toString = function(options) {
            return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
          };
          return XMLCData2;
        })(XMLCharacterData);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLComment.js
  var require_XMLComment = __commonJS({
    "node_modules/xmlbuilder/lib/XMLComment.js"(exports, module) {
      (function() {
        var NodeType2, XMLCharacterData, XMLComment, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType2 = require_NodeType();
        XMLCharacterData = require_XMLCharacterData();
        module.exports = XMLComment = (function(superClass) {
          extend2(XMLComment2, superClass);
          function XMLComment2(parent, text) {
            XMLComment2.__super__.constructor.call(this, parent);
            if (text == null) {
              throw new Error("Missing comment text. " + this.debugInfo());
            }
            this.name = "#comment";
            this.type = NodeType2.Comment;
            this.value = this.stringify.comment(text);
          }
          XMLComment2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLComment2.prototype.toString = function(options) {
            return this.options.writer.comment(this, this.options.writer.filterOptions(options));
          };
          return XMLComment2;
        })(XMLCharacterData);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDeclaration.js
  var require_XMLDeclaration = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDeclaration.js"(exports, module) {
      (function() {
        var NodeType2, XMLDeclaration, XMLNode, isObject, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        isObject = require_Utility().isObject;
        XMLNode = require_XMLNode();
        NodeType2 = require_NodeType();
        module.exports = XMLDeclaration = (function(superClass) {
          extend2(XMLDeclaration2, superClass);
          function XMLDeclaration2(parent, version, encoding, standalone) {
            var ref;
            XMLDeclaration2.__super__.constructor.call(this, parent);
            if (isObject(version)) {
              ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
            }
            if (!version) {
              version = "1.0";
            }
            this.type = NodeType2.Declaration;
            this.version = this.stringify.xmlVersion(version);
            if (encoding != null) {
              this.encoding = this.stringify.xmlEncoding(encoding);
            }
            if (standalone != null) {
              this.standalone = this.stringify.xmlStandalone(standalone);
            }
          }
          XMLDeclaration2.prototype.toString = function(options) {
            return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
          };
          return XMLDeclaration2;
        })(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDTDAttList.js
  var require_XMLDTDAttList = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDTDAttList.js"(exports, module) {
      (function() {
        var NodeType2, XMLDTDAttList, XMLNode, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode = require_XMLNode();
        NodeType2 = require_NodeType();
        module.exports = XMLDTDAttList = (function(superClass) {
          extend2(XMLDTDAttList2, superClass);
          function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            XMLDTDAttList2.__super__.constructor.call(this, parent);
            if (elementName == null) {
              throw new Error("Missing DTD element name. " + this.debugInfo());
            }
            if (attributeName == null) {
              throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
            }
            if (!attributeType) {
              throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
            }
            if (!defaultValueType) {
              throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
            }
            if (defaultValueType.indexOf("#") !== 0) {
              defaultValueType = "#" + defaultValueType;
            }
            if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
              throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
            }
            if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
              throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
            }
            this.elementName = this.stringify.name(elementName);
            this.type = NodeType2.AttributeDeclaration;
            this.attributeName = this.stringify.name(attributeName);
            this.attributeType = this.stringify.dtdAttType(attributeType);
            if (defaultValue) {
              this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
            }
            this.defaultValueType = defaultValueType;
          }
          XMLDTDAttList2.prototype.toString = function(options) {
            return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
          };
          return XMLDTDAttList2;
        })(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDTDEntity.js
  var require_XMLDTDEntity = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDTDEntity.js"(exports, module) {
      (function() {
        var NodeType2, XMLDTDEntity, XMLNode, isObject, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        isObject = require_Utility().isObject;
        XMLNode = require_XMLNode();
        NodeType2 = require_NodeType();
        module.exports = XMLDTDEntity = (function(superClass) {
          extend2(XMLDTDEntity2, superClass);
          function XMLDTDEntity2(parent, pe, name, value) {
            XMLDTDEntity2.__super__.constructor.call(this, parent);
            if (name == null) {
              throw new Error("Missing DTD entity name. " + this.debugInfo(name));
            }
            if (value == null) {
              throw new Error("Missing DTD entity value. " + this.debugInfo(name));
            }
            this.pe = !!pe;
            this.name = this.stringify.name(name);
            this.type = NodeType2.EntityDeclaration;
            if (!isObject(value)) {
              this.value = this.stringify.dtdEntityValue(value);
              this.internal = true;
            } else {
              if (!value.pubID && !value.sysID) {
                throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
              }
              if (value.pubID && !value.sysID) {
                throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
              }
              this.internal = false;
              if (value.pubID != null) {
                this.pubID = this.stringify.dtdPubID(value.pubID);
              }
              if (value.sysID != null) {
                this.sysID = this.stringify.dtdSysID(value.sysID);
              }
              if (value.nData != null) {
                this.nData = this.stringify.dtdNData(value.nData);
              }
              if (this.pe && this.nData) {
                throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
              }
            }
          }
          Object.defineProperty(XMLDTDEntity2.prototype, "publicId", {
            get: function() {
              return this.pubID;
            }
          });
          Object.defineProperty(XMLDTDEntity2.prototype, "systemId", {
            get: function() {
              return this.sysID;
            }
          });
          Object.defineProperty(XMLDTDEntity2.prototype, "notationName", {
            get: function() {
              return this.nData || null;
            }
          });
          Object.defineProperty(XMLDTDEntity2.prototype, "inputEncoding", {
            get: function() {
              return null;
            }
          });
          Object.defineProperty(XMLDTDEntity2.prototype, "xmlEncoding", {
            get: function() {
              return null;
            }
          });
          Object.defineProperty(XMLDTDEntity2.prototype, "xmlVersion", {
            get: function() {
              return null;
            }
          });
          XMLDTDEntity2.prototype.toString = function(options) {
            return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
          };
          return XMLDTDEntity2;
        })(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDTDElement.js
  var require_XMLDTDElement = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDTDElement.js"(exports, module) {
      (function() {
        var NodeType2, XMLDTDElement, XMLNode, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode = require_XMLNode();
        NodeType2 = require_NodeType();
        module.exports = XMLDTDElement = (function(superClass) {
          extend2(XMLDTDElement2, superClass);
          function XMLDTDElement2(parent, name, value) {
            XMLDTDElement2.__super__.constructor.call(this, parent);
            if (name == null) {
              throw new Error("Missing DTD element name. " + this.debugInfo());
            }
            if (!value) {
              value = "(#PCDATA)";
            }
            if (Array.isArray(value)) {
              value = "(" + value.join(",") + ")";
            }
            this.name = this.stringify.name(name);
            this.type = NodeType2.ElementDeclaration;
            this.value = this.stringify.dtdElementValue(value);
          }
          XMLDTDElement2.prototype.toString = function(options) {
            return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
          };
          return XMLDTDElement2;
        })(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDTDNotation.js
  var require_XMLDTDNotation = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDTDNotation.js"(exports, module) {
      (function() {
        var NodeType2, XMLDTDNotation, XMLNode, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode = require_XMLNode();
        NodeType2 = require_NodeType();
        module.exports = XMLDTDNotation = (function(superClass) {
          extend2(XMLDTDNotation2, superClass);
          function XMLDTDNotation2(parent, name, value) {
            XMLDTDNotation2.__super__.constructor.call(this, parent);
            if (name == null) {
              throw new Error("Missing DTD notation name. " + this.debugInfo(name));
            }
            if (!value.pubID && !value.sysID) {
              throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
            }
            this.name = this.stringify.name(name);
            this.type = NodeType2.NotationDeclaration;
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
          }
          Object.defineProperty(XMLDTDNotation2.prototype, "publicId", {
            get: function() {
              return this.pubID;
            }
          });
          Object.defineProperty(XMLDTDNotation2.prototype, "systemId", {
            get: function() {
              return this.sysID;
            }
          });
          XMLDTDNotation2.prototype.toString = function(options) {
            return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
          };
          return XMLDTDNotation2;
        })(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDocType.js
  var require_XMLDocType = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDocType.js"(exports, module) {
      (function() {
        var NodeType2, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        isObject = require_Utility().isObject;
        XMLNode = require_XMLNode();
        NodeType2 = require_NodeType();
        XMLDTDAttList = require_XMLDTDAttList();
        XMLDTDEntity = require_XMLDTDEntity();
        XMLDTDElement = require_XMLDTDElement();
        XMLDTDNotation = require_XMLDTDNotation();
        XMLNamedNodeMap = require_XMLNamedNodeMap();
        module.exports = XMLDocType = (function(superClass) {
          extend2(XMLDocType2, superClass);
          function XMLDocType2(parent, pubID, sysID) {
            var child, i2, len, ref, ref1, ref2;
            XMLDocType2.__super__.constructor.call(this, parent);
            this.type = NodeType2.DocType;
            if (parent.children) {
              ref = parent.children;
              for (i2 = 0, len = ref.length; i2 < len; i2++) {
                child = ref[i2];
                if (child.type === NodeType2.Element) {
                  this.name = child.name;
                  break;
                }
              }
            }
            this.documentObject = parent;
            if (isObject(pubID)) {
              ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
            }
            if (sysID == null) {
              ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
            }
            if (pubID != null) {
              this.pubID = this.stringify.dtdPubID(pubID);
            }
            if (sysID != null) {
              this.sysID = this.stringify.dtdSysID(sysID);
            }
          }
          Object.defineProperty(XMLDocType2.prototype, "entities", {
            get: function() {
              var child, i2, len, nodes, ref;
              nodes = {};
              ref = this.children;
              for (i2 = 0, len = ref.length; i2 < len; i2++) {
                child = ref[i2];
                if (child.type === NodeType2.EntityDeclaration && !child.pe) {
                  nodes[child.name] = child;
                }
              }
              return new XMLNamedNodeMap(nodes);
            }
          });
          Object.defineProperty(XMLDocType2.prototype, "notations", {
            get: function() {
              var child, i2, len, nodes, ref;
              nodes = {};
              ref = this.children;
              for (i2 = 0, len = ref.length; i2 < len; i2++) {
                child = ref[i2];
                if (child.type === NodeType2.NotationDeclaration) {
                  nodes[child.name] = child;
                }
              }
              return new XMLNamedNodeMap(nodes);
            }
          });
          Object.defineProperty(XMLDocType2.prototype, "publicId", {
            get: function() {
              return this.pubID;
            }
          });
          Object.defineProperty(XMLDocType2.prototype, "systemId", {
            get: function() {
              return this.sysID;
            }
          });
          Object.defineProperty(XMLDocType2.prototype, "internalSubset", {
            get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });
          XMLDocType2.prototype.element = function(name, value) {
            var child;
            child = new XMLDTDElement(this, name, value);
            this.children.push(child);
            return this;
          };
          XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            var child;
            child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
            this.children.push(child);
            return this;
          };
          XMLDocType2.prototype.entity = function(name, value) {
            var child;
            child = new XMLDTDEntity(this, false, name, value);
            this.children.push(child);
            return this;
          };
          XMLDocType2.prototype.pEntity = function(name, value) {
            var child;
            child = new XMLDTDEntity(this, true, name, value);
            this.children.push(child);
            return this;
          };
          XMLDocType2.prototype.notation = function(name, value) {
            var child;
            child = new XMLDTDNotation(this, name, value);
            this.children.push(child);
            return this;
          };
          XMLDocType2.prototype.toString = function(options) {
            return this.options.writer.docType(this, this.options.writer.filterOptions(options));
          };
          XMLDocType2.prototype.ele = function(name, value) {
            return this.element(name, value);
          };
          XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
          };
          XMLDocType2.prototype.ent = function(name, value) {
            return this.entity(name, value);
          };
          XMLDocType2.prototype.pent = function(name, value) {
            return this.pEntity(name, value);
          };
          XMLDocType2.prototype.not = function(name, value) {
            return this.notation(name, value);
          };
          XMLDocType2.prototype.up = function() {
            return this.root() || this.documentObject;
          };
          XMLDocType2.prototype.isEqualNode = function(node) {
            if (!XMLDocType2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
              return false;
            }
            if (node.name !== this.name) {
              return false;
            }
            if (node.publicId !== this.publicId) {
              return false;
            }
            if (node.systemId !== this.systemId) {
              return false;
            }
            return true;
          };
          return XMLDocType2;
        })(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLRaw.js
  var require_XMLRaw = __commonJS({
    "node_modules/xmlbuilder/lib/XMLRaw.js"(exports, module) {
      (function() {
        var NodeType2, XMLNode, XMLRaw, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType2 = require_NodeType();
        XMLNode = require_XMLNode();
        module.exports = XMLRaw = (function(superClass) {
          extend2(XMLRaw2, superClass);
          function XMLRaw2(parent, text) {
            XMLRaw2.__super__.constructor.call(this, parent);
            if (text == null) {
              throw new Error("Missing raw text. " + this.debugInfo());
            }
            this.type = NodeType2.Raw;
            this.value = this.stringify.raw(text);
          }
          XMLRaw2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLRaw2.prototype.toString = function(options) {
            return this.options.writer.raw(this, this.options.writer.filterOptions(options));
          };
          return XMLRaw2;
        })(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLText.js
  var require_XMLText = __commonJS({
    "node_modules/xmlbuilder/lib/XMLText.js"(exports, module) {
      (function() {
        var NodeType2, XMLCharacterData, XMLText, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType2 = require_NodeType();
        XMLCharacterData = require_XMLCharacterData();
        module.exports = XMLText = (function(superClass) {
          extend2(XMLText2, superClass);
          function XMLText2(parent, text) {
            XMLText2.__super__.constructor.call(this, parent);
            if (text == null) {
              throw new Error("Missing element text. " + this.debugInfo());
            }
            this.name = "#text";
            this.type = NodeType2.Text;
            this.value = this.stringify.text(text);
          }
          Object.defineProperty(XMLText2.prototype, "isElementContentWhitespace", {
            get: function() {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });
          Object.defineProperty(XMLText2.prototype, "wholeText", {
            get: function() {
              var next, prev, str;
              str = "";
              prev = this.previousSibling;
              while (prev) {
                str = prev.data + str;
                prev = prev.previousSibling;
              }
              str += this.data;
              next = this.nextSibling;
              while (next) {
                str = str + next.data;
                next = next.nextSibling;
              }
              return str;
            }
          });
          XMLText2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLText2.prototype.toString = function(options) {
            return this.options.writer.text(this, this.options.writer.filterOptions(options));
          };
          XMLText2.prototype.splitText = function(offset) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLText2.prototype.replaceWholeText = function(content) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          return XMLText2;
        })(XMLCharacterData);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
  var require_XMLProcessingInstruction = __commonJS({
    "node_modules/xmlbuilder/lib/XMLProcessingInstruction.js"(exports, module) {
      (function() {
        var NodeType2, XMLCharacterData, XMLProcessingInstruction, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType2 = require_NodeType();
        XMLCharacterData = require_XMLCharacterData();
        module.exports = XMLProcessingInstruction = (function(superClass) {
          extend2(XMLProcessingInstruction2, superClass);
          function XMLProcessingInstruction2(parent, target, value) {
            XMLProcessingInstruction2.__super__.constructor.call(this, parent);
            if (target == null) {
              throw new Error("Missing instruction target. " + this.debugInfo());
            }
            this.type = NodeType2.ProcessingInstruction;
            this.target = this.stringify.insTarget(target);
            this.name = this.target;
            if (value) {
              this.value = this.stringify.insValue(value);
            }
          }
          XMLProcessingInstruction2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLProcessingInstruction2.prototype.toString = function(options) {
            return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
          };
          XMLProcessingInstruction2.prototype.isEqualNode = function(node) {
            if (!XMLProcessingInstruction2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
              return false;
            }
            if (node.target !== this.target) {
              return false;
            }
            return true;
          };
          return XMLProcessingInstruction2;
        })(XMLCharacterData);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDummy.js
  var require_XMLDummy = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDummy.js"(exports, module) {
      (function() {
        var NodeType2, XMLDummy, XMLNode, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        XMLNode = require_XMLNode();
        NodeType2 = require_NodeType();
        module.exports = XMLDummy = (function(superClass) {
          extend2(XMLDummy2, superClass);
          function XMLDummy2(parent) {
            XMLDummy2.__super__.constructor.call(this, parent);
            this.type = NodeType2.Dummy;
          }
          XMLDummy2.prototype.clone = function() {
            return Object.create(this);
          };
          XMLDummy2.prototype.toString = function(options) {
            return "";
          };
          return XMLDummy2;
        })(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLNodeList.js
  var require_XMLNodeList = __commonJS({
    "node_modules/xmlbuilder/lib/XMLNodeList.js"(exports, module) {
      (function() {
        var XMLNodeList;
        module.exports = XMLNodeList = (function() {
          function XMLNodeList2(nodes) {
            this.nodes = nodes;
          }
          Object.defineProperty(XMLNodeList2.prototype, "length", {
            get: function() {
              return this.nodes.length || 0;
            }
          });
          XMLNodeList2.prototype.clone = function() {
            return this.nodes = null;
          };
          XMLNodeList2.prototype.item = function(index) {
            return this.nodes[index] || null;
          };
          return XMLNodeList2;
        })();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/DocumentPosition.js
  var require_DocumentPosition = __commonJS({
    "node_modules/xmlbuilder/lib/DocumentPosition.js"(exports, module) {
      (function() {
        module.exports = {
          Disconnected: 1,
          Preceding: 2,
          Following: 4,
          Contains: 8,
          ContainedBy: 16,
          ImplementationSpecific: 32
        };
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLNode.js
  var require_XMLNode = __commonJS({
    "node_modules/xmlbuilder/lib/XMLNode.js"(exports, module) {
      (function() {
        var DocumentPosition, NodeType2, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
        ref1 = require_Utility(), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
        XMLElement = null;
        XMLCData = null;
        XMLComment = null;
        XMLDeclaration = null;
        XMLDocType = null;
        XMLRaw = null;
        XMLText = null;
        XMLProcessingInstruction = null;
        XMLDummy = null;
        NodeType2 = null;
        XMLNodeList = null;
        XMLNamedNodeMap = null;
        DocumentPosition = null;
        module.exports = XMLNode = (function() {
          function XMLNode2(parent1) {
            this.parent = parent1;
            if (this.parent) {
              this.options = this.parent.options;
              this.stringify = this.parent.stringify;
            }
            this.value = null;
            this.children = [];
            this.baseURI = null;
            if (!XMLElement) {
              XMLElement = require_XMLElement();
              XMLCData = require_XMLCData();
              XMLComment = require_XMLComment();
              XMLDeclaration = require_XMLDeclaration();
              XMLDocType = require_XMLDocType();
              XMLRaw = require_XMLRaw();
              XMLText = require_XMLText();
              XMLProcessingInstruction = require_XMLProcessingInstruction();
              XMLDummy = require_XMLDummy();
              NodeType2 = require_NodeType();
              XMLNodeList = require_XMLNodeList();
              XMLNamedNodeMap = require_XMLNamedNodeMap();
              DocumentPosition = require_DocumentPosition();
            }
          }
          Object.defineProperty(XMLNode2.prototype, "nodeName", {
            get: function() {
              return this.name;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "nodeType", {
            get: function() {
              return this.type;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "nodeValue", {
            get: function() {
              return this.value;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "parentNode", {
            get: function() {
              return this.parent;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "childNodes", {
            get: function() {
              if (!this.childNodeList || !this.childNodeList.nodes) {
                this.childNodeList = new XMLNodeList(this.children);
              }
              return this.childNodeList;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "firstChild", {
            get: function() {
              return this.children[0] || null;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "lastChild", {
            get: function() {
              return this.children[this.children.length - 1] || null;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "previousSibling", {
            get: function() {
              var i2;
              i2 = this.parent.children.indexOf(this);
              return this.parent.children[i2 - 1] || null;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "nextSibling", {
            get: function() {
              var i2;
              i2 = this.parent.children.indexOf(this);
              return this.parent.children[i2 + 1] || null;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "ownerDocument", {
            get: function() {
              return this.document() || null;
            }
          });
          Object.defineProperty(XMLNode2.prototype, "textContent", {
            get: function() {
              var child, j, len, ref2, str;
              if (this.nodeType === NodeType2.Element || this.nodeType === NodeType2.DocumentFragment) {
                str = "";
                ref2 = this.children;
                for (j = 0, len = ref2.length; j < len; j++) {
                  child = ref2[j];
                  if (child.textContent) {
                    str += child.textContent;
                  }
                }
                return str;
              } else {
                return null;
              }
            },
            set: function(value) {
              throw new Error("This DOM method is not implemented." + this.debugInfo());
            }
          });
          XMLNode2.prototype.setParent = function(parent) {
            var child, j, len, ref2, results;
            this.parent = parent;
            if (parent) {
              this.options = parent.options;
              this.stringify = parent.stringify;
            }
            ref2 = this.children;
            results = [];
            for (j = 0, len = ref2.length; j < len; j++) {
              child = ref2[j];
              results.push(child.setParent(this));
            }
            return results;
          };
          XMLNode2.prototype.element = function(name, attributes, text) {
            var childNode, item, j, k2, key, lastChild, len, len1, ref2, ref3, val;
            lastChild = null;
            if (attributes === null && text == null) {
              ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
            }
            if (attributes == null) {
              attributes = {};
            }
            attributes = getValue(attributes);
            if (!isObject(attributes)) {
              ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
            }
            if (name != null) {
              name = getValue(name);
            }
            if (Array.isArray(name)) {
              for (j = 0, len = name.length; j < len; j++) {
                item = name[j];
                lastChild = this.element(item);
              }
            } else if (isFunction(name)) {
              lastChild = this.element(name.apply());
            } else if (isObject(name)) {
              for (key in name) {
                if (!hasProp.call(name, key)) continue;
                val = name[key];
                if (isFunction(val)) {
                  val = val.apply();
                }
                if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                  lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
                } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
                  lastChild = this.dummy();
                } else if (isObject(val) && isEmpty(val)) {
                  lastChild = this.element(key);
                } else if (!this.options.keepNullNodes && val == null) {
                  lastChild = this.dummy();
                } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                  for (k2 = 0, len1 = val.length; k2 < len1; k2++) {
                    item = val[k2];
                    childNode = {};
                    childNode[key] = item;
                    lastChild = this.element(childNode);
                  }
                } else if (isObject(val)) {
                  if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                    lastChild = this.element(val);
                  } else {
                    lastChild = this.element(key);
                    lastChild.element(val);
                  }
                } else {
                  lastChild = this.element(key, val);
                }
              }
            } else if (!this.options.keepNullNodes && text === null) {
              lastChild = this.dummy();
            } else {
              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
                lastChild = this.text(text);
              } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
                lastChild = this.cdata(text);
              } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
                lastChild = this.comment(text);
              } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
                lastChild = this.raw(text);
              } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
                lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
              } else {
                lastChild = this.node(name, attributes, text);
              }
            }
            if (lastChild == null) {
              throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
            }
            return lastChild;
          };
          XMLNode2.prototype.insertBefore = function(name, attributes, text) {
            var child, i2, newChild, refChild, removed;
            if (name != null ? name.type : void 0) {
              newChild = name;
              refChild = attributes;
              newChild.setParent(this);
              if (refChild) {
                i2 = children.indexOf(refChild);
                removed = children.splice(i2);
                children.push(newChild);
                Array.prototype.push.apply(children, removed);
              } else {
                children.push(newChild);
              }
              return newChild;
            } else {
              if (this.isRoot) {
                throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
              }
              i2 = this.parent.children.indexOf(this);
              removed = this.parent.children.splice(i2);
              child = this.parent.element(name, attributes, text);
              Array.prototype.push.apply(this.parent.children, removed);
              return child;
            }
          };
          XMLNode2.prototype.insertAfter = function(name, attributes, text) {
            var child, i2, removed;
            if (this.isRoot) {
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
            }
            i2 = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i2 + 1);
            child = this.parent.element(name, attributes, text);
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
          };
          XMLNode2.prototype.remove = function() {
            var i2, ref2;
            if (this.isRoot) {
              throw new Error("Cannot remove the root element. " + this.debugInfo());
            }
            i2 = this.parent.children.indexOf(this);
            [].splice.apply(this.parent.children, [i2, i2 - i2 + 1].concat(ref2 = [])), ref2;
            return this.parent;
          };
          XMLNode2.prototype.node = function(name, attributes, text) {
            var child, ref2;
            if (name != null) {
              name = getValue(name);
            }
            attributes || (attributes = {});
            attributes = getValue(attributes);
            if (!isObject(attributes)) {
              ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
            }
            child = new XMLElement(this, name, attributes);
            if (text != null) {
              child.text(text);
            }
            this.children.push(child);
            return child;
          };
          XMLNode2.prototype.text = function(value) {
            var child;
            if (isObject(value)) {
              this.element(value);
            }
            child = new XMLText(this, value);
            this.children.push(child);
            return this;
          };
          XMLNode2.prototype.cdata = function(value) {
            var child;
            child = new XMLCData(this, value);
            this.children.push(child);
            return this;
          };
          XMLNode2.prototype.comment = function(value) {
            var child;
            child = new XMLComment(this, value);
            this.children.push(child);
            return this;
          };
          XMLNode2.prototype.commentBefore = function(value) {
            var child, i2, removed;
            i2 = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i2);
            child = this.parent.comment(value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          };
          XMLNode2.prototype.commentAfter = function(value) {
            var child, i2, removed;
            i2 = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i2 + 1);
            child = this.parent.comment(value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          };
          XMLNode2.prototype.raw = function(value) {
            var child;
            child = new XMLRaw(this, value);
            this.children.push(child);
            return this;
          };
          XMLNode2.prototype.dummy = function() {
            var child;
            child = new XMLDummy(this);
            return child;
          };
          XMLNode2.prototype.instruction = function(target, value) {
            var insTarget, insValue, instruction, j, len;
            if (target != null) {
              target = getValue(target);
            }
            if (value != null) {
              value = getValue(value);
            }
            if (Array.isArray(target)) {
              for (j = 0, len = target.length; j < len; j++) {
                insTarget = target[j];
                this.instruction(insTarget);
              }
            } else if (isObject(target)) {
              for (insTarget in target) {
                if (!hasProp.call(target, insTarget)) continue;
                insValue = target[insTarget];
                this.instruction(insTarget, insValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              instruction = new XMLProcessingInstruction(this, target, value);
              this.children.push(instruction);
            }
            return this;
          };
          XMLNode2.prototype.instructionBefore = function(target, value) {
            var child, i2, removed;
            i2 = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i2);
            child = this.parent.instruction(target, value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          };
          XMLNode2.prototype.instructionAfter = function(target, value) {
            var child, i2, removed;
            i2 = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i2 + 1);
            child = this.parent.instruction(target, value);
            Array.prototype.push.apply(this.parent.children, removed);
            return this;
          };
          XMLNode2.prototype.declaration = function(version, encoding, standalone) {
            var doc2, xmldec;
            doc2 = this.document();
            xmldec = new XMLDeclaration(doc2, version, encoding, standalone);
            if (doc2.children.length === 0) {
              doc2.children.unshift(xmldec);
            } else if (doc2.children[0].type === NodeType2.Declaration) {
              doc2.children[0] = xmldec;
            } else {
              doc2.children.unshift(xmldec);
            }
            return doc2.root() || doc2;
          };
          XMLNode2.prototype.dtd = function(pubID, sysID) {
            var child, doc2, doctype, i2, j, k2, len, len1, ref2, ref3;
            doc2 = this.document();
            doctype = new XMLDocType(doc2, pubID, sysID);
            ref2 = doc2.children;
            for (i2 = j = 0, len = ref2.length; j < len; i2 = ++j) {
              child = ref2[i2];
              if (child.type === NodeType2.DocType) {
                doc2.children[i2] = doctype;
                return doctype;
              }
            }
            ref3 = doc2.children;
            for (i2 = k2 = 0, len1 = ref3.length; k2 < len1; i2 = ++k2) {
              child = ref3[i2];
              if (child.isRoot) {
                doc2.children.splice(i2, 0, doctype);
                return doctype;
              }
            }
            doc2.children.push(doctype);
            return doctype;
          };
          XMLNode2.prototype.up = function() {
            if (this.isRoot) {
              throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
            }
            return this.parent;
          };
          XMLNode2.prototype.root = function() {
            var node;
            node = this;
            while (node) {
              if (node.type === NodeType2.Document) {
                return node.rootObject;
              } else if (node.isRoot) {
                return node;
              } else {
                node = node.parent;
              }
            }
          };
          XMLNode2.prototype.document = function() {
            var node;
            node = this;
            while (node) {
              if (node.type === NodeType2.Document) {
                return node;
              } else {
                node = node.parent;
              }
            }
          };
          XMLNode2.prototype.end = function(options) {
            return this.document().end(options);
          };
          XMLNode2.prototype.prev = function() {
            var i2;
            i2 = this.parent.children.indexOf(this);
            if (i2 < 1) {
              throw new Error("Already at the first node. " + this.debugInfo());
            }
            return this.parent.children[i2 - 1];
          };
          XMLNode2.prototype.next = function() {
            var i2;
            i2 = this.parent.children.indexOf(this);
            if (i2 === -1 || i2 === this.parent.children.length - 1) {
              throw new Error("Already at the last node. " + this.debugInfo());
            }
            return this.parent.children[i2 + 1];
          };
          XMLNode2.prototype.importDocument = function(doc2) {
            var clonedRoot;
            clonedRoot = doc2.root().clone();
            clonedRoot.parent = this;
            clonedRoot.isRoot = false;
            this.children.push(clonedRoot);
            return this;
          };
          XMLNode2.prototype.debugInfo = function(name) {
            var ref2, ref3;
            name = name || this.name;
            if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
              return "";
            } else if (name == null) {
              return "parent: <" + this.parent.name + ">";
            } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
              return "node: <" + name + ">";
            } else {
              return "node: <" + name + ">, parent: <" + this.parent.name + ">";
            }
          };
          XMLNode2.prototype.ele = function(name, attributes, text) {
            return this.element(name, attributes, text);
          };
          XMLNode2.prototype.nod = function(name, attributes, text) {
            return this.node(name, attributes, text);
          };
          XMLNode2.prototype.txt = function(value) {
            return this.text(value);
          };
          XMLNode2.prototype.dat = function(value) {
            return this.cdata(value);
          };
          XMLNode2.prototype.com = function(value) {
            return this.comment(value);
          };
          XMLNode2.prototype.ins = function(target, value) {
            return this.instruction(target, value);
          };
          XMLNode2.prototype.doc = function() {
            return this.document();
          };
          XMLNode2.prototype.dec = function(version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
          };
          XMLNode2.prototype.e = function(name, attributes, text) {
            return this.element(name, attributes, text);
          };
          XMLNode2.prototype.n = function(name, attributes, text) {
            return this.node(name, attributes, text);
          };
          XMLNode2.prototype.t = function(value) {
            return this.text(value);
          };
          XMLNode2.prototype.d = function(value) {
            return this.cdata(value);
          };
          XMLNode2.prototype.c = function(value) {
            return this.comment(value);
          };
          XMLNode2.prototype.r = function(value) {
            return this.raw(value);
          };
          XMLNode2.prototype.i = function(target, value) {
            return this.instruction(target, value);
          };
          XMLNode2.prototype.u = function() {
            return this.up();
          };
          XMLNode2.prototype.importXMLBuilder = function(doc2) {
            return this.importDocument(doc2);
          };
          XMLNode2.prototype.replaceChild = function(newChild, oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.removeChild = function(oldChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.appendChild = function(newChild) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.hasChildNodes = function() {
            return this.children.length !== 0;
          };
          XMLNode2.prototype.cloneNode = function(deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.normalize = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.isSupported = function(feature, version) {
            return true;
          };
          XMLNode2.prototype.hasAttributes = function() {
            return this.attribs.length !== 0;
          };
          XMLNode2.prototype.compareDocumentPosition = function(other) {
            var ref, res;
            ref = this;
            if (ref === other) {
              return 0;
            } else if (this.document() !== other.document()) {
              res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
              if (Math.random() < 0.5) {
                res |= DocumentPosition.Preceding;
              } else {
                res |= DocumentPosition.Following;
              }
              return res;
            } else if (ref.isAncestor(other)) {
              return DocumentPosition.Contains | DocumentPosition.Preceding;
            } else if (ref.isDescendant(other)) {
              return DocumentPosition.Contains | DocumentPosition.Following;
            } else if (ref.isPreceding(other)) {
              return DocumentPosition.Preceding;
            } else {
              return DocumentPosition.Following;
            }
          };
          XMLNode2.prototype.isSameNode = function(other) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.lookupPrefix = function(namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.isDefaultNamespace = function(namespaceURI) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.lookupNamespaceURI = function(prefix) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.isEqualNode = function(node) {
            var i2, j, ref2;
            if (node.nodeType !== this.nodeType) {
              return false;
            }
            if (node.children.length !== this.children.length) {
              return false;
            }
            for (i2 = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i2 = 0 <= ref2 ? ++j : --j) {
              if (!this.children[i2].isEqualNode(node.children[i2])) {
                return false;
              }
            }
            return true;
          };
          XMLNode2.prototype.getFeature = function(feature, version) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.setUserData = function(key, data, handler) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.getUserData = function(key) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLNode2.prototype.contains = function(other) {
            if (!other) {
              return false;
            }
            return other === this || this.isDescendant(other);
          };
          XMLNode2.prototype.isDescendant = function(node) {
            var child, isDescendantChild, j, len, ref2;
            ref2 = this.children;
            for (j = 0, len = ref2.length; j < len; j++) {
              child = ref2[j];
              if (node === child) {
                return true;
              }
              isDescendantChild = child.isDescendant(node);
              if (isDescendantChild) {
                return true;
              }
            }
            return false;
          };
          XMLNode2.prototype.isAncestor = function(node) {
            return node.isDescendant(this);
          };
          XMLNode2.prototype.isPreceding = function(node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) {
              return false;
            } else {
              return nodePos < thisPos;
            }
          };
          XMLNode2.prototype.isFollowing = function(node) {
            var nodePos, thisPos;
            nodePos = this.treePosition(node);
            thisPos = this.treePosition(this);
            if (nodePos === -1 || thisPos === -1) {
              return false;
            } else {
              return nodePos > thisPos;
            }
          };
          XMLNode2.prototype.treePosition = function(node) {
            var found, pos;
            pos = 0;
            found = false;
            this.foreachTreeNode(this.document(), function(childNode) {
              pos++;
              if (!found && childNode === node) {
                return found = true;
              }
            });
            if (found) {
              return pos;
            } else {
              return -1;
            }
          };
          XMLNode2.prototype.foreachTreeNode = function(node, func) {
            var child, j, len, ref2, res;
            node || (node = this.document());
            ref2 = node.children;
            for (j = 0, len = ref2.length; j < len; j++) {
              child = ref2[j];
              if (res = func(child)) {
                return res;
              } else {
                res = this.foreachTreeNode(child, func);
                if (res) {
                  return res;
                }
              }
            }
          };
          return XMLNode2;
        })();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLStringifier.js
  var require_XMLStringifier = __commonJS({
    "node_modules/xmlbuilder/lib/XMLStringifier.js"(exports, module) {
      (function() {
        var XMLStringifier, bind = function(fn2, me) {
          return function() {
            return fn2.apply(me, arguments);
          };
        }, hasProp = {}.hasOwnProperty;
        module.exports = XMLStringifier = (function() {
          function XMLStringifier2(options) {
            this.assertLegalName = bind(this.assertLegalName, this);
            this.assertLegalChar = bind(this.assertLegalChar, this);
            var key, ref, value;
            options || (options = {});
            this.options = options;
            if (!this.options.version) {
              this.options.version = "1.0";
            }
            ref = options.stringify || {};
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              value = ref[key];
              this[key] = value;
            }
          }
          XMLStringifier2.prototype.name = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalName("" + val || "");
          };
          XMLStringifier2.prototype.text = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar(this.textEscape("" + val || ""));
          };
          XMLStringifier2.prototype.cdata = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            val = val.replace("]]>", "]]]]><![CDATA[>");
            return this.assertLegalChar(val);
          };
          XMLStringifier2.prototype.comment = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (val.match(/--/)) {
              throw new Error("Comment text cannot contain double-hypen: " + val);
            }
            return this.assertLegalChar(val);
          };
          XMLStringifier2.prototype.raw = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return "" + val || "";
          };
          XMLStringifier2.prototype.attValue = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar(this.attEscape(val = "" + val || ""));
          };
          XMLStringifier2.prototype.insTarget = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.insValue = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (val.match(/\?>/)) {
              throw new Error("Invalid processing instruction value: " + val);
            }
            return this.assertLegalChar(val);
          };
          XMLStringifier2.prototype.xmlVersion = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (!val.match(/1\.[0-9]+/)) {
              throw new Error("Invalid version number: " + val);
            }
            return val;
          };
          XMLStringifier2.prototype.xmlEncoding = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            val = "" + val || "";
            if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
              throw new Error("Invalid encoding: " + val);
            }
            return this.assertLegalChar(val);
          };
          XMLStringifier2.prototype.xmlStandalone = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            if (val) {
              return "yes";
            } else {
              return "no";
            }
          };
          XMLStringifier2.prototype.dtdPubID = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.dtdSysID = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.dtdElementValue = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.dtdAttType = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.dtdAttDefault = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.dtdEntityValue = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.dtdNData = function(val) {
            if (this.options.noValidation) {
              return val;
            }
            return this.assertLegalChar("" + val || "");
          };
          XMLStringifier2.prototype.convertAttKey = "@";
          XMLStringifier2.prototype.convertPIKey = "?";
          XMLStringifier2.prototype.convertTextKey = "#text";
          XMLStringifier2.prototype.convertCDataKey = "#cdata";
          XMLStringifier2.prototype.convertCommentKey = "#comment";
          XMLStringifier2.prototype.convertRawKey = "#raw";
          XMLStringifier2.prototype.assertLegalChar = function(str) {
            var regex, res;
            if (this.options.noValidation) {
              return str;
            }
            regex = "";
            if (this.options.version === "1.0") {
              regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
              if (res = str.match(regex)) {
                throw new Error("Invalid character in string: " + str + " at index " + res.index);
              }
            } else if (this.options.version === "1.1") {
              regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
              if (res = str.match(regex)) {
                throw new Error("Invalid character in string: " + str + " at index " + res.index);
              }
            }
            return str;
          };
          XMLStringifier2.prototype.assertLegalName = function(str) {
            var regex;
            if (this.options.noValidation) {
              return str;
            }
            this.assertLegalChar(str);
            regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
            if (!str.match(regex)) {
              throw new Error("Invalid character in name");
            }
            return str;
          };
          XMLStringifier2.prototype.textEscape = function(str) {
            var ampregex;
            if (this.options.noValidation) {
              return str;
            }
            ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
            return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
          };
          XMLStringifier2.prototype.attEscape = function(str) {
            var ampregex;
            if (this.options.noValidation) {
              return str;
            }
            ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
            return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
          };
          return XMLStringifier2;
        })();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/WriterState.js
  var require_WriterState = __commonJS({
    "node_modules/xmlbuilder/lib/WriterState.js"(exports, module) {
      (function() {
        module.exports = {
          None: 0,
          OpenTag: 1,
          InsideTag: 2,
          CloseTag: 3
        };
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLWriterBase.js
  var require_XMLWriterBase = __commonJS({
    "node_modules/xmlbuilder/lib/XMLWriterBase.js"(exports, module) {
      (function() {
        var NodeType2, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
        assign = require_Utility().assign;
        NodeType2 = require_NodeType();
        XMLDeclaration = require_XMLDeclaration();
        XMLDocType = require_XMLDocType();
        XMLCData = require_XMLCData();
        XMLComment = require_XMLComment();
        XMLElement = require_XMLElement();
        XMLRaw = require_XMLRaw();
        XMLText = require_XMLText();
        XMLProcessingInstruction = require_XMLProcessingInstruction();
        XMLDummy = require_XMLDummy();
        XMLDTDAttList = require_XMLDTDAttList();
        XMLDTDElement = require_XMLDTDElement();
        XMLDTDEntity = require_XMLDTDEntity();
        XMLDTDNotation = require_XMLDTDNotation();
        WriterState = require_WriterState();
        module.exports = XMLWriterBase = (function() {
          function XMLWriterBase2(options) {
            var key, ref, value;
            options || (options = {});
            this.options = options;
            ref = options.writer || {};
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              value = ref[key];
              this["_" + key] = this[key];
              this[key] = value;
            }
          }
          XMLWriterBase2.prototype.filterOptions = function(options) {
            var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
            options || (options = {});
            options = assign({}, this.options, options);
            filteredOptions = {
              writer: this
            };
            filteredOptions.pretty = options.pretty || false;
            filteredOptions.allowEmpty = options.allowEmpty || false;
            filteredOptions.indent = (ref = options.indent) != null ? ref : "  ";
            filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
            filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
            filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
            filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
            if (filteredOptions.spaceBeforeSlash === true) {
              filteredOptions.spaceBeforeSlash = " ";
            }
            filteredOptions.suppressPrettyCount = 0;
            filteredOptions.user = {};
            filteredOptions.state = WriterState.None;
            return filteredOptions;
          };
          XMLWriterBase2.prototype.indent = function(node, options, level) {
            var indentLevel;
            if (!options.pretty || options.suppressPrettyCount) {
              return "";
            } else if (options.pretty) {
              indentLevel = (level || 0) + options.offset + 1;
              if (indentLevel > 0) {
                return new Array(indentLevel).join(options.indent);
              }
            }
            return "";
          };
          XMLWriterBase2.prototype.endline = function(node, options, level) {
            if (!options.pretty || options.suppressPrettyCount) {
              return "";
            } else {
              return options.newline;
            }
          };
          XMLWriterBase2.prototype.attribute = function(att, options, level) {
            var r2;
            this.openAttribute(att, options, level);
            r2 = " " + att.name + '="' + att.value + '"';
            this.closeAttribute(att, options, level);
            return r2;
          };
          XMLWriterBase2.prototype.cdata = function(node, options, level) {
            var r2;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r2 = this.indent(node, options, level) + "<![CDATA[";
            options.state = WriterState.InsideTag;
            r2 += node.value;
            options.state = WriterState.CloseTag;
            r2 += "]]>" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r2;
          };
          XMLWriterBase2.prototype.comment = function(node, options, level) {
            var r2;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r2 = this.indent(node, options, level) + "<!-- ";
            options.state = WriterState.InsideTag;
            r2 += node.value;
            options.state = WriterState.CloseTag;
            r2 += " -->" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r2;
          };
          XMLWriterBase2.prototype.declaration = function(node, options, level) {
            var r2;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r2 = this.indent(node, options, level) + "<?xml";
            options.state = WriterState.InsideTag;
            r2 += ' version="' + node.version + '"';
            if (node.encoding != null) {
              r2 += ' encoding="' + node.encoding + '"';
            }
            if (node.standalone != null) {
              r2 += ' standalone="' + node.standalone + '"';
            }
            options.state = WriterState.CloseTag;
            r2 += options.spaceBeforeSlash + "?>";
            r2 += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r2;
          };
          XMLWriterBase2.prototype.docType = function(node, options, level) {
            var child, i2, len, r2, ref;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r2 = this.indent(node, options, level);
            r2 += "<!DOCTYPE " + node.root().name;
            if (node.pubID && node.sysID) {
              r2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r2 += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.children.length > 0) {
              r2 += " [";
              r2 += this.endline(node, options, level);
              options.state = WriterState.InsideTag;
              ref = node.children;
              for (i2 = 0, len = ref.length; i2 < len; i2++) {
                child = ref[i2];
                r2 += this.writeChildNode(child, options, level + 1);
              }
              options.state = WriterState.CloseTag;
              r2 += "]";
            }
            options.state = WriterState.CloseTag;
            r2 += options.spaceBeforeSlash + ">";
            r2 += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r2;
          };
          XMLWriterBase2.prototype.element = function(node, options, level) {
            var att, child, childNodeCount, firstChildNode, i2, j, len, len1, name, prettySuppressed, r2, ref, ref1, ref2;
            level || (level = 0);
            prettySuppressed = false;
            r2 = "";
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r2 += this.indent(node, options, level) + "<" + node.name;
            ref = node.attribs;
            for (name in ref) {
              if (!hasProp.call(ref, name)) continue;
              att = ref[name];
              r2 += this.attribute(att, options, level);
            }
            childNodeCount = node.children.length;
            firstChildNode = childNodeCount === 0 ? null : node.children[0];
            if (childNodeCount === 0 || node.children.every(function(e2) {
              return (e2.type === NodeType2.Text || e2.type === NodeType2.Raw) && e2.value === "";
            })) {
              if (options.allowEmpty) {
                r2 += ">";
                options.state = WriterState.CloseTag;
                r2 += "</" + node.name + ">" + this.endline(node, options, level);
              } else {
                options.state = WriterState.CloseTag;
                r2 += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
              }
            } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType2.Text || firstChildNode.type === NodeType2.Raw) && firstChildNode.value != null) {
              r2 += ">";
              options.state = WriterState.InsideTag;
              options.suppressPrettyCount++;
              prettySuppressed = true;
              r2 += this.writeChildNode(firstChildNode, options, level + 1);
              options.suppressPrettyCount--;
              prettySuppressed = false;
              options.state = WriterState.CloseTag;
              r2 += "</" + node.name + ">" + this.endline(node, options, level);
            } else {
              if (options.dontPrettyTextNodes) {
                ref1 = node.children;
                for (i2 = 0, len = ref1.length; i2 < len; i2++) {
                  child = ref1[i2];
                  if ((child.type === NodeType2.Text || child.type === NodeType2.Raw) && child.value != null) {
                    options.suppressPrettyCount++;
                    prettySuppressed = true;
                    break;
                  }
                }
              }
              r2 += ">" + this.endline(node, options, level);
              options.state = WriterState.InsideTag;
              ref2 = node.children;
              for (j = 0, len1 = ref2.length; j < len1; j++) {
                child = ref2[j];
                r2 += this.writeChildNode(child, options, level + 1);
              }
              options.state = WriterState.CloseTag;
              r2 += this.indent(node, options, level) + "</" + node.name + ">";
              if (prettySuppressed) {
                options.suppressPrettyCount--;
              }
              r2 += this.endline(node, options, level);
              options.state = WriterState.None;
            }
            this.closeNode(node, options, level);
            return r2;
          };
          XMLWriterBase2.prototype.writeChildNode = function(node, options, level) {
            switch (node.type) {
              case NodeType2.CData:
                return this.cdata(node, options, level);
              case NodeType2.Comment:
                return this.comment(node, options, level);
              case NodeType2.Element:
                return this.element(node, options, level);
              case NodeType2.Raw:
                return this.raw(node, options, level);
              case NodeType2.Text:
                return this.text(node, options, level);
              case NodeType2.ProcessingInstruction:
                return this.processingInstruction(node, options, level);
              case NodeType2.Dummy:
                return "";
              case NodeType2.Declaration:
                return this.declaration(node, options, level);
              case NodeType2.DocType:
                return this.docType(node, options, level);
              case NodeType2.AttributeDeclaration:
                return this.dtdAttList(node, options, level);
              case NodeType2.ElementDeclaration:
                return this.dtdElement(node, options, level);
              case NodeType2.EntityDeclaration:
                return this.dtdEntity(node, options, level);
              case NodeType2.NotationDeclaration:
                return this.dtdNotation(node, options, level);
              default:
                throw new Error("Unknown XML node type: " + node.constructor.name);
            }
          };
          XMLWriterBase2.prototype.processingInstruction = function(node, options, level) {
            var r2;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r2 = this.indent(node, options, level) + "<?";
            options.state = WriterState.InsideTag;
            r2 += node.target;
            if (node.value) {
              r2 += " " + node.value;
            }
            options.state = WriterState.CloseTag;
            r2 += options.spaceBeforeSlash + "?>";
            r2 += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r2;
          };
          XMLWriterBase2.prototype.raw = function(node, options, level) {
            var r2;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r2 = this.indent(node, options, level);
            options.state = WriterState.InsideTag;
            r2 += node.value;
            options.state = WriterState.CloseTag;
            r2 += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r2;
          };
          XMLWriterBase2.prototype.text = function(node, options, level) {
            var r2;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r2 = this.indent(node, options, level);
            options.state = WriterState.InsideTag;
            r2 += node.value;
            options.state = WriterState.CloseTag;
            r2 += this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r2;
          };
          XMLWriterBase2.prototype.dtdAttList = function(node, options, level) {
            var r2;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r2 = this.indent(node, options, level) + "<!ATTLIST";
            options.state = WriterState.InsideTag;
            r2 += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
            if (node.defaultValueType !== "#DEFAULT") {
              r2 += " " + node.defaultValueType;
            }
            if (node.defaultValue) {
              r2 += ' "' + node.defaultValue + '"';
            }
            options.state = WriterState.CloseTag;
            r2 += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r2;
          };
          XMLWriterBase2.prototype.dtdElement = function(node, options, level) {
            var r2;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r2 = this.indent(node, options, level) + "<!ELEMENT";
            options.state = WriterState.InsideTag;
            r2 += " " + node.name + " " + node.value;
            options.state = WriterState.CloseTag;
            r2 += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r2;
          };
          XMLWriterBase2.prototype.dtdEntity = function(node, options, level) {
            var r2;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r2 = this.indent(node, options, level) + "<!ENTITY";
            options.state = WriterState.InsideTag;
            if (node.pe) {
              r2 += " %";
            }
            r2 += " " + node.name;
            if (node.value) {
              r2 += ' "' + node.value + '"';
            } else {
              if (node.pubID && node.sysID) {
                r2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.sysID) {
                r2 += ' SYSTEM "' + node.sysID + '"';
              }
              if (node.nData) {
                r2 += " NDATA " + node.nData;
              }
            }
            options.state = WriterState.CloseTag;
            r2 += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r2;
          };
          XMLWriterBase2.prototype.dtdNotation = function(node, options, level) {
            var r2;
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            r2 = this.indent(node, options, level) + "<!NOTATION";
            options.state = WriterState.InsideTag;
            r2 += " " + node.name;
            if (node.pubID && node.sysID) {
              r2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.pubID) {
              r2 += ' PUBLIC "' + node.pubID + '"';
            } else if (node.sysID) {
              r2 += ' SYSTEM "' + node.sysID + '"';
            }
            options.state = WriterState.CloseTag;
            r2 += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
            options.state = WriterState.None;
            this.closeNode(node, options, level);
            return r2;
          };
          XMLWriterBase2.prototype.openNode = function(node, options, level) {
          };
          XMLWriterBase2.prototype.closeNode = function(node, options, level) {
          };
          XMLWriterBase2.prototype.openAttribute = function(att, options, level) {
          };
          XMLWriterBase2.prototype.closeAttribute = function(att, options, level) {
          };
          return XMLWriterBase2;
        })();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLStringWriter.js
  var require_XMLStringWriter = __commonJS({
    "node_modules/xmlbuilder/lib/XMLStringWriter.js"(exports, module) {
      (function() {
        var XMLStringWriter, XMLWriterBase, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        XMLWriterBase = require_XMLWriterBase();
        module.exports = XMLStringWriter = (function(superClass) {
          extend2(XMLStringWriter2, superClass);
          function XMLStringWriter2(options) {
            XMLStringWriter2.__super__.constructor.call(this, options);
          }
          XMLStringWriter2.prototype.document = function(doc2, options) {
            var child, i2, len, r2, ref;
            options = this.filterOptions(options);
            r2 = "";
            ref = doc2.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              r2 += this.writeChildNode(child, options, 0);
            }
            if (options.pretty && r2.slice(-options.newline.length) === options.newline) {
              r2 = r2.slice(0, -options.newline.length);
            }
            return r2;
          };
          return XMLStringWriter2;
        })(XMLWriterBase);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDocument.js
  var require_XMLDocument = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDocument.js"(exports, module) {
      (function() {
        var NodeType2, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        isPlainObject = require_Utility().isPlainObject;
        XMLDOMImplementation = require_XMLDOMImplementation();
        XMLDOMConfiguration = require_XMLDOMConfiguration();
        XMLNode = require_XMLNode();
        NodeType2 = require_NodeType();
        XMLStringifier = require_XMLStringifier();
        XMLStringWriter = require_XMLStringWriter();
        module.exports = XMLDocument = (function(superClass) {
          extend2(XMLDocument2, superClass);
          function XMLDocument2(options) {
            XMLDocument2.__super__.constructor.call(this, null);
            this.name = "#document";
            this.type = NodeType2.Document;
            this.documentURI = null;
            this.domConfig = new XMLDOMConfiguration();
            options || (options = {});
            if (!options.writer) {
              options.writer = new XMLStringWriter();
            }
            this.options = options;
            this.stringify = new XMLStringifier(options);
          }
          Object.defineProperty(XMLDocument2.prototype, "implementation", {
            value: new XMLDOMImplementation()
          });
          Object.defineProperty(XMLDocument2.prototype, "doctype", {
            get: function() {
              var child, i2, len, ref;
              ref = this.children;
              for (i2 = 0, len = ref.length; i2 < len; i2++) {
                child = ref[i2];
                if (child.type === NodeType2.DocType) {
                  return child;
                }
              }
              return null;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "documentElement", {
            get: function() {
              return this.rootObject || null;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "inputEncoding", {
            get: function() {
              return null;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "strictErrorChecking", {
            get: function() {
              return false;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "xmlEncoding", {
            get: function() {
              if (this.children.length !== 0 && this.children[0].type === NodeType2.Declaration) {
                return this.children[0].encoding;
              } else {
                return null;
              }
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "xmlStandalone", {
            get: function() {
              if (this.children.length !== 0 && this.children[0].type === NodeType2.Declaration) {
                return this.children[0].standalone === "yes";
              } else {
                return false;
              }
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "xmlVersion", {
            get: function() {
              if (this.children.length !== 0 && this.children[0].type === NodeType2.Declaration) {
                return this.children[0].version;
              } else {
                return "1.0";
              }
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "URL", {
            get: function() {
              return this.documentURI;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "origin", {
            get: function() {
              return null;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "compatMode", {
            get: function() {
              return null;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "characterSet", {
            get: function() {
              return null;
            }
          });
          Object.defineProperty(XMLDocument2.prototype, "contentType", {
            get: function() {
              return null;
            }
          });
          XMLDocument2.prototype.end = function(writer) {
            var writerOptions;
            writerOptions = {};
            if (!writer) {
              writer = this.options.writer;
            } else if (isPlainObject(writer)) {
              writerOptions = writer;
              writer = this.options.writer;
            }
            return writer.document(this, writer.filterOptions(writerOptions));
          };
          XMLDocument2.prototype.toString = function(options) {
            return this.options.writer.document(this, this.options.writer.filterOptions(options));
          };
          XMLDocument2.prototype.createElement = function(tagName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createDocumentFragment = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createTextNode = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createComment = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createCDATASection = function(data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createProcessingInstruction = function(target, data) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createAttribute = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createEntityReference = function(name) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.getElementsByTagName = function(tagname) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.importNode = function(importedNode, deep) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createElementNS = function(namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.getElementById = function(elementId) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.adoptNode = function(source) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.normalizeDocument = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.getElementsByClassName = function(classNames) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createEvent = function(eventInterface) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createRange = function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createNodeIterator = function(root2, whatToShow, filter2) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          XMLDocument2.prototype.createTreeWalker = function(root2, whatToShow, filter2) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          };
          return XMLDocument2;
        })(XMLNode);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLDocumentCB.js
  var require_XMLDocumentCB = __commonJS({
    "node_modules/xmlbuilder/lib/XMLDocumentCB.js"(exports, module) {
      (function() {
        var NodeType2, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
        ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
        NodeType2 = require_NodeType();
        XMLDocument = require_XMLDocument();
        XMLElement = require_XMLElement();
        XMLCData = require_XMLCData();
        XMLComment = require_XMLComment();
        XMLRaw = require_XMLRaw();
        XMLText = require_XMLText();
        XMLProcessingInstruction = require_XMLProcessingInstruction();
        XMLDeclaration = require_XMLDeclaration();
        XMLDocType = require_XMLDocType();
        XMLDTDAttList = require_XMLDTDAttList();
        XMLDTDEntity = require_XMLDTDEntity();
        XMLDTDElement = require_XMLDTDElement();
        XMLDTDNotation = require_XMLDTDNotation();
        XMLAttribute = require_XMLAttribute();
        XMLStringifier = require_XMLStringifier();
        XMLStringWriter = require_XMLStringWriter();
        WriterState = require_WriterState();
        module.exports = XMLDocumentCB = (function() {
          function XMLDocumentCB2(options, onData, onEnd) {
            var writerOptions;
            this.name = "?xml";
            this.type = NodeType2.Document;
            options || (options = {});
            writerOptions = {};
            if (!options.writer) {
              options.writer = new XMLStringWriter();
            } else if (isPlainObject(options.writer)) {
              writerOptions = options.writer;
              options.writer = new XMLStringWriter();
            }
            this.options = options;
            this.writer = options.writer;
            this.writerOptions = this.writer.filterOptions(writerOptions);
            this.stringify = new XMLStringifier(options);
            this.onDataCallback = onData || function() {
            };
            this.onEndCallback = onEnd || function() {
            };
            this.currentNode = null;
            this.currentLevel = -1;
            this.openTags = {};
            this.documentStarted = false;
            this.documentCompleted = false;
            this.root = null;
          }
          XMLDocumentCB2.prototype.createChildNode = function(node) {
            var att, attName, attributes, child, i2, len, ref1, ref2;
            switch (node.type) {
              case NodeType2.CData:
                this.cdata(node.value);
                break;
              case NodeType2.Comment:
                this.comment(node.value);
                break;
              case NodeType2.Element:
                attributes = {};
                ref1 = node.attribs;
                for (attName in ref1) {
                  if (!hasProp.call(ref1, attName)) continue;
                  att = ref1[attName];
                  attributes[attName] = att.value;
                }
                this.node(node.name, attributes);
                break;
              case NodeType2.Dummy:
                this.dummy();
                break;
              case NodeType2.Raw:
                this.raw(node.value);
                break;
              case NodeType2.Text:
                this.text(node.value);
                break;
              case NodeType2.ProcessingInstruction:
                this.instruction(node.target, node.value);
                break;
              default:
                throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
            }
            ref2 = node.children;
            for (i2 = 0, len = ref2.length; i2 < len; i2++) {
              child = ref2[i2];
              this.createChildNode(child);
              if (child.type === NodeType2.Element) {
                this.up();
              }
            }
            return this;
          };
          XMLDocumentCB2.prototype.dummy = function() {
            return this;
          };
          XMLDocumentCB2.prototype.node = function(name, attributes, text) {
            var ref1;
            if (name == null) {
              throw new Error("Missing node name.");
            }
            if (this.root && this.currentLevel === -1) {
              throw new Error("Document can only have one root node. " + this.debugInfo(name));
            }
            this.openCurrent();
            name = getValue(name);
            if (attributes == null) {
              attributes = {};
            }
            attributes = getValue(attributes);
            if (!isObject(attributes)) {
              ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
            }
            this.currentNode = new XMLElement(this, name, attributes);
            this.currentNode.children = false;
            this.currentLevel++;
            this.openTags[this.currentLevel] = this.currentNode;
            if (text != null) {
              this.text(text);
            }
            return this;
          };
          XMLDocumentCB2.prototype.element = function(name, attributes, text) {
            var child, i2, len, oldValidationFlag, ref1, root2;
            if (this.currentNode && this.currentNode.type === NodeType2.DocType) {
              this.dtdElement.apply(this, arguments);
            } else {
              if (Array.isArray(name) || isObject(name) || isFunction(name)) {
                oldValidationFlag = this.options.noValidation;
                this.options.noValidation = true;
                root2 = new XMLDocument(this.options).element("TEMP_ROOT");
                root2.element(name);
                this.options.noValidation = oldValidationFlag;
                ref1 = root2.children;
                for (i2 = 0, len = ref1.length; i2 < len; i2++) {
                  child = ref1[i2];
                  this.createChildNode(child);
                  if (child.type === NodeType2.Element) {
                    this.up();
                  }
                }
              } else {
                this.node(name, attributes, text);
              }
            }
            return this;
          };
          XMLDocumentCB2.prototype.attribute = function(name, value) {
            var attName, attValue;
            if (!this.currentNode || this.currentNode.children) {
              throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
            }
            if (name != null) {
              name = getValue(name);
            }
            if (isObject(name)) {
              for (attName in name) {
                if (!hasProp.call(name, attName)) continue;
                attValue = name[attName];
                this.attribute(attName, attValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              if (this.options.keepNullAttributes && value == null) {
                this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
              } else if (value != null) {
                this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
              }
            }
            return this;
          };
          XMLDocumentCB2.prototype.text = function(value) {
            var node;
            this.openCurrent();
            node = new XMLText(this, value);
            this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.cdata = function(value) {
            var node;
            this.openCurrent();
            node = new XMLCData(this, value);
            this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.comment = function(value) {
            var node;
            this.openCurrent();
            node = new XMLComment(this, value);
            this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.raw = function(value) {
            var node;
            this.openCurrent();
            node = new XMLRaw(this, value);
            this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.instruction = function(target, value) {
            var i2, insTarget, insValue, len, node;
            this.openCurrent();
            if (target != null) {
              target = getValue(target);
            }
            if (value != null) {
              value = getValue(value);
            }
            if (Array.isArray(target)) {
              for (i2 = 0, len = target.length; i2 < len; i2++) {
                insTarget = target[i2];
                this.instruction(insTarget);
              }
            } else if (isObject(target)) {
              for (insTarget in target) {
                if (!hasProp.call(target, insTarget)) continue;
                insValue = target[insTarget];
                this.instruction(insTarget, insValue);
              }
            } else {
              if (isFunction(value)) {
                value = value.apply();
              }
              node = new XMLProcessingInstruction(this, target, value);
              this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            }
            return this;
          };
          XMLDocumentCB2.prototype.declaration = function(version, encoding, standalone) {
            var node;
            this.openCurrent();
            if (this.documentStarted) {
              throw new Error("declaration() must be the first node.");
            }
            node = new XMLDeclaration(this, version, encoding, standalone);
            this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.doctype = function(root2, pubID, sysID) {
            this.openCurrent();
            if (root2 == null) {
              throw new Error("Missing root node name.");
            }
            if (this.root) {
              throw new Error("dtd() must come before the root node.");
            }
            this.currentNode = new XMLDocType(this, pubID, sysID);
            this.currentNode.rootNodeName = root2;
            this.currentNode.children = false;
            this.currentLevel++;
            this.openTags[this.currentLevel] = this.currentNode;
            return this;
          };
          XMLDocumentCB2.prototype.dtdElement = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDElement(this, name, value);
            this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
            var node;
            this.openCurrent();
            node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
            this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.entity = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDEntity(this, false, name, value);
            this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.pEntity = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDEntity(this, true, name, value);
            this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.notation = function(name, value) {
            var node;
            this.openCurrent();
            node = new XMLDTDNotation(this, name, value);
            this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
            return this;
          };
          XMLDocumentCB2.prototype.up = function() {
            if (this.currentLevel < 0) {
              throw new Error("The document node has no parent.");
            }
            if (this.currentNode) {
              if (this.currentNode.children) {
                this.closeNode(this.currentNode);
              } else {
                this.openNode(this.currentNode);
              }
              this.currentNode = null;
            } else {
              this.closeNode(this.openTags[this.currentLevel]);
            }
            delete this.openTags[this.currentLevel];
            this.currentLevel--;
            return this;
          };
          XMLDocumentCB2.prototype.end = function() {
            while (this.currentLevel >= 0) {
              this.up();
            }
            return this.onEnd();
          };
          XMLDocumentCB2.prototype.openCurrent = function() {
            if (this.currentNode) {
              this.currentNode.children = true;
              return this.openNode(this.currentNode);
            }
          };
          XMLDocumentCB2.prototype.openNode = function(node) {
            var att, chunk, name, ref1;
            if (!node.isOpen) {
              if (!this.root && this.currentLevel === 0 && node.type === NodeType2.Element) {
                this.root = node;
              }
              chunk = "";
              if (node.type === NodeType2.Element) {
                this.writerOptions.state = WriterState.OpenTag;
                chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
                ref1 = node.attribs;
                for (name in ref1) {
                  if (!hasProp.call(ref1, name)) continue;
                  att = ref1[name];
                  chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
                }
                chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
                this.writerOptions.state = WriterState.InsideTag;
              } else {
                this.writerOptions.state = WriterState.OpenTag;
                chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
                if (node.pubID && node.sysID) {
                  chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
                } else if (node.sysID) {
                  chunk += ' SYSTEM "' + node.sysID + '"';
                }
                if (node.children) {
                  chunk += " [";
                  this.writerOptions.state = WriterState.InsideTag;
                } else {
                  this.writerOptions.state = WriterState.CloseTag;
                  chunk += ">";
                }
                chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
              }
              this.onData(chunk, this.currentLevel);
              return node.isOpen = true;
            }
          };
          XMLDocumentCB2.prototype.closeNode = function(node) {
            var chunk;
            if (!node.isClosed) {
              chunk = "";
              this.writerOptions.state = WriterState.CloseTag;
              if (node.type === NodeType2.Element) {
                chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
              } else {
                chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
              }
              this.writerOptions.state = WriterState.None;
              this.onData(chunk, this.currentLevel);
              return node.isClosed = true;
            }
          };
          XMLDocumentCB2.prototype.onData = function(chunk, level) {
            this.documentStarted = true;
            return this.onDataCallback(chunk, level + 1);
          };
          XMLDocumentCB2.prototype.onEnd = function() {
            this.documentCompleted = true;
            return this.onEndCallback();
          };
          XMLDocumentCB2.prototype.debugInfo = function(name) {
            if (name == null) {
              return "";
            } else {
              return "node: <" + name + ">";
            }
          };
          XMLDocumentCB2.prototype.ele = function() {
            return this.element.apply(this, arguments);
          };
          XMLDocumentCB2.prototype.nod = function(name, attributes, text) {
            return this.node(name, attributes, text);
          };
          XMLDocumentCB2.prototype.txt = function(value) {
            return this.text(value);
          };
          XMLDocumentCB2.prototype.dat = function(value) {
            return this.cdata(value);
          };
          XMLDocumentCB2.prototype.com = function(value) {
            return this.comment(value);
          };
          XMLDocumentCB2.prototype.ins = function(target, value) {
            return this.instruction(target, value);
          };
          XMLDocumentCB2.prototype.dec = function(version, encoding, standalone) {
            return this.declaration(version, encoding, standalone);
          };
          XMLDocumentCB2.prototype.dtd = function(root2, pubID, sysID) {
            return this.doctype(root2, pubID, sysID);
          };
          XMLDocumentCB2.prototype.e = function(name, attributes, text) {
            return this.element(name, attributes, text);
          };
          XMLDocumentCB2.prototype.n = function(name, attributes, text) {
            return this.node(name, attributes, text);
          };
          XMLDocumentCB2.prototype.t = function(value) {
            return this.text(value);
          };
          XMLDocumentCB2.prototype.d = function(value) {
            return this.cdata(value);
          };
          XMLDocumentCB2.prototype.c = function(value) {
            return this.comment(value);
          };
          XMLDocumentCB2.prototype.r = function(value) {
            return this.raw(value);
          };
          XMLDocumentCB2.prototype.i = function(target, value) {
            return this.instruction(target, value);
          };
          XMLDocumentCB2.prototype.att = function() {
            if (this.currentNode && this.currentNode.type === NodeType2.DocType) {
              return this.attList.apply(this, arguments);
            } else {
              return this.attribute.apply(this, arguments);
            }
          };
          XMLDocumentCB2.prototype.a = function() {
            if (this.currentNode && this.currentNode.type === NodeType2.DocType) {
              return this.attList.apply(this, arguments);
            } else {
              return this.attribute.apply(this, arguments);
            }
          };
          XMLDocumentCB2.prototype.ent = function(name, value) {
            return this.entity(name, value);
          };
          XMLDocumentCB2.prototype.pent = function(name, value) {
            return this.pEntity(name, value);
          };
          XMLDocumentCB2.prototype.not = function(name, value) {
            return this.notation(name, value);
          };
          return XMLDocumentCB2;
        })();
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/XMLStreamWriter.js
  var require_XMLStreamWriter = __commonJS({
    "node_modules/xmlbuilder/lib/XMLStreamWriter.js"(exports, module) {
      (function() {
        var NodeType2, WriterState, XMLStreamWriter, XMLWriterBase, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        NodeType2 = require_NodeType();
        XMLWriterBase = require_XMLWriterBase();
        WriterState = require_WriterState();
        module.exports = XMLStreamWriter = (function(superClass) {
          extend2(XMLStreamWriter2, superClass);
          function XMLStreamWriter2(stream, options) {
            this.stream = stream;
            XMLStreamWriter2.__super__.constructor.call(this, options);
          }
          XMLStreamWriter2.prototype.endline = function(node, options, level) {
            if (node.isLastRootNode && options.state === WriterState.CloseTag) {
              return "";
            } else {
              return XMLStreamWriter2.__super__.endline.call(this, node, options, level);
            }
          };
          XMLStreamWriter2.prototype.document = function(doc2, options) {
            var child, i2, j, k2, len, len1, ref, ref1, results;
            ref = doc2.children;
            for (i2 = j = 0, len = ref.length; j < len; i2 = ++j) {
              child = ref[i2];
              child.isLastRootNode = i2 === doc2.children.length - 1;
            }
            options = this.filterOptions(options);
            ref1 = doc2.children;
            results = [];
            for (k2 = 0, len1 = ref1.length; k2 < len1; k2++) {
              child = ref1[k2];
              results.push(this.writeChildNode(child, options, 0));
            }
            return results;
          };
          XMLStreamWriter2.prototype.attribute = function(att, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.attribute.call(this, att, options, level));
          };
          XMLStreamWriter2.prototype.cdata = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.cdata.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.comment = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.comment.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.declaration = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.declaration.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.docType = function(node, options, level) {
            var child, j, len, ref;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            this.stream.write(this.indent(node, options, level));
            this.stream.write("<!DOCTYPE " + node.root().name);
            if (node.pubID && node.sysID) {
              this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
            } else if (node.sysID) {
              this.stream.write(' SYSTEM "' + node.sysID + '"');
            }
            if (node.children.length > 0) {
              this.stream.write(" [");
              this.stream.write(this.endline(node, options, level));
              options.state = WriterState.InsideTag;
              ref = node.children;
              for (j = 0, len = ref.length; j < len; j++) {
                child = ref[j];
                this.writeChildNode(child, options, level + 1);
              }
              options.state = WriterState.CloseTag;
              this.stream.write("]");
            }
            options.state = WriterState.CloseTag;
            this.stream.write(options.spaceBeforeSlash + ">");
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.None;
            return this.closeNode(node, options, level);
          };
          XMLStreamWriter2.prototype.element = function(node, options, level) {
            var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
            level || (level = 0);
            this.openNode(node, options, level);
            options.state = WriterState.OpenTag;
            this.stream.write(this.indent(node, options, level) + "<" + node.name);
            ref = node.attribs;
            for (name in ref) {
              if (!hasProp.call(ref, name)) continue;
              att = ref[name];
              this.attribute(att, options, level);
            }
            childNodeCount = node.children.length;
            firstChildNode = childNodeCount === 0 ? null : node.children[0];
            if (childNodeCount === 0 || node.children.every(function(e2) {
              return (e2.type === NodeType2.Text || e2.type === NodeType2.Raw) && e2.value === "";
            })) {
              if (options.allowEmpty) {
                this.stream.write(">");
                options.state = WriterState.CloseTag;
                this.stream.write("</" + node.name + ">");
              } else {
                options.state = WriterState.CloseTag;
                this.stream.write(options.spaceBeforeSlash + "/>");
              }
            } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType2.Text || firstChildNode.type === NodeType2.Raw) && firstChildNode.value != null) {
              this.stream.write(">");
              options.state = WriterState.InsideTag;
              options.suppressPrettyCount++;
              prettySuppressed = true;
              this.writeChildNode(firstChildNode, options, level + 1);
              options.suppressPrettyCount--;
              prettySuppressed = false;
              options.state = WriterState.CloseTag;
              this.stream.write("</" + node.name + ">");
            } else {
              this.stream.write(">" + this.endline(node, options, level));
              options.state = WriterState.InsideTag;
              ref1 = node.children;
              for (j = 0, len = ref1.length; j < len; j++) {
                child = ref1[j];
                this.writeChildNode(child, options, level + 1);
              }
              options.state = WriterState.CloseTag;
              this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
            }
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.None;
            return this.closeNode(node, options, level);
          };
          XMLStreamWriter2.prototype.processingInstruction = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.processingInstruction.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.raw = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.raw.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.text = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.text.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.dtdAttList = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.dtdAttList.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.dtdElement = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.dtdElement.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.dtdEntity = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.dtdEntity.call(this, node, options, level));
          };
          XMLStreamWriter2.prototype.dtdNotation = function(node, options, level) {
            return this.stream.write(XMLStreamWriter2.__super__.dtdNotation.call(this, node, options, level));
          };
          return XMLStreamWriter2;
        })(XMLWriterBase);
      }).call(exports);
    }
  });

  // node_modules/xmlbuilder/lib/index.js
  var require_lib = __commonJS({
    "node_modules/xmlbuilder/lib/index.js"(exports, module) {
      (function() {
        var NodeType2, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
        ref = require_Utility(), assign = ref.assign, isFunction = ref.isFunction;
        XMLDOMImplementation = require_XMLDOMImplementation();
        XMLDocument = require_XMLDocument();
        XMLDocumentCB = require_XMLDocumentCB();
        XMLStringWriter = require_XMLStringWriter();
        XMLStreamWriter = require_XMLStreamWriter();
        NodeType2 = require_NodeType();
        WriterState = require_WriterState();
        module.exports.create = function(name, xmldec, doctype, options) {
          var doc2, root2;
          if (name == null) {
            throw new Error("Root element needs a name.");
          }
          options = assign({}, xmldec, doctype, options);
          doc2 = new XMLDocument(options);
          root2 = doc2.element(name);
          if (!options.headless) {
            doc2.declaration(options);
            if (options.pubID != null || options.sysID != null) {
              doc2.dtd(options);
            }
          }
          return root2;
        };
        module.exports.begin = function(options, onData, onEnd) {
          var ref1;
          if (isFunction(options)) {
            ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
            options = {};
          }
          if (onData) {
            return new XMLDocumentCB(options, onData, onEnd);
          } else {
            return new XMLDocument(options);
          }
        };
        module.exports.stringWriter = function(options) {
          return new XMLStringWriter(options);
        };
        module.exports.streamWriter = function(stream, options) {
          return new XMLStreamWriter(stream, options);
        };
        module.exports.implementation = new XMLDOMImplementation();
        module.exports.nodeType = NodeType2;
        module.exports.writerState = WriterState;
      }).call(exports);
    }
  });

  // node_modules/xml2js/lib/builder.js
  var require_builder = __commonJS({
    "node_modules/xml2js/lib/builder.js"(exports) {
      (function() {
        "use strict";
        var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
        builder = require_lib();
        defaults = require_defaults().defaults;
        requiresCDATA = function(entry) {
          return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
        };
        wrapCDATA = function(entry) {
          return "<![CDATA[" + escapeCDATA(entry) + "]]>";
        };
        escapeCDATA = function(entry) {
          return entry.replace("]]>", "]]]]><![CDATA[>");
        };
        exports.Builder = (function() {
          function Builder(opts) {
            var key, ref, value;
            this.options = {};
            ref = defaults["0.2"];
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              value = ref[key];
              this.options[key] = value;
            }
            for (key in opts) {
              if (!hasProp.call(opts, key)) continue;
              value = opts[key];
              this.options[key] = value;
            }
          }
          Builder.prototype.buildObject = function(rootObj) {
            var attrkey, charkey, render, rootElement, rootName;
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
              rootName = Object.keys(rootObj)[0];
              rootObj = rootObj[rootName];
            } else {
              rootName = this.options.rootName;
            }
            render = /* @__PURE__ */ (function(_this) {
              return function(element, obj) {
                var attr, child, entry, index, key, value;
                if (typeof obj !== "object") {
                  if (_this.options.cdata && requiresCDATA(obj)) {
                    element.raw(wrapCDATA(obj));
                  } else {
                    element.txt(obj);
                  }
                } else if (Array.isArray(obj)) {
                  for (index in obj) {
                    if (!hasProp.call(obj, index)) continue;
                    child = obj[index];
                    for (key in child) {
                      entry = child[key];
                      element = render(element.ele(key), entry).up();
                    }
                  }
                } else {
                  for (key in obj) {
                    if (!hasProp.call(obj, key)) continue;
                    child = obj[key];
                    if (key === attrkey) {
                      if (typeof child === "object") {
                        for (attr in child) {
                          value = child[attr];
                          element = element.att(attr, value);
                        }
                      }
                    } else if (key === charkey) {
                      if (_this.options.cdata && requiresCDATA(child)) {
                        element = element.raw(wrapCDATA(child));
                      } else {
                        element = element.txt(child);
                      }
                    } else if (Array.isArray(child)) {
                      for (index in child) {
                        if (!hasProp.call(child, index)) continue;
                        entry = child[index];
                        if (typeof entry === "string") {
                          if (_this.options.cdata && requiresCDATA(entry)) {
                            element = element.ele(key).raw(wrapCDATA(entry)).up();
                          } else {
                            element = element.ele(key, entry).up();
                          }
                        } else {
                          element = render(element.ele(key), entry).up();
                        }
                      }
                    } else if (typeof child === "object") {
                      element = render(element.ele(key), child).up();
                    } else {
                      if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                        element = element.ele(key).raw(wrapCDATA(child)).up();
                      } else {
                        if (child == null) {
                          child = "";
                        }
                        element = element.ele(key, child.toString()).up();
                      }
                    }
                  }
                }
                return element;
              };
            })(this);
            rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
              headless: this.options.headless,
              allowSurrogateChars: this.options.allowSurrogateChars
            });
            return render(rootElement, rootObj).end(this.options.renderOpts);
          };
          return Builder;
        })();
      }).call(exports);
    }
  });

  // node_modules/sax/lib/sax.js
  var require_sax = __commonJS({
    "node_modules/sax/lib/sax.js"(exports) {
      (function(sax) {
        sax.parser = function(strict, opt) {
          return new SAXParser(strict, opt);
        };
        sax.SAXParser = SAXParser;
        sax.SAXStream = SAXStream;
        sax.createStream = createStream;
        sax.MAX_BUFFER_LENGTH = 64 * 1024;
        var buffers = [
          "comment",
          "sgmlDecl",
          "textNode",
          "tagName",
          "doctype",
          "procInstName",
          "procInstBody",
          "entity",
          "attribName",
          "attribValue",
          "cdata",
          "script"
        ];
        sax.EVENTS = [
          "text",
          "processinginstruction",
          "sgmldeclaration",
          "doctype",
          "comment",
          "opentagstart",
          "attribute",
          "opentag",
          "closetag",
          "opencdata",
          "cdata",
          "closecdata",
          "error",
          "end",
          "ready",
          "script",
          "opennamespace",
          "closenamespace"
        ];
        function SAXParser(strict, opt) {
          if (!(this instanceof SAXParser)) {
            return new SAXParser(strict, opt);
          }
          var parser = this;
          clearBuffers(parser);
          parser.q = parser.c = "";
          parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
          parser.opt = opt || {};
          parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
          parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
          parser.tags = [];
          parser.closed = parser.closedRoot = parser.sawRoot = false;
          parser.tag = parser.error = null;
          parser.strict = !!strict;
          parser.noscript = !!(strict || parser.opt.noscript);
          parser.state = S2.BEGIN;
          parser.strictEntities = parser.opt.strictEntities;
          parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
          parser.attribList = [];
          if (parser.opt.xmlns) {
            parser.ns = Object.create(rootNS);
          }
          if (parser.opt.unquotedAttributeValues === void 0) {
            parser.opt.unquotedAttributeValues = !strict;
          }
          parser.trackPosition = parser.opt.position !== false;
          if (parser.trackPosition) {
            parser.position = parser.line = parser.column = 0;
          }
          emit(parser, "onready");
        }
        if (!Object.create) {
          Object.create = function(o2) {
            function F2() {
            }
            F2.prototype = o2;
            var newf = new F2();
            return newf;
          };
        }
        if (!Object.keys) {
          Object.keys = function(o2) {
            var a2 = [];
            for (var i2 in o2) if (o2.hasOwnProperty(i2)) a2.push(i2);
            return a2;
          };
        }
        function checkBufferLength(parser) {
          var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
          var maxActual = 0;
          for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
            var len = parser[buffers[i2]].length;
            if (len > maxAllowed) {
              switch (buffers[i2]) {
                case "textNode":
                  closeText(parser);
                  break;
                case "cdata":
                  emitNode(parser, "oncdata", parser.cdata);
                  parser.cdata = "";
                  break;
                case "script":
                  emitNode(parser, "onscript", parser.script);
                  parser.script = "";
                  break;
                default:
                  error(parser, "Max buffer length exceeded: " + buffers[i2]);
              }
            }
            maxActual = Math.max(maxActual, len);
          }
          var m2 = sax.MAX_BUFFER_LENGTH - maxActual;
          parser.bufferCheckPosition = m2 + parser.position;
        }
        function clearBuffers(parser) {
          for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
            parser[buffers[i2]] = "";
          }
        }
        function flushBuffers(parser) {
          closeText(parser);
          if (parser.cdata !== "") {
            emitNode(parser, "oncdata", parser.cdata);
            parser.cdata = "";
          }
          if (parser.script !== "") {
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
        }
        SAXParser.prototype = {
          end: function() {
            end(this);
          },
          write,
          resume: function() {
            this.error = null;
            return this;
          },
          close: function() {
            return this.write(null);
          },
          flush: function() {
            flushBuffers(this);
          }
        };
        var Stream;
        try {
          Stream = __require("stream").Stream;
        } catch (ex) {
          Stream = function() {
          };
        }
        if (!Stream) Stream = function() {
        };
        var streamWraps = sax.EVENTS.filter(function(ev) {
          return ev !== "error" && ev !== "end";
        });
        function createStream(strict, opt) {
          return new SAXStream(strict, opt);
        }
        function SAXStream(strict, opt) {
          if (!(this instanceof SAXStream)) {
            return new SAXStream(strict, opt);
          }
          Stream.apply(this);
          this._parser = new SAXParser(strict, opt);
          this.writable = true;
          this.readable = true;
          var me = this;
          this._parser.onend = function() {
            me.emit("end");
          };
          this._parser.onerror = function(er) {
            me.emit("error", er);
            me._parser.error = null;
          };
          this._decoder = null;
          streamWraps.forEach(function(ev) {
            Object.defineProperty(me, "on" + ev, {
              get: function() {
                return me._parser["on" + ev];
              },
              set: function(h2) {
                if (!h2) {
                  me.removeAllListeners(ev);
                  me._parser["on" + ev] = h2;
                  return h2;
                }
                me.on(ev, h2);
              },
              enumerable: true,
              configurable: false
            });
          });
        }
        SAXStream.prototype = Object.create(Stream.prototype, {
          constructor: {
            value: SAXStream
          }
        });
        SAXStream.prototype.write = function(data) {
          if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
            if (!this._decoder) {
              this._decoder = new TextDecoder("utf8");
            }
            data = this._decoder.decode(data, { stream: true });
          }
          this._parser.write(data.toString());
          this.emit("data", data);
          return true;
        };
        SAXStream.prototype.end = function(chunk) {
          if (chunk && chunk.length) {
            this.write(chunk);
          }
          if (this._decoder) {
            var remaining = this._decoder.decode();
            if (remaining) {
              this._parser.write(remaining);
              this.emit("data", remaining);
            }
          }
          this._parser.end();
          return true;
        };
        SAXStream.prototype.on = function(ev, handler) {
          var me = this;
          if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
            me._parser["on" + ev] = function() {
              var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
              args.splice(0, 0, ev);
              me.emit.apply(me, args);
            };
          }
          return Stream.prototype.on.call(me, ev, handler);
        };
        var CDATA = "[CDATA[";
        var DOCTYPE = "DOCTYPE";
        var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
        var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
        var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
        var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
        var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
        var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
        function isWhitespace(c2) {
          return c2 === " " || c2 === "\n" || c2 === "\r" || c2 === "	";
        }
        function isQuote(c2) {
          return c2 === '"' || c2 === "'";
        }
        function isAttribEnd(c2) {
          return c2 === ">" || isWhitespace(c2);
        }
        function isMatch(regex, c2) {
          return regex.test(c2);
        }
        function notMatch(regex, c2) {
          return !isMatch(regex, c2);
        }
        var S2 = 0;
        sax.STATE = {
          BEGIN: S2++,
          // leading byte order mark or whitespace
          BEGIN_WHITESPACE: S2++,
          // leading whitespace
          TEXT: S2++,
          // general stuff
          TEXT_ENTITY: S2++,
          // &amp and such.
          OPEN_WAKA: S2++,
          // <
          SGML_DECL: S2++,
          // <!BLARG
          SGML_DECL_QUOTED: S2++,
          // <!BLARG foo "bar
          DOCTYPE: S2++,
          // <!DOCTYPE
          DOCTYPE_QUOTED: S2++,
          // <!DOCTYPE "//blah
          DOCTYPE_DTD: S2++,
          // <!DOCTYPE "//blah" [ ...
          DOCTYPE_DTD_QUOTED: S2++,
          // <!DOCTYPE "//blah" [ "foo
          COMMENT_STARTING: S2++,
          // <!-
          COMMENT: S2++,
          // <!--
          COMMENT_ENDING: S2++,
          // <!-- blah -
          COMMENT_ENDED: S2++,
          // <!-- blah --
          CDATA: S2++,
          // <![CDATA[ something
          CDATA_ENDING: S2++,
          // ]
          CDATA_ENDING_2: S2++,
          // ]]
          PROC_INST: S2++,
          // <?hi
          PROC_INST_BODY: S2++,
          // <?hi there
          PROC_INST_ENDING: S2++,
          // <?hi "there" ?
          OPEN_TAG: S2++,
          // <strong
          OPEN_TAG_SLASH: S2++,
          // <strong /
          ATTRIB: S2++,
          // <a
          ATTRIB_NAME: S2++,
          // <a foo
          ATTRIB_NAME_SAW_WHITE: S2++,
          // <a foo _
          ATTRIB_VALUE: S2++,
          // <a foo=
          ATTRIB_VALUE_QUOTED: S2++,
          // <a foo="bar
          ATTRIB_VALUE_CLOSED: S2++,
          // <a foo="bar"
          ATTRIB_VALUE_UNQUOTED: S2++,
          // <a foo=bar
          ATTRIB_VALUE_ENTITY_Q: S2++,
          // <foo bar="&quot;"
          ATTRIB_VALUE_ENTITY_U: S2++,
          // <foo bar=&quot
          CLOSE_TAG: S2++,
          // </a
          CLOSE_TAG_SAW_WHITE: S2++,
          // </a   >
          SCRIPT: S2++,
          // <script> ...
          SCRIPT_ENDING: S2++
          // <script> ... <
        };
        sax.XML_ENTITIES = {
          amp: "&",
          gt: ">",
          lt: "<",
          quot: '"',
          apos: "'"
        };
        sax.ENTITIES = {
          amp: "&",
          gt: ">",
          lt: "<",
          quot: '"',
          apos: "'",
          AElig: 198,
          Aacute: 193,
          Acirc: 194,
          Agrave: 192,
          Aring: 197,
          Atilde: 195,
          Auml: 196,
          Ccedil: 199,
          ETH: 208,
          Eacute: 201,
          Ecirc: 202,
          Egrave: 200,
          Euml: 203,
          Iacute: 205,
          Icirc: 206,
          Igrave: 204,
          Iuml: 207,
          Ntilde: 209,
          Oacute: 211,
          Ocirc: 212,
          Ograve: 210,
          Oslash: 216,
          Otilde: 213,
          Ouml: 214,
          THORN: 222,
          Uacute: 218,
          Ucirc: 219,
          Ugrave: 217,
          Uuml: 220,
          Yacute: 221,
          aacute: 225,
          acirc: 226,
          aelig: 230,
          agrave: 224,
          aring: 229,
          atilde: 227,
          auml: 228,
          ccedil: 231,
          eacute: 233,
          ecirc: 234,
          egrave: 232,
          eth: 240,
          euml: 235,
          iacute: 237,
          icirc: 238,
          igrave: 236,
          iuml: 239,
          ntilde: 241,
          oacute: 243,
          ocirc: 244,
          ograve: 242,
          oslash: 248,
          otilde: 245,
          ouml: 246,
          szlig: 223,
          thorn: 254,
          uacute: 250,
          ucirc: 251,
          ugrave: 249,
          uuml: 252,
          yacute: 253,
          yuml: 255,
          copy: 169,
          reg: 174,
          nbsp: 160,
          iexcl: 161,
          cent: 162,
          pound: 163,
          curren: 164,
          yen: 165,
          brvbar: 166,
          sect: 167,
          uml: 168,
          ordf: 170,
          laquo: 171,
          not: 172,
          shy: 173,
          macr: 175,
          deg: 176,
          plusmn: 177,
          sup1: 185,
          sup2: 178,
          sup3: 179,
          acute: 180,
          micro: 181,
          para: 182,
          middot: 183,
          cedil: 184,
          ordm: 186,
          raquo: 187,
          frac14: 188,
          frac12: 189,
          frac34: 190,
          iquest: 191,
          times: 215,
          divide: 247,
          OElig: 338,
          oelig: 339,
          Scaron: 352,
          scaron: 353,
          Yuml: 376,
          fnof: 402,
          circ: 710,
          tilde: 732,
          Alpha: 913,
          Beta: 914,
          Gamma: 915,
          Delta: 916,
          Epsilon: 917,
          Zeta: 918,
          Eta: 919,
          Theta: 920,
          Iota: 921,
          Kappa: 922,
          Lambda: 923,
          Mu: 924,
          Nu: 925,
          Xi: 926,
          Omicron: 927,
          Pi: 928,
          Rho: 929,
          Sigma: 931,
          Tau: 932,
          Upsilon: 933,
          Phi: 934,
          Chi: 935,
          Psi: 936,
          Omega: 937,
          alpha: 945,
          beta: 946,
          gamma: 947,
          delta: 948,
          epsilon: 949,
          zeta: 950,
          eta: 951,
          theta: 952,
          iota: 953,
          kappa: 954,
          lambda: 955,
          mu: 956,
          nu: 957,
          xi: 958,
          omicron: 959,
          pi: 960,
          rho: 961,
          sigmaf: 962,
          sigma: 963,
          tau: 964,
          upsilon: 965,
          phi: 966,
          chi: 967,
          psi: 968,
          omega: 969,
          thetasym: 977,
          upsih: 978,
          piv: 982,
          ensp: 8194,
          emsp: 8195,
          thinsp: 8201,
          zwnj: 8204,
          zwj: 8205,
          lrm: 8206,
          rlm: 8207,
          ndash: 8211,
          mdash: 8212,
          lsquo: 8216,
          rsquo: 8217,
          sbquo: 8218,
          ldquo: 8220,
          rdquo: 8221,
          bdquo: 8222,
          dagger: 8224,
          Dagger: 8225,
          bull: 8226,
          hellip: 8230,
          permil: 8240,
          prime: 8242,
          Prime: 8243,
          lsaquo: 8249,
          rsaquo: 8250,
          oline: 8254,
          frasl: 8260,
          euro: 8364,
          image: 8465,
          weierp: 8472,
          real: 8476,
          trade: 8482,
          alefsym: 8501,
          larr: 8592,
          uarr: 8593,
          rarr: 8594,
          darr: 8595,
          harr: 8596,
          crarr: 8629,
          lArr: 8656,
          uArr: 8657,
          rArr: 8658,
          dArr: 8659,
          hArr: 8660,
          forall: 8704,
          part: 8706,
          exist: 8707,
          empty: 8709,
          nabla: 8711,
          isin: 8712,
          notin: 8713,
          ni: 8715,
          prod: 8719,
          sum: 8721,
          minus: 8722,
          lowast: 8727,
          radic: 8730,
          prop: 8733,
          infin: 8734,
          ang: 8736,
          and: 8743,
          or: 8744,
          cap: 8745,
          cup: 8746,
          int: 8747,
          there4: 8756,
          sim: 8764,
          cong: 8773,
          asymp: 8776,
          ne: 8800,
          equiv: 8801,
          le: 8804,
          ge: 8805,
          sub: 8834,
          sup: 8835,
          nsub: 8836,
          sube: 8838,
          supe: 8839,
          oplus: 8853,
          otimes: 8855,
          perp: 8869,
          sdot: 8901,
          lceil: 8968,
          rceil: 8969,
          lfloor: 8970,
          rfloor: 8971,
          lang: 9001,
          rang: 9002,
          loz: 9674,
          spades: 9824,
          clubs: 9827,
          hearts: 9829,
          diams: 9830
        };
        Object.keys(sax.ENTITIES).forEach(function(key) {
          var e2 = sax.ENTITIES[key];
          var s3 = typeof e2 === "number" ? String.fromCharCode(e2) : e2;
          sax.ENTITIES[key] = s3;
        });
        for (var s2 in sax.STATE) {
          sax.STATE[sax.STATE[s2]] = s2;
        }
        S2 = sax.STATE;
        function emit(parser, event, data) {
          parser[event] && parser[event](data);
        }
        function emitNode(parser, nodeType, data) {
          if (parser.textNode) closeText(parser);
          emit(parser, nodeType, data);
        }
        function closeText(parser) {
          parser.textNode = textopts(parser.opt, parser.textNode);
          if (parser.textNode) emit(parser, "ontext", parser.textNode);
          parser.textNode = "";
        }
        function textopts(opt, text) {
          if (opt.trim) text = text.trim();
          if (opt.normalize) text = text.replace(/\s+/g, " ");
          return text;
        }
        function error(parser, er) {
          closeText(parser);
          if (parser.trackPosition) {
            er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
          }
          er = new Error(er);
          parser.error = er;
          emit(parser, "onerror", er);
          return parser;
        }
        function end(parser) {
          if (parser.sawRoot && !parser.closedRoot)
            strictFail(parser, "Unclosed root tag");
          if (parser.state !== S2.BEGIN && parser.state !== S2.BEGIN_WHITESPACE && parser.state !== S2.TEXT) {
            error(parser, "Unexpected end");
          }
          closeText(parser);
          parser.c = "";
          parser.closed = true;
          emit(parser, "onend");
          SAXParser.call(parser, parser.strict, parser.opt);
          return parser;
        }
        function strictFail(parser, message) {
          if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
            throw new Error("bad call to strictFail");
          }
          if (parser.strict) {
            error(parser, message);
          }
        }
        function newTag(parser) {
          if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
          var parent = parser.tags[parser.tags.length - 1] || parser;
          var tag = parser.tag = { name: parser.tagName, attributes: {} };
          if (parser.opt.xmlns) {
            tag.ns = parent.ns;
          }
          parser.attribList.length = 0;
          emitNode(parser, "onopentagstart", tag);
        }
        function qname(name, attribute) {
          var i2 = name.indexOf(":");
          var qualName = i2 < 0 ? ["", name] : name.split(":");
          var prefix = qualName[0];
          var local = qualName[1];
          if (attribute && name === "xmlns") {
            prefix = "xmlns";
            local = "";
          }
          return { prefix, local };
        }
        function attrib(parser) {
          if (!parser.strict) {
            parser.attribName = parser.attribName[parser.looseCase]();
          }
          if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
            parser.attribName = parser.attribValue = "";
            return;
          }
          if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === "xmlns") {
              if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
                strictFail(
                  parser,
                  "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
                );
              } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
                strictFail(
                  parser,
                  "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
                );
              } else {
                var tag = parser.tag;
                var parent = parser.tags[parser.tags.length - 1] || parser;
                if (tag.ns === parent.ns) {
                  tag.ns = Object.create(parent.ns);
                }
                tag.ns[local] = parser.attribValue;
              }
            }
            parser.attribList.push([parser.attribName, parser.attribValue]);
          } else {
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, "onattribute", {
              name: parser.attribName,
              value: parser.attribValue
            });
          }
          parser.attribName = parser.attribValue = "";
        }
        function openTag(parser, selfClosing) {
          if (parser.opt.xmlns) {
            var tag = parser.tag;
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || "";
            if (tag.prefix && !tag.uri) {
              strictFail(
                parser,
                "Unbound namespace prefix: " + JSON.stringify(parser.tagName)
              );
              tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) {
              Object.keys(tag.ns).forEach(function(p2) {
                emitNode(parser, "onopennamespace", {
                  prefix: p2,
                  uri: tag.ns[p2]
                });
              });
            }
            for (var i2 = 0, l2 = parser.attribList.length; i2 < l2; i2++) {
              var nv = parser.attribList[i2];
              var name = nv[0];
              var value = nv[1];
              var qualName = qname(name, true);
              var prefix = qualName.prefix;
              var local = qualName.local;
              var uri = prefix === "" ? "" : tag.ns[prefix] || "";
              var a2 = {
                name,
                value,
                prefix,
                local,
                uri
              };
              if (prefix && prefix !== "xmlns" && !uri) {
                strictFail(
                  parser,
                  "Unbound namespace prefix: " + JSON.stringify(prefix)
                );
                a2.uri = prefix;
              }
              parser.tag.attributes[name] = a2;
              emitNode(parser, "onattribute", a2);
            }
            parser.attribList.length = 0;
          }
          parser.tag.isSelfClosing = !!selfClosing;
          parser.sawRoot = true;
          parser.tags.push(parser.tag);
          emitNode(parser, "onopentag", parser.tag);
          if (!selfClosing) {
            if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
              parser.state = S2.SCRIPT;
            } else {
              parser.state = S2.TEXT;
            }
            parser.tag = null;
            parser.tagName = "";
          }
          parser.attribName = parser.attribValue = "";
          parser.attribList.length = 0;
        }
        function closeTag(parser) {
          if (!parser.tagName) {
            strictFail(parser, "Weird empty close tag.");
            parser.textNode += "</>";
            parser.state = S2.TEXT;
            return;
          }
          if (parser.script) {
            if (parser.tagName !== "script") {
              parser.script += "</" + parser.tagName + ">";
              parser.tagName = "";
              parser.state = S2.SCRIPT;
              return;
            }
            emitNode(parser, "onscript", parser.script);
            parser.script = "";
          }
          var t2 = parser.tags.length;
          var tagName = parser.tagName;
          if (!parser.strict) {
            tagName = tagName[parser.looseCase]();
          }
          var closeTo = tagName;
          while (t2--) {
            var close = parser.tags[t2];
            if (close.name !== closeTo) {
              strictFail(parser, "Unexpected close tag");
            } else {
              break;
            }
          }
          if (t2 < 0) {
            strictFail(parser, "Unmatched closing tag: " + parser.tagName);
            parser.textNode += "</" + parser.tagName + ">";
            parser.state = S2.TEXT;
            return;
          }
          parser.tagName = tagName;
          var s3 = parser.tags.length;
          while (s3-- > t2) {
            var tag = parser.tag = parser.tags.pop();
            parser.tagName = parser.tag.name;
            emitNode(parser, "onclosetag", parser.tagName);
            var x2 = {};
            for (var i2 in tag.ns) {
              x2[i2] = tag.ns[i2];
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) {
              Object.keys(tag.ns).forEach(function(p2) {
                var n2 = tag.ns[p2];
                emitNode(parser, "onclosenamespace", { prefix: p2, uri: n2 });
              });
            }
          }
          if (t2 === 0) parser.closedRoot = true;
          parser.tagName = parser.attribValue = parser.attribName = "";
          parser.attribList.length = 0;
          parser.state = S2.TEXT;
        }
        function parseEntity(parser) {
          var entity = parser.entity;
          var entityLC = entity.toLowerCase();
          var num;
          var numStr = "";
          if (parser.ENTITIES[entity]) {
            return parser.ENTITIES[entity];
          }
          if (parser.ENTITIES[entityLC]) {
            return parser.ENTITIES[entityLC];
          }
          entity = entityLC;
          if (entity.charAt(0) === "#") {
            if (entity.charAt(1) === "x") {
              entity = entity.slice(2);
              num = parseInt(entity, 16);
              numStr = num.toString(16);
            } else {
              entity = entity.slice(1);
              num = parseInt(entity, 10);
              numStr = num.toString(10);
            }
          }
          entity = entity.replace(/^0+/, "");
          if (isNaN(num) || numStr.toLowerCase() !== entity || num < 0 || num > 1114111) {
            strictFail(parser, "Invalid character entity");
            return "&" + parser.entity + ";";
          }
          return String.fromCodePoint(num);
        }
        function beginWhiteSpace(parser, c2) {
          if (c2 === "<") {
            parser.state = S2.OPEN_WAKA;
            parser.startTagPosition = parser.position;
          } else if (!isWhitespace(c2)) {
            strictFail(parser, "Non-whitespace before first tag.");
            parser.textNode = c2;
            parser.state = S2.TEXT;
          }
        }
        function charAt(chunk, i2) {
          var result = "";
          if (i2 < chunk.length) {
            result = chunk.charAt(i2);
          }
          return result;
        }
        function write(chunk) {
          var parser = this;
          if (this.error) {
            throw this.error;
          }
          if (parser.closed) {
            return error(
              parser,
              "Cannot write after close. Assign an onready handler."
            );
          }
          if (chunk === null) {
            return end(parser);
          }
          if (typeof chunk === "object") {
            chunk = chunk.toString();
          }
          var i2 = 0;
          var c2 = "";
          while (true) {
            c2 = charAt(chunk, i2++);
            parser.c = c2;
            if (!c2) {
              break;
            }
            if (parser.trackPosition) {
              parser.position++;
              if (c2 === "\n") {
                parser.line++;
                parser.column = 0;
              } else {
                parser.column++;
              }
            }
            switch (parser.state) {
              case S2.BEGIN:
                parser.state = S2.BEGIN_WHITESPACE;
                if (c2 === "\uFEFF") {
                  continue;
                }
                beginWhiteSpace(parser, c2);
                continue;
              case S2.BEGIN_WHITESPACE:
                beginWhiteSpace(parser, c2);
                continue;
              case S2.TEXT:
                if (parser.sawRoot && !parser.closedRoot) {
                  var starti = i2 - 1;
                  while (c2 && c2 !== "<" && c2 !== "&") {
                    c2 = charAt(chunk, i2++);
                    if (c2 && parser.trackPosition) {
                      parser.position++;
                      if (c2 === "\n") {
                        parser.line++;
                        parser.column = 0;
                      } else {
                        parser.column++;
                      }
                    }
                  }
                  parser.textNode += chunk.substring(starti, i2 - 1);
                }
                if (c2 === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                  parser.state = S2.OPEN_WAKA;
                  parser.startTagPosition = parser.position;
                } else {
                  if (!isWhitespace(c2) && (!parser.sawRoot || parser.closedRoot)) {
                    strictFail(parser, "Text data outside of root node.");
                  }
                  if (c2 === "&") {
                    parser.state = S2.TEXT_ENTITY;
                  } else {
                    parser.textNode += c2;
                  }
                }
                continue;
              case S2.SCRIPT:
                if (c2 === "<") {
                  parser.state = S2.SCRIPT_ENDING;
                } else {
                  parser.script += c2;
                }
                continue;
              case S2.SCRIPT_ENDING:
                if (c2 === "/") {
                  parser.state = S2.CLOSE_TAG;
                } else {
                  parser.script += "<" + c2;
                  parser.state = S2.SCRIPT;
                }
                continue;
              case S2.OPEN_WAKA:
                if (c2 === "!") {
                  parser.state = S2.SGML_DECL;
                  parser.sgmlDecl = "";
                } else if (isWhitespace(c2)) {
                } else if (isMatch(nameStart, c2)) {
                  parser.state = S2.OPEN_TAG;
                  parser.tagName = c2;
                } else if (c2 === "/") {
                  parser.state = S2.CLOSE_TAG;
                  parser.tagName = "";
                } else if (c2 === "?") {
                  parser.state = S2.PROC_INST;
                  parser.procInstName = parser.procInstBody = "";
                } else {
                  strictFail(parser, "Unencoded <");
                  if (parser.startTagPosition + 1 < parser.position) {
                    var pad = parser.position - parser.startTagPosition;
                    c2 = new Array(pad).join(" ") + c2;
                  }
                  parser.textNode += "<" + c2;
                  parser.state = S2.TEXT;
                }
                continue;
              case S2.SGML_DECL:
                if (parser.sgmlDecl + c2 === "--") {
                  parser.state = S2.COMMENT;
                  parser.comment = "";
                  parser.sgmlDecl = "";
                  continue;
                }
                if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                  parser.state = S2.DOCTYPE_DTD;
                  parser.doctype += "<!" + parser.sgmlDecl + c2;
                  parser.sgmlDecl = "";
                } else if ((parser.sgmlDecl + c2).toUpperCase() === CDATA) {
                  emitNode(parser, "onopencdata");
                  parser.state = S2.CDATA;
                  parser.sgmlDecl = "";
                  parser.cdata = "";
                } else if ((parser.sgmlDecl + c2).toUpperCase() === DOCTYPE) {
                  parser.state = S2.DOCTYPE;
                  if (parser.doctype || parser.sawRoot) {
                    strictFail(
                      parser,
                      "Inappropriately located doctype declaration"
                    );
                  }
                  parser.doctype = "";
                  parser.sgmlDecl = "";
                } else if (c2 === ">") {
                  emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                  parser.sgmlDecl = "";
                  parser.state = S2.TEXT;
                } else if (isQuote(c2)) {
                  parser.state = S2.SGML_DECL_QUOTED;
                  parser.sgmlDecl += c2;
                } else {
                  parser.sgmlDecl += c2;
                }
                continue;
              case S2.SGML_DECL_QUOTED:
                if (c2 === parser.q) {
                  parser.state = S2.SGML_DECL;
                  parser.q = "";
                }
                parser.sgmlDecl += c2;
                continue;
              case S2.DOCTYPE:
                if (c2 === ">") {
                  parser.state = S2.TEXT;
                  emitNode(parser, "ondoctype", parser.doctype);
                  parser.doctype = true;
                } else {
                  parser.doctype += c2;
                  if (c2 === "[") {
                    parser.state = S2.DOCTYPE_DTD;
                  } else if (isQuote(c2)) {
                    parser.state = S2.DOCTYPE_QUOTED;
                    parser.q = c2;
                  }
                }
                continue;
              case S2.DOCTYPE_QUOTED:
                parser.doctype += c2;
                if (c2 === parser.q) {
                  parser.q = "";
                  parser.state = S2.DOCTYPE;
                }
                continue;
              case S2.DOCTYPE_DTD:
                if (c2 === "]") {
                  parser.doctype += c2;
                  parser.state = S2.DOCTYPE;
                } else if (c2 === "<") {
                  parser.state = S2.OPEN_WAKA;
                  parser.startTagPosition = parser.position;
                } else if (isQuote(c2)) {
                  parser.doctype += c2;
                  parser.state = S2.DOCTYPE_DTD_QUOTED;
                  parser.q = c2;
                } else {
                  parser.doctype += c2;
                }
                continue;
              case S2.DOCTYPE_DTD_QUOTED:
                parser.doctype += c2;
                if (c2 === parser.q) {
                  parser.state = S2.DOCTYPE_DTD;
                  parser.q = "";
                }
                continue;
              case S2.COMMENT:
                if (c2 === "-") {
                  parser.state = S2.COMMENT_ENDING;
                } else {
                  parser.comment += c2;
                }
                continue;
              case S2.COMMENT_ENDING:
                if (c2 === "-") {
                  parser.state = S2.COMMENT_ENDED;
                  parser.comment = textopts(parser.opt, parser.comment);
                  if (parser.comment) {
                    emitNode(parser, "oncomment", parser.comment);
                  }
                  parser.comment = "";
                } else {
                  parser.comment += "-" + c2;
                  parser.state = S2.COMMENT;
                }
                continue;
              case S2.COMMENT_ENDED:
                if (c2 !== ">") {
                  strictFail(parser, "Malformed comment");
                  parser.comment += "--" + c2;
                  parser.state = S2.COMMENT;
                } else if (parser.doctype && parser.doctype !== true) {
                  parser.state = S2.DOCTYPE_DTD;
                } else {
                  parser.state = S2.TEXT;
                }
                continue;
              case S2.CDATA:
                var starti = i2 - 1;
                while (c2 && c2 !== "]") {
                  c2 = charAt(chunk, i2++);
                  if (c2 && parser.trackPosition) {
                    parser.position++;
                    if (c2 === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.cdata += chunk.substring(starti, i2 - 1);
                if (c2 === "]") {
                  parser.state = S2.CDATA_ENDING;
                }
                continue;
              case S2.CDATA_ENDING:
                if (c2 === "]") {
                  parser.state = S2.CDATA_ENDING_2;
                } else {
                  parser.cdata += "]" + c2;
                  parser.state = S2.CDATA;
                }
                continue;
              case S2.CDATA_ENDING_2:
                if (c2 === ">") {
                  if (parser.cdata) {
                    emitNode(parser, "oncdata", parser.cdata);
                  }
                  emitNode(parser, "onclosecdata");
                  parser.cdata = "";
                  parser.state = S2.TEXT;
                } else if (c2 === "]") {
                  parser.cdata += "]";
                } else {
                  parser.cdata += "]]" + c2;
                  parser.state = S2.CDATA;
                }
                continue;
              case S2.PROC_INST:
                if (c2 === "?") {
                  parser.state = S2.PROC_INST_ENDING;
                } else if (isWhitespace(c2)) {
                  parser.state = S2.PROC_INST_BODY;
                } else {
                  parser.procInstName += c2;
                }
                continue;
              case S2.PROC_INST_BODY:
                if (!parser.procInstBody && isWhitespace(c2)) {
                  continue;
                } else if (c2 === "?") {
                  parser.state = S2.PROC_INST_ENDING;
                } else {
                  parser.procInstBody += c2;
                }
                continue;
              case S2.PROC_INST_ENDING:
                if (c2 === ">") {
                  emitNode(parser, "onprocessinginstruction", {
                    name: parser.procInstName,
                    body: parser.procInstBody
                  });
                  parser.procInstName = parser.procInstBody = "";
                  parser.state = S2.TEXT;
                } else {
                  parser.procInstBody += "?" + c2;
                  parser.state = S2.PROC_INST_BODY;
                }
                continue;
              case S2.OPEN_TAG:
                if (isMatch(nameBody, c2)) {
                  parser.tagName += c2;
                } else {
                  newTag(parser);
                  if (c2 === ">") {
                    openTag(parser);
                  } else if (c2 === "/") {
                    parser.state = S2.OPEN_TAG_SLASH;
                  } else {
                    if (!isWhitespace(c2)) {
                      strictFail(parser, "Invalid character in tag name");
                    }
                    parser.state = S2.ATTRIB;
                  }
                }
                continue;
              case S2.OPEN_TAG_SLASH:
                if (c2 === ">") {
                  openTag(parser, true);
                  closeTag(parser);
                } else {
                  strictFail(
                    parser,
                    "Forward-slash in opening tag not followed by >"
                  );
                  parser.state = S2.ATTRIB;
                }
                continue;
              case S2.ATTRIB:
                if (isWhitespace(c2)) {
                  continue;
                } else if (c2 === ">") {
                  openTag(parser);
                } else if (c2 === "/") {
                  parser.state = S2.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c2)) {
                  parser.attribName = c2;
                  parser.attribValue = "";
                  parser.state = S2.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S2.ATTRIB_NAME:
                if (c2 === "=") {
                  parser.state = S2.ATTRIB_VALUE;
                } else if (c2 === ">") {
                  strictFail(parser, "Attribute without value");
                  parser.attribValue = parser.attribName;
                  attrib(parser);
                  openTag(parser);
                } else if (isWhitespace(c2)) {
                  parser.state = S2.ATTRIB_NAME_SAW_WHITE;
                } else if (isMatch(nameBody, c2)) {
                  parser.attribName += c2;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S2.ATTRIB_NAME_SAW_WHITE:
                if (c2 === "=") {
                  parser.state = S2.ATTRIB_VALUE;
                } else if (isWhitespace(c2)) {
                  continue;
                } else {
                  strictFail(parser, "Attribute without value");
                  parser.tag.attributes[parser.attribName] = "";
                  parser.attribValue = "";
                  emitNode(parser, "onattribute", {
                    name: parser.attribName,
                    value: ""
                  });
                  parser.attribName = "";
                  if (c2 === ">") {
                    openTag(parser);
                  } else if (isMatch(nameStart, c2)) {
                    parser.attribName = c2;
                    parser.state = S2.ATTRIB_NAME;
                  } else {
                    strictFail(parser, "Invalid attribute name");
                    parser.state = S2.ATTRIB;
                  }
                }
                continue;
              case S2.ATTRIB_VALUE:
                if (isWhitespace(c2)) {
                  continue;
                } else if (isQuote(c2)) {
                  parser.q = c2;
                  parser.state = S2.ATTRIB_VALUE_QUOTED;
                } else {
                  if (!parser.opt.unquotedAttributeValues) {
                    error(parser, "Unquoted attribute value");
                  }
                  parser.state = S2.ATTRIB_VALUE_UNQUOTED;
                  parser.attribValue = c2;
                }
                continue;
              case S2.ATTRIB_VALUE_QUOTED:
                if (c2 !== parser.q) {
                  if (c2 === "&") {
                    parser.state = S2.ATTRIB_VALUE_ENTITY_Q;
                  } else {
                    parser.attribValue += c2;
                  }
                  continue;
                }
                attrib(parser);
                parser.q = "";
                parser.state = S2.ATTRIB_VALUE_CLOSED;
                continue;
              case S2.ATTRIB_VALUE_CLOSED:
                if (isWhitespace(c2)) {
                  parser.state = S2.ATTRIB;
                } else if (c2 === ">") {
                  openTag(parser);
                } else if (c2 === "/") {
                  parser.state = S2.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c2)) {
                  strictFail(parser, "No whitespace between attributes");
                  parser.attribName = c2;
                  parser.attribValue = "";
                  parser.state = S2.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                }
                continue;
              case S2.ATTRIB_VALUE_UNQUOTED:
                if (!isAttribEnd(c2)) {
                  if (c2 === "&") {
                    parser.state = S2.ATTRIB_VALUE_ENTITY_U;
                  } else {
                    parser.attribValue += c2;
                  }
                  continue;
                }
                attrib(parser);
                if (c2 === ">") {
                  openTag(parser);
                } else {
                  parser.state = S2.ATTRIB;
                }
                continue;
              case S2.CLOSE_TAG:
                if (!parser.tagName) {
                  if (isWhitespace(c2)) {
                    continue;
                  } else if (notMatch(nameStart, c2)) {
                    if (parser.script) {
                      parser.script += "</" + c2;
                      parser.state = S2.SCRIPT;
                    } else {
                      strictFail(parser, "Invalid tagname in closing tag.");
                    }
                  } else {
                    parser.tagName = c2;
                  }
                } else if (c2 === ">") {
                  closeTag(parser);
                } else if (isMatch(nameBody, c2)) {
                  parser.tagName += c2;
                } else if (parser.script) {
                  parser.script += "</" + parser.tagName + c2;
                  parser.tagName = "";
                  parser.state = S2.SCRIPT;
                } else {
                  if (!isWhitespace(c2)) {
                    strictFail(parser, "Invalid tagname in closing tag");
                  }
                  parser.state = S2.CLOSE_TAG_SAW_WHITE;
                }
                continue;
              case S2.CLOSE_TAG_SAW_WHITE:
                if (isWhitespace(c2)) {
                  continue;
                }
                if (c2 === ">") {
                  closeTag(parser);
                } else {
                  strictFail(parser, "Invalid characters in closing tag");
                }
                continue;
              case S2.TEXT_ENTITY:
              case S2.ATTRIB_VALUE_ENTITY_Q:
              case S2.ATTRIB_VALUE_ENTITY_U:
                var returnState;
                var buffer;
                switch (parser.state) {
                  case S2.TEXT_ENTITY:
                    returnState = S2.TEXT;
                    buffer = "textNode";
                    break;
                  case S2.ATTRIB_VALUE_ENTITY_Q:
                    returnState = S2.ATTRIB_VALUE_QUOTED;
                    buffer = "attribValue";
                    break;
                  case S2.ATTRIB_VALUE_ENTITY_U:
                    returnState = S2.ATTRIB_VALUE_UNQUOTED;
                    buffer = "attribValue";
                    break;
                }
                if (c2 === ";") {
                  var parsedEntity = parseEntity(parser);
                  if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
                    parser.entity = "";
                    parser.state = returnState;
                    parser.write(parsedEntity);
                  } else {
                    parser[buffer] += parsedEntity;
                    parser.entity = "";
                    parser.state = returnState;
                  }
                } else if (isMatch(parser.entity.length ? entityBody : entityStart, c2)) {
                  parser.entity += c2;
                } else {
                  strictFail(parser, "Invalid character in entity name");
                  parser[buffer] += "&" + parser.entity + c2;
                  parser.entity = "";
                  parser.state = returnState;
                }
                continue;
              default: {
                throw new Error(parser, "Unknown state: " + parser.state);
              }
            }
          }
          if (parser.position >= parser.bufferCheckPosition) {
            checkBufferLength(parser);
          }
          return parser;
        }
        if (!String.fromCodePoint) {
          ;
          (function() {
            var stringFromCharCode = String.fromCharCode;
            var floor = Math.floor;
            var fromCodePoint = function() {
              var MAX_SIZE = 16384;
              var codeUnits = [];
              var highSurrogate;
              var lowSurrogate;
              var index = -1;
              var length = arguments.length;
              if (!length) {
                return "";
              }
              var result = "";
              while (++index < length) {
                var codePoint = Number(arguments[index]);
                if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                codePoint < 0 || // not a valid Unicode code point
                codePoint > 1114111 || // not a valid Unicode code point
                floor(codePoint) !== codePoint) {
                  throw RangeError("Invalid code point: " + codePoint);
                }
                if (codePoint <= 65535) {
                  codeUnits.push(codePoint);
                } else {
                  codePoint -= 65536;
                  highSurrogate = (codePoint >> 10) + 55296;
                  lowSurrogate = codePoint % 1024 + 56320;
                  codeUnits.push(highSurrogate, lowSurrogate);
                }
                if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                  result += stringFromCharCode.apply(null, codeUnits);
                  codeUnits.length = 0;
                }
              }
              return result;
            };
            if (Object.defineProperty) {
              Object.defineProperty(String, "fromCodePoint", {
                value: fromCodePoint,
                configurable: true,
                writable: true
              });
            } else {
              String.fromCodePoint = fromCodePoint;
            }
          })();
        }
      })(typeof exports === "undefined" ? exports.sax = {} : exports);
    }
  });

  // ../node_modules/events/events.js
  var require_events = __commonJS({
    "../node_modules/events/events.js"(exports, module) {
      "use strict";
      var R2 = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R2 && typeof R2.ownKeys === "function") {
        ReflectOwnKeys = R2.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module.exports = EventEmitter;
      module.exports.once = once;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
        if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
        }
        this._maxListeners = n2;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type) {
        var args = [];
        for (var i2 = 1; i2 < arguments.length; i2++) args.push(arguments[i2]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i2 = 0; i2 < len; ++i2)
            ReflectApply(listeners[i2], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m2;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m2 = _getMaxListeners(target);
          if (m2 > 0 && existing.length > m2 && !existing.warned) {
            existing.warned = true;
            var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w2.name = "MaxListenersExceededWarning";
            w2.emitter = target;
            w2.type = type;
            w2.count = existing.length;
            ProcessEmitWarning(w2);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position2, i2, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position2 = -1;
          for (i2 = list.length - 1; i2 >= 0; i2--) {
            if (list[i2] === listener || list[i2].listener === listener) {
              originalListener = list[i2].listener;
              position2 = i2;
              break;
            }
          }
          if (position2 < 0)
            return this;
          if (position2 === 0)
            list.shift();
          else {
            spliceOne(list, position2);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i2;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i2 = 0; i2 < keys.length; ++i2) {
            key = keys[i2];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i2 = listeners.length - 1; i2 >= 0; i2--) {
            this.removeListener(type, listeners[i2]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n2) {
        var copy2 = new Array(n2);
        for (var i2 = 0; i2 < n2; ++i2)
          copy2[i2] = arr[i2];
        return copy2;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i2 = 0; i2 < ret.length; ++i2) {
          ret[i2] = arr[i2].listener || arr[i2];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // node_modules/xml2js/lib/bom.js
  var require_bom = __commonJS({
    "node_modules/xml2js/lib/bom.js"(exports) {
      (function() {
        "use strict";
        exports.stripBOM = function(str) {
          if (str[0] === "\uFEFF") {
            return str.substring(1);
          } else {
            return str;
          }
        };
      }).call(exports);
    }
  });

  // node_modules/xml2js/lib/processors.js
  var require_processors = __commonJS({
    "node_modules/xml2js/lib/processors.js"(exports) {
      (function() {
        "use strict";
        var prefixMatch;
        prefixMatch = new RegExp(/(?!xmlns)^.*:/);
        exports.normalize = function(str) {
          return str.toLowerCase();
        };
        exports.firstCharLowerCase = function(str) {
          return str.charAt(0).toLowerCase() + str.slice(1);
        };
        exports.stripPrefix = function(str) {
          return str.replace(prefixMatch, "");
        };
        exports.parseNumbers = function(str) {
          if (!isNaN(str)) {
            str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
          }
          return str;
        };
        exports.parseBooleans = function(str) {
          if (/^(?:true|false)$/i.test(str)) {
            str = str.toLowerCase() === "true";
          }
          return str;
        };
      }).call(exports);
    }
  });

  // scripts/browser-shims.mjs
  var browser_shims_exports = {};
  __export(browser_shims_exports, {
    clearImmediate: () => clearImmediate,
    setImmediate: () => setImmediate2
  });
  var setImmediate2, clearImmediate;
  var init_browser_shims = __esm({
    "scripts/browser-shims.mjs"() {
      setImmediate2 = (fn2, ...args) => setTimeout(fn2, 0, ...args);
      clearImmediate = (id2) => clearTimeout(id2);
    }
  });

  // node_modules/xml2js/lib/parser.js
  var require_parser = __commonJS({
    "node_modules/xml2js/lib/parser.js"(exports) {
      (function() {
        "use strict";
        var bom, defaults, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate3, bind = function(fn2, me) {
          return function() {
            return fn2.apply(me, arguments);
          };
        }, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        sax = require_sax();
        events = require_events();
        bom = require_bom();
        processors = require_processors();
        setImmediate3 = (init_browser_shims(), __toCommonJS(browser_shims_exports)).setImmediate;
        defaults = require_defaults().defaults;
        isEmpty = function(thing) {
          return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
        };
        processItem = function(processors2, item, key) {
          var i2, len, process2;
          for (i2 = 0, len = processors2.length; i2 < len; i2++) {
            process2 = processors2[i2];
            item = process2(item, key);
          }
          return item;
        };
        defineProperty = function(obj, key, value) {
          var descriptor;
          descriptor = /* @__PURE__ */ Object.create(null);
          descriptor.value = value;
          descriptor.writable = true;
          descriptor.enumerable = true;
          descriptor.configurable = true;
          return Object.defineProperty(obj, key, descriptor);
        };
        exports.Parser = (function(superClass) {
          extend2(Parser, superClass);
          function Parser(opts) {
            this.parseStringPromise = bind(this.parseStringPromise, this);
            this.parseString = bind(this.parseString, this);
            this.reset = bind(this.reset, this);
            this.assignOrPush = bind(this.assignOrPush, this);
            this.processAsync = bind(this.processAsync, this);
            var key, ref, value;
            if (!(this instanceof exports.Parser)) {
              return new exports.Parser(opts);
            }
            this.options = {};
            ref = defaults["0.2"];
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              value = ref[key];
              this.options[key] = value;
            }
            for (key in opts) {
              if (!hasProp.call(opts, key)) continue;
              value = opts[key];
              this.options[key] = value;
            }
            if (this.options.xmlns) {
              this.options.xmlnskey = this.options.attrkey + "ns";
            }
            if (this.options.normalizeTags) {
              if (!this.options.tagNameProcessors) {
                this.options.tagNameProcessors = [];
              }
              this.options.tagNameProcessors.unshift(processors.normalize);
            }
            this.reset();
          }
          Parser.prototype.processAsync = function() {
            var chunk, err;
            try {
              if (this.remaining.length <= this.options.chunkSize) {
                chunk = this.remaining;
                this.remaining = "";
                this.saxParser = this.saxParser.write(chunk);
                return this.saxParser.close();
              } else {
                chunk = this.remaining.substr(0, this.options.chunkSize);
                this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                this.saxParser = this.saxParser.write(chunk);
                return setImmediate3(this.processAsync);
              }
            } catch (error1) {
              err = error1;
              if (!this.saxParser.errThrown) {
                this.saxParser.errThrown = true;
                return this.emit(err);
              }
            }
          };
          Parser.prototype.assignOrPush = function(obj, key, newValue) {
            if (!(key in obj)) {
              if (!this.options.explicitArray) {
                return defineProperty(obj, key, newValue);
              } else {
                return defineProperty(obj, key, [newValue]);
              }
            } else {
              if (!(obj[key] instanceof Array)) {
                defineProperty(obj, key, [obj[key]]);
              }
              return obj[key].push(newValue);
            }
          };
          Parser.prototype.reset = function() {
            var attrkey, charkey, ontext, stack;
            this.removeAllListeners();
            this.saxParser = sax.parser(this.options.strict, {
              trim: false,
              normalize: false,
              xmlns: this.options.xmlns
            });
            this.saxParser.errThrown = false;
            this.saxParser.onerror = /* @__PURE__ */ (function(_this) {
              return function(error) {
                _this.saxParser.resume();
                if (!_this.saxParser.errThrown) {
                  _this.saxParser.errThrown = true;
                  return _this.emit("error", error);
                }
              };
            })(this);
            this.saxParser.onend = /* @__PURE__ */ (function(_this) {
              return function() {
                if (!_this.saxParser.ended) {
                  _this.saxParser.ended = true;
                  return _this.emit("end", _this.resultObject);
                }
              };
            })(this);
            this.saxParser.ended = false;
            this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
            this.resultObject = null;
            stack = [];
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            this.saxParser.onopentag = /* @__PURE__ */ (function(_this) {
              return function(node) {
                var key, newValue, obj, processedKey, ref;
                obj = {};
                obj[charkey] = "";
                if (!_this.options.ignoreAttrs) {
                  ref = node.attributes;
                  for (key in ref) {
                    if (!hasProp.call(ref, key)) continue;
                    if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                      obj[attrkey] = {};
                    }
                    newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                    processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                    if (_this.options.mergeAttrs) {
                      _this.assignOrPush(obj, processedKey, newValue);
                    } else {
                      defineProperty(obj[attrkey], processedKey, newValue);
                    }
                  }
                }
                obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
                if (_this.options.xmlns) {
                  obj[_this.options.xmlnskey] = {
                    uri: node.uri,
                    local: node.local
                  };
                }
                return stack.push(obj);
              };
            })(this);
            this.saxParser.onclosetag = /* @__PURE__ */ (function(_this) {
              return function() {
                var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s2, xpath;
                obj = stack.pop();
                nodeName = obj["#name"];
                if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                  delete obj["#name"];
                }
                if (obj.cdata === true) {
                  cdata = obj.cdata;
                  delete obj.cdata;
                }
                s2 = stack[stack.length - 1];
                if (obj[charkey].match(/^\s*$/) && !cdata) {
                  emptyStr = obj[charkey];
                  delete obj[charkey];
                } else {
                  if (_this.options.trim) {
                    obj[charkey] = obj[charkey].trim();
                  }
                  if (_this.options.normalize) {
                    obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                  }
                  obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                  if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                    obj = obj[charkey];
                  }
                }
                if (isEmpty(obj)) {
                  if (typeof _this.options.emptyTag === "function") {
                    obj = _this.options.emptyTag();
                  } else {
                    obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
                  }
                }
                if (_this.options.validator != null) {
                  xpath = "/" + (function() {
                    var i2, len, results;
                    results = [];
                    for (i2 = 0, len = stack.length; i2 < len; i2++) {
                      node = stack[i2];
                      results.push(node["#name"]);
                    }
                    return results;
                  })().concat(nodeName).join("/");
                  (function() {
                    var err;
                    try {
                      return obj = _this.options.validator(xpath, s2 && s2[nodeName], obj);
                    } catch (error1) {
                      err = error1;
                      return _this.emit("error", err);
                    }
                  })();
                }
                if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                  if (!_this.options.preserveChildrenOrder) {
                    node = {};
                    if (_this.options.attrkey in obj) {
                      node[_this.options.attrkey] = obj[_this.options.attrkey];
                      delete obj[_this.options.attrkey];
                    }
                    if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                      node[_this.options.charkey] = obj[_this.options.charkey];
                      delete obj[_this.options.charkey];
                    }
                    if (Object.getOwnPropertyNames(obj).length > 0) {
                      node[_this.options.childkey] = obj;
                    }
                    obj = node;
                  } else if (s2) {
                    s2[_this.options.childkey] = s2[_this.options.childkey] || [];
                    objClone = {};
                    for (key in obj) {
                      if (!hasProp.call(obj, key)) continue;
                      defineProperty(objClone, key, obj[key]);
                    }
                    s2[_this.options.childkey].push(objClone);
                    delete obj["#name"];
                    if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                      obj = obj[charkey];
                    }
                  }
                }
                if (stack.length > 0) {
                  return _this.assignOrPush(s2, nodeName, obj);
                } else {
                  if (_this.options.explicitRoot) {
                    old = obj;
                    obj = {};
                    defineProperty(obj, nodeName, old);
                  }
                  _this.resultObject = obj;
                  _this.saxParser.ended = true;
                  return _this.emit("end", _this.resultObject);
                }
              };
            })(this);
            ontext = /* @__PURE__ */ (function(_this) {
              return function(text) {
                var charChild, s2;
                s2 = stack[stack.length - 1];
                if (s2) {
                  s2[charkey] += text;
                  if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")) {
                    s2[_this.options.childkey] = s2[_this.options.childkey] || [];
                    charChild = {
                      "#name": "__text__"
                    };
                    charChild[charkey] = text;
                    if (_this.options.normalize) {
                      charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                    }
                    s2[_this.options.childkey].push(charChild);
                  }
                  return s2;
                }
              };
            })(this);
            this.saxParser.ontext = ontext;
            return this.saxParser.oncdata = /* @__PURE__ */ (function(_this) {
              return function(text) {
                var s2;
                s2 = ontext(text);
                if (s2) {
                  return s2.cdata = true;
                }
              };
            })(this);
          };
          Parser.prototype.parseString = function(str, cb) {
            var err;
            if (cb != null && typeof cb === "function") {
              this.on("end", function(result) {
                this.reset();
                return cb(null, result);
              });
              this.on("error", function(err2) {
                this.reset();
                return cb(err2);
              });
            }
            try {
              str = str.toString();
              if (str.trim() === "") {
                this.emit("end", null);
                return true;
              }
              str = bom.stripBOM(str);
              if (this.options.async) {
                this.remaining = str;
                setImmediate3(this.processAsync);
                return this.saxParser;
              }
              return this.saxParser.write(str).close();
            } catch (error1) {
              err = error1;
              if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                this.emit("error", err);
                return this.saxParser.errThrown = true;
              } else if (this.saxParser.ended) {
                throw err;
              }
            }
          };
          Parser.prototype.parseStringPromise = function(str) {
            return new Promise(/* @__PURE__ */ (function(_this) {
              return function(resolve, reject) {
                return _this.parseString(str, function(err, value) {
                  if (err) {
                    return reject(err);
                  } else {
                    return resolve(value);
                  }
                });
              };
            })(this));
          };
          return Parser;
        })(events);
        exports.parseString = function(str, a2, b2) {
          var cb, options, parser;
          if (b2 != null) {
            if (typeof b2 === "function") {
              cb = b2;
            }
            if (typeof a2 === "object") {
              options = a2;
            }
          } else {
            if (typeof a2 === "function") {
              cb = a2;
            }
            options = {};
          }
          parser = new exports.Parser(options);
          return parser.parseString(str, cb);
        };
        exports.parseStringPromise = function(str, a2) {
          var options, parser;
          if (typeof a2 === "object") {
            options = a2;
          }
          parser = new exports.Parser(options);
          return parser.parseStringPromise(str);
        };
      }).call(exports);
    }
  });

  // node_modules/xml2js/lib/xml2js.js
  var require_xml2js = __commonJS({
    "node_modules/xml2js/lib/xml2js.js"(exports) {
      (function() {
        "use strict";
        var builder, defaults, parser, processors, extend2 = function(child, parent) {
          for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        }, hasProp = {}.hasOwnProperty;
        defaults = require_defaults();
        builder = require_builder();
        parser = require_parser();
        processors = require_processors();
        exports.defaults = defaults.defaults;
        exports.processors = processors;
        exports.ValidationError = (function(superClass) {
          extend2(ValidationError, superClass);
          function ValidationError(message) {
            this.message = message;
          }
          return ValidationError;
        })(Error);
        exports.Builder = builder.Builder;
        exports.Parser = parser.Parser;
        exports.parseString = parser.parseString;
        exports.parseStringPromise = parser.parseStringPromise;
      }).call(exports);
    }
  });

  // standalone.tsx
  var import_react24 = __toESM(require_react(), 1);
  var import_client = __toESM(require_client(), 1);

  // components/ModelVisualizer.tsx
  var import_react23 = __toESM(require_react(), 1);

  // node_modules/@reactflow/core/dist/esm/index.mjs
  var import_react2 = __toESM(require_react(), 1);

  // node_modules/classcat/index.js
  function cc(names) {
    if (typeof names === "string" || typeof names === "number") return "" + names;
    let out = "";
    if (Array.isArray(names)) {
      for (let i2 = 0, tmp; i2 < names.length; i2++) {
        if ((tmp = cc(names[i2])) !== "") {
          out += (out && " ") + tmp;
        }
      }
    } else {
      for (let k2 in names) {
        if (names[k2]) out += (out && " ") + k2;
      }
    }
    return out;
  }

  // node_modules/zustand/esm/traditional.mjs
  var import_react = __toESM(require_react(), 1);
  var import_with_selector = __toESM(require_with_selector(), 1);

  // node_modules/zustand/esm/vanilla.mjs
  var import_meta = {};
  var createStoreImpl = (createState) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const getInitialState = () => initialState2;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const destroy = () => {
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
        );
      }
      listeners.clear();
    };
    const api = { setState, getState, getInitialState, subscribe, destroy };
    const initialState2 = state = createState(setState, getState, api);
    return api;
  };
  var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

  // node_modules/zustand/esm/traditional.mjs
  var { useDebugValue } = import_react.default;
  var { useSyncExternalStoreWithSelector } = import_with_selector.default;
  var identity = (arg) => arg;
  function useStoreWithEqualityFn(api, selector3 = identity, equalityFn) {
    const slice = useSyncExternalStoreWithSelector(
      api.subscribe,
      api.getState,
      api.getServerState || api.getInitialState,
      selector3,
      equalityFn
    );
    useDebugValue(slice);
    return slice;
  }
  var createWithEqualityFnImpl = (createState, defaultEqualityFn) => {
    const api = createStore(createState);
    const useBoundStoreWithEqualityFn = (selector3, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector3, equalityFn);
    Object.assign(useBoundStoreWithEqualityFn, api);
    return useBoundStoreWithEqualityFn;
  };
  var createWithEqualityFn = (createState, defaultEqualityFn) => createState ? createWithEqualityFnImpl(createState, defaultEqualityFn) : createWithEqualityFnImpl;

  // node_modules/zustand/esm/shallow.mjs
  function shallow$1(objA, objB) {
    if (Object.is(objA, objB)) {
      return true;
    }
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
      return false;
    }
    if (objA instanceof Map && objB instanceof Map) {
      if (objA.size !== objB.size) return false;
      for (const [key, value] of objA) {
        if (!Object.is(value, objB.get(key))) {
          return false;
        }
      }
      return true;
    }
    if (objA instanceof Set && objB instanceof Set) {
      if (objA.size !== objB.size) return false;
      for (const value of objA) {
        if (!objB.has(value)) {
          return false;
        }
      }
      return true;
    }
    const keysA = Object.keys(objA);
    if (keysA.length !== Object.keys(objB).length) {
      return false;
    }
    for (const keyA of keysA) {
      if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {
        return false;
      }
    }
    return true;
  }

  // node_modules/d3-dispatch/src/dispatch.js
  var noop = { value: () => {
  } };
  function dispatch() {
    for (var i2 = 0, n2 = arguments.length, _2 = {}, t2; i2 < n2; ++i2) {
      if (!(t2 = arguments[i2] + "") || t2 in _2 || /[\s.]/.test(t2)) throw new Error("illegal type: " + t2);
      _2[t2] = [];
    }
    return new Dispatch(_2);
  }
  function Dispatch(_2) {
    this._ = _2;
  }
  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t2) {
      var name = "", i2 = t2.indexOf(".");
      if (i2 >= 0) name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
      if (t2 && !types.hasOwnProperty(t2)) throw new Error("unknown type: " + t2);
      return { type: t2, name };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _2 = this._, T2 = parseTypenames(typename + "", _2), t2, i2 = -1, n2 = T2.length;
      if (arguments.length < 2) {
        while (++i2 < n2) if ((t2 = (typename = T2[i2]).type) && (t2 = get(_2[t2], typename.name))) return t2;
        return;
      }
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i2 < n2) {
        if (t2 = (typename = T2[i2]).type) _2[t2] = set(_2[t2], typename.name, callback);
        else if (callback == null) for (t2 in _2) _2[t2] = set(_2[t2], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy2 = {}, _2 = this._;
      for (var t2 in _2) copy2[t2] = _2[t2].slice();
      return new Dispatch(copy2);
    },
    call: function(type, that) {
      if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i2 = 0, n2, t2; i2 < n2; ++i2) args[i2] = arguments[i2 + 2];
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
    },
    apply: function(type, that, args) {
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (var t2 = this._[type], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
    }
  };
  function get(type, name) {
    for (var i2 = 0, n2 = type.length, c2; i2 < n2; ++i2) {
      if ((c2 = type[i2]).name === name) {
        return c2.value;
      }
    }
  }
  function set(type, name, callback) {
    for (var i2 = 0, n2 = type.length; i2 < n2; ++i2) {
      if (type[i2].name === name) {
        type[i2] = noop, type = type.slice(0, i2).concat(type.slice(i2 + 1));
        break;
      }
    }
    if (callback != null) type.push({ name, value: callback });
    return type;
  }
  var dispatch_default = dispatch;

  // node_modules/d3-selection/src/namespaces.js
  var xhtml = "http://www.w3.org/1999/xhtml";
  var namespaces_default = {
    svg: "http://www.w3.org/2000/svg",
    xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  // node_modules/d3-selection/src/namespace.js
  function namespace_default(name) {
    var prefix = name += "", i2 = prefix.indexOf(":");
    if (i2 >= 0 && (prefix = name.slice(0, i2)) !== "xmlns") name = name.slice(i2 + 1);
    return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
  }

  // node_modules/d3-selection/src/creator.js
  function creatorInherit(name) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
    };
  }
  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator_default(name) {
    var fullname = namespace_default(name);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  }

  // node_modules/d3-selection/src/selector.js
  function none() {
  }
  function selector_default(selector3) {
    return selector3 == null ? none : function() {
      return this.querySelector(selector3);
    };
  }

  // node_modules/d3-selection/src/selection/select.js
  function select_default(select) {
    if (typeof select !== "function") select = selector_default(select);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = new Array(n2), node, subnode, i2 = 0; i2 < n2; ++i2) {
        if ((node = group[i2]) && (subnode = select.call(node, node.__data__, i2, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i2] = subnode;
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/array.js
  function array(x2) {
    return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
  }

  // node_modules/d3-selection/src/selectorAll.js
  function empty() {
    return [];
  }
  function selectorAll_default(selector3) {
    return selector3 == null ? empty : function() {
      return this.querySelectorAll(selector3);
    };
  }

  // node_modules/d3-selection/src/selection/selectAll.js
  function arrayAll(select) {
    return function() {
      return array(select.apply(this, arguments));
    };
  }
  function selectAll_default(select) {
    if (typeof select === "function") select = arrayAll(select);
    else select = selectorAll_default(select);
    for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
      for (var group = groups[j], n2 = group.length, node, i2 = 0; i2 < n2; ++i2) {
        if (node = group[i2]) {
          subgroups.push(select.call(node, node.__data__, i2, group));
          parents.push(node);
        }
      }
    }
    return new Selection(subgroups, parents);
  }

  // node_modules/d3-selection/src/matcher.js
  function matcher_default(selector3) {
    return function() {
      return this.matches(selector3);
    };
  }
  function childMatcher(selector3) {
    return function(node) {
      return node.matches(selector3);
    };
  }

  // node_modules/d3-selection/src/selection/selectChild.js
  var find = Array.prototype.find;
  function childFind(match) {
    return function() {
      return find.call(this.children, match);
    };
  }
  function childFirst() {
    return this.firstElementChild;
  }
  function selectChild_default(match) {
    return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
  }

  // node_modules/d3-selection/src/selection/selectChildren.js
  var filter = Array.prototype.filter;
  function children2() {
    return Array.from(this.children);
  }
  function childrenFilter(match) {
    return function() {
      return filter.call(this.children, match);
    };
  }
  function selectChildren_default(match) {
    return this.selectAll(match == null ? children2 : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
  }

  // node_modules/d3-selection/src/selection/filter.js
  function filter_default(match) {
    if (typeof match !== "function") match = matcher_default(match);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = [], node, i2 = 0; i2 < n2; ++i2) {
        if ((node = group[i2]) && match.call(node, node.__data__, i2, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/d3-selection/src/selection/sparse.js
  function sparse_default(update) {
    return new Array(update.length);
  }

  // node_modules/d3-selection/src/selection/enter.js
  function enter_default() {
    return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
  }
  function EnterNode(parent, datum2) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum2;
  }
  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) {
      return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next) {
      return this._parent.insertBefore(child, next);
    },
    querySelector: function(selector3) {
      return this._parent.querySelector(selector3);
    },
    querySelectorAll: function(selector3) {
      return this._parent.querySelectorAll(selector3);
    }
  };

  // node_modules/d3-selection/src/constant.js
  function constant_default(x2) {
    return function() {
      return x2;
    };
  }

  // node_modules/d3-selection/src/selection/data.js
  function bindIndex(parent, group, enter, update, exit, data) {
    var i2 = 0, node, groupLength = group.length, dataLength = data.length;
    for (; i2 < dataLength; ++i2) {
      if (node = group[i2]) {
        node.__data__ = data[i2];
        update[i2] = node;
      } else {
        enter[i2] = new EnterNode(parent, data[i2]);
      }
    }
    for (; i2 < groupLength; ++i2) {
      if (node = group[i2]) {
        exit[i2] = node;
      }
    }
  }
  function bindKey(parent, group, enter, update, exit, data, key) {
    var i2, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
    for (i2 = 0; i2 < groupLength; ++i2) {
      if (node = group[i2]) {
        keyValues[i2] = keyValue = key.call(node, node.__data__, i2, group) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i2] = node;
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
      }
    }
    for (i2 = 0; i2 < dataLength; ++i2) {
      keyValue = key.call(parent, data[i2], i2, data) + "";
      if (node = nodeByKeyValue.get(keyValue)) {
        update[i2] = node;
        node.__data__ = data[i2];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i2] = new EnterNode(parent, data[i2]);
      }
    }
    for (i2 = 0; i2 < groupLength; ++i2) {
      if ((node = group[i2]) && nodeByKeyValue.get(keyValues[i2]) === node) {
        exit[i2] = node;
      }
    }
  }
  function datum(node) {
    return node.__data__;
  }
  function data_default(value, key) {
    if (!arguments.length) return Array.from(this, datum);
    var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
    if (typeof value !== "function") value = constant_default(value);
    for (var m2 = groups.length, update = new Array(m2), enter = new Array(m2), exit = new Array(m2), j = 0; j < m2; ++j) {
      var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1) i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength) ;
          previous._next = next || null;
        }
      }
    }
    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }
  function arraylike(data) {
    return typeof data === "object" && "length" in data ? data : Array.from(data);
  }

  // node_modules/d3-selection/src/selection/exit.js
  function exit_default() {
    return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
  }

  // node_modules/d3-selection/src/selection/join.js
  function join_default(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    if (typeof onenter === "function") {
      enter = onenter(enter);
      if (enter) enter = enter.selection();
    } else {
      enter = enter.append(onenter + "");
    }
    if (onupdate != null) {
      update = onupdate(update);
      if (update) update = update.selection();
    }
    if (onexit == null) exit.remove();
    else onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }

  // node_modules/d3-selection/src/selection/merge.js
  function merge_default(context) {
    var selection2 = context.selection ? context.selection() : context;
    for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n2 = group0.length, merge = merges[j] = new Array(n2), node, i2 = 0; i2 < n2; ++i2) {
        if (node = group0[i2] || group1[i2]) {
          merge[i2] = node;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Selection(merges, this._parents);
  }

  // node_modules/d3-selection/src/selection/order.js
  function order_default() {
    for (var groups = this._groups, j = -1, m2 = groups.length; ++j < m2; ) {
      for (var group = groups[j], i2 = group.length - 1, next = group[i2], node; --i2 >= 0; ) {
        if (node = group[i2]) {
          if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/sort.js
  function sort_default(compare2) {
    if (!compare2) compare2 = ascending;
    function compareNode(a2, b2) {
      return a2 && b2 ? compare2(a2.__data__, b2.__data__) : !a2 - !b2;
    }
    for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group = groups[j], n2 = group.length, sortgroup = sortgroups[j] = new Array(n2), node, i2 = 0; i2 < n2; ++i2) {
        if (node = group[i2]) {
          sortgroup[i2] = node;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection(sortgroups, this._parents).order();
  }
  function ascending(a2, b2) {
    return a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
  }

  // node_modules/d3-selection/src/selection/call.js
  function call_default() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  // node_modules/d3-selection/src/selection/nodes.js
  function nodes_default() {
    return Array.from(this);
  }

  // node_modules/d3-selection/src/selection/node.js
  function node_default() {
    for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
      for (var group = groups[j], i2 = 0, n2 = group.length; i2 < n2; ++i2) {
        var node = group[i2];
        if (node) return node;
      }
    }
    return null;
  }

  // node_modules/d3-selection/src/selection/size.js
  function size_default() {
    let size = 0;
    for (const node of this) ++size;
    return size;
  }

  // node_modules/d3-selection/src/selection/empty.js
  function empty_default() {
    return !this.node();
  }

  // node_modules/d3-selection/src/selection/each.js
  function each_default(callback) {
    for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
      for (var group = groups[j], i2 = 0, n2 = group.length, node; i2 < n2; ++i2) {
        if (node = group[i2]) callback.call(node, node.__data__, i2, group);
      }
    }
    return this;
  }

  // node_modules/d3-selection/src/selection/attr.js
  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }
  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }
  function attrFunction(name, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null) this.removeAttribute(name);
      else this.setAttribute(name, v2);
    };
  }
  function attrFunctionNS(fullname, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v2);
    };
  }
  function attr_default(name, value) {
    var fullname = namespace_default(name);
    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
  }

  // node_modules/d3-selection/src/window.js
  function window_default(node) {
    return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
  }

  // node_modules/d3-selection/src/selection/style.js
  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }
  function styleFunction(name, value, priority) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v2, priority);
    };
  }
  function style_default(name, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
  }
  function styleValue(node, name) {
    return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  // node_modules/d3-selection/src/selection/property.js
  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }
  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }
  function propertyFunction(name, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (v2 == null) delete this[name];
      else this[name] = v2;
    };
  }
  function property_default(name, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
  }

  // node_modules/d3-selection/src/selection/classed.js
  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }
  function classList(node) {
    return node.classList || new ClassList(node);
  }
  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }
  ClassList.prototype = {
    add: function(name) {
      var i2 = this._names.indexOf(name);
      if (i2 < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i2 = this._names.indexOf(name);
      if (i2 >= 0) {
        this._names.splice(i2, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };
  function classedAdd(node, names) {
    var list = classList(node), i2 = -1, n2 = names.length;
    while (++i2 < n2) list.add(names[i2]);
  }
  function classedRemove(node, names) {
    var list = classList(node), i2 = -1, n2 = names.length;
    while (++i2 < n2) list.remove(names[i2]);
  }
  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }
  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }
  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }
  function classed_default(name, value) {
    var names = classArray(name + "");
    if (arguments.length < 2) {
      var list = classList(this.node()), i2 = -1, n2 = names.length;
      while (++i2 < n2) if (!list.contains(names[i2])) return false;
      return true;
    }
    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
  }

  // node_modules/d3-selection/src/selection/text.js
  function textRemove() {
    this.textContent = "";
  }
  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction(value) {
    return function() {
      var v2 = value.apply(this, arguments);
      this.textContent = v2 == null ? "" : v2;
    };
  }
  function text_default(value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
  }

  // node_modules/d3-selection/src/selection/html.js
  function htmlRemove() {
    this.innerHTML = "";
  }
  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }
  function htmlFunction(value) {
    return function() {
      var v2 = value.apply(this, arguments);
      this.innerHTML = v2 == null ? "" : v2;
    };
  }
  function html_default(value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
  }

  // node_modules/d3-selection/src/selection/raise.js
  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }
  function raise_default() {
    return this.each(raise);
  }

  // node_modules/d3-selection/src/selection/lower.js
  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function lower_default() {
    return this.each(lower);
  }

  // node_modules/d3-selection/src/selection/append.js
  function append_default(name) {
    var create2 = typeof name === "function" ? name : creator_default(name);
    return this.select(function() {
      return this.appendChild(create2.apply(this, arguments));
    });
  }

  // node_modules/d3-selection/src/selection/insert.js
  function constantNull() {
    return null;
  }
  function insert_default(name, before) {
    var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
    return this.select(function() {
      return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  // node_modules/d3-selection/src/selection/remove.js
  function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  function remove_default() {
    return this.each(remove);
  }

  // node_modules/d3-selection/src/selection/clone.js
  function selection_cloneShallow() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function selection_cloneDeep() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function clone_default(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  // node_modules/d3-selection/src/selection/datum.js
  function datum_default(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  }

  // node_modules/d3-selection/src/selection/on.js
  function contextListener(listener) {
    return function(event) {
      listener.call(this, event, this.__data__);
    };
  }
  function parseTypenames2(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t2) {
      var name = "", i2 = t2.indexOf(".");
      if (i2 >= 0) name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
      return { type: t2, name };
    });
  }
  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j = 0, i2 = -1, m2 = on.length, o2; j < m2; ++j) {
        if (o2 = on[j], (!typename.type || o2.type === typename.type) && o2.name === typename.name) {
          this.removeEventListener(o2.type, o2.listener, o2.options);
        } else {
          on[++i2] = o2;
        }
      }
      if (++i2) on.length = i2;
      else delete this.__on;
    };
  }
  function onAdd(typename, value, options) {
    return function() {
      var on = this.__on, o2, listener = contextListener(value);
      if (on) for (var j = 0, m2 = on.length; j < m2; ++j) {
        if ((o2 = on[j]).type === typename.type && o2.name === typename.name) {
          this.removeEventListener(o2.type, o2.listener, o2.options);
          this.addEventListener(o2.type, o2.listener = listener, o2.options = options);
          o2.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, options);
      o2 = { type: typename.type, name: typename.name, value, listener, options };
      if (!on) this.__on = [o2];
      else on.push(o2);
    };
  }
  function on_default(typename, value, options) {
    var typenames = parseTypenames2(typename + ""), i2, n2 = typenames.length, t2;
    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j = 0, m2 = on.length, o2; j < m2; ++j) {
        for (i2 = 0, o2 = on[j]; i2 < n2; ++i2) {
          if ((t2 = typenames[i2]).type === o2.type && t2.name === o2.name) {
            return o2.value;
          }
        }
      }
      return;
    }
    on = value ? onAdd : onRemove;
    for (i2 = 0; i2 < n2; ++i2) this.each(on(typenames[i2], value, options));
    return this;
  }

  // node_modules/d3-selection/src/selection/dispatch.js
  function dispatchEvent(node, type, params) {
    var window2 = window_default(node), event = window2.CustomEvent;
    if (typeof event === "function") {
      event = new event(type, params);
    } else {
      event = window2.document.createEvent("Event");
      if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type, false, false);
    }
    node.dispatchEvent(event);
  }
  function dispatchConstant(type, params) {
    return function() {
      return dispatchEvent(this, type, params);
    };
  }
  function dispatchFunction(type, params) {
    return function() {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }
  function dispatch_default2(type, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
  }

  // node_modules/d3-selection/src/selection/iterator.js
  function* iterator_default() {
    for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
      for (var group = groups[j], i2 = 0, n2 = group.length, node; i2 < n2; ++i2) {
        if (node = group[i2]) yield node;
      }
    }
  }

  // node_modules/d3-selection/src/selection/index.js
  var root = [null];
  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }
  function selection() {
    return new Selection([[document.documentElement]], root);
  }
  function selection_selection() {
    return this;
  }
  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: select_default,
    selectAll: selectAll_default,
    selectChild: selectChild_default,
    selectChildren: selectChildren_default,
    filter: filter_default,
    data: data_default,
    enter: enter_default,
    exit: exit_default,
    join: join_default,
    merge: merge_default,
    selection: selection_selection,
    order: order_default,
    sort: sort_default,
    call: call_default,
    nodes: nodes_default,
    node: node_default,
    size: size_default,
    empty: empty_default,
    each: each_default,
    attr: attr_default,
    style: style_default,
    property: property_default,
    classed: classed_default,
    text: text_default,
    html: html_default,
    raise: raise_default,
    lower: lower_default,
    append: append_default,
    insert: insert_default,
    remove: remove_default,
    clone: clone_default,
    datum: datum_default,
    on: on_default,
    dispatch: dispatch_default2,
    [Symbol.iterator]: iterator_default
  };
  var selection_default = selection;

  // node_modules/d3-selection/src/select.js
  function select_default2(selector3) {
    return typeof selector3 === "string" ? new Selection([[document.querySelector(selector3)]], [document.documentElement]) : new Selection([[selector3]], root);
  }

  // node_modules/d3-selection/src/sourceEvent.js
  function sourceEvent_default(event) {
    let sourceEvent;
    while (sourceEvent = event.sourceEvent) event = sourceEvent;
    return event;
  }

  // node_modules/d3-selection/src/pointer.js
  function pointer_default(event, node) {
    event = sourceEvent_default(event);
    if (node === void 0) node = event.currentTarget;
    if (node) {
      var svg = node.ownerSVGElement || node;
      if (svg.createSVGPoint) {
        var point = svg.createSVGPoint();
        point.x = event.clientX, point.y = event.clientY;
        point = point.matrixTransform(node.getScreenCTM().inverse());
        return [point.x, point.y];
      }
      if (node.getBoundingClientRect) {
        var rect = node.getBoundingClientRect();
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
      }
    }
    return [event.pageX, event.pageY];
  }

  // node_modules/d3-drag/src/noevent.js
  var nonpassive = { passive: false };
  var nonpassivecapture = { capture: true, passive: false };
  function nopropagation(event) {
    event.stopImmediatePropagation();
  }
  function noevent_default(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }

  // node_modules/d3-drag/src/nodrag.js
  function nodrag_default(view) {
    var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
    if ("onselectstart" in root2) {
      selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
    } else {
      root2.__noselect = root2.style.MozUserSelect;
      root2.style.MozUserSelect = "none";
    }
  }
  function yesdrag(view, noclick) {
    var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
    if (noclick) {
      selection2.on("click.drag", noevent_default, nonpassivecapture);
      setTimeout(function() {
        selection2.on("click.drag", null);
      }, 0);
    }
    if ("onselectstart" in root2) {
      selection2.on("selectstart.drag", null);
    } else {
      root2.style.MozUserSelect = root2.__noselect;
      delete root2.__noselect;
    }
  }

  // node_modules/d3-drag/src/constant.js
  var constant_default2 = (x2) => () => x2;

  // node_modules/d3-drag/src/event.js
  function DragEvent(type, {
    sourceEvent,
    subject,
    target,
    identifier,
    active,
    x: x2,
    y: y2,
    dx,
    dy,
    dispatch: dispatch2
  }) {
    Object.defineProperties(this, {
      type: { value: type, enumerable: true, configurable: true },
      sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
      subject: { value: subject, enumerable: true, configurable: true },
      target: { value: target, enumerable: true, configurable: true },
      identifier: { value: identifier, enumerable: true, configurable: true },
      active: { value: active, enumerable: true, configurable: true },
      x: { value: x2, enumerable: true, configurable: true },
      y: { value: y2, enumerable: true, configurable: true },
      dx: { value: dx, enumerable: true, configurable: true },
      dy: { value: dy, enumerable: true, configurable: true },
      _: { value: dispatch2 }
    });
  }
  DragEvent.prototype.on = function() {
    var value = this._.on.apply(this._, arguments);
    return value === this._ ? this : value;
  };

  // node_modules/d3-drag/src/drag.js
  function defaultFilter(event) {
    return !event.ctrlKey && !event.button;
  }
  function defaultContainer() {
    return this.parentNode;
  }
  function defaultSubject(event, d2) {
    return d2 == null ? { x: event.x, y: event.y } : d2;
  }
  function defaultTouchable() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function drag_default() {
    var filter2 = defaultFilter, container2 = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
    function drag(selection2) {
      selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    function mousedowned(event, d2) {
      if (touchending || !filter2.call(this, event, d2)) return;
      var gesture = beforestart(this, container2.call(this, event, d2), event, d2, "mouse");
      if (!gesture) return;
      select_default2(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
      nodrag_default(event.view);
      nopropagation(event);
      mousemoving = false;
      mousedownx = event.clientX;
      mousedowny = event.clientY;
      gesture("start", event);
    }
    function mousemoved(event) {
      noevent_default(event);
      if (!mousemoving) {
        var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
        mousemoving = dx * dx + dy * dy > clickDistance2;
      }
      gestures.mouse("drag", event);
    }
    function mouseupped(event) {
      select_default2(event.view).on("mousemove.drag mouseup.drag", null);
      yesdrag(event.view, mousemoving);
      noevent_default(event);
      gestures.mouse("end", event);
    }
    function touchstarted(event, d2) {
      if (!filter2.call(this, event, d2)) return;
      var touches = event.changedTouches, c2 = container2.call(this, event, d2), n2 = touches.length, i2, gesture;
      for (i2 = 0; i2 < n2; ++i2) {
        if (gesture = beforestart(this, c2, event, d2, touches[i2].identifier, touches[i2])) {
          nopropagation(event);
          gesture("start", event, touches[i2]);
        }
      }
    }
    function touchmoved(event) {
      var touches = event.changedTouches, n2 = touches.length, i2, gesture;
      for (i2 = 0; i2 < n2; ++i2) {
        if (gesture = gestures[touches[i2].identifier]) {
          noevent_default(event);
          gesture("drag", event, touches[i2]);
        }
      }
    }
    function touchended(event) {
      var touches = event.changedTouches, n2 = touches.length, i2, gesture;
      if (touchending) clearTimeout(touchending);
      touchending = setTimeout(function() {
        touchending = null;
      }, 500);
      for (i2 = 0; i2 < n2; ++i2) {
        if (gesture = gestures[touches[i2].identifier]) {
          nopropagation(event);
          gesture("end", event, touches[i2]);
        }
      }
    }
    function beforestart(that, container3, event, d2, identifier, touch) {
      var dispatch2 = listeners.copy(), p2 = pointer_default(touch || event, container3), dx, dy, s2;
      if ((s2 = subject.call(that, new DragEvent("beforestart", {
        sourceEvent: event,
        target: drag,
        identifier,
        active,
        x: p2[0],
        y: p2[1],
        dx: 0,
        dy: 0,
        dispatch: dispatch2
      }), d2)) == null) return;
      dx = s2.x - p2[0] || 0;
      dy = s2.y - p2[1] || 0;
      return function gesture(type, event2, touch2) {
        var p0 = p2, n2;
        switch (type) {
          case "start":
            gestures[identifier] = gesture, n2 = active++;
            break;
          case "end":
            delete gestures[identifier], --active;
          // falls through
          case "drag":
            p2 = pointer_default(touch2 || event2, container3), n2 = active;
            break;
        }
        dispatch2.call(
          type,
          that,
          new DragEvent(type, {
            sourceEvent: event2,
            subject: s2,
            target: drag,
            identifier,
            active: n2,
            x: p2[0] + dx,
            y: p2[1] + dy,
            dx: p2[0] - p0[0],
            dy: p2[1] - p0[1],
            dispatch: dispatch2
          }),
          d2
        );
      };
    }
    drag.filter = function(_2) {
      return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant_default2(!!_2), drag) : filter2;
    };
    drag.container = function(_2) {
      return arguments.length ? (container2 = typeof _2 === "function" ? _2 : constant_default2(_2), drag) : container2;
    };
    drag.subject = function(_2) {
      return arguments.length ? (subject = typeof _2 === "function" ? _2 : constant_default2(_2), drag) : subject;
    };
    drag.touchable = function(_2) {
      return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant_default2(!!_2), drag) : touchable;
    };
    drag.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? drag : value;
    };
    drag.clickDistance = function(_2) {
      return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, drag) : Math.sqrt(clickDistance2);
    };
    return drag;
  }

  // node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  // node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
  var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
  var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
  var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
  var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
  var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format) {
    var m2, l2;
    format = (format + "").trim().toLowerCase();
    return (m2 = reHex.exec(format)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n2) {
    return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
  }
  function rgba(r2, g2, b2, a2) {
    if (a2 <= 0) r2 = g2 = b2 = NaN;
    return new Rgb(r2, g2, b2, a2);
  }
  function rgbConvert(o2) {
    if (!(o2 instanceof Color)) o2 = color(o2);
    if (!o2) return new Rgb();
    o2 = o2.rgb();
    return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
  }
  function rgb(r2, g2, b2, opacity) {
    return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b2, opacity == null ? 1 : opacity);
  }
  function Rgb(r2, g2, b2, opacity) {
    this.r = +r2;
    this.g = +g2;
    this.b = +b2;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend(Color, {
    brighter(k2) {
      k2 = k2 == null ? brighter : Math.pow(brighter, k2);
      return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
    },
    darker(k2) {
      k2 = k2 == null ? darker : Math.pow(darker, k2);
      return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h2, s2, l2, a2) {
    if (a2 <= 0) h2 = s2 = l2 = NaN;
    else if (l2 <= 0 || l2 >= 1) h2 = s2 = NaN;
    else if (s2 <= 0) h2 = NaN;
    return new Hsl(h2, s2, l2, a2);
  }
  function hslConvert(o2) {
    if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
    if (!(o2 instanceof Color)) o2 = color(o2);
    if (!o2) return new Hsl();
    if (o2 instanceof Hsl) return o2;
    o2 = o2.rgb();
    var r2 = o2.r / 255, g2 = o2.g / 255, b2 = o2.b / 255, min = Math.min(r2, g2, b2), max = Math.max(r2, g2, b2), h2 = NaN, s2 = max - min, l2 = (max + min) / 2;
    if (s2) {
      if (r2 === max) h2 = (g2 - b2) / s2 + (g2 < b2) * 6;
      else if (g2 === max) h2 = (b2 - r2) / s2 + 2;
      else h2 = (r2 - g2) / s2 + 4;
      s2 /= l2 < 0.5 ? max + min : 2 - max - min;
      h2 *= 60;
    } else {
      s2 = l2 > 0 && l2 < 1 ? 0 : h2;
    }
    return new Hsl(h2, s2, l2, o2.opacity);
  }
  function hsl(h2, s2, l2, opacity) {
    return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
  }
  function Hsl(h2, s2, l2, opacity) {
    this.h = +h2;
    this.s = +s2;
    this.l = +l2;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend(Color, {
    brighter(k2) {
      k2 = k2 == null ? brighter : Math.pow(brighter, k2);
      return new Hsl(this.h, this.s, this.l * k2, this.opacity);
    },
    darker(k2) {
      k2 = k2 == null ? darker : Math.pow(darker, k2);
      return new Hsl(this.h, this.s, this.l * k2, this.opacity);
    },
    rgb() {
      var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
      return new Rgb(
        hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
        hsl2rgb(h2, m1, m2),
        hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a2 = clampa(this.opacity);
      return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h2, m1, m2) {
    return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
  }

  // node_modules/d3-interpolate/src/basis.js
  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  function basis_default(values) {
    var n2 = values.length - 1;
    return function(t2) {
      var i2 = t2 <= 0 ? t2 = 0 : t2 >= 1 ? (t2 = 1, n2 - 1) : Math.floor(t2 * n2), v1 = values[i2], v2 = values[i2 + 1], v0 = i2 > 0 ? values[i2 - 1] : 2 * v1 - v2, v3 = i2 < n2 - 1 ? values[i2 + 2] : 2 * v2 - v1;
      return basis((t2 - i2 / n2) * n2, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values) {
    var n2 = values.length;
    return function(t2) {
      var i2 = Math.floor(((t2 %= 1) < 0 ? ++t2 : t2) * n2), v0 = values[(i2 + n2 - 1) % n2], v1 = values[i2 % n2], v2 = values[(i2 + 1) % n2], v3 = values[(i2 + 2) % n2];
      return basis((t2 - i2 / n2) * n2, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/constant.js
  var constant_default3 = (x2) => () => x2;

  // node_modules/d3-interpolate/src/color.js
  function linear(a2, d2) {
    return function(t2) {
      return a2 + t2 * d2;
    };
  }
  function exponential(a2, b2, y2) {
    return a2 = Math.pow(a2, y2), b2 = Math.pow(b2, y2) - a2, y2 = 1 / y2, function(t2) {
      return Math.pow(a2 + t2 * b2, y2);
    };
  }
  function gamma(y2) {
    return (y2 = +y2) === 1 ? nogamma : function(a2, b2) {
      return b2 - a2 ? exponential(a2, b2, y2) : constant_default3(isNaN(a2) ? b2 : a2);
    };
  }
  function nogamma(a2, b2) {
    var d2 = b2 - a2;
    return d2 ? linear(a2, d2) : constant_default3(isNaN(a2) ? b2 : a2);
  }

  // node_modules/d3-interpolate/src/rgb.js
  var rgb_default = (function rgbGamma(y2) {
    var color2 = gamma(y2);
    function rgb2(start2, end) {
      var r2 = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g2 = color2(start2.g, end.g), b2 = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
      return function(t2) {
        start2.r = r2(t2);
        start2.g = g2(t2);
        start2.b = b2(t2);
        start2.opacity = opacity(t2);
        return start2 + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  })(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n2 = colors.length, r2 = new Array(n2), g2 = new Array(n2), b2 = new Array(n2), i2, color2;
      for (i2 = 0; i2 < n2; ++i2) {
        color2 = rgb(colors[i2]);
        r2[i2] = color2.r || 0;
        g2[i2] = color2.g || 0;
        b2[i2] = color2.b || 0;
      }
      r2 = spline(r2);
      g2 = spline(g2);
      b2 = spline(b2);
      color2.opacity = 1;
      return function(t2) {
        color2.r = r2(t2);
        color2.g = g2(t2);
        color2.b = b2(t2);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // node_modules/d3-interpolate/src/number.js
  function number_default(a2, b2) {
    return a2 = +a2, b2 = +b2, function(t2) {
      return a2 * (1 - t2) + b2 * t2;
    };
  }

  // node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero(b2) {
    return function() {
      return b2;
    };
  }
  function one(b2) {
    return function(t2) {
      return b2(t2) + "";
    };
  }
  function string_default(a2, b2) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s2 = [], q = [];
    a2 = a2 + "", b2 = b2 + "";
    while ((am = reA.exec(a2)) && (bm = reB.exec(b2))) {
      if ((bs = bm.index) > bi) {
        bs = b2.slice(bi, bs);
        if (s2[i2]) s2[i2] += bs;
        else s2[++i2] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s2[i2]) s2[i2] += bm;
        else s2[++i2] = bm;
      } else {
        s2[++i2] = null;
        q.push({ i: i2, x: number_default(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b2.length) {
      bs = b2.slice(bi);
      if (s2[i2]) s2[i2] += bs;
      else s2[++i2] = bs;
    }
    return s2.length < 2 ? q[0] ? one(q[0].x) : zero(b2) : (b2 = q.length, function(t2) {
      for (var i3 = 0, o2; i3 < b2; ++i3) s2[(o2 = q[i3]).i] = o2.x(t2);
      return s2.join("");
    });
  }

  // node_modules/d3-interpolate/src/transform/decompose.js
  var degrees = 180 / Math.PI;
  var identity2 = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function decompose_default(a2, b2, c2, d2, e2, f2) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a2 * a2 + b2 * b2)) a2 /= scaleX, b2 /= scaleX;
    if (skewX = a2 * c2 + b2 * d2) c2 -= a2 * skewX, d2 -= b2 * skewX;
    if (scaleY = Math.sqrt(c2 * c2 + d2 * d2)) c2 /= scaleY, d2 /= scaleY, skewX /= scaleY;
    if (a2 * d2 < b2 * c2) a2 = -a2, b2 = -b2, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e2,
      translateY: f2,
      rotate: Math.atan2(b2, a2) * degrees,
      skewX: Math.atan(skewX) * degrees,
      scaleX,
      scaleY
    };
  }

  // node_modules/d3-interpolate/src/transform/parse.js
  var svgNode;
  function parseCss(value) {
    const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
    return m2.isIdentity ? identity2 : decompose_default(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
  }
  function parseSvg(value) {
    if (value == null) return identity2;
    if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate())) return identity2;
    value = value.matrix;
    return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
  }

  // node_modules/d3-interpolate/src/transform/index.js
  function interpolateTransform(parse3, pxComma, pxParen, degParen) {
    function pop(s2) {
      return s2.length ? s2.pop() + " " : "";
    }
    function translate(xa, ya, xb, yb, s2, q) {
      if (xa !== xb || ya !== yb) {
        var i2 = s2.push("translate(", null, pxComma, null, pxParen);
        q.push({ i: i2 - 4, x: number_default(xa, xb) }, { i: i2 - 2, x: number_default(ya, yb) });
      } else if (xb || yb) {
        s2.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }
    function rotate(a2, b2, s2, q) {
      if (a2 !== b2) {
        if (a2 - b2 > 180) b2 += 360;
        else if (b2 - a2 > 180) a2 += 360;
        q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default(a2, b2) });
      } else if (b2) {
        s2.push(pop(s2) + "rotate(" + b2 + degParen);
      }
    }
    function skewX(a2, b2, s2, q) {
      if (a2 !== b2) {
        q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default(a2, b2) });
      } else if (b2) {
        s2.push(pop(s2) + "skewX(" + b2 + degParen);
      }
    }
    function scale(xa, ya, xb, yb, s2, q) {
      if (xa !== xb || ya !== yb) {
        var i2 = s2.push(pop(s2) + "scale(", null, ",", null, ")");
        q.push({ i: i2 - 4, x: number_default(xa, xb) }, { i: i2 - 2, x: number_default(ya, yb) });
      } else if (xb !== 1 || yb !== 1) {
        s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
      }
    }
    return function(a2, b2) {
      var s2 = [], q = [];
      a2 = parse3(a2), b2 = parse3(b2);
      translate(a2.translateX, a2.translateY, b2.translateX, b2.translateY, s2, q);
      rotate(a2.rotate, b2.rotate, s2, q);
      skewX(a2.skewX, b2.skewX, s2, q);
      scale(a2.scaleX, a2.scaleY, b2.scaleX, b2.scaleY, s2, q);
      a2 = b2 = null;
      return function(t2) {
        var i2 = -1, n2 = q.length, o2;
        while (++i2 < n2) s2[(o2 = q[i2]).i] = o2.x(t2);
        return s2.join("");
      };
    };
  }
  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

  // node_modules/d3-interpolate/src/zoom.js
  var epsilon2 = 1e-12;
  function cosh(x2) {
    return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
  }
  function sinh(x2) {
    return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
  }
  function tanh(x2) {
    return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
  }
  var zoom_default = (function zoomRho(rho, rho2, rho4) {
    function zoom(p0, p1) {
      var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i2, S2;
      if (d2 < epsilon2) {
        S2 = Math.log(w1 / w0) / rho;
        i2 = function(t2) {
          return [
            ux0 + t2 * dx,
            uy0 + t2 * dy,
            w0 * Math.exp(rho * t2 * S2)
          ];
        };
      } else {
        var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
        S2 = (r1 - r0) / rho;
        i2 = function(t2) {
          var s2 = t2 * S2, coshr0 = cosh(r0), u2 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
          return [
            ux0 + u2 * dx,
            uy0 + u2 * dy,
            w0 * coshr0 / cosh(rho * s2 + r0)
          ];
        };
      }
      i2.duration = S2 * 1e3 * rho / Math.SQRT2;
      return i2;
    }
    zoom.rho = function(_2) {
      var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
      return zoomRho(_1, _22, _4);
    };
    return zoom;
  })(Math.SQRT2, 2, 4);

  // node_modules/d3-timer/src/timer.js
  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
    setTimeout(f2, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function") throw new TypeError("callback is not a function");
      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail) taskTail._next = this;
        else taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    var t2 = new Timer();
    t2.restart(callback, delay, time);
    return t2;
  }
  function timerFlush() {
    now();
    ++frame;
    var t2 = taskHead, e2;
    while (t2) {
      if ((e2 = clockNow - t2._time) >= 0) t2._call.call(void 0, e2);
      t2 = t2._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now2 = clock.now(), delay = now2 - clockLast;
    if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time) time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame) return;
    if (timeout) timeout = clearTimeout(timeout);
    var delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
      if (interval) interval = clearInterval(interval);
    } else {
      if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  // node_modules/d3-timer/src/timeout.js
  function timeout_default(callback, delay, time) {
    var t2 = new Timer();
    delay = delay == null ? 0 : +delay;
    t2.restart((elapsed) => {
      t2.stop();
      callback(elapsed + delay);
    }, delay, time);
    return t2;
  }

  // node_modules/d3-transition/src/transition/schedule.js
  var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
  var emptyTween = [];
  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;
  function schedule_default(node, name, id2, index, group, timing) {
    var schedules = node.__transition;
    if (!schedules) node.__transition = {};
    else if (id2 in schedules) return;
    create(node, id2, {
      name,
      index,
      // For context during callback.
      group,
      // For context during callback.
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }
  function init(node, id2) {
    var schedule = get2(node, id2);
    if (schedule.state > CREATED) throw new Error("too late; already scheduled");
    return schedule;
  }
  function set2(node, id2) {
    var schedule = get2(node, id2);
    if (schedule.state > STARTED) throw new Error("too late; already running");
    return schedule;
  }
  function get2(node, id2) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id2])) throw new Error("transition not found");
    return schedule;
  }
  function create(node, id2, self2) {
    var schedules = node.__transition, tween;
    schedules[id2] = self2;
    self2.timer = timer(schedule, 0, self2.time);
    function schedule(elapsed) {
      self2.state = SCHEDULED;
      self2.timer.restart(start2, self2.delay, self2.time);
      if (self2.delay <= elapsed) start2(elapsed - self2.delay);
    }
    function start2(elapsed) {
      var i2, j, n2, o2;
      if (self2.state !== SCHEDULED) return stop();
      for (i2 in schedules) {
        o2 = schedules[i2];
        if (o2.name !== self2.name) continue;
        if (o2.state === STARTED) return timeout_default(start2);
        if (o2.state === RUNNING) {
          o2.state = ENDED;
          o2.timer.stop();
          o2.on.call("interrupt", node, node.__data__, o2.index, o2.group);
          delete schedules[i2];
        } else if (+i2 < id2) {
          o2.state = ENDED;
          o2.timer.stop();
          o2.on.call("cancel", node, node.__data__, o2.index, o2.group);
          delete schedules[i2];
        }
      }
      timeout_default(function() {
        if (self2.state === STARTED) {
          self2.state = RUNNING;
          self2.timer.restart(tick, self2.delay, self2.time);
          tick(elapsed);
        }
      });
      self2.state = STARTING;
      self2.on.call("start", node, node.__data__, self2.index, self2.group);
      if (self2.state !== STARTING) return;
      self2.state = STARTED;
      tween = new Array(n2 = self2.tween.length);
      for (i2 = 0, j = -1; i2 < n2; ++i2) {
        if (o2 = self2.tween[i2].value.call(node, node.__data__, self2.index, self2.group)) {
          tween[++j] = o2;
        }
      }
      tween.length = j + 1;
    }
    function tick(elapsed) {
      var t2 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i2 = -1, n2 = tween.length;
      while (++i2 < n2) {
        tween[i2].call(node, t2);
      }
      if (self2.state === ENDING) {
        self2.on.call("end", node, node.__data__, self2.index, self2.group);
        stop();
      }
    }
    function stop() {
      self2.state = ENDED;
      self2.timer.stop();
      delete schedules[id2];
      for (var i2 in schedules) return;
      delete node.__transition;
    }
  }

  // node_modules/d3-transition/src/interrupt.js
  function interrupt_default(node, name) {
    var schedules = node.__transition, schedule, active, empty2 = true, i2;
    if (!schedules) return;
    name = name == null ? null : name + "";
    for (i2 in schedules) {
      if ((schedule = schedules[i2]).name !== name) {
        empty2 = false;
        continue;
      }
      active = schedule.state > STARTING && schedule.state < ENDING;
      schedule.state = ENDED;
      schedule.timer.stop();
      schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
      delete schedules[i2];
    }
    if (empty2) delete node.__transition;
  }

  // node_modules/d3-transition/src/selection/interrupt.js
  function interrupt_default2(name) {
    return this.each(function() {
      interrupt_default(this, name);
    });
  }

  // node_modules/d3-transition/src/transition/tween.js
  function tweenRemove(id2, name) {
    var tween0, tween1;
    return function() {
      var schedule = set2(this, id2), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i2 = 0, n2 = tween1.length; i2 < n2; ++i2) {
          if (tween1[i2].name === name) {
            tween1 = tween1.slice();
            tween1.splice(i2, 1);
            break;
          }
        }
      }
      schedule.tween = tween1;
    };
  }
  function tweenFunction(id2, name, value) {
    var tween0, tween1;
    if (typeof value !== "function") throw new Error();
    return function() {
      var schedule = set2(this, id2), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t2 = { name, value }, i2 = 0, n2 = tween1.length; i2 < n2; ++i2) {
          if (tween1[i2].name === name) {
            tween1[i2] = t2;
            break;
          }
        }
        if (i2 === n2) tween1.push(t2);
      }
      schedule.tween = tween1;
    };
  }
  function tween_default(name, value) {
    var id2 = this._id;
    name += "";
    if (arguments.length < 2) {
      var tween = get2(this.node(), id2).tween;
      for (var i2 = 0, n2 = tween.length, t2; i2 < n2; ++i2) {
        if ((t2 = tween[i2]).name === name) {
          return t2.value;
        }
      }
      return null;
    }
    return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
  }
  function tweenValue(transition2, name, value) {
    var id2 = transition2._id;
    transition2.each(function() {
      var schedule = set2(this, id2);
      (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
    });
    return function(node) {
      return get2(node, id2).value[name];
    };
  }

  // node_modules/d3-transition/src/transition/interpolate.js
  function interpolate_default(a2, b2) {
    var c2;
    return (typeof b2 === "number" ? number_default : b2 instanceof color ? rgb_default : (c2 = color(b2)) ? (b2 = c2, rgb_default) : string_default)(a2, b2);
  }

  // node_modules/d3-transition/src/transition/attr.js
  function attrRemove2(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS2(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant2(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttribute(name);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrConstantNS2(fullname, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrFunction2(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) return void this.removeAttribute(name);
      string0 = this.getAttribute(name);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attrFunctionNS2(fullname, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attr_default2(name, value) {
    var fullname = namespace_default(name), i2 = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
    return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i2, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i2, value));
  }

  // node_modules/d3-transition/src/transition/attrTween.js
  function attrInterpolate(name, i2) {
    return function(t2) {
      this.setAttribute(name, i2.call(this, t2));
    };
  }
  function attrInterpolateNS(fullname, i2) {
    return function(t2) {
      this.setAttributeNS(fullname.space, fullname.local, i2.call(this, t2));
    };
  }
  function attrTweenNS(fullname, value) {
    var t0, i0;
    function tween() {
      var i2 = value.apply(this, arguments);
      if (i2 !== i0) t0 = (i0 = i2) && attrInterpolateNS(fullname, i2);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween(name, value) {
    var t0, i0;
    function tween() {
      var i2 = value.apply(this, arguments);
      if (i2 !== i0) t0 = (i0 = i2) && attrInterpolate(name, i2);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween_default(name, value) {
    var key = "attr." + name;
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    var fullname = namespace_default(name);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }

  // node_modules/d3-transition/src/transition/delay.js
  function delayFunction(id2, value) {
    return function() {
      init(this, id2).delay = +value.apply(this, arguments);
    };
  }
  function delayConstant(id2, value) {
    return value = +value, function() {
      init(this, id2).delay = value;
    };
  }
  function delay_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
  }

  // node_modules/d3-transition/src/transition/duration.js
  function durationFunction(id2, value) {
    return function() {
      set2(this, id2).duration = +value.apply(this, arguments);
    };
  }
  function durationConstant(id2, value) {
    return value = +value, function() {
      set2(this, id2).duration = value;
    };
  }
  function duration_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
  }

  // node_modules/d3-transition/src/transition/ease.js
  function easeConstant(id2, value) {
    if (typeof value !== "function") throw new Error();
    return function() {
      set2(this, id2).ease = value;
    };
  }
  function ease_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
  }

  // node_modules/d3-transition/src/transition/easeVarying.js
  function easeVarying(id2, value) {
    return function() {
      var v2 = value.apply(this, arguments);
      if (typeof v2 !== "function") throw new Error();
      set2(this, id2).ease = v2;
    };
  }
  function easeVarying_default(value) {
    if (typeof value !== "function") throw new Error();
    return this.each(easeVarying(this._id, value));
  }

  // node_modules/d3-transition/src/transition/filter.js
  function filter_default2(match) {
    if (typeof match !== "function") match = matcher_default(match);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = [], node, i2 = 0; i2 < n2; ++i2) {
        if ((node = group[i2]) && match.call(node, node.__data__, i2, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Transition(subgroups, this._parents, this._name, this._id);
  }

  // node_modules/d3-transition/src/transition/merge.js
  function merge_default2(transition2) {
    if (transition2._id !== this._id) throw new Error();
    for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n2 = group0.length, merge = merges[j] = new Array(n2), node, i2 = 0; i2 < n2; ++i2) {
        if (node = group0[i2] || group1[i2]) {
          merge[i2] = node;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Transition(merges, this._parents, this._name, this._id);
  }

  // node_modules/d3-transition/src/transition/on.js
  function start(name) {
    return (name + "").trim().split(/^|\s+/).every(function(t2) {
      var i2 = t2.indexOf(".");
      if (i2 >= 0) t2 = t2.slice(0, i2);
      return !t2 || t2 === "start";
    });
  }
  function onFunction(id2, name, listener) {
    var on0, on1, sit = start(name) ? init : set2;
    return function() {
      var schedule = sit(this, id2), on = schedule.on;
      if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
      schedule.on = on1;
    };
  }
  function on_default2(name, listener) {
    var id2 = this._id;
    return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
  }

  // node_modules/d3-transition/src/transition/remove.js
  function removeFunction(id2) {
    return function() {
      var parent = this.parentNode;
      for (var i2 in this.__transition) if (+i2 !== id2) return;
      if (parent) parent.removeChild(this);
    };
  }
  function remove_default2() {
    return this.on("end.remove", removeFunction(this._id));
  }

  // node_modules/d3-transition/src/transition/select.js
  function select_default3(select) {
    var name = this._name, id2 = this._id;
    if (typeof select !== "function") select = selector_default(select);
    for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = new Array(n2), node, subnode, i2 = 0; i2 < n2; ++i2) {
        if ((node = group[i2]) && (subnode = select.call(node, node.__data__, i2, group))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i2] = subnode;
          schedule_default(subgroup[i2], name, id2, i2, subgroup, get2(node, id2));
        }
      }
    }
    return new Transition(subgroups, this._parents, name, id2);
  }

  // node_modules/d3-transition/src/transition/selectAll.js
  function selectAll_default2(select) {
    var name = this._name, id2 = this._id;
    if (typeof select !== "function") select = selectorAll_default(select);
    for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
      for (var group = groups[j], n2 = group.length, node, i2 = 0; i2 < n2; ++i2) {
        if (node = group[i2]) {
          for (var children3 = select.call(node, node.__data__, i2, group), child, inherit2 = get2(node, id2), k2 = 0, l2 = children3.length; k2 < l2; ++k2) {
            if (child = children3[k2]) {
              schedule_default(child, name, id2, k2, children3, inherit2);
            }
          }
          subgroups.push(children3);
          parents.push(node);
        }
      }
    }
    return new Transition(subgroups, parents, name, id2);
  }

  // node_modules/d3-transition/src/transition/selection.js
  var Selection2 = selection_default.prototype.constructor;
  function selection_default2() {
    return new Selection2(this._groups, this._parents);
  }

  // node_modules/d3-transition/src/transition/style.js
  function styleNull(name, interpolate) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
    };
  }
  function styleRemove2(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant2(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = styleValue(this, name);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function styleFunction2(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
      if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function styleMaybeRemove(id2, name) {
    var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
    return function() {
      var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
      if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
      schedule.on = on1;
    };
  }
  function style_default2(name, value, priority) {
    var i2 = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
    return value == null ? this.styleTween(name, styleNull(name, i2)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i2, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i2, value), priority).on("end.style." + name, null);
  }

  // node_modules/d3-transition/src/transition/styleTween.js
  function styleInterpolate(name, i2, priority) {
    return function(t2) {
      this.style.setProperty(name, i2.call(this, t2), priority);
    };
  }
  function styleTween(name, value, priority) {
    var t2, i0;
    function tween() {
      var i2 = value.apply(this, arguments);
      if (i2 !== i0) t2 = (i0 = i2) && styleInterpolate(name, i2, priority);
      return t2;
    }
    tween._value = value;
    return tween;
  }
  function styleTween_default(name, value, priority) {
    var key = "style." + (name += "");
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
  }

  // node_modules/d3-transition/src/transition/text.js
  function textConstant2(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction2(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }
  function text_default2(value) {
    return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
  }

  // node_modules/d3-transition/src/transition/textTween.js
  function textInterpolate(i2) {
    return function(t2) {
      this.textContent = i2.call(this, t2);
    };
  }
  function textTween(value) {
    var t0, i0;
    function tween() {
      var i2 = value.apply(this, arguments);
      if (i2 !== i0) t0 = (i0 = i2) && textInterpolate(i2);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function textTween_default(value) {
    var key = "text";
    if (arguments.length < 1) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    return this.tween(key, textTween(value));
  }

  // node_modules/d3-transition/src/transition/transition.js
  function transition_default() {
    var name = this._name, id0 = this._id, id1 = newId();
    for (var groups = this._groups, m2 = groups.length, j = 0; j < m2; ++j) {
      for (var group = groups[j], n2 = group.length, node, i2 = 0; i2 < n2; ++i2) {
        if (node = group[i2]) {
          var inherit2 = get2(node, id0);
          schedule_default(node, name, id1, i2, group, {
            time: inherit2.time + inherit2.delay + inherit2.duration,
            delay: 0,
            duration: inherit2.duration,
            ease: inherit2.ease
          });
        }
      }
    }
    return new Transition(groups, this._parents, name, id1);
  }

  // node_modules/d3-transition/src/transition/end.js
  function end_default() {
    var on0, on1, that = this, id2 = that._id, size = that.size();
    return new Promise(function(resolve, reject) {
      var cancel = { value: reject }, end = { value: function() {
        if (--size === 0) resolve();
      } };
      that.each(function() {
        var schedule = set2(this, id2), on = schedule.on;
        if (on !== on0) {
          on1 = (on0 = on).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end);
        }
        schedule.on = on1;
      });
      if (size === 0) resolve();
    });
  }

  // node_modules/d3-transition/src/transition/index.js
  var id = 0;
  function Transition(groups, parents, name, id2) {
    this._groups = groups;
    this._parents = parents;
    this._name = name;
    this._id = id2;
  }
  function transition(name) {
    return selection_default().transition(name);
  }
  function newId() {
    return ++id;
  }
  var selection_prototype = selection_default.prototype;
  Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: select_default3,
    selectAll: selectAll_default2,
    selectChild: selection_prototype.selectChild,
    selectChildren: selection_prototype.selectChildren,
    filter: filter_default2,
    merge: merge_default2,
    selection: selection_default2,
    transition: transition_default,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: on_default2,
    attr: attr_default2,
    attrTween: attrTween_default,
    style: style_default2,
    styleTween: styleTween_default,
    text: text_default2,
    textTween: textTween_default,
    remove: remove_default2,
    tween: tween_default,
    delay: delay_default,
    duration: duration_default,
    ease: ease_default,
    easeVarying: easeVarying_default,
    end: end_default,
    [Symbol.iterator]: selection_prototype[Symbol.iterator]
  };

  // node_modules/d3-ease/src/cubic.js
  function cubicInOut(t2) {
    return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
  }

  // node_modules/d3-transition/src/selection/transition.js
  var defaultTiming = {
    time: null,
    // Set on use.
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };
  function inherit(node, id2) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id2])) {
      if (!(node = node.parentNode)) {
        throw new Error(`transition ${id2} not found`);
      }
    }
    return timing;
  }
  function transition_default2(name) {
    var id2, timing;
    if (name instanceof Transition) {
      id2 = name._id, name = name._name;
    } else {
      id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
    }
    for (var groups = this._groups, m2 = groups.length, j = 0; j < m2; ++j) {
      for (var group = groups[j], n2 = group.length, node, i2 = 0; i2 < n2; ++i2) {
        if (node = group[i2]) {
          schedule_default(node, name, id2, i2, group, timing || inherit(node, id2));
        }
      }
    }
    return new Transition(groups, this._parents, name, id2);
  }

  // node_modules/d3-transition/src/selection/index.js
  selection_default.prototype.interrupt = interrupt_default2;
  selection_default.prototype.transition = transition_default2;

  // node_modules/d3-zoom/src/constant.js
  var constant_default4 = (x2) => () => x2;

  // node_modules/d3-zoom/src/event.js
  function ZoomEvent(type, {
    sourceEvent,
    target,
    transform: transform2,
    dispatch: dispatch2
  }) {
    Object.defineProperties(this, {
      type: { value: type, enumerable: true, configurable: true },
      sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
      target: { value: target, enumerable: true, configurable: true },
      transform: { value: transform2, enumerable: true, configurable: true },
      _: { value: dispatch2 }
    });
  }

  // node_modules/d3-zoom/src/transform.js
  function Transform(k2, x2, y2) {
    this.k = k2;
    this.x = x2;
    this.y = y2;
  }
  Transform.prototype = {
    constructor: Transform,
    scale: function(k2) {
      return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
    },
    translate: function(x2, y2) {
      return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
    },
    apply: function(point) {
      return [point[0] * this.k + this.x, point[1] * this.k + this.y];
    },
    applyX: function(x2) {
      return x2 * this.k + this.x;
    },
    applyY: function(y2) {
      return y2 * this.k + this.y;
    },
    invert: function(location) {
      return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
    },
    invertX: function(x2) {
      return (x2 - this.x) / this.k;
    },
    invertY: function(y2) {
      return (y2 - this.y) / this.k;
    },
    rescaleX: function(x2) {
      return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
    },
    rescaleY: function(y2) {
      return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  var identity3 = new Transform(1, 0, 0);
  transform.prototype = Transform.prototype;
  function transform(node) {
    while (!node.__zoom) if (!(node = node.parentNode)) return identity3;
    return node.__zoom;
  }

  // node_modules/d3-zoom/src/noevent.js
  function nopropagation2(event) {
    event.stopImmediatePropagation();
  }
  function noevent_default2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }

  // node_modules/d3-zoom/src/zoom.js
  function defaultFilter2(event) {
    return (!event.ctrlKey || event.type === "wheel") && !event.button;
  }
  function defaultExtent() {
    var e2 = this;
    if (e2 instanceof SVGElement) {
      e2 = e2.ownerSVGElement || e2;
      if (e2.hasAttribute("viewBox")) {
        e2 = e2.viewBox.baseVal;
        return [[e2.x, e2.y], [e2.x + e2.width, e2.y + e2.height]];
      }
      return [[0, 0], [e2.width.baseVal.value, e2.height.baseVal.value]];
    }
    return [[0, 0], [e2.clientWidth, e2.clientHeight]];
  }
  function defaultTransform() {
    return this.__zoom || identity3;
  }
  function defaultWheelDelta(event) {
    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
  }
  function defaultTouchable2() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function defaultConstrain(transform2, extent, translateExtent) {
    var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
    return transform2.translate(
      dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
      dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
    );
  }
  function zoom_default2() {
    var filter2 = defaultFilter2, extent = defaultExtent, constrain = defaultConstrain, wheelDelta2 = defaultWheelDelta, touchable = defaultTouchable2, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
    function zoom(selection2) {
      selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    zoom.transform = function(collection, transform2, point, event) {
      var selection2 = collection.selection ? collection.selection() : collection;
      selection2.property("__zoom", defaultTransform);
      if (collection !== selection2) {
        schedule(collection, transform2, point, event);
      } else {
        selection2.interrupt().each(function() {
          gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
        });
      }
    };
    zoom.scaleBy = function(selection2, k2, p2, event) {
      zoom.scaleTo(selection2, function() {
        var k0 = this.__zoom.k, k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
        return k0 * k1;
      }, p2, event);
    };
    zoom.scaleTo = function(selection2, k2, p2, event) {
      zoom.transform(selection2, function() {
        var e2 = extent.apply(this, arguments), t0 = this.__zoom, p0 = p2 == null ? centroid(e2) : typeof p2 === "function" ? p2.apply(this, arguments) : p2, p1 = t0.invert(p0), k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
        return constrain(translate(scale(t0, k1), p0, p1), e2, translateExtent);
      }, p2, event);
    };
    zoom.translateBy = function(selection2, x2, y2, event) {
      zoom.transform(selection2, function() {
        return constrain(this.__zoom.translate(
          typeof x2 === "function" ? x2.apply(this, arguments) : x2,
          typeof y2 === "function" ? y2.apply(this, arguments) : y2
        ), extent.apply(this, arguments), translateExtent);
      }, null, event);
    };
    zoom.translateTo = function(selection2, x2, y2, p2, event) {
      zoom.transform(selection2, function() {
        var e2 = extent.apply(this, arguments), t2 = this.__zoom, p0 = p2 == null ? centroid(e2) : typeof p2 === "function" ? p2.apply(this, arguments) : p2;
        return constrain(identity3.translate(p0[0], p0[1]).scale(t2.k).translate(
          typeof x2 === "function" ? -x2.apply(this, arguments) : -x2,
          typeof y2 === "function" ? -y2.apply(this, arguments) : -y2
        ), e2, translateExtent);
      }, p2, event);
    };
    function scale(transform2, k2) {
      k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));
      return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);
    }
    function translate(transform2, p0, p1) {
      var x2 = p0[0] - p1[0] * transform2.k, y2 = p0[1] - p1[1] * transform2.k;
      return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
    }
    function centroid(extent2) {
      return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
    }
    function schedule(transition2, transform2, point, event) {
      transition2.on("start.zoom", function() {
        gesture(this, arguments).event(event).start();
      }).on("interrupt.zoom end.zoom", function() {
        gesture(this, arguments).event(event).end();
      }).tween("zoom", function() {
        var that = this, args = arguments, g2 = gesture(that, args).event(event), e2 = extent.apply(that, args), p2 = point == null ? centroid(e2) : typeof point === "function" ? point.apply(that, args) : point, w2 = Math.max(e2[1][0] - e2[0][0], e2[1][1] - e2[0][1]), a2 = that.__zoom, b2 = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i2 = interpolate(a2.invert(p2).concat(w2 / a2.k), b2.invert(p2).concat(w2 / b2.k));
        return function(t2) {
          if (t2 === 1) t2 = b2;
          else {
            var l2 = i2(t2), k2 = w2 / l2[2];
            t2 = new Transform(k2, p2[0] - l2[0] * k2, p2[1] - l2[1] * k2);
          }
          g2.zoom(null, t2);
        };
      });
    }
    function gesture(that, args, clean) {
      return !clean && that.__zooming || new Gesture(that, args);
    }
    function Gesture(that, args) {
      this.that = that;
      this.args = args;
      this.active = 0;
      this.sourceEvent = null;
      this.extent = extent.apply(that, args);
      this.taps = 0;
    }
    Gesture.prototype = {
      event: function(event) {
        if (event) this.sourceEvent = event;
        return this;
      },
      start: function() {
        if (++this.active === 1) {
          this.that.__zooming = this;
          this.emit("start");
        }
        return this;
      },
      zoom: function(key, transform2) {
        if (this.mouse && key !== "mouse") this.mouse[1] = transform2.invert(this.mouse[0]);
        if (this.touch0 && key !== "touch") this.touch0[1] = transform2.invert(this.touch0[0]);
        if (this.touch1 && key !== "touch") this.touch1[1] = transform2.invert(this.touch1[0]);
        this.that.__zoom = transform2;
        this.emit("zoom");
        return this;
      },
      end: function() {
        if (--this.active === 0) {
          delete this.that.__zooming;
          this.emit("end");
        }
        return this;
      },
      emit: function(type) {
        var d2 = select_default2(this.that).datum();
        listeners.call(
          type,
          this.that,
          new ZoomEvent(type, {
            sourceEvent: this.sourceEvent,
            target: zoom,
            type,
            transform: this.that.__zoom,
            dispatch: listeners
          }),
          d2
        );
      }
    };
    function wheeled(event, ...args) {
      if (!filter2.apply(this, arguments)) return;
      var g2 = gesture(this, args).event(event), t2 = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t2.k * Math.pow(2, wheelDelta2.apply(this, arguments)))), p2 = pointer_default(event);
      if (g2.wheel) {
        if (g2.mouse[0][0] !== p2[0] || g2.mouse[0][1] !== p2[1]) {
          g2.mouse[1] = t2.invert(g2.mouse[0] = p2);
        }
        clearTimeout(g2.wheel);
      } else if (t2.k === k2) return;
      else {
        g2.mouse = [p2, t2.invert(p2)];
        interrupt_default(this);
        g2.start();
      }
      noevent_default2(event);
      g2.wheel = setTimeout(wheelidled, wheelDelay);
      g2.zoom("mouse", constrain(translate(scale(t2, k2), g2.mouse[0], g2.mouse[1]), g2.extent, translateExtent));
      function wheelidled() {
        g2.wheel = null;
        g2.end();
      }
    }
    function mousedowned(event, ...args) {
      if (touchending || !filter2.apply(this, arguments)) return;
      var currentTarget = event.currentTarget, g2 = gesture(this, args, true).event(event), v2 = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p2 = pointer_default(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
      nodrag_default(event.view);
      nopropagation2(event);
      g2.mouse = [p2, this.__zoom.invert(p2)];
      interrupt_default(this);
      g2.start();
      function mousemoved(event2) {
        noevent_default2(event2);
        if (!g2.moved) {
          var dx = event2.clientX - x0, dy = event2.clientY - y0;
          g2.moved = dx * dx + dy * dy > clickDistance2;
        }
        g2.event(event2).zoom("mouse", constrain(translate(g2.that.__zoom, g2.mouse[0] = pointer_default(event2, currentTarget), g2.mouse[1]), g2.extent, translateExtent));
      }
      function mouseupped(event2) {
        v2.on("mousemove.zoom mouseup.zoom", null);
        yesdrag(event2.view, g2.moved);
        noevent_default2(event2);
        g2.event(event2).end();
      }
    }
    function dblclicked(event, ...args) {
      if (!filter2.apply(this, arguments)) return;
      var t0 = this.__zoom, p0 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
      noevent_default2(event);
      if (duration > 0) select_default2(this).transition().duration(duration).call(schedule, t1, p0, event);
      else select_default2(this).call(zoom.transform, t1, p0, event);
    }
    function touchstarted(event, ...args) {
      if (!filter2.apply(this, arguments)) return;
      var touches = event.touches, n2 = touches.length, g2 = gesture(this, args, event.changedTouches.length === n2).event(event), started, i2, t2, p2;
      nopropagation2(event);
      for (i2 = 0; i2 < n2; ++i2) {
        t2 = touches[i2], p2 = pointer_default(t2, this);
        p2 = [p2, this.__zoom.invert(p2), t2.identifier];
        if (!g2.touch0) g2.touch0 = p2, started = true, g2.taps = 1 + !!touchstarting;
        else if (!g2.touch1 && g2.touch0[2] !== p2[2]) g2.touch1 = p2, g2.taps = 0;
      }
      if (touchstarting) touchstarting = clearTimeout(touchstarting);
      if (started) {
        if (g2.taps < 2) touchfirst = p2[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
        interrupt_default(this);
        g2.start();
      }
    }
    function touchmoved(event, ...args) {
      if (!this.__zooming) return;
      var g2 = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t2, p2, l2;
      noevent_default2(event);
      for (i2 = 0; i2 < n2; ++i2) {
        t2 = touches[i2], p2 = pointer_default(t2, this);
        if (g2.touch0 && g2.touch0[2] === t2.identifier) g2.touch0[0] = p2;
        else if (g2.touch1 && g2.touch1[2] === t2.identifier) g2.touch1[0] = p2;
      }
      t2 = g2.that.__zoom;
      if (g2.touch1) {
        var p0 = g2.touch0[0], l0 = g2.touch0[1], p1 = g2.touch1[0], l1 = g2.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
        t2 = scale(t2, Math.sqrt(dp / dl));
        p2 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
        l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      } else if (g2.touch0) p2 = g2.touch0[0], l2 = g2.touch0[1];
      else return;
      g2.zoom("touch", constrain(translate(t2, p2, l2), g2.extent, translateExtent));
    }
    function touchended(event, ...args) {
      if (!this.__zooming) return;
      var g2 = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i2, t2;
      nopropagation2(event);
      if (touchending) clearTimeout(touchending);
      touchending = setTimeout(function() {
        touchending = null;
      }, touchDelay);
      for (i2 = 0; i2 < n2; ++i2) {
        t2 = touches[i2];
        if (g2.touch0 && g2.touch0[2] === t2.identifier) delete g2.touch0;
        else if (g2.touch1 && g2.touch1[2] === t2.identifier) delete g2.touch1;
      }
      if (g2.touch1 && !g2.touch0) g2.touch0 = g2.touch1, delete g2.touch1;
      if (g2.touch0) g2.touch0[1] = this.__zoom.invert(g2.touch0[0]);
      else {
        g2.end();
        if (g2.taps === 2) {
          t2 = pointer_default(t2, this);
          if (Math.hypot(touchfirst[0] - t2[0], touchfirst[1] - t2[1]) < tapDistance) {
            var p2 = select_default2(this).on("dblclick.zoom");
            if (p2) p2.apply(this, arguments);
          }
        }
      }
    }
    zoom.wheelDelta = function(_2) {
      return arguments.length ? (wheelDelta2 = typeof _2 === "function" ? _2 : constant_default4(+_2), zoom) : wheelDelta2;
    };
    zoom.filter = function(_2) {
      return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant_default4(!!_2), zoom) : filter2;
    };
    zoom.touchable = function(_2) {
      return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant_default4(!!_2), zoom) : touchable;
    };
    zoom.extent = function(_2) {
      return arguments.length ? (extent = typeof _2 === "function" ? _2 : constant_default4([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom) : extent;
    };
    zoom.scaleExtent = function(_2) {
      return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom) : [scaleExtent[0], scaleExtent[1]];
    };
    zoom.translateExtent = function(_2) {
      return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
    };
    zoom.constrain = function(_2) {
      return arguments.length ? (constrain = _2, zoom) : constrain;
    };
    zoom.duration = function(_2) {
      return arguments.length ? (duration = +_2, zoom) : duration;
    };
    zoom.interpolate = function(_2) {
      return arguments.length ? (interpolate = _2, zoom) : interpolate;
    };
    zoom.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? zoom : value;
    };
    zoom.clickDistance = function(_2) {
      return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, zoom) : Math.sqrt(clickDistance2);
    };
    zoom.tapDistance = function(_2) {
      return arguments.length ? (tapDistance = +_2, zoom) : tapDistance;
    };
    return zoom;
  }

  // node_modules/@reactflow/core/dist/esm/index.mjs
  var import_react_dom = __toESM(require_react_dom(), 1);
  var StoreContext = (0, import_react2.createContext)(null);
  var Provider$1 = StoreContext.Provider;
  var errorMessages = {
    error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
    error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
    error003: (nodeType) => `Node type "${nodeType}" not found. Using fallback type "default".`,
    error004: () => "The React Flow parent container needs a width and a height to render the graph.",
    error005: () => "Only child nodes can use a parent extent.",
    error006: () => "Can't create edge. An edge needs a source and a target.",
    error007: (id2) => `The old edge with id=${id2} does not exist.`,
    error009: (type) => `Marker type "${type}" doesn't exist.`,
    error008: (sourceHandle, edge) => `Couldn't create edge for ${!sourceHandle ? "source" : "target"} handle id: "${!sourceHandle ? edge.sourceHandle : edge.targetHandle}", edge id: ${edge.id}.`,
    error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
    error011: (edgeType) => `Edge type "${edgeType}" not found. Using fallback type "default".`,
    error012: (id2) => `Node with id "${id2}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`
  };
  var zustandErrorMessage = errorMessages["error001"]();
  function useStore(selector3, equalityFn) {
    const store = (0, import_react2.useContext)(StoreContext);
    if (store === null) {
      throw new Error(zustandErrorMessage);
    }
    return useStoreWithEqualityFn(store, selector3, equalityFn);
  }
  var useStoreApi = () => {
    const store = (0, import_react2.useContext)(StoreContext);
    if (store === null) {
      throw new Error(zustandErrorMessage);
    }
    return (0, import_react2.useMemo)(() => ({
      getState: store.getState,
      setState: store.setState,
      subscribe: store.subscribe,
      destroy: store.destroy
    }), [store]);
  };
  var selector$g = (s2) => s2.userSelectionActive ? "none" : "all";
  function Panel({ position: position2, children: children3, className, style: style2, ...rest }) {
    const pointerEvents = useStore(selector$g);
    const positionClasses = `${position2}`.split("-");
    return import_react2.default.createElement("div", { className: cc(["react-flow__panel", className, ...positionClasses]), style: { ...style2, pointerEvents }, ...rest }, children3);
  }
  function Attribution({ proOptions, position: position2 = "bottom-right" }) {
    if (proOptions?.hideAttribution) {
      return null;
    }
    return import_react2.default.createElement(
      Panel,
      { position: position2, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://reactflow.dev/pro" },
      import_react2.default.createElement("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution" }, "React Flow")
    );
  }
  var EdgeText = ({ x: x2, y: y2, label, labelStyle = {}, labelShowBg = true, labelBgStyle = {}, labelBgPadding = [2, 4], labelBgBorderRadius = 2, children: children3, className, ...rest }) => {
    const edgeRef = (0, import_react2.useRef)(null);
    const [edgeTextBbox, setEdgeTextBbox] = (0, import_react2.useState)({ x: 0, y: 0, width: 0, height: 0 });
    const edgeTextClasses = cc(["react-flow__edge-textwrapper", className]);
    (0, import_react2.useEffect)(() => {
      if (edgeRef.current) {
        const textBbox = edgeRef.current.getBBox();
        setEdgeTextBbox({
          x: textBbox.x,
          y: textBbox.y,
          width: textBbox.width,
          height: textBbox.height
        });
      }
    }, [label]);
    if (typeof label === "undefined" || !label) {
      return null;
    }
    return import_react2.default.createElement(
      "g",
      { transform: `translate(${x2 - edgeTextBbox.width / 2} ${y2 - edgeTextBbox.height / 2})`, className: edgeTextClasses, visibility: edgeTextBbox.width ? "visible" : "hidden", ...rest },
      labelShowBg && import_react2.default.createElement("rect", { width: edgeTextBbox.width + 2 * labelBgPadding[0], x: -labelBgPadding[0], y: -labelBgPadding[1], height: edgeTextBbox.height + 2 * labelBgPadding[1], className: "react-flow__edge-textbg", style: labelBgStyle, rx: labelBgBorderRadius, ry: labelBgBorderRadius }),
      import_react2.default.createElement("text", { className: "react-flow__edge-text", y: edgeTextBbox.height / 2, dy: "0.3em", ref: edgeRef, style: labelStyle }, label),
      children3
    );
  };
  var EdgeText$1 = (0, import_react2.memo)(EdgeText);
  var getDimensions = (node) => ({
    width: node.offsetWidth,
    height: node.offsetHeight
  });
  var clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);
  var clampPosition = (position2 = { x: 0, y: 0 }, extent) => ({
    x: clamp(position2.x, extent[0][0], extent[1][0]),
    y: clamp(position2.y, extent[0][1], extent[1][1])
  });
  var calcAutoPanVelocity = (value, min, max) => {
    if (value < min) {
      return clamp(Math.abs(value - min), 1, 50) / 50;
    } else if (value > max) {
      return -clamp(Math.abs(value - max), 1, 50) / 50;
    }
    return 0;
  };
  var calcAutoPan = (pos, bounds) => {
    const xMovement = calcAutoPanVelocity(pos.x, 35, bounds.width - 35) * 20;
    const yMovement = calcAutoPanVelocity(pos.y, 35, bounds.height - 35) * 20;
    return [xMovement, yMovement];
  };
  var getHostForElement = (element) => element.getRootNode?.() || window?.document;
  var getBoundsOfBoxes = (box1, box2) => ({
    x: Math.min(box1.x, box2.x),
    y: Math.min(box1.y, box2.y),
    x2: Math.max(box1.x2, box2.x2),
    y2: Math.max(box1.y2, box2.y2)
  });
  var rectToBox = ({ x: x2, y: y2, width, height: height2 }) => ({
    x: x2,
    y: y2,
    x2: x2 + width,
    y2: y2 + height2
  });
  var boxToRect = ({ x: x2, y: y2, x2: x22, y2: y22 }) => ({
    x: x2,
    y: y2,
    width: x22 - x2,
    height: y22 - y2
  });
  var nodeToRect = (node) => ({
    ...node.positionAbsolute || { x: 0, y: 0 },
    width: node.width || 0,
    height: node.height || 0
  });
  var getOverlappingArea = (rectA, rectB) => {
    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));
    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));
    return Math.ceil(xOverlap * yOverlap);
  };
  var isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);
  var isNumeric = (n2) => !isNaN(n2) && isFinite(n2);
  var internalsSymbol = /* @__PURE__ */ Symbol.for("internals");
  var elementSelectionKeys = ["Enter", " ", "Escape"];
  var devWarn = (id2, message) => {
    if (false) {
      console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id2}`);
    }
  };
  var isReactKeyboardEvent = (event) => "nativeEvent" in event;
  function isInputDOMNode(event) {
    const kbEvent = isReactKeyboardEvent(event) ? event.nativeEvent : event;
    const target = kbEvent.composedPath?.()?.[0] || event.target;
    const isInput = ["INPUT", "SELECT", "TEXTAREA"].includes(target?.nodeName) || target?.hasAttribute("contenteditable");
    return isInput || !!target?.closest(".nokey");
  }
  var isMouseEvent = (event) => "clientX" in event;
  var getEventPosition = (event, bounds) => {
    const isMouseTriggered = isMouseEvent(event);
    const evtX = isMouseTriggered ? event.clientX : event.touches?.[0].clientX;
    const evtY = isMouseTriggered ? event.clientY : event.touches?.[0].clientY;
    return {
      x: evtX - (bounds?.left ?? 0),
      y: evtY - (bounds?.top ?? 0)
    };
  };
  var isMacOs = () => typeof navigator !== "undefined" && navigator?.userAgent?.indexOf("Mac") >= 0;
  var BaseEdge = ({ id: id2, path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth = 20 }) => {
    return import_react2.default.createElement(
      import_react2.default.Fragment,
      null,
      import_react2.default.createElement("path", { id: id2, style: style2, d: path, fill: "none", className: "react-flow__edge-path", markerEnd, markerStart }),
      interactionWidth && import_react2.default.createElement("path", { d: path, fill: "none", strokeOpacity: 0, strokeWidth: interactionWidth, className: "react-flow__edge-interaction" }),
      label && isNumeric(labelX) && isNumeric(labelY) ? import_react2.default.createElement(EdgeText$1, { x: labelX, y: labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius }) : null
    );
  };
  BaseEdge.displayName = "BaseEdge";
  function getMouseHandler$1(id2, getState, handler) {
    return handler === void 0 ? handler : (event) => {
      const edge = getState().edges.find((e2) => e2.id === id2);
      if (edge) {
        handler(event, { ...edge });
      }
    };
  }
  function getEdgeCenter({ sourceX, sourceY, targetX, targetY }) {
    const xOffset = Math.abs(targetX - sourceX) / 2;
    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;
    const yOffset = Math.abs(targetY - sourceY) / 2;
    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
    return [centerX, centerY, xOffset, yOffset];
  }
  function getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY }) {
    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;
    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;
    const offsetX = Math.abs(centerX - sourceX);
    const offsetY = Math.abs(centerY - sourceY);
    return [centerX, centerY, offsetX, offsetY];
  }
  var ConnectionMode;
  (function(ConnectionMode2) {
    ConnectionMode2["Strict"] = "strict";
    ConnectionMode2["Loose"] = "loose";
  })(ConnectionMode || (ConnectionMode = {}));
  var PanOnScrollMode;
  (function(PanOnScrollMode2) {
    PanOnScrollMode2["Free"] = "free";
    PanOnScrollMode2["Vertical"] = "vertical";
    PanOnScrollMode2["Horizontal"] = "horizontal";
  })(PanOnScrollMode || (PanOnScrollMode = {}));
  var SelectionMode;
  (function(SelectionMode2) {
    SelectionMode2["Partial"] = "partial";
    SelectionMode2["Full"] = "full";
  })(SelectionMode || (SelectionMode = {}));
  var ConnectionLineType;
  (function(ConnectionLineType2) {
    ConnectionLineType2["Bezier"] = "default";
    ConnectionLineType2["Straight"] = "straight";
    ConnectionLineType2["Step"] = "step";
    ConnectionLineType2["SmoothStep"] = "smoothstep";
    ConnectionLineType2["SimpleBezier"] = "simplebezier";
  })(ConnectionLineType || (ConnectionLineType = {}));
  var MarkerType;
  (function(MarkerType2) {
    MarkerType2["Arrow"] = "arrow";
    MarkerType2["ArrowClosed"] = "arrowclosed";
  })(MarkerType || (MarkerType = {}));
  var Position;
  (function(Position2) {
    Position2["Left"] = "left";
    Position2["Top"] = "top";
    Position2["Right"] = "right";
    Position2["Bottom"] = "bottom";
  })(Position || (Position = {}));
  function getControl({ pos, x1, y1, x2, y2 }) {
    if (pos === Position.Left || pos === Position.Right) {
      return [0.5 * (x1 + x2), y1];
    }
    return [x1, 0.5 * (y1 + y2)];
  }
  function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top }) {
    const [sourceControlX, sourceControlY] = getControl({
      pos: sourcePosition,
      x1: sourceX,
      y1: sourceY,
      x2: targetX,
      y2: targetY
    });
    const [targetControlX, targetControlY] = getControl({
      pos: targetPosition,
      x1: targetX,
      y1: targetY,
      x2: sourceX,
      y2: sourceY
    });
    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
      sourceX,
      sourceY,
      targetX,
      targetY,
      sourceControlX,
      sourceControlY,
      targetControlX,
      targetControlY
    });
    return [
      `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
      labelX,
      labelY,
      offsetX,
      offsetY
    ];
  }
  var SimpleBezierEdge = (0, import_react2.memo)(({ sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth }) => {
    const [path, labelX, labelY] = getSimpleBezierPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition
    });
    return import_react2.default.createElement(BaseEdge, { path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
  SimpleBezierEdge.displayName = "SimpleBezierEdge";
  var handleDirections = {
    [Position.Left]: { x: -1, y: 0 },
    [Position.Right]: { x: 1, y: 0 },
    [Position.Top]: { x: 0, y: -1 },
    [Position.Bottom]: { x: 0, y: 1 }
  };
  var getDirection = ({ source, sourcePosition = Position.Bottom, target }) => {
    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {
      return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };
    }
    return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };
  };
  var distance = (a2, b2) => Math.sqrt(Math.pow(b2.x - a2.x, 2) + Math.pow(b2.y - a2.y, 2));
  function getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset }) {
    const sourceDir = handleDirections[sourcePosition];
    const targetDir = handleDirections[targetPosition];
    const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };
    const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };
    const dir = getDirection({
      source: sourceGapped,
      sourcePosition,
      target: targetGapped
    });
    const dirAccessor = dir.x !== 0 ? "x" : "y";
    const currDir = dir[dirAccessor];
    let points = [];
    let centerX, centerY;
    const sourceGapOffset = { x: 0, y: 0 };
    const targetGapOffset = { x: 0, y: 0 };
    const [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({
      sourceX: source.x,
      sourceY: source.y,
      targetX: target.x,
      targetY: target.y
    });
    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
      centerX = center.x ?? defaultCenterX;
      centerY = center.y ?? defaultCenterY;
      const verticalSplit = [
        { x: centerX, y: sourceGapped.y },
        { x: centerX, y: targetGapped.y }
      ];
      const horizontalSplit = [
        { x: sourceGapped.x, y: centerY },
        { x: targetGapped.x, y: centerY }
      ];
      if (sourceDir[dirAccessor] === currDir) {
        points = dirAccessor === "x" ? verticalSplit : horizontalSplit;
      } else {
        points = dirAccessor === "x" ? horizontalSplit : verticalSplit;
      }
    } else {
      const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];
      const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];
      if (dirAccessor === "x") {
        points = sourceDir.x === currDir ? targetSource : sourceTarget;
      } else {
        points = sourceDir.y === currDir ? sourceTarget : targetSource;
      }
      if (sourcePosition === targetPosition) {
        const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);
        if (diff <= offset) {
          const gapOffset = Math.min(offset - 1, offset - diff);
          if (sourceDir[dirAccessor] === currDir) {
            sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;
          } else {
            targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;
          }
        }
      }
      if (sourcePosition !== targetPosition) {
        const dirAccessorOpposite = dirAccessor === "x" ? "y" : "x";
        const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];
        const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];
        const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
        const flipSourceTarget = sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo);
        if (flipSourceTarget) {
          points = dirAccessor === "x" ? sourceTarget : targetSource;
        }
      }
      const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };
      const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };
      const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));
      const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));
      if (maxXDistance >= maxYDistance) {
        centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;
        centerY = points[0].y;
      } else {
        centerX = points[0].x;
        centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;
      }
    }
    const pathPoints = [
      source,
      { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },
      ...points,
      { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },
      target
    ];
    return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];
  }
  function getBend(a2, b2, c2, size) {
    const bendSize = Math.min(distance(a2, b2) / 2, distance(b2, c2) / 2, size);
    const { x: x2, y: y2 } = b2;
    if (a2.x === x2 && x2 === c2.x || a2.y === y2 && y2 === c2.y) {
      return `L${x2} ${y2}`;
    }
    if (a2.y === y2) {
      const xDir2 = a2.x < c2.x ? -1 : 1;
      const yDir2 = a2.y < c2.y ? 1 : -1;
      return `L ${x2 + bendSize * xDir2},${y2}Q ${x2},${y2} ${x2},${y2 + bendSize * yDir2}`;
    }
    const xDir = a2.x < c2.x ? 1 : -1;
    const yDir = a2.y < c2.y ? -1 : 1;
    return `L ${x2},${y2 + bendSize * yDir}Q ${x2},${y2} ${x2 + bendSize * xDir},${y2}`;
  }
  function getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20 }) {
    const [points, labelX, labelY, offsetX, offsetY] = getPoints({
      source: { x: sourceX, y: sourceY },
      sourcePosition,
      target: { x: targetX, y: targetY },
      targetPosition,
      center: { x: centerX, y: centerY },
      offset
    });
    const path = points.reduce((res, p2, i2) => {
      let segment = "";
      if (i2 > 0 && i2 < points.length - 1) {
        segment = getBend(points[i2 - 1], p2, points[i2 + 1], borderRadius);
      } else {
        segment = `${i2 === 0 ? "M" : "L"}${p2.x} ${p2.y}`;
      }
      res += segment;
      return res;
    }, "");
    return [path, labelX, labelY, offsetX, offsetY];
  }
  var SmoothStepEdge = (0, import_react2.memo)(({ sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, sourcePosition = Position.Bottom, targetPosition = Position.Top, markerEnd, markerStart, pathOptions, interactionWidth }) => {
    const [path, labelX, labelY] = getSmoothStepPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition,
      borderRadius: pathOptions?.borderRadius,
      offset: pathOptions?.offset
    });
    return import_react2.default.createElement(BaseEdge, { path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
  SmoothStepEdge.displayName = "SmoothStepEdge";
  var StepEdge = (0, import_react2.memo)((props) => import_react2.default.createElement(SmoothStepEdge, { ...props, pathOptions: (0, import_react2.useMemo)(() => ({ borderRadius: 0, offset: props.pathOptions?.offset }), [props.pathOptions?.offset]) }));
  StepEdge.displayName = "StepEdge";
  function getStraightPath({ sourceX, sourceY, targetX, targetY }) {
    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({
      sourceX,
      sourceY,
      targetX,
      targetY
    });
    return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];
  }
  var StraightEdge = (0, import_react2.memo)(({ sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth }) => {
    const [path, labelX, labelY] = getStraightPath({ sourceX, sourceY, targetX, targetY });
    return import_react2.default.createElement(BaseEdge, { path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
  StraightEdge.displayName = "StraightEdge";
  function calculateControlOffset(distance3, curvature) {
    if (distance3 >= 0) {
      return 0.5 * distance3;
    }
    return curvature * 25 * Math.sqrt(-distance3);
  }
  function getControlWithCurvature({ pos, x1, y1, x2, y2, c: c2 }) {
    switch (pos) {
      case Position.Left:
        return [x1 - calculateControlOffset(x1 - x2, c2), y1];
      case Position.Right:
        return [x1 + calculateControlOffset(x2 - x1, c2), y1];
      case Position.Top:
        return [x1, y1 - calculateControlOffset(y1 - y2, c2)];
      case Position.Bottom:
        return [x1, y1 + calculateControlOffset(y2 - y1, c2)];
    }
  }
  function getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {
    const [sourceControlX, sourceControlY] = getControlWithCurvature({
      pos: sourcePosition,
      x1: sourceX,
      y1: sourceY,
      x2: targetX,
      y2: targetY,
      c: curvature
    });
    const [targetControlX, targetControlY] = getControlWithCurvature({
      pos: targetPosition,
      x1: targetX,
      y1: targetY,
      x2: sourceX,
      y2: sourceY,
      c: curvature
    });
    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
      sourceX,
      sourceY,
      targetX,
      targetY,
      sourceControlX,
      sourceControlY,
      targetControlX,
      targetControlY
    });
    return [
      `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
      labelX,
      labelY,
      offsetX,
      offsetY
    ];
  }
  var BezierEdge = (0, import_react2.memo)(({ sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, pathOptions, interactionWidth }) => {
    const [path, labelX, labelY] = getBezierPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition,
      curvature: pathOptions?.curvature
    });
    return import_react2.default.createElement(BaseEdge, { path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
  });
  BezierEdge.displayName = "BezierEdge";
  var NodeIdContext = (0, import_react2.createContext)(null);
  var Provider = NodeIdContext.Provider;
  NodeIdContext.Consumer;
  var useNodeId = () => {
    const nodeId = (0, import_react2.useContext)(NodeIdContext);
    return nodeId;
  };
  var isEdge = (element) => "id" in element && "source" in element && "target" in element;
  var getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `reactflow__edge-${source}${sourceHandle || ""}-${target}${targetHandle || ""}`;
  var getMarkerId = (marker, rfId) => {
    if (typeof marker === "undefined") {
      return "";
    }
    if (typeof marker === "string") {
      return marker;
    }
    const idPrefix = rfId ? `${rfId}__` : "";
    return `${idPrefix}${Object.keys(marker).sort().map((key) => `${key}=${marker[key]}`).join("&")}`;
  };
  var connectionExists = (edge, edges) => {
    return edges.some((el) => el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle));
  };
  var addEdge = (edgeParams, edges) => {
    if (!edgeParams.source || !edgeParams.target) {
      devWarn("006", errorMessages["error006"]());
      return edges;
    }
    let edge;
    if (isEdge(edgeParams)) {
      edge = { ...edgeParams };
    } else {
      edge = {
        ...edgeParams,
        id: getEdgeId(edgeParams)
      };
    }
    if (connectionExists(edge, edges)) {
      return edges;
    }
    return edges.concat(edge);
  };
  var pointToRendererPoint = ({ x: x2, y: y2 }, [tx, ty, tScale], snapToGrid, [snapX, snapY]) => {
    const position2 = {
      x: (x2 - tx) / tScale,
      y: (y2 - ty) / tScale
    };
    if (snapToGrid) {
      return {
        x: snapX * Math.round(position2.x / snapX),
        y: snapY * Math.round(position2.y / snapY)
      };
    }
    return position2;
  };
  var rendererPointToPoint = ({ x: x2, y: y2 }, [tx, ty, tScale]) => {
    return {
      x: x2 * tScale + tx,
      y: y2 * tScale + ty
    };
  };
  var getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {
    if (!node) {
      return {
        x: 0,
        y: 0,
        positionAbsolute: {
          x: 0,
          y: 0
        }
      };
    }
    const offsetX = (node.width ?? 0) * nodeOrigin[0];
    const offsetY = (node.height ?? 0) * nodeOrigin[1];
    const position2 = {
      x: node.position.x - offsetX,
      y: node.position.y - offsetY
    };
    return {
      ...position2,
      positionAbsolute: node.positionAbsolute ? {
        x: node.positionAbsolute.x - offsetX,
        y: node.positionAbsolute.y - offsetY
      } : position2
    };
  };
  var getNodesBounds = (nodes, nodeOrigin = [0, 0]) => {
    if (nodes.length === 0) {
      return { x: 0, y: 0, width: 0, height: 0 };
    }
    const box = nodes.reduce((currBox, node) => {
      const { x: x2, y: y2 } = getNodePositionWithOrigin(node, nodeOrigin).positionAbsolute;
      return getBoundsOfBoxes(currBox, rectToBox({
        x: x2,
        y: y2,
        width: node.width || 0,
        height: node.height || 0
      }));
    }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });
    return boxToRect(box);
  };
  var getNodesInside = (nodeInternals, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, excludeNonSelectableNodes = false, nodeOrigin = [0, 0]) => {
    const paneRect = {
      x: (rect.x - tx) / tScale,
      y: (rect.y - ty) / tScale,
      width: rect.width / tScale,
      height: rect.height / tScale
    };
    const visibleNodes = [];
    nodeInternals.forEach((node) => {
      const { width, height: height2, selectable = true, hidden = false } = node;
      if (excludeNonSelectableNodes && !selectable || hidden) {
        return false;
      }
      const { positionAbsolute } = getNodePositionWithOrigin(node, nodeOrigin);
      const nodeRect = {
        x: positionAbsolute.x,
        y: positionAbsolute.y,
        width: width || 0,
        height: height2 || 0
      };
      const overlappingArea = getOverlappingArea(paneRect, nodeRect);
      const notInitialized = typeof width === "undefined" || typeof height2 === "undefined" || width === null || height2 === null;
      const partiallyVisible = partially && overlappingArea > 0;
      const area = (width || 0) * (height2 || 0);
      const isVisible = notInitialized || partiallyVisible || overlappingArea >= area;
      if (isVisible || node.dragging) {
        visibleNodes.push(node);
      }
    });
    return visibleNodes;
  };
  var getConnectedEdges = (nodes, edges) => {
    const nodeIds = nodes.map((node) => node.id);
    return edges.filter((edge) => nodeIds.includes(edge.source) || nodeIds.includes(edge.target));
  };
  var getViewportForBounds = (bounds, width, height2, minZoom, maxZoom, padding = 0.1) => {
    const xZoom = width / (bounds.width * (1 + padding));
    const yZoom = height2 / (bounds.height * (1 + padding));
    const zoom = Math.min(xZoom, yZoom);
    const clampedZoom = clamp(zoom, minZoom, maxZoom);
    const boundsCenterX = bounds.x + bounds.width / 2;
    const boundsCenterY = bounds.y + bounds.height / 2;
    const x2 = width / 2 - boundsCenterX * clampedZoom;
    const y2 = height2 / 2 - boundsCenterY * clampedZoom;
    return { x: x2, y: y2, zoom: clampedZoom };
  };
  var getD3Transition = (selection2, duration = 0) => {
    return selection2.transition().duration(duration);
  };
  function getHandles(node, handleBounds, type, currentHandle) {
    return (handleBounds[type] || []).reduce((res, h2) => {
      if (`${node.id}-${h2.id}-${type}` !== currentHandle) {
        res.push({
          id: h2.id || null,
          type,
          nodeId: node.id,
          x: (node.positionAbsolute?.x ?? 0) + h2.x + h2.width / 2,
          y: (node.positionAbsolute?.y ?? 0) + h2.y + h2.height / 2
        });
      }
      return res;
    }, []);
  }
  function getClosestHandle(event, doc2, pos, connectionRadius, handles, validator) {
    const { x: x2, y: y2 } = getEventPosition(event);
    const domNodes = doc2.elementsFromPoint(x2, y2);
    const handleBelow = domNodes.find((el) => el.classList.contains("react-flow__handle"));
    if (handleBelow) {
      const handleNodeId = handleBelow.getAttribute("data-nodeid");
      if (handleNodeId) {
        const handleType = getHandleType(void 0, handleBelow);
        const handleId = handleBelow.getAttribute("data-handleid");
        const validHandleResult = validator({ nodeId: handleNodeId, id: handleId, type: handleType });
        if (validHandleResult) {
          const handle = handles.find((h2) => h2.nodeId === handleNodeId && h2.type === handleType && h2.id === handleId);
          return {
            handle: {
              id: handleId,
              type: handleType,
              nodeId: handleNodeId,
              x: handle?.x || pos.x,
              y: handle?.y || pos.y
            },
            validHandleResult
          };
        }
      }
    }
    let closestHandles = [];
    let minDistance = Infinity;
    handles.forEach((handle) => {
      const distance3 = Math.sqrt((handle.x - pos.x) ** 2 + (handle.y - pos.y) ** 2);
      if (distance3 <= connectionRadius) {
        const validHandleResult = validator(handle);
        if (distance3 <= minDistance) {
          if (distance3 < minDistance) {
            closestHandles = [{ handle, validHandleResult }];
          } else if (distance3 === minDistance) {
            closestHandles.push({
              handle,
              validHandleResult
            });
          }
          minDistance = distance3;
        }
      }
    });
    if (!closestHandles.length) {
      return { handle: null, validHandleResult: defaultResult() };
    }
    if (closestHandles.length === 1) {
      return closestHandles[0];
    }
    const hasValidHandle = closestHandles.some(({ validHandleResult }) => validHandleResult.isValid);
    const hasTargetHandle = closestHandles.some(({ handle }) => handle.type === "target");
    return closestHandles.find(({ handle, validHandleResult }) => hasTargetHandle ? handle.type === "target" : hasValidHandle ? validHandleResult.isValid : true) || closestHandles[0];
  }
  var nullConnection = { source: null, target: null, sourceHandle: null, targetHandle: null };
  var defaultResult = () => ({
    handleDomNode: null,
    isValid: false,
    connection: nullConnection,
    endHandle: null
  });
  function isValidHandle(handle, connectionMode, fromNodeId, fromHandleId, fromType, isValidConnection, doc2) {
    const isTarget = fromType === "target";
    const handleToCheck = doc2.querySelector(`.react-flow__handle[data-id="${handle?.nodeId}-${handle?.id}-${handle?.type}"]`);
    const result = {
      ...defaultResult(),
      handleDomNode: handleToCheck
    };
    if (handleToCheck) {
      const handleType = getHandleType(void 0, handleToCheck);
      const handleNodeId = handleToCheck.getAttribute("data-nodeid");
      const handleId = handleToCheck.getAttribute("data-handleid");
      const connectable = handleToCheck.classList.contains("connectable");
      const connectableEnd = handleToCheck.classList.contains("connectableend");
      const connection = {
        source: isTarget ? handleNodeId : fromNodeId,
        sourceHandle: isTarget ? handleId : fromHandleId,
        target: isTarget ? fromNodeId : handleNodeId,
        targetHandle: isTarget ? fromHandleId : handleId
      };
      result.connection = connection;
      const isConnectable = connectable && connectableEnd;
      const isValid = isConnectable && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === "source" || !isTarget && handleType === "target" : handleNodeId !== fromNodeId || handleId !== fromHandleId);
      if (isValid) {
        result.endHandle = {
          nodeId: handleNodeId,
          handleId,
          type: handleType
        };
        result.isValid = isValidConnection(connection);
      }
    }
    return result;
  }
  function getHandleLookup({ nodes, nodeId, handleId, handleType }) {
    return nodes.reduce((res, node) => {
      if (node[internalsSymbol]) {
        const { handleBounds } = node[internalsSymbol];
        let sourceHandles = [];
        let targetHandles = [];
        if (handleBounds) {
          sourceHandles = getHandles(node, handleBounds, "source", `${nodeId}-${handleId}-${handleType}`);
          targetHandles = getHandles(node, handleBounds, "target", `${nodeId}-${handleId}-${handleType}`);
        }
        res.push(...sourceHandles, ...targetHandles);
      }
      return res;
    }, []);
  }
  function getHandleType(edgeUpdaterType, handleDomNode) {
    if (edgeUpdaterType) {
      return edgeUpdaterType;
    } else if (handleDomNode?.classList.contains("target")) {
      return "target";
    } else if (handleDomNode?.classList.contains("source")) {
      return "source";
    }
    return null;
  }
  function resetRecentHandle(handleDomNode) {
    handleDomNode?.classList.remove("valid", "connecting", "react-flow__handle-valid", "react-flow__handle-connecting");
  }
  function getConnectionStatus(isInsideConnectionRadius, isHandleValid) {
    let connectionStatus = null;
    if (isHandleValid) {
      connectionStatus = "valid";
    } else if (isInsideConnectionRadius && !isHandleValid) {
      connectionStatus = "invalid";
    }
    return connectionStatus;
  }
  function handlePointerDown({ event, handleId, nodeId, onConnect, isTarget, getState, setState, isValidConnection, edgeUpdaterType, onReconnectEnd }) {
    const doc2 = getHostForElement(event.target);
    const { connectionMode, domNode, autoPanOnConnect, connectionRadius, onConnectStart, panBy, getNodes, cancelConnection } = getState();
    let autoPanId = 0;
    let closestHandle;
    const { x: x2, y: y2 } = getEventPosition(event);
    const clickedHandle = doc2?.elementFromPoint(x2, y2);
    const handleType = getHandleType(edgeUpdaterType, clickedHandle);
    const containerBounds = domNode?.getBoundingClientRect();
    if (!containerBounds || !handleType) {
      return;
    }
    let prevActiveHandle;
    let connectionPosition = getEventPosition(event, containerBounds);
    let autoPanStarted = false;
    let connection = null;
    let isValid = false;
    let handleDomNode = null;
    const handleLookup = getHandleLookup({
      nodes: getNodes(),
      nodeId,
      handleId,
      handleType
    });
    const autoPan = () => {
      if (!autoPanOnConnect) {
        return;
      }
      const [xMovement, yMovement] = calcAutoPan(connectionPosition, containerBounds);
      panBy({ x: xMovement, y: yMovement });
      autoPanId = requestAnimationFrame(autoPan);
    };
    setState({
      connectionPosition,
      connectionStatus: null,
      // connectionNodeId etc will be removed in the next major in favor of connectionStartHandle
      connectionNodeId: nodeId,
      connectionHandleId: handleId,
      connectionHandleType: handleType,
      connectionStartHandle: {
        nodeId,
        handleId,
        type: handleType
      },
      connectionEndHandle: null
    });
    onConnectStart?.(event, { nodeId, handleId, handleType });
    function onPointerMove(event2) {
      const { transform: transform2 } = getState();
      connectionPosition = getEventPosition(event2, containerBounds);
      const { handle, validHandleResult } = getClosestHandle(event2, doc2, pointToRendererPoint(connectionPosition, transform2, false, [1, 1]), connectionRadius, handleLookup, (handle2) => isValidHandle(handle2, connectionMode, nodeId, handleId, isTarget ? "target" : "source", isValidConnection, doc2));
      closestHandle = handle;
      if (!autoPanStarted) {
        autoPan();
        autoPanStarted = true;
      }
      handleDomNode = validHandleResult.handleDomNode;
      connection = validHandleResult.connection;
      isValid = validHandleResult.isValid;
      setState({
        connectionPosition: closestHandle && isValid ? rendererPointToPoint({
          x: closestHandle.x,
          y: closestHandle.y
        }, transform2) : connectionPosition,
        connectionStatus: getConnectionStatus(!!closestHandle, isValid),
        connectionEndHandle: validHandleResult.endHandle
      });
      if (!closestHandle && !isValid && !handleDomNode) {
        return resetRecentHandle(prevActiveHandle);
      }
      if (connection.source !== connection.target && handleDomNode) {
        resetRecentHandle(prevActiveHandle);
        prevActiveHandle = handleDomNode;
        handleDomNode.classList.add("connecting", "react-flow__handle-connecting");
        handleDomNode.classList.toggle("valid", isValid);
        handleDomNode.classList.toggle("react-flow__handle-valid", isValid);
      }
    }
    function onPointerUp(event2) {
      if ((closestHandle || handleDomNode) && connection && isValid) {
        onConnect?.(connection);
      }
      getState().onConnectEnd?.(event2);
      if (edgeUpdaterType) {
        onReconnectEnd?.(event2);
      }
      resetRecentHandle(prevActiveHandle);
      cancelConnection();
      cancelAnimationFrame(autoPanId);
      autoPanStarted = false;
      isValid = false;
      connection = null;
      handleDomNode = null;
      doc2.removeEventListener("mousemove", onPointerMove);
      doc2.removeEventListener("mouseup", onPointerUp);
      doc2.removeEventListener("touchmove", onPointerMove);
      doc2.removeEventListener("touchend", onPointerUp);
    }
    doc2.addEventListener("mousemove", onPointerMove);
    doc2.addEventListener("mouseup", onPointerUp);
    doc2.addEventListener("touchmove", onPointerMove);
    doc2.addEventListener("touchend", onPointerUp);
  }
  var alwaysValid = () => true;
  var selector$f = (s2) => ({
    connectionStartHandle: s2.connectionStartHandle,
    connectOnClick: s2.connectOnClick,
    noPanClassName: s2.noPanClassName
  });
  var connectingSelector = (nodeId, handleId, type) => (state) => {
    const { connectionStartHandle: startHandle, connectionEndHandle: endHandle, connectionClickStartHandle: clickHandle } = state;
    return {
      connecting: startHandle?.nodeId === nodeId && startHandle?.handleId === handleId && startHandle?.type === type || endHandle?.nodeId === nodeId && endHandle?.handleId === handleId && endHandle?.type === type,
      clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.handleId === handleId && clickHandle?.type === type
    };
  };
  var Handle = (0, import_react2.forwardRef)(({ type = "source", position: position2 = Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id: id2, onConnect, children: children3, className, onMouseDown, onTouchStart, ...rest }, ref) => {
    const handleId = id2 || null;
    const isTarget = type === "target";
    const store = useStoreApi();
    const nodeId = useNodeId();
    const { connectOnClick, noPanClassName } = useStore(selector$f, shallow$1);
    const { connecting, clickConnecting } = useStore(connectingSelector(nodeId, handleId, type), shallow$1);
    if (!nodeId) {
      store.getState().onError?.("010", errorMessages["error010"]());
    }
    const onConnectExtended = (params) => {
      const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();
      const edgeParams = {
        ...defaultEdgeOptions,
        ...params
      };
      if (hasDefaultEdges) {
        const { edges, setEdges } = store.getState();
        setEdges(addEdge(edgeParams, edges));
      }
      onConnectAction?.(edgeParams);
      onConnect?.(edgeParams);
    };
    const onPointerDown = (event) => {
      if (!nodeId) {
        return;
      }
      const isMouseTriggered = isMouseEvent(event);
      if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {
        handlePointerDown({
          event,
          handleId,
          nodeId,
          onConnect: onConnectExtended,
          isTarget,
          getState: store.getState,
          setState: store.setState,
          isValidConnection: isValidConnection || store.getState().isValidConnection || alwaysValid
        });
      }
      if (isMouseTriggered) {
        onMouseDown?.(event);
      } else {
        onTouchStart?.(event);
      }
    };
    const onClick = (event) => {
      const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore } = store.getState();
      if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {
        return;
      }
      if (!connectionClickStartHandle) {
        onClickConnectStart?.(event, { nodeId, handleId, handleType: type });
        store.setState({ connectionClickStartHandle: { nodeId, type, handleId } });
        return;
      }
      const doc2 = getHostForElement(event.target);
      const isValidConnectionHandler = isValidConnection || isValidConnectionStore || alwaysValid;
      const { connection, isValid } = isValidHandle({
        nodeId,
        id: handleId,
        type
      }, connectionMode, connectionClickStartHandle.nodeId, connectionClickStartHandle.handleId || null, connectionClickStartHandle.type, isValidConnectionHandler, doc2);
      if (isValid) {
        onConnectExtended(connection);
      }
      onClickConnectEnd?.(event);
      store.setState({ connectionClickStartHandle: null });
    };
    return import_react2.default.createElement("div", { "data-handleid": handleId, "data-nodeid": nodeId, "data-handlepos": position2, "data-id": `${nodeId}-${handleId}-${type}`, className: cc([
      "react-flow__handle",
      `react-flow__handle-${position2}`,
      "nodrag",
      noPanClassName,
      className,
      {
        source: !isTarget,
        target: isTarget,
        connectable: isConnectable,
        connectablestart: isConnectableStart,
        connectableend: isConnectableEnd,
        connecting: clickConnecting,
        // this class is used to style the handle when the user is connecting
        connectionindicator: isConnectable && (isConnectableStart && !connecting || isConnectableEnd && connecting)
      }
    ]), onMouseDown: onPointerDown, onTouchStart: onPointerDown, onClick: connectOnClick ? onClick : void 0, ref, ...rest }, children3);
  });
  Handle.displayName = "Handle";
  var Handle$1 = (0, import_react2.memo)(Handle);
  var DefaultNode = ({ data, isConnectable, targetPosition = Position.Top, sourcePosition = Position.Bottom }) => {
    return import_react2.default.createElement(
      import_react2.default.Fragment,
      null,
      import_react2.default.createElement(Handle$1, { type: "target", position: targetPosition, isConnectable }),
      data?.label,
      import_react2.default.createElement(Handle$1, { type: "source", position: sourcePosition, isConnectable })
    );
  };
  DefaultNode.displayName = "DefaultNode";
  var DefaultNode$1 = (0, import_react2.memo)(DefaultNode);
  var InputNode = ({ data, isConnectable, sourcePosition = Position.Bottom }) => import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    data?.label,
    import_react2.default.createElement(Handle$1, { type: "source", position: sourcePosition, isConnectable })
  );
  InputNode.displayName = "InputNode";
  var InputNode$1 = (0, import_react2.memo)(InputNode);
  var OutputNode = ({ data, isConnectable, targetPosition = Position.Top }) => import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(Handle$1, { type: "target", position: targetPosition, isConnectable }),
    data?.label
  );
  OutputNode.displayName = "OutputNode";
  var OutputNode$1 = (0, import_react2.memo)(OutputNode);
  var GroupNode = () => null;
  GroupNode.displayName = "GroupNode";
  var selector$e = (s2) => ({
    selectedNodes: s2.getNodes().filter((n2) => n2.selected),
    selectedEdges: s2.edges.filter((e2) => e2.selected).map((e2) => ({ ...e2 }))
  });
  var selectId = (obj) => obj.id;
  function areEqual(a2, b2) {
    return shallow$1(a2.selectedNodes.map(selectId), b2.selectedNodes.map(selectId)) && shallow$1(a2.selectedEdges.map(selectId), b2.selectedEdges.map(selectId));
  }
  var SelectionListener = (0, import_react2.memo)(({ onSelectionChange }) => {
    const store = useStoreApi();
    const { selectedNodes, selectedEdges } = useStore(selector$e, areEqual);
    (0, import_react2.useEffect)(() => {
      const params = { nodes: selectedNodes, edges: selectedEdges };
      onSelectionChange?.(params);
      store.getState().onSelectionChange.forEach((fn2) => fn2(params));
    }, [selectedNodes, selectedEdges, onSelectionChange]);
    return null;
  });
  SelectionListener.displayName = "SelectionListener";
  var changeSelector = (s2) => !!s2.onSelectionChange;
  function Wrapper$1({ onSelectionChange }) {
    const storeHasSelectionChange = useStore(changeSelector);
    if (onSelectionChange || storeHasSelectionChange) {
      return import_react2.default.createElement(SelectionListener, { onSelectionChange });
    }
    return null;
  }
  var selector$d = (s2) => ({
    setNodes: s2.setNodes,
    setEdges: s2.setEdges,
    setDefaultNodesAndEdges: s2.setDefaultNodesAndEdges,
    setMinZoom: s2.setMinZoom,
    setMaxZoom: s2.setMaxZoom,
    setTranslateExtent: s2.setTranslateExtent,
    setNodeExtent: s2.setNodeExtent,
    reset: s2.reset
  });
  function useStoreUpdater(value, setStoreState) {
    (0, import_react2.useEffect)(() => {
      if (typeof value !== "undefined") {
        setStoreState(value);
      }
    }, [value]);
  }
  function useDirectStoreUpdater(key, value, setState) {
    (0, import_react2.useEffect)(() => {
      if (typeof value !== "undefined") {
        setState({ [key]: value });
      }
    }, [value]);
  }
  var StoreUpdater = ({ nodes, edges, defaultNodes, defaultEdges, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, nodesDraggable, nodesConnectable, nodesFocusable, edgesFocusable, edgesUpdatable, elevateNodesOnSelect, minZoom, maxZoom, nodeExtent, onNodesChange, onEdgesChange, elementsSelectable, connectionMode, snapGrid, snapToGrid, translateExtent, connectOnClick, defaultEdgeOptions, fitView: fitView2, fitViewOptions, onNodesDelete, onEdgesDelete, onNodeDrag, onNodeDragStart, onNodeDragStop, onSelectionDrag, onSelectionDragStart, onSelectionDragStop, noPanClassName, nodeOrigin, rfId, autoPanOnConnect, autoPanOnNodeDrag, onError, connectionRadius, isValidConnection, nodeDragThreshold }) => {
    const { setNodes, setEdges, setDefaultNodesAndEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset } = useStore(selector$d, shallow$1);
    const store = useStoreApi();
    (0, import_react2.useEffect)(() => {
      const edgesWithDefaults = defaultEdges?.map((e2) => ({ ...e2, ...defaultEdgeOptions }));
      setDefaultNodesAndEdges(defaultNodes, edgesWithDefaults);
      return () => {
        reset();
      };
    }, []);
    useDirectStoreUpdater("defaultEdgeOptions", defaultEdgeOptions, store.setState);
    useDirectStoreUpdater("connectionMode", connectionMode, store.setState);
    useDirectStoreUpdater("onConnect", onConnect, store.setState);
    useDirectStoreUpdater("onConnectStart", onConnectStart, store.setState);
    useDirectStoreUpdater("onConnectEnd", onConnectEnd, store.setState);
    useDirectStoreUpdater("onClickConnectStart", onClickConnectStart, store.setState);
    useDirectStoreUpdater("onClickConnectEnd", onClickConnectEnd, store.setState);
    useDirectStoreUpdater("nodesDraggable", nodesDraggable, store.setState);
    useDirectStoreUpdater("nodesConnectable", nodesConnectable, store.setState);
    useDirectStoreUpdater("nodesFocusable", nodesFocusable, store.setState);
    useDirectStoreUpdater("edgesFocusable", edgesFocusable, store.setState);
    useDirectStoreUpdater("edgesUpdatable", edgesUpdatable, store.setState);
    useDirectStoreUpdater("elementsSelectable", elementsSelectable, store.setState);
    useDirectStoreUpdater("elevateNodesOnSelect", elevateNodesOnSelect, store.setState);
    useDirectStoreUpdater("snapToGrid", snapToGrid, store.setState);
    useDirectStoreUpdater("snapGrid", snapGrid, store.setState);
    useDirectStoreUpdater("onNodesChange", onNodesChange, store.setState);
    useDirectStoreUpdater("onEdgesChange", onEdgesChange, store.setState);
    useDirectStoreUpdater("connectOnClick", connectOnClick, store.setState);
    useDirectStoreUpdater("fitViewOnInit", fitView2, store.setState);
    useDirectStoreUpdater("fitViewOnInitOptions", fitViewOptions, store.setState);
    useDirectStoreUpdater("onNodesDelete", onNodesDelete, store.setState);
    useDirectStoreUpdater("onEdgesDelete", onEdgesDelete, store.setState);
    useDirectStoreUpdater("onNodeDrag", onNodeDrag, store.setState);
    useDirectStoreUpdater("onNodeDragStart", onNodeDragStart, store.setState);
    useDirectStoreUpdater("onNodeDragStop", onNodeDragStop, store.setState);
    useDirectStoreUpdater("onSelectionDrag", onSelectionDrag, store.setState);
    useDirectStoreUpdater("onSelectionDragStart", onSelectionDragStart, store.setState);
    useDirectStoreUpdater("onSelectionDragStop", onSelectionDragStop, store.setState);
    useDirectStoreUpdater("noPanClassName", noPanClassName, store.setState);
    useDirectStoreUpdater("nodeOrigin", nodeOrigin, store.setState);
    useDirectStoreUpdater("rfId", rfId, store.setState);
    useDirectStoreUpdater("autoPanOnConnect", autoPanOnConnect, store.setState);
    useDirectStoreUpdater("autoPanOnNodeDrag", autoPanOnNodeDrag, store.setState);
    useDirectStoreUpdater("onError", onError, store.setState);
    useDirectStoreUpdater("connectionRadius", connectionRadius, store.setState);
    useDirectStoreUpdater("isValidConnection", isValidConnection, store.setState);
    useDirectStoreUpdater("nodeDragThreshold", nodeDragThreshold, store.setState);
    useStoreUpdater(nodes, setNodes);
    useStoreUpdater(edges, setEdges);
    useStoreUpdater(minZoom, setMinZoom);
    useStoreUpdater(maxZoom, setMaxZoom);
    useStoreUpdater(translateExtent, setTranslateExtent);
    useStoreUpdater(nodeExtent, setNodeExtent);
    return null;
  };
  var style = { display: "none" };
  var ariaLiveStyle = {
    position: "absolute",
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: "hidden",
    clip: "rect(0px, 0px, 0px, 0px)",
    clipPath: "inset(100%)"
  };
  var ARIA_NODE_DESC_KEY = "react-flow__node-desc";
  var ARIA_EDGE_DESC_KEY = "react-flow__edge-desc";
  var ARIA_LIVE_MESSAGE = "react-flow__aria-live";
  var selector$c = (s2) => s2.ariaLiveMessage;
  function AriaLiveMessage({ rfId }) {
    const ariaLiveMessage = useStore(selector$c);
    return import_react2.default.createElement("div", { id: `${ARIA_LIVE_MESSAGE}-${rfId}`, "aria-live": "assertive", "aria-atomic": "true", style: ariaLiveStyle }, ariaLiveMessage);
  }
  function A11yDescriptions({ rfId, disableKeyboardA11y }) {
    return import_react2.default.createElement(
      import_react2.default.Fragment,
      null,
      import_react2.default.createElement(
        "div",
        { id: `${ARIA_NODE_DESC_KEY}-${rfId}`, style },
        "Press enter or space to select a node.",
        !disableKeyboardA11y && "You can then use the arrow keys to move the node around.",
        " Press delete to remove it and escape to cancel.",
        " "
      ),
      import_react2.default.createElement("div", { id: `${ARIA_EDGE_DESC_KEY}-${rfId}`, style }, "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel."),
      !disableKeyboardA11y && import_react2.default.createElement(AriaLiveMessage, { rfId })
    );
  }
  var useKeyPress = (keyCode = null, options = { actInsideInputWithModifier: true }) => {
    const [keyPressed, setKeyPressed] = (0, import_react2.useState)(false);
    const modifierPressed = (0, import_react2.useRef)(false);
    const pressedKeys = (0, import_react2.useRef)(/* @__PURE__ */ new Set([]));
    const [keyCodes, keysToWatch] = (0, import_react2.useMemo)(() => {
      if (keyCode !== null) {
        const keyCodeArr = Array.isArray(keyCode) ? keyCode : [keyCode];
        const keys = keyCodeArr.filter((kc) => typeof kc === "string").map((kc) => kc.split("+"));
        const keysFlat = keys.reduce((res, item) => res.concat(...item), []);
        return [keys, keysFlat];
      }
      return [[], []];
    }, [keyCode]);
    (0, import_react2.useEffect)(() => {
      const doc2 = typeof document !== "undefined" ? document : null;
      const target = options?.target || doc2;
      if (keyCode !== null) {
        const downHandler = (event) => {
          modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey;
          const preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && isInputDOMNode(event);
          if (preventAction) {
            return false;
          }
          const keyOrCode = useKeyOrCode(event.code, keysToWatch);
          pressedKeys.current.add(event[keyOrCode]);
          if (isMatchingKey(keyCodes, pressedKeys.current, false)) {
            event.preventDefault();
            setKeyPressed(true);
          }
        };
        const upHandler = (event) => {
          const preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && isInputDOMNode(event);
          if (preventAction) {
            return false;
          }
          const keyOrCode = useKeyOrCode(event.code, keysToWatch);
          if (isMatchingKey(keyCodes, pressedKeys.current, true)) {
            setKeyPressed(false);
            pressedKeys.current.clear();
          } else {
            pressedKeys.current.delete(event[keyOrCode]);
          }
          if (event.key === "Meta") {
            pressedKeys.current.clear();
          }
          modifierPressed.current = false;
        };
        const resetHandler = () => {
          pressedKeys.current.clear();
          setKeyPressed(false);
        };
        target?.addEventListener("keydown", downHandler);
        target?.addEventListener("keyup", upHandler);
        window.addEventListener("blur", resetHandler);
        return () => {
          target?.removeEventListener("keydown", downHandler);
          target?.removeEventListener("keyup", upHandler);
          window.removeEventListener("blur", resetHandler);
        };
      }
    }, [keyCode, setKeyPressed]);
    return keyPressed;
  };
  function isMatchingKey(keyCodes, pressedKeys, isUp) {
    return keyCodes.filter((keys) => isUp || keys.length === pressedKeys.size).some((keys) => keys.every((k2) => pressedKeys.has(k2)));
  }
  function useKeyOrCode(eventCode, keysToWatch) {
    return keysToWatch.includes(eventCode) ? "code" : "key";
  }
  function calculateXYZPosition(node, nodeInternals, result, nodeOrigin) {
    const parentId = node.parentNode || node.parentId;
    if (!parentId) {
      return result;
    }
    const parentNode = nodeInternals.get(parentId);
    const parentNodePosition = getNodePositionWithOrigin(parentNode, nodeOrigin);
    return calculateXYZPosition(parentNode, nodeInternals, {
      x: (result.x ?? 0) + parentNodePosition.x,
      y: (result.y ?? 0) + parentNodePosition.y,
      z: (parentNode[internalsSymbol]?.z ?? 0) > (result.z ?? 0) ? parentNode[internalsSymbol]?.z ?? 0 : result.z ?? 0
    }, nodeOrigin);
  }
  function updateAbsoluteNodePositions(nodeInternals, nodeOrigin, parentNodes) {
    nodeInternals.forEach((node) => {
      const parentId = node.parentNode || node.parentId;
      if (parentId && !nodeInternals.has(parentId)) {
        throw new Error(`Parent node ${parentId} not found`);
      }
      if (parentId || parentNodes?.[node.id]) {
        const { x: x2, y: y2, z } = calculateXYZPosition(node, nodeInternals, {
          ...node.position,
          z: node[internalsSymbol]?.z ?? 0
        }, nodeOrigin);
        node.positionAbsolute = {
          x: x2,
          y: y2
        };
        node[internalsSymbol].z = z;
        if (parentNodes?.[node.id]) {
          node[internalsSymbol].isParent = true;
        }
      }
    });
  }
  function createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect) {
    const nextNodeInternals = /* @__PURE__ */ new Map();
    const parentNodes = {};
    const selectedNodeZ = elevateNodesOnSelect ? 1e3 : 0;
    nodes.forEach((node) => {
      const z = (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);
      const currInternals = nodeInternals.get(node.id);
      const internals = {
        ...node,
        positionAbsolute: {
          x: node.position.x,
          y: node.position.y
        }
      };
      const parentId = node.parentNode || node.parentId;
      if (parentId) {
        parentNodes[parentId] = true;
      }
      const resetHandleBounds = currInternals?.type && currInternals?.type !== node.type;
      Object.defineProperty(internals, internalsSymbol, {
        enumerable: false,
        value: {
          handleBounds: resetHandleBounds ? void 0 : currInternals?.[internalsSymbol]?.handleBounds,
          z
        }
      });
      nextNodeInternals.set(node.id, internals);
    });
    updateAbsoluteNodePositions(nextNodeInternals, nodeOrigin, parentNodes);
    return nextNodeInternals;
  }
  function fitView(get3, options = {}) {
    const { getNodes, width, height: height2, minZoom, maxZoom, d3Zoom, d3Selection, fitViewOnInitDone, fitViewOnInit, nodeOrigin } = get3();
    const isInitialFitView = options.initial && !fitViewOnInitDone && fitViewOnInit;
    const d3initialized = d3Zoom && d3Selection;
    if (d3initialized && (isInitialFitView || !options.initial)) {
      const nodes = getNodes().filter((n2) => {
        const isVisible = options.includeHiddenNodes ? n2.width && n2.height : !n2.hidden;
        if (options.nodes?.length) {
          return isVisible && options.nodes.some((optionNode) => optionNode.id === n2.id);
        }
        return isVisible;
      });
      const nodesInitialized = nodes.every((n2) => n2.width && n2.height);
      if (nodes.length > 0 && nodesInitialized) {
        const bounds = getNodesBounds(nodes, nodeOrigin);
        const { x: x2, y: y2, zoom } = getViewportForBounds(bounds, width, height2, options.minZoom ?? minZoom, options.maxZoom ?? maxZoom, options.padding ?? 0.1);
        const nextTransform = identity3.translate(x2, y2).scale(zoom);
        if (typeof options.duration === "number" && options.duration > 0) {
          d3Zoom.transform(getD3Transition(d3Selection, options.duration), nextTransform);
        } else {
          d3Zoom.transform(d3Selection, nextTransform);
        }
        return true;
      }
    }
    return false;
  }
  function handleControlledNodeSelectionChange(nodeChanges, nodeInternals) {
    nodeChanges.forEach((change) => {
      const node = nodeInternals.get(change.id);
      if (node) {
        nodeInternals.set(node.id, {
          ...node,
          [internalsSymbol]: node[internalsSymbol],
          selected: change.selected
        });
      }
    });
    return new Map(nodeInternals);
  }
  function handleControlledEdgeSelectionChange(edgeChanges, edges) {
    return edges.map((e2) => {
      const change = edgeChanges.find((change2) => change2.id === e2.id);
      if (change) {
        e2.selected = change.selected;
      }
      return e2;
    });
  }
  function updateNodesAndEdgesSelections({ changedNodes, changedEdges, get: get3, set: set3 }) {
    const { nodeInternals, edges, onNodesChange, onEdgesChange, hasDefaultNodes, hasDefaultEdges } = get3();
    if (changedNodes?.length) {
      if (hasDefaultNodes) {
        set3({ nodeInternals: handleControlledNodeSelectionChange(changedNodes, nodeInternals) });
      }
      onNodesChange?.(changedNodes);
    }
    if (changedEdges?.length) {
      if (hasDefaultEdges) {
        set3({ edges: handleControlledEdgeSelectionChange(changedEdges, edges) });
      }
      onEdgesChange?.(changedEdges);
    }
  }
  var noop2 = () => {
  };
  var initialViewportHelper = {
    zoomIn: noop2,
    zoomOut: noop2,
    zoomTo: noop2,
    getZoom: () => 1,
    setViewport: noop2,
    getViewport: () => ({ x: 0, y: 0, zoom: 1 }),
    fitView: () => false,
    setCenter: noop2,
    fitBounds: noop2,
    project: (position2) => position2,
    screenToFlowPosition: (position2) => position2,
    flowToScreenPosition: (position2) => position2,
    viewportInitialized: false
  };
  var selector$b = (s2) => ({
    d3Zoom: s2.d3Zoom,
    d3Selection: s2.d3Selection
  });
  var useViewportHelper = () => {
    const store = useStoreApi();
    const { d3Zoom, d3Selection } = useStore(selector$b, shallow$1);
    const viewportHelperFunctions = (0, import_react2.useMemo)(() => {
      if (d3Selection && d3Zoom) {
        return {
          zoomIn: (options) => d3Zoom.scaleBy(getD3Transition(d3Selection, options?.duration), 1.2),
          zoomOut: (options) => d3Zoom.scaleBy(getD3Transition(d3Selection, options?.duration), 1 / 1.2),
          zoomTo: (zoomLevel, options) => d3Zoom.scaleTo(getD3Transition(d3Selection, options?.duration), zoomLevel),
          getZoom: () => store.getState().transform[2],
          setViewport: (transform2, options) => {
            const [x2, y2, zoom] = store.getState().transform;
            const nextTransform = identity3.translate(transform2.x ?? x2, transform2.y ?? y2).scale(transform2.zoom ?? zoom);
            d3Zoom.transform(getD3Transition(d3Selection, options?.duration), nextTransform);
          },
          getViewport: () => {
            const [x2, y2, zoom] = store.getState().transform;
            return { x: x2, y: y2, zoom };
          },
          fitView: (options) => fitView(store.getState, options),
          setCenter: (x2, y2, options) => {
            const { width, height: height2, maxZoom } = store.getState();
            const nextZoom = typeof options?.zoom !== "undefined" ? options.zoom : maxZoom;
            const centerX = width / 2 - x2 * nextZoom;
            const centerY = height2 / 2 - y2 * nextZoom;
            const transform2 = identity3.translate(centerX, centerY).scale(nextZoom);
            d3Zoom.transform(getD3Transition(d3Selection, options?.duration), transform2);
          },
          fitBounds: (bounds, options) => {
            const { width, height: height2, minZoom, maxZoom } = store.getState();
            const { x: x2, y: y2, zoom } = getViewportForBounds(bounds, width, height2, minZoom, maxZoom, options?.padding ?? 0.1);
            const transform2 = identity3.translate(x2, y2).scale(zoom);
            d3Zoom.transform(getD3Transition(d3Selection, options?.duration), transform2);
          },
          // @deprecated Use `screenToFlowPosition`.
          project: (position2) => {
            const { transform: transform2, snapToGrid, snapGrid } = store.getState();
            console.warn("[DEPRECATED] `project` is deprecated. Instead use `screenToFlowPosition`. There is no need to subtract the react flow bounds anymore! https://reactflow.dev/api-reference/types/react-flow-instance#screen-to-flow-position");
            return pointToRendererPoint(position2, transform2, snapToGrid, snapGrid);
          },
          screenToFlowPosition: (position2) => {
            const { transform: transform2, snapToGrid, snapGrid, domNode } = store.getState();
            if (!domNode) {
              return position2;
            }
            const { x: domX, y: domY } = domNode.getBoundingClientRect();
            const relativePosition = {
              x: position2.x - domX,
              y: position2.y - domY
            };
            return pointToRendererPoint(relativePosition, transform2, snapToGrid, snapGrid);
          },
          flowToScreenPosition: (position2) => {
            const { transform: transform2, domNode } = store.getState();
            if (!domNode) {
              return position2;
            }
            const { x: domX, y: domY } = domNode.getBoundingClientRect();
            const rendererPosition = rendererPointToPoint(position2, transform2);
            return {
              x: rendererPosition.x + domX,
              y: rendererPosition.y + domY
            };
          },
          viewportInitialized: true
        };
      }
      return initialViewportHelper;
    }, [d3Zoom, d3Selection]);
    return viewportHelperFunctions;
  };
  function useReactFlow() {
    const viewportHelper = useViewportHelper();
    const store = useStoreApi();
    const getNodes = (0, import_react2.useCallback)(() => {
      return store.getState().getNodes().map((n2) => ({ ...n2 }));
    }, []);
    const getNode = (0, import_react2.useCallback)((id2) => {
      return store.getState().nodeInternals.get(id2);
    }, []);
    const getEdges = (0, import_react2.useCallback)(() => {
      const { edges = [] } = store.getState();
      return edges.map((e2) => ({ ...e2 }));
    }, []);
    const getEdge = (0, import_react2.useCallback)((id2) => {
      const { edges = [] } = store.getState();
      return edges.find((e2) => e2.id === id2);
    }, []);
    const setNodes = (0, import_react2.useCallback)((payload) => {
      const { getNodes: getNodes2, setNodes: setNodes2, hasDefaultNodes, onNodesChange } = store.getState();
      const nodes = getNodes2();
      const nextNodes = typeof payload === "function" ? payload(nodes) : payload;
      if (hasDefaultNodes) {
        setNodes2(nextNodes);
      } else if (onNodesChange) {
        const changes = nextNodes.length === 0 ? nodes.map((node) => ({ type: "remove", id: node.id })) : nextNodes.map((node) => ({ item: node, type: "reset" }));
        onNodesChange(changes);
      }
    }, []);
    const setEdges = (0, import_react2.useCallback)((payload) => {
      const { edges = [], setEdges: setEdges2, hasDefaultEdges, onEdgesChange } = store.getState();
      const nextEdges = typeof payload === "function" ? payload(edges) : payload;
      if (hasDefaultEdges) {
        setEdges2(nextEdges);
      } else if (onEdgesChange) {
        const changes = nextEdges.length === 0 ? edges.map((edge) => ({ type: "remove", id: edge.id })) : nextEdges.map((edge) => ({ item: edge, type: "reset" }));
        onEdgesChange(changes);
      }
    }, []);
    const addNodes = (0, import_react2.useCallback)((payload) => {
      const nodes = Array.isArray(payload) ? payload : [payload];
      const { getNodes: getNodes2, setNodes: setNodes2, hasDefaultNodes, onNodesChange } = store.getState();
      if (hasDefaultNodes) {
        const currentNodes = getNodes2();
        const nextNodes = [...currentNodes, ...nodes];
        setNodes2(nextNodes);
      } else if (onNodesChange) {
        const changes = nodes.map((node) => ({ item: node, type: "add" }));
        onNodesChange(changes);
      }
    }, []);
    const addEdges = (0, import_react2.useCallback)((payload) => {
      const nextEdges = Array.isArray(payload) ? payload : [payload];
      const { edges = [], setEdges: setEdges2, hasDefaultEdges, onEdgesChange } = store.getState();
      if (hasDefaultEdges) {
        setEdges2([...edges, ...nextEdges]);
      } else if (onEdgesChange) {
        const changes = nextEdges.map((edge) => ({ item: edge, type: "add" }));
        onEdgesChange(changes);
      }
    }, []);
    const toObject = (0, import_react2.useCallback)(() => {
      const { getNodes: getNodes2, edges = [], transform: transform2 } = store.getState();
      const [x2, y2, zoom] = transform2;
      return {
        nodes: getNodes2().map((n2) => ({ ...n2 })),
        edges: edges.map((e2) => ({ ...e2 })),
        viewport: {
          x: x2,
          y: y2,
          zoom
        }
      };
    }, []);
    const deleteElements = (0, import_react2.useCallback)(({ nodes: nodesDeleted, edges: edgesDeleted }) => {
      const { nodeInternals, getNodes: getNodes2, edges, hasDefaultNodes, hasDefaultEdges, onNodesDelete, onEdgesDelete, onNodesChange, onEdgesChange } = store.getState();
      const nodeIds = (nodesDeleted || []).map((node) => node.id);
      const edgeIds = (edgesDeleted || []).map((edge) => edge.id);
      const nodesToRemove = getNodes2().reduce((res, node) => {
        const parentId = node.parentNode || node.parentId;
        const parentHit = !nodeIds.includes(node.id) && parentId && res.find((n2) => n2.id === parentId);
        const deletable = typeof node.deletable === "boolean" ? node.deletable : true;
        if (deletable && (nodeIds.includes(node.id) || parentHit)) {
          res.push(node);
        }
        return res;
      }, []);
      const deletableEdges = edges.filter((e2) => typeof e2.deletable === "boolean" ? e2.deletable : true);
      const initialHitEdges = deletableEdges.filter((e2) => edgeIds.includes(e2.id));
      if (nodesToRemove || initialHitEdges) {
        const connectedEdges = getConnectedEdges(nodesToRemove, deletableEdges);
        const edgesToRemove = [...initialHitEdges, ...connectedEdges];
        const edgeIdsToRemove = edgesToRemove.reduce((res, edge) => {
          if (!res.includes(edge.id)) {
            res.push(edge.id);
          }
          return res;
        }, []);
        if (hasDefaultEdges || hasDefaultNodes) {
          if (hasDefaultEdges) {
            store.setState({
              edges: edges.filter((e2) => !edgeIdsToRemove.includes(e2.id))
            });
          }
          if (hasDefaultNodes) {
            nodesToRemove.forEach((node) => {
              nodeInternals.delete(node.id);
            });
            store.setState({
              nodeInternals: new Map(nodeInternals)
            });
          }
        }
        if (edgeIdsToRemove.length > 0) {
          onEdgesDelete?.(edgesToRemove);
          if (onEdgesChange) {
            onEdgesChange(edgeIdsToRemove.map((id2) => ({
              id: id2,
              type: "remove"
            })));
          }
        }
        if (nodesToRemove.length > 0) {
          onNodesDelete?.(nodesToRemove);
          if (onNodesChange) {
            const nodeChanges = nodesToRemove.map((n2) => ({ id: n2.id, type: "remove" }));
            onNodesChange(nodeChanges);
          }
        }
      }
    }, []);
    const getNodeRect = (0, import_react2.useCallback)((nodeOrRect) => {
      const isRect = isRectObject(nodeOrRect);
      const node = isRect ? null : store.getState().nodeInternals.get(nodeOrRect.id);
      if (!isRect && !node) {
        return [null, null, isRect];
      }
      const nodeRect = isRect ? nodeOrRect : nodeToRect(node);
      return [nodeRect, node, isRect];
    }, []);
    const getIntersectingNodes = (0, import_react2.useCallback)((nodeOrRect, partially = true, nodes) => {
      const [nodeRect, node, isRect] = getNodeRect(nodeOrRect);
      if (!nodeRect) {
        return [];
      }
      return (nodes || store.getState().getNodes()).filter((n2) => {
        if (!isRect && (n2.id === node.id || !n2.positionAbsolute)) {
          return false;
        }
        const currNodeRect = nodeToRect(n2);
        const overlappingArea = getOverlappingArea(currNodeRect, nodeRect);
        const partiallyVisible = partially && overlappingArea > 0;
        return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
      });
    }, []);
    const isNodeIntersecting = (0, import_react2.useCallback)((nodeOrRect, area, partially = true) => {
      const [nodeRect] = getNodeRect(nodeOrRect);
      if (!nodeRect) {
        return false;
      }
      const overlappingArea = getOverlappingArea(nodeRect, area);
      const partiallyVisible = partially && overlappingArea > 0;
      return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
    }, []);
    return (0, import_react2.useMemo)(() => {
      return {
        ...viewportHelper,
        getNodes,
        getNode,
        getEdges,
        getEdge,
        setNodes,
        setEdges,
        addNodes,
        addEdges,
        toObject,
        deleteElements,
        getIntersectingNodes,
        isNodeIntersecting
      };
    }, [
      viewportHelper,
      getNodes,
      getNode,
      getEdges,
      getEdge,
      setNodes,
      setEdges,
      addNodes,
      addEdges,
      toObject,
      deleteElements,
      getIntersectingNodes,
      isNodeIntersecting
    ]);
  }
  var deleteKeyOptions = { actInsideInputWithModifier: false };
  var useGlobalKeyHandler = ({ deleteKeyCode, multiSelectionKeyCode }) => {
    const store = useStoreApi();
    const { deleteElements } = useReactFlow();
    const deleteKeyPressed = useKeyPress(deleteKeyCode, deleteKeyOptions);
    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode);
    (0, import_react2.useEffect)(() => {
      if (deleteKeyPressed) {
        const { edges, getNodes } = store.getState();
        const selectedNodes = getNodes().filter((node) => node.selected);
        const selectedEdges = edges.filter((edge) => edge.selected);
        deleteElements({ nodes: selectedNodes, edges: selectedEdges });
        store.setState({ nodesSelectionActive: false });
      }
    }, [deleteKeyPressed]);
    (0, import_react2.useEffect)(() => {
      store.setState({ multiSelectionActive: multiSelectionKeyPressed });
    }, [multiSelectionKeyPressed]);
  };
  function useResizeHandler(rendererNode) {
    const store = useStoreApi();
    (0, import_react2.useEffect)(() => {
      let resizeObserver;
      const updateDimensions = () => {
        if (!rendererNode.current) {
          return;
        }
        const size = getDimensions(rendererNode.current);
        if (size.height === 0 || size.width === 0) {
          store.getState().onError?.("004", errorMessages["error004"]());
        }
        store.setState({ width: size.width || 500, height: size.height || 500 });
      };
      updateDimensions();
      window.addEventListener("resize", updateDimensions);
      if (rendererNode.current) {
        resizeObserver = new ResizeObserver(() => updateDimensions());
        resizeObserver.observe(rendererNode.current);
      }
      return () => {
        window.removeEventListener("resize", updateDimensions);
        if (resizeObserver && rendererNode.current) {
          resizeObserver.unobserve(rendererNode.current);
        }
      };
    }, []);
  }
  var containerStyle = {
    position: "absolute",
    width: "100%",
    height: "100%",
    top: 0,
    left: 0
  };
  var viewChanged = (prevViewport, eventTransform) => prevViewport.x !== eventTransform.x || prevViewport.y !== eventTransform.y || prevViewport.zoom !== eventTransform.k;
  var eventToFlowTransform = (eventTransform) => ({
    x: eventTransform.x,
    y: eventTransform.y,
    zoom: eventTransform.k
  });
  var isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);
  var isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);
  var wheelDelta = (event) => {
    const factor = event.ctrlKey && isMacOs() ? 10 : 1;
    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * factor;
  };
  var selector$a = (s2) => ({
    d3Zoom: s2.d3Zoom,
    d3Selection: s2.d3Selection,
    d3ZoomHandler: s2.d3ZoomHandler,
    userSelectionActive: s2.userSelectionActive
  });
  var ZoomPane = ({ onMove, onMoveStart, onMoveEnd, onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = true, elementsSelectable, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children: children3, noWheelClassName, noPanClassName }) => {
    const timerId = (0, import_react2.useRef)();
    const store = useStoreApi();
    const isZoomingOrPanning = (0, import_react2.useRef)(false);
    const zoomedWithRightMouseButton = (0, import_react2.useRef)(false);
    const zoomPane = (0, import_react2.useRef)(null);
    const prevTransform = (0, import_react2.useRef)({ x: 0, y: 0, zoom: 0 });
    const { d3Zoom, d3Selection, d3ZoomHandler, userSelectionActive } = useStore(selector$a, shallow$1);
    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);
    const mouseButton = (0, import_react2.useRef)(0);
    const isPanScrolling = (0, import_react2.useRef)(false);
    const panScrollTimeout = (0, import_react2.useRef)();
    useResizeHandler(zoomPane);
    (0, import_react2.useEffect)(() => {
      if (zoomPane.current) {
        const bbox = zoomPane.current.getBoundingClientRect();
        const d3ZoomInstance = zoom_default2().scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent);
        const selection2 = select_default2(zoomPane.current).call(d3ZoomInstance);
        const updatedTransform = identity3.translate(defaultViewport.x, defaultViewport.y).scale(clamp(defaultViewport.zoom, minZoom, maxZoom));
        const extent = [
          [0, 0],
          [bbox.width, bbox.height]
        ];
        const constrainedTransform = d3ZoomInstance.constrain()(updatedTransform, extent, translateExtent);
        d3ZoomInstance.transform(selection2, constrainedTransform);
        d3ZoomInstance.wheelDelta(wheelDelta);
        store.setState({
          d3Zoom: d3ZoomInstance,
          d3Selection: selection2,
          d3ZoomHandler: selection2.on("wheel.zoom"),
          // we need to pass transform because zoom handler is not registered when we set the initial transform
          transform: [constrainedTransform.x, constrainedTransform.y, constrainedTransform.k],
          domNode: zoomPane.current.closest(".react-flow")
        });
      }
    }, []);
    (0, import_react2.useEffect)(() => {
      if (d3Selection && d3Zoom) {
        if (panOnScroll && !zoomActivationKeyPressed && !userSelectionActive) {
          d3Selection.on("wheel.zoom", (event) => {
            if (isWrappedWithClass(event, noWheelClassName)) {
              return false;
            }
            event.preventDefault();
            event.stopImmediatePropagation();
            const currentZoom = d3Selection.property("__zoom").k || 1;
            if (event.ctrlKey && zoomOnPinch) {
              const point = pointer_default(event);
              const pinchDelta = wheelDelta(event);
              const zoom = currentZoom * Math.pow(2, pinchDelta);
              d3Zoom.scaleTo(d3Selection, zoom, point, event);
              return;
            }
            const deltaNormalize = event.deltaMode === 1 ? 20 : 1;
            let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;
            let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;
            if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {
              deltaX = event.deltaY * deltaNormalize;
              deltaY = 0;
            }
            d3Zoom.translateBy(
              d3Selection,
              -(deltaX / currentZoom) * panOnScrollSpeed,
              -(deltaY / currentZoom) * panOnScrollSpeed,
              // @ts-ignore
              { internal: true }
            );
            const nextViewport = eventToFlowTransform(d3Selection.property("__zoom"));
            const { onViewportChangeStart, onViewportChange, onViewportChangeEnd } = store.getState();
            clearTimeout(panScrollTimeout.current);
            if (!isPanScrolling.current) {
              isPanScrolling.current = true;
              onMoveStart?.(event, nextViewport);
              onViewportChangeStart?.(nextViewport);
            }
            if (isPanScrolling.current) {
              onMove?.(event, nextViewport);
              onViewportChange?.(nextViewport);
              panScrollTimeout.current = setTimeout(() => {
                onMoveEnd?.(event, nextViewport);
                onViewportChangeEnd?.(nextViewport);
                isPanScrolling.current = false;
              }, 150);
            }
          }, { passive: false });
        } else if (typeof d3ZoomHandler !== "undefined") {
          d3Selection.on("wheel.zoom", function(event, d2) {
            const invalidEvent = !preventScrolling && event.type === "wheel" && !event.ctrlKey;
            if (invalidEvent || isWrappedWithClass(event, noWheelClassName)) {
              return null;
            }
            event.preventDefault();
            d3ZoomHandler.call(this, event, d2);
          }, { passive: false });
        }
      }
    }, [
      userSelectionActive,
      panOnScroll,
      panOnScrollMode,
      d3Selection,
      d3Zoom,
      d3ZoomHandler,
      zoomActivationKeyPressed,
      zoomOnPinch,
      preventScrolling,
      noWheelClassName,
      onMoveStart,
      onMove,
      onMoveEnd
    ]);
    (0, import_react2.useEffect)(() => {
      if (d3Zoom) {
        d3Zoom.on("start", (event) => {
          if (!event.sourceEvent || event.sourceEvent.internal) {
            return null;
          }
          mouseButton.current = event.sourceEvent?.button;
          const { onViewportChangeStart } = store.getState();
          const flowTransform = eventToFlowTransform(event.transform);
          isZoomingOrPanning.current = true;
          prevTransform.current = flowTransform;
          if (event.sourceEvent?.type === "mousedown") {
            store.setState({ paneDragging: true });
          }
          onViewportChangeStart?.(flowTransform);
          onMoveStart?.(event.sourceEvent, flowTransform);
        });
      }
    }, [d3Zoom, onMoveStart]);
    (0, import_react2.useEffect)(() => {
      if (d3Zoom) {
        if (userSelectionActive && !isZoomingOrPanning.current) {
          d3Zoom.on("zoom", null);
        } else if (!userSelectionActive) {
          d3Zoom.on("zoom", (event) => {
            const { onViewportChange } = store.getState();
            store.setState({ transform: [event.transform.x, event.transform.y, event.transform.k] });
            zoomedWithRightMouseButton.current = !!(onPaneContextMenu && isRightClickPan(panOnDrag, mouseButton.current ?? 0));
            if ((onMove || onViewportChange) && !event.sourceEvent?.internal) {
              const flowTransform = eventToFlowTransform(event.transform);
              onViewportChange?.(flowTransform);
              onMove?.(event.sourceEvent, flowTransform);
            }
          });
        }
      }
    }, [userSelectionActive, d3Zoom, onMove, panOnDrag, onPaneContextMenu]);
    (0, import_react2.useEffect)(() => {
      if (d3Zoom) {
        d3Zoom.on("end", (event) => {
          if (!event.sourceEvent || event.sourceEvent.internal) {
            return null;
          }
          const { onViewportChangeEnd } = store.getState();
          isZoomingOrPanning.current = false;
          store.setState({ paneDragging: false });
          if (onPaneContextMenu && isRightClickPan(panOnDrag, mouseButton.current ?? 0) && !zoomedWithRightMouseButton.current) {
            onPaneContextMenu(event.sourceEvent);
          }
          zoomedWithRightMouseButton.current = false;
          if ((onMoveEnd || onViewportChangeEnd) && viewChanged(prevTransform.current, event.transform)) {
            const flowTransform = eventToFlowTransform(event.transform);
            prevTransform.current = flowTransform;
            clearTimeout(timerId.current);
            timerId.current = setTimeout(() => {
              onViewportChangeEnd?.(flowTransform);
              onMoveEnd?.(event.sourceEvent, flowTransform);
            }, panOnScroll ? 150 : 0);
          }
        });
      }
    }, [d3Zoom, panOnScroll, panOnDrag, onMoveEnd, onPaneContextMenu]);
    (0, import_react2.useEffect)(() => {
      if (d3Zoom) {
        d3Zoom.filter((event) => {
          const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;
          const pinchZoom = zoomOnPinch && event.ctrlKey;
          if ((panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(1)) && event.button === 1 && event.type === "mousedown" && (isWrappedWithClass(event, "react-flow__node") || isWrappedWithClass(event, "react-flow__edge"))) {
            return true;
          }
          if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {
            return false;
          }
          if (userSelectionActive) {
            return false;
          }
          if (!zoomOnDoubleClick && event.type === "dblclick") {
            return false;
          }
          if (isWrappedWithClass(event, noWheelClassName) && event.type === "wheel") {
            return false;
          }
          if (isWrappedWithClass(event, noPanClassName) && (event.type !== "wheel" || panOnScroll && event.type === "wheel" && !zoomActivationKeyPressed)) {
            return false;
          }
          if (!zoomOnPinch && event.ctrlKey && event.type === "wheel") {
            return false;
          }
          if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === "wheel") {
            return false;
          }
          if (!panOnDrag && (event.type === "mousedown" || event.type === "touchstart")) {
            return false;
          }
          if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === "mousedown") {
            return false;
          }
          const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event.button) || !event.button || event.button <= 1;
          return (!event.ctrlKey || event.type === "wheel") && buttonAllowed;
        });
      }
    }, [
      userSelectionActive,
      d3Zoom,
      zoomOnScroll,
      zoomOnPinch,
      panOnScroll,
      zoomOnDoubleClick,
      panOnDrag,
      elementsSelectable,
      zoomActivationKeyPressed
    ]);
    return import_react2.default.createElement("div", { className: "react-flow__renderer", ref: zoomPane, style: containerStyle }, children3);
  };
  var selector$9 = (s2) => ({
    userSelectionActive: s2.userSelectionActive,
    userSelectionRect: s2.userSelectionRect
  });
  function UserSelection() {
    const { userSelectionActive, userSelectionRect } = useStore(selector$9, shallow$1);
    const isActive = userSelectionActive && userSelectionRect;
    if (!isActive) {
      return null;
    }
    return import_react2.default.createElement("div", { className: "react-flow__selection react-flow__container", style: {
      width: userSelectionRect.width,
      height: userSelectionRect.height,
      transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`
    } });
  }
  function handleParentExpand(res, updateItem) {
    const parentId = updateItem.parentNode || updateItem.parentId;
    const parent = res.find((e2) => e2.id === parentId);
    if (parent) {
      const extendWidth = updateItem.position.x + updateItem.width - parent.width;
      const extendHeight = updateItem.position.y + updateItem.height - parent.height;
      if (extendWidth > 0 || extendHeight > 0 || updateItem.position.x < 0 || updateItem.position.y < 0) {
        parent.style = { ...parent.style };
        parent.style.width = parent.style.width ?? parent.width;
        parent.style.height = parent.style.height ?? parent.height;
        if (extendWidth > 0) {
          parent.style.width += extendWidth;
        }
        if (extendHeight > 0) {
          parent.style.height += extendHeight;
        }
        if (updateItem.position.x < 0) {
          const xDiff = Math.abs(updateItem.position.x);
          parent.position.x = parent.position.x - xDiff;
          parent.style.width += xDiff;
          updateItem.position.x = 0;
        }
        if (updateItem.position.y < 0) {
          const yDiff = Math.abs(updateItem.position.y);
          parent.position.y = parent.position.y - yDiff;
          parent.style.height += yDiff;
          updateItem.position.y = 0;
        }
        parent.width = parent.style.width;
        parent.height = parent.style.height;
      }
    }
  }
  function applyChanges(changes, elements) {
    if (changes.some((c2) => c2.type === "reset")) {
      return changes.filter((c2) => c2.type === "reset").map((c2) => c2.item);
    }
    const initElements = changes.filter((c2) => c2.type === "add").map((c2) => c2.item);
    return elements.reduce((res, item) => {
      const currentChanges = changes.filter((c2) => c2.id === item.id);
      if (currentChanges.length === 0) {
        res.push(item);
        return res;
      }
      const updateItem = { ...item };
      for (const currentChange of currentChanges) {
        if (currentChange) {
          switch (currentChange.type) {
            case "select": {
              updateItem.selected = currentChange.selected;
              break;
            }
            case "position": {
              if (typeof currentChange.position !== "undefined") {
                updateItem.position = currentChange.position;
              }
              if (typeof currentChange.positionAbsolute !== "undefined") {
                updateItem.positionAbsolute = currentChange.positionAbsolute;
              }
              if (typeof currentChange.dragging !== "undefined") {
                updateItem.dragging = currentChange.dragging;
              }
              if (updateItem.expandParent) {
                handleParentExpand(res, updateItem);
              }
              break;
            }
            case "dimensions": {
              if (typeof currentChange.dimensions !== "undefined") {
                updateItem.width = currentChange.dimensions.width;
                updateItem.height = currentChange.dimensions.height;
              }
              if (typeof currentChange.updateStyle !== "undefined") {
                updateItem.style = { ...updateItem.style || {}, ...currentChange.dimensions };
              }
              if (typeof currentChange.resizing === "boolean") {
                updateItem.resizing = currentChange.resizing;
              }
              if (updateItem.expandParent) {
                handleParentExpand(res, updateItem);
              }
              break;
            }
            case "remove": {
              return res;
            }
          }
        }
      }
      res.push(updateItem);
      return res;
    }, initElements);
  }
  function applyNodeChanges(changes, nodes) {
    return applyChanges(changes, nodes);
  }
  function applyEdgeChanges(changes, edges) {
    return applyChanges(changes, edges);
  }
  var createSelectionChange = (id2, selected) => ({
    id: id2,
    type: "select",
    selected
  });
  function getSelectionChanges(items, selectedIds) {
    return items.reduce((res, item) => {
      const willBeSelected = selectedIds.includes(item.id);
      if (!item.selected && willBeSelected) {
        item.selected = true;
        res.push(createSelectionChange(item.id, true));
      } else if (item.selected && !willBeSelected) {
        item.selected = false;
        res.push(createSelectionChange(item.id, false));
      }
      return res;
    }, []);
  }
  var wrapHandler = (handler, containerRef) => {
    return (event) => {
      if (event.target !== containerRef.current) {
        return;
      }
      handler?.(event);
    };
  };
  var selector$8 = (s2) => ({
    userSelectionActive: s2.userSelectionActive,
    elementsSelectable: s2.elementsSelectable,
    dragging: s2.paneDragging
  });
  var Pane = (0, import_react2.memo)(({ isSelecting, selectionMode = SelectionMode.Full, panOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children: children3 }) => {
    const container2 = (0, import_react2.useRef)(null);
    const store = useStoreApi();
    const prevSelectedNodesCount = (0, import_react2.useRef)(0);
    const prevSelectedEdgesCount = (0, import_react2.useRef)(0);
    const containerBounds = (0, import_react2.useRef)();
    const { userSelectionActive, elementsSelectable, dragging } = useStore(selector$8, shallow$1);
    const resetUserSelection = () => {
      store.setState({ userSelectionActive: false, userSelectionRect: null });
      prevSelectedNodesCount.current = 0;
      prevSelectedEdgesCount.current = 0;
    };
    const onClick = (event) => {
      onPaneClick?.(event);
      store.getState().resetSelectedElements();
      store.setState({ nodesSelectionActive: false });
    };
    const onContextMenu = (event) => {
      if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {
        event.preventDefault();
        return;
      }
      onPaneContextMenu?.(event);
    };
    const onWheel = onPaneScroll ? (event) => onPaneScroll(event) : void 0;
    const onMouseDown = (event) => {
      const { resetSelectedElements, domNode } = store.getState();
      containerBounds.current = domNode?.getBoundingClientRect();
      if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container2.current || !containerBounds.current) {
        return;
      }
      const { x: x2, y: y2 } = getEventPosition(event, containerBounds.current);
      resetSelectedElements();
      store.setState({
        userSelectionRect: {
          width: 0,
          height: 0,
          startX: x2,
          startY: y2,
          x: x2,
          y: y2
        }
      });
      onSelectionStart?.(event);
    };
    const onMouseMove = (event) => {
      const { userSelectionRect, nodeInternals, edges, transform: transform2, onNodesChange, onEdgesChange, nodeOrigin, getNodes } = store.getState();
      if (!isSelecting || !containerBounds.current || !userSelectionRect) {
        return;
      }
      store.setState({ userSelectionActive: true, nodesSelectionActive: false });
      const mousePos = getEventPosition(event, containerBounds.current);
      const startX = userSelectionRect.startX ?? 0;
      const startY = userSelectionRect.startY ?? 0;
      const nextUserSelectRect = {
        ...userSelectionRect,
        x: mousePos.x < startX ? mousePos.x : startX,
        y: mousePos.y < startY ? mousePos.y : startY,
        width: Math.abs(mousePos.x - startX),
        height: Math.abs(mousePos.y - startY)
      };
      const nodes = getNodes();
      const selectedNodes = getNodesInside(nodeInternals, nextUserSelectRect, transform2, selectionMode === SelectionMode.Partial, true, nodeOrigin);
      const selectedEdgeIds = getConnectedEdges(selectedNodes, edges).map((e2) => e2.id);
      const selectedNodeIds = selectedNodes.map((n2) => n2.id);
      if (prevSelectedNodesCount.current !== selectedNodeIds.length) {
        prevSelectedNodesCount.current = selectedNodeIds.length;
        const changes = getSelectionChanges(nodes, selectedNodeIds);
        if (changes.length) {
          onNodesChange?.(changes);
        }
      }
      if (prevSelectedEdgesCount.current !== selectedEdgeIds.length) {
        prevSelectedEdgesCount.current = selectedEdgeIds.length;
        const changes = getSelectionChanges(edges, selectedEdgeIds);
        if (changes.length) {
          onEdgesChange?.(changes);
        }
      }
      store.setState({
        userSelectionRect: nextUserSelectRect
      });
    };
    const onMouseUp = (event) => {
      if (event.button !== 0) {
        return;
      }
      const { userSelectionRect } = store.getState();
      if (!userSelectionActive && userSelectionRect && event.target === container2.current) {
        onClick?.(event);
      }
      store.setState({ nodesSelectionActive: prevSelectedNodesCount.current > 0 });
      resetUserSelection();
      onSelectionEnd?.(event);
    };
    const onMouseLeave = (event) => {
      if (userSelectionActive) {
        store.setState({ nodesSelectionActive: prevSelectedNodesCount.current > 0 });
        onSelectionEnd?.(event);
      }
      resetUserSelection();
    };
    const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);
    return import_react2.default.createElement(
      "div",
      { className: cc(["react-flow__pane", { dragging, selection: isSelecting }]), onClick: hasActiveSelection ? void 0 : wrapHandler(onClick, container2), onContextMenu: wrapHandler(onContextMenu, container2), onWheel: wrapHandler(onWheel, container2), onMouseEnter: hasActiveSelection ? void 0 : onPaneMouseEnter, onMouseDown: hasActiveSelection ? onMouseDown : void 0, onMouseMove: hasActiveSelection ? onMouseMove : onPaneMouseMove, onMouseUp: hasActiveSelection ? onMouseUp : void 0, onMouseLeave: hasActiveSelection ? onMouseLeave : onPaneMouseLeave, ref: container2, style: containerStyle },
      children3,
      import_react2.default.createElement(UserSelection, null)
    );
  });
  Pane.displayName = "Pane";
  function isParentSelected(node, nodeInternals) {
    const parentId = node.parentNode || node.parentId;
    if (!parentId) {
      return false;
    }
    const parentNode = nodeInternals.get(parentId);
    if (!parentNode) {
      return false;
    }
    if (parentNode.selected) {
      return true;
    }
    return isParentSelected(parentNode, nodeInternals);
  }
  function hasSelector(target, selector3, nodeRef) {
    let current = target;
    do {
      if (current?.matches(selector3))
        return true;
      if (current === nodeRef.current)
        return false;
      current = current.parentElement;
    } while (current);
    return false;
  }
  function getDragItems(nodeInternals, nodesDraggable, mousePos, nodeId) {
    return Array.from(nodeInternals.values()).filter((n2) => (n2.selected || n2.id === nodeId) && (!n2.parentNode || n2.parentId || !isParentSelected(n2, nodeInternals)) && (n2.draggable || nodesDraggable && typeof n2.draggable === "undefined")).map((n2) => ({
      id: n2.id,
      position: n2.position || { x: 0, y: 0 },
      positionAbsolute: n2.positionAbsolute || { x: 0, y: 0 },
      distance: {
        x: mousePos.x - (n2.positionAbsolute?.x ?? 0),
        y: mousePos.y - (n2.positionAbsolute?.y ?? 0)
      },
      delta: {
        x: 0,
        y: 0
      },
      extent: n2.extent,
      parentNode: n2.parentNode || n2.parentId,
      parentId: n2.parentNode || n2.parentId,
      width: n2.width,
      height: n2.height,
      expandParent: n2.expandParent
    }));
  }
  function clampNodeExtent(node, extent) {
    if (!extent || extent === "parent") {
      return extent;
    }
    return [extent[0], [extent[1][0] - (node.width || 0), extent[1][1] - (node.height || 0)]];
  }
  function calcNextPosition(node, nextPosition, nodeInternals, nodeExtent, nodeOrigin = [0, 0], onError) {
    const clampedNodeExtent = clampNodeExtent(node, node.extent || nodeExtent);
    let currentExtent = clampedNodeExtent;
    const parentId = node.parentNode || node.parentId;
    if (node.extent === "parent" && !node.expandParent) {
      if (parentId && node.width && node.height) {
        const parent = nodeInternals.get(parentId);
        const { x: parentX, y: parentY } = getNodePositionWithOrigin(parent, nodeOrigin).positionAbsolute;
        currentExtent = parent && isNumeric(parentX) && isNumeric(parentY) && isNumeric(parent.width) && isNumeric(parent.height) ? [
          [parentX + node.width * nodeOrigin[0], parentY + node.height * nodeOrigin[1]],
          [
            parentX + parent.width - node.width + node.width * nodeOrigin[0],
            parentY + parent.height - node.height + node.height * nodeOrigin[1]
          ]
        ] : currentExtent;
      } else {
        onError?.("005", errorMessages["error005"]());
        currentExtent = clampedNodeExtent;
      }
    } else if (node.extent && parentId && node.extent !== "parent") {
      const parent = nodeInternals.get(parentId);
      const { x: parentX, y: parentY } = getNodePositionWithOrigin(parent, nodeOrigin).positionAbsolute;
      currentExtent = [
        [node.extent[0][0] + parentX, node.extent[0][1] + parentY],
        [node.extent[1][0] + parentX, node.extent[1][1] + parentY]
      ];
    }
    let parentPosition = { x: 0, y: 0 };
    if (parentId) {
      const parentNode = nodeInternals.get(parentId);
      parentPosition = getNodePositionWithOrigin(parentNode, nodeOrigin).positionAbsolute;
    }
    const positionAbsolute = currentExtent && currentExtent !== "parent" ? clampPosition(nextPosition, currentExtent) : nextPosition;
    return {
      position: {
        x: positionAbsolute.x - parentPosition.x,
        y: positionAbsolute.y - parentPosition.y
      },
      positionAbsolute
    };
  }
  function getEventHandlerParams({ nodeId, dragItems, nodeInternals }) {
    const extentedDragItems = dragItems.map((n2) => {
      const node = nodeInternals.get(n2.id);
      return {
        ...node,
        position: n2.position,
        positionAbsolute: n2.positionAbsolute
      };
    });
    return [nodeId ? extentedDragItems.find((n2) => n2.id === nodeId) : extentedDragItems[0], extentedDragItems];
  }
  var getHandleBounds = (selector3, nodeElement, zoom, nodeOrigin) => {
    const handles = nodeElement.querySelectorAll(selector3);
    if (!handles || !handles.length) {
      return null;
    }
    const handlesArray = Array.from(handles);
    const nodeBounds = nodeElement.getBoundingClientRect();
    const nodeOffset = {
      x: nodeBounds.width * nodeOrigin[0],
      y: nodeBounds.height * nodeOrigin[1]
    };
    return handlesArray.map((handle) => {
      const handleBounds = handle.getBoundingClientRect();
      return {
        id: handle.getAttribute("data-handleid"),
        position: handle.getAttribute("data-handlepos"),
        x: (handleBounds.left - nodeBounds.left - nodeOffset.x) / zoom,
        y: (handleBounds.top - nodeBounds.top - nodeOffset.y) / zoom,
        ...getDimensions(handle)
      };
    });
  };
  function getMouseHandler(id2, getState, handler) {
    return handler === void 0 ? handler : (event) => {
      const node = getState().nodeInternals.get(id2);
      if (node) {
        handler(event, { ...node });
      }
    };
  }
  function handleNodeClick({ id: id2, store, unselect = false, nodeRef }) {
    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeInternals, onError } = store.getState();
    const node = nodeInternals.get(id2);
    if (!node) {
      onError?.("012", errorMessages["error012"](id2));
      return;
    }
    store.setState({ nodesSelectionActive: false });
    if (!node.selected) {
      addSelectedNodes([id2]);
    } else if (unselect || node.selected && multiSelectionActive) {
      unselectNodesAndEdges({ nodes: [node], edges: [] });
      requestAnimationFrame(() => nodeRef?.current?.blur());
    }
  }
  function useGetPointerPosition() {
    const store = useStoreApi();
    const getPointerPosition = (0, import_react2.useCallback)(({ sourceEvent }) => {
      const { transform: transform2, snapGrid, snapToGrid } = store.getState();
      const x2 = sourceEvent.touches ? sourceEvent.touches[0].clientX : sourceEvent.clientX;
      const y2 = sourceEvent.touches ? sourceEvent.touches[0].clientY : sourceEvent.clientY;
      const pointerPos = {
        x: (x2 - transform2[0]) / transform2[2],
        y: (y2 - transform2[1]) / transform2[2]
      };
      return {
        xSnapped: snapToGrid ? snapGrid[0] * Math.round(pointerPos.x / snapGrid[0]) : pointerPos.x,
        ySnapped: snapToGrid ? snapGrid[1] * Math.round(pointerPos.y / snapGrid[1]) : pointerPos.y,
        ...pointerPos
      };
    }, []);
    return getPointerPosition;
  }
  function wrapSelectionDragFunc(selectionFunc) {
    return (event, _2, nodes) => selectionFunc?.(event, nodes);
  }
  function useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, selectNodesOnDrag }) {
    const store = useStoreApi();
    const [dragging, setDragging] = (0, import_react2.useState)(false);
    const dragItems = (0, import_react2.useRef)([]);
    const lastPos = (0, import_react2.useRef)({ x: null, y: null });
    const autoPanId = (0, import_react2.useRef)(0);
    const containerBounds = (0, import_react2.useRef)(null);
    const mousePosition = (0, import_react2.useRef)({ x: 0, y: 0 });
    const dragEvent = (0, import_react2.useRef)(null);
    const autoPanStarted = (0, import_react2.useRef)(false);
    const dragStarted = (0, import_react2.useRef)(false);
    const abortDrag = (0, import_react2.useRef)(false);
    const getPointerPosition = useGetPointerPosition();
    (0, import_react2.useEffect)(() => {
      if (nodeRef?.current) {
        const selection2 = select_default2(nodeRef.current);
        const updateNodes = ({ x: x2, y: y2 }) => {
          const { nodeInternals, onNodeDrag, onSelectionDrag, updateNodePositions, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onError } = store.getState();
          lastPos.current = { x: x2, y: y2 };
          let hasChange = false;
          let nodesBox = { x: 0, y: 0, x2: 0, y2: 0 };
          if (dragItems.current.length > 1 && nodeExtent) {
            const rect = getNodesBounds(dragItems.current, nodeOrigin);
            nodesBox = rectToBox(rect);
          }
          dragItems.current = dragItems.current.map((n2) => {
            const nextPosition = { x: x2 - n2.distance.x, y: y2 - n2.distance.y };
            if (snapToGrid) {
              nextPosition.x = snapGrid[0] * Math.round(nextPosition.x / snapGrid[0]);
              nextPosition.y = snapGrid[1] * Math.round(nextPosition.y / snapGrid[1]);
            }
            const adjustedNodeExtent = [
              [nodeExtent[0][0], nodeExtent[0][1]],
              [nodeExtent[1][0], nodeExtent[1][1]]
            ];
            if (dragItems.current.length > 1 && nodeExtent && !n2.extent) {
              adjustedNodeExtent[0][0] = n2.positionAbsolute.x - nodesBox.x + nodeExtent[0][0];
              adjustedNodeExtent[1][0] = n2.positionAbsolute.x + (n2.width ?? 0) - nodesBox.x2 + nodeExtent[1][0];
              adjustedNodeExtent[0][1] = n2.positionAbsolute.y - nodesBox.y + nodeExtent[0][1];
              adjustedNodeExtent[1][1] = n2.positionAbsolute.y + (n2.height ?? 0) - nodesBox.y2 + nodeExtent[1][1];
            }
            const updatedPos = calcNextPosition(n2, nextPosition, nodeInternals, adjustedNodeExtent, nodeOrigin, onError);
            hasChange = hasChange || n2.position.x !== updatedPos.position.x || n2.position.y !== updatedPos.position.y;
            n2.position = updatedPos.position;
            n2.positionAbsolute = updatedPos.positionAbsolute;
            return n2;
          });
          if (!hasChange) {
            return;
          }
          updateNodePositions(dragItems.current, true, true);
          setDragging(true);
          const onDrag = nodeId ? onNodeDrag : wrapSelectionDragFunc(onSelectionDrag);
          if (onDrag && dragEvent.current) {
            const [currentNode, nodes] = getEventHandlerParams({
              nodeId,
              dragItems: dragItems.current,
              nodeInternals
            });
            onDrag(dragEvent.current, currentNode, nodes);
          }
        };
        const autoPan = () => {
          if (!containerBounds.current) {
            return;
          }
          const [xMovement, yMovement] = calcAutoPan(mousePosition.current, containerBounds.current);
          if (xMovement !== 0 || yMovement !== 0) {
            const { transform: transform2, panBy } = store.getState();
            lastPos.current.x = (lastPos.current.x ?? 0) - xMovement / transform2[2];
            lastPos.current.y = (lastPos.current.y ?? 0) - yMovement / transform2[2];
            if (panBy({ x: xMovement, y: yMovement })) {
              updateNodes(lastPos.current);
            }
          }
          autoPanId.current = requestAnimationFrame(autoPan);
        };
        const startDrag = (event) => {
          const { nodeInternals, multiSelectionActive, nodesDraggable, unselectNodesAndEdges, onNodeDragStart, onSelectionDragStart } = store.getState();
          dragStarted.current = true;
          const onStart = nodeId ? onNodeDragStart : wrapSelectionDragFunc(onSelectionDragStart);
          if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {
            if (!nodeInternals.get(nodeId)?.selected) {
              unselectNodesAndEdges();
            }
          }
          if (nodeId && isSelectable && selectNodesOnDrag) {
            handleNodeClick({
              id: nodeId,
              store,
              nodeRef
            });
          }
          const pointerPos = getPointerPosition(event);
          lastPos.current = pointerPos;
          dragItems.current = getDragItems(nodeInternals, nodesDraggable, pointerPos, nodeId);
          if (onStart && dragItems.current) {
            const [currentNode, nodes] = getEventHandlerParams({
              nodeId,
              dragItems: dragItems.current,
              nodeInternals
            });
            onStart(event.sourceEvent, currentNode, nodes);
          }
        };
        if (disabled) {
          selection2.on(".drag", null);
        } else {
          const dragHandler = drag_default().on("start", (event) => {
            const { domNode, nodeDragThreshold } = store.getState();
            if (nodeDragThreshold === 0) {
              startDrag(event);
            }
            abortDrag.current = false;
            const pointerPos = getPointerPosition(event);
            lastPos.current = pointerPos;
            containerBounds.current = domNode?.getBoundingClientRect() || null;
            mousePosition.current = getEventPosition(event.sourceEvent, containerBounds.current);
          }).on("drag", (event) => {
            const pointerPos = getPointerPosition(event);
            const { autoPanOnNodeDrag, nodeDragThreshold } = store.getState();
            if (event.sourceEvent.type === "touchmove" && event.sourceEvent.touches.length > 1) {
              abortDrag.current = true;
            }
            if (abortDrag.current) {
              return;
            }
            if (!autoPanStarted.current && dragStarted.current && autoPanOnNodeDrag) {
              autoPanStarted.current = true;
              autoPan();
            }
            if (!dragStarted.current) {
              const x2 = pointerPos.xSnapped - (lastPos?.current?.x ?? 0);
              const y2 = pointerPos.ySnapped - (lastPos?.current?.y ?? 0);
              const distance3 = Math.sqrt(x2 * x2 + y2 * y2);
              if (distance3 > nodeDragThreshold) {
                startDrag(event);
              }
            }
            if ((lastPos.current.x !== pointerPos.xSnapped || lastPos.current.y !== pointerPos.ySnapped) && dragItems.current && dragStarted.current) {
              dragEvent.current = event.sourceEvent;
              mousePosition.current = getEventPosition(event.sourceEvent, containerBounds.current);
              updateNodes(pointerPos);
            }
          }).on("end", (event) => {
            if (!dragStarted.current || abortDrag.current) {
              return;
            }
            setDragging(false);
            autoPanStarted.current = false;
            dragStarted.current = false;
            cancelAnimationFrame(autoPanId.current);
            if (dragItems.current) {
              const { updateNodePositions, nodeInternals, onNodeDragStop, onSelectionDragStop } = store.getState();
              const onStop = nodeId ? onNodeDragStop : wrapSelectionDragFunc(onSelectionDragStop);
              updateNodePositions(dragItems.current, false, false);
              if (onStop) {
                const [currentNode, nodes] = getEventHandlerParams({
                  nodeId,
                  dragItems: dragItems.current,
                  nodeInternals
                });
                onStop(event.sourceEvent, currentNode, nodes);
              }
            }
          }).filter((event) => {
            const target = event.target;
            const isDraggable = !event.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, nodeRef)) && (!handleSelector || hasSelector(target, handleSelector, nodeRef));
            return isDraggable;
          });
          selection2.call(dragHandler);
          return () => {
            selection2.on(".drag", null);
          };
        }
      }
    }, [
      nodeRef,
      disabled,
      noDragClassName,
      handleSelector,
      isSelectable,
      store,
      nodeId,
      selectNodesOnDrag,
      getPointerPosition
    ]);
    return dragging;
  }
  function useUpdateNodePositions() {
    const store = useStoreApi();
    const updatePositions = (0, import_react2.useCallback)((params) => {
      const { nodeInternals, nodeExtent, updateNodePositions, getNodes, snapToGrid, snapGrid, onError, nodesDraggable } = store.getState();
      const selectedNodes = getNodes().filter((n2) => n2.selected && (n2.draggable || nodesDraggable && typeof n2.draggable === "undefined"));
      const xVelo = snapToGrid ? snapGrid[0] : 5;
      const yVelo = snapToGrid ? snapGrid[1] : 5;
      const factor = params.isShiftPressed ? 4 : 1;
      const positionDiffX = params.x * xVelo * factor;
      const positionDiffY = params.y * yVelo * factor;
      const nodeUpdates = selectedNodes.map((n2) => {
        if (n2.positionAbsolute) {
          const nextPosition = { x: n2.positionAbsolute.x + positionDiffX, y: n2.positionAbsolute.y + positionDiffY };
          if (snapToGrid) {
            nextPosition.x = snapGrid[0] * Math.round(nextPosition.x / snapGrid[0]);
            nextPosition.y = snapGrid[1] * Math.round(nextPosition.y / snapGrid[1]);
          }
          const { positionAbsolute, position: position2 } = calcNextPosition(n2, nextPosition, nodeInternals, nodeExtent, void 0, onError);
          n2.position = position2;
          n2.positionAbsolute = positionAbsolute;
        }
        return n2;
      });
      updateNodePositions(nodeUpdates, true, false);
    }, []);
    return updatePositions;
  }
  var arrowKeyDiffs = {
    ArrowUp: { x: 0, y: -1 },
    ArrowDown: { x: 0, y: 1 },
    ArrowLeft: { x: -1, y: 0 },
    ArrowRight: { x: 1, y: 0 }
  };
  var wrapNode = (NodeComponent) => {
    const NodeWrapper = ({ id: id2, type, data, xPos, yPos, xPosOrigin, yPosOrigin, selected, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, style: style2, className, isDraggable, isSelectable, isConnectable, isFocusable, selectNodesOnDrag, sourcePosition, targetPosition, hidden, resizeObserver, dragHandle, zIndex, isParent, noDragClassName, noPanClassName, initialized, disableKeyboardA11y, ariaLabel, rfId, hasHandleBounds }) => {
      const store = useStoreApi();
      const nodeRef = (0, import_react2.useRef)(null);
      const prevNodeRef = (0, import_react2.useRef)(null);
      const prevSourcePosition = (0, import_react2.useRef)(sourcePosition);
      const prevTargetPosition = (0, import_react2.useRef)(targetPosition);
      const prevType = (0, import_react2.useRef)(type);
      const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;
      const updatePositions = useUpdateNodePositions();
      const onMouseEnterHandler = getMouseHandler(id2, store.getState, onMouseEnter);
      const onMouseMoveHandler = getMouseHandler(id2, store.getState, onMouseMove);
      const onMouseLeaveHandler = getMouseHandler(id2, store.getState, onMouseLeave);
      const onContextMenuHandler = getMouseHandler(id2, store.getState, onContextMenu);
      const onDoubleClickHandler = getMouseHandler(id2, store.getState, onDoubleClick);
      const onSelectNodeHandler = (event) => {
        const { nodeDragThreshold } = store.getState();
        if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {
          handleNodeClick({
            id: id2,
            store,
            nodeRef
          });
        }
        if (onClick) {
          const node = store.getState().nodeInternals.get(id2);
          if (node) {
            onClick(event, { ...node });
          }
        }
      };
      const onKeyDown = (event) => {
        if (isInputDOMNode(event)) {
          return;
        }
        if (disableKeyboardA11y) {
          return;
        }
        if (elementSelectionKeys.includes(event.key) && isSelectable) {
          const unselect = event.key === "Escape";
          handleNodeClick({
            id: id2,
            store,
            unselect,
            nodeRef
          });
        } else if (isDraggable && selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {
          store.setState({
            ariaLiveMessage: `Moved selected node ${event.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~xPos}, y: ${~~yPos}`
          });
          updatePositions({
            x: arrowKeyDiffs[event.key].x,
            y: arrowKeyDiffs[event.key].y,
            isShiftPressed: event.shiftKey
          });
        }
      };
      (0, import_react2.useEffect)(() => {
        return () => {
          if (prevNodeRef.current) {
            resizeObserver?.unobserve(prevNodeRef.current);
            prevNodeRef.current = null;
          }
        };
      }, []);
      (0, import_react2.useEffect)(() => {
        if (nodeRef.current && !hidden) {
          const currNode = nodeRef.current;
          if (!initialized || !hasHandleBounds || prevNodeRef.current !== currNode) {
            if (prevNodeRef.current) {
              resizeObserver?.unobserve(prevNodeRef.current);
            }
            resizeObserver?.observe(currNode);
            prevNodeRef.current = currNode;
          }
        }
      }, [hidden, initialized, hasHandleBounds]);
      (0, import_react2.useEffect)(() => {
        const typeChanged = prevType.current !== type;
        const sourcePosChanged = prevSourcePosition.current !== sourcePosition;
        const targetPosChanged = prevTargetPosition.current !== targetPosition;
        if (nodeRef.current && (typeChanged || sourcePosChanged || targetPosChanged)) {
          if (typeChanged) {
            prevType.current = type;
          }
          if (sourcePosChanged) {
            prevSourcePosition.current = sourcePosition;
          }
          if (targetPosChanged) {
            prevTargetPosition.current = targetPosition;
          }
          store.getState().updateNodeDimensions([{ id: id2, nodeElement: nodeRef.current, forceUpdate: true }]);
        }
      }, [id2, type, sourcePosition, targetPosition]);
      const dragging = useDrag({
        nodeRef,
        disabled: hidden || !isDraggable,
        noDragClassName,
        handleSelector: dragHandle,
        nodeId: id2,
        isSelectable,
        selectNodesOnDrag
      });
      if (hidden) {
        return null;
      }
      return import_react2.default.createElement(
        "div",
        { className: cc([
          "react-flow__node",
          `react-flow__node-${type}`,
          {
            // this is overwritable by passing `nopan` as a class name
            [noPanClassName]: isDraggable
          },
          className,
          {
            selected,
            selectable: isSelectable,
            parent: isParent,
            dragging
          }
        ]), ref: nodeRef, style: {
          zIndex,
          transform: `translate(${xPosOrigin}px,${yPosOrigin}px)`,
          pointerEvents: hasPointerEvents ? "all" : "none",
          visibility: initialized ? "visible" : "hidden",
          ...style2
        }, "data-id": id2, "data-testid": `rf__node-${id2}`, onMouseEnter: onMouseEnterHandler, onMouseMove: onMouseMoveHandler, onMouseLeave: onMouseLeaveHandler, onContextMenu: onContextMenuHandler, onClick: onSelectNodeHandler, onDoubleClick: onDoubleClickHandler, onKeyDown: isFocusable ? onKeyDown : void 0, tabIndex: isFocusable ? 0 : void 0, role: isFocusable ? "button" : void 0, "aria-describedby": disableKeyboardA11y ? void 0 : `${ARIA_NODE_DESC_KEY}-${rfId}`, "aria-label": ariaLabel },
        import_react2.default.createElement(
          Provider,
          { value: id2 },
          import_react2.default.createElement(NodeComponent, { id: id2, data, type, xPos, yPos, selected, isConnectable, sourcePosition, targetPosition, dragging, dragHandle, zIndex })
        )
      );
    };
    NodeWrapper.displayName = "NodeWrapper";
    return (0, import_react2.memo)(NodeWrapper);
  };
  var selector$7 = (s2) => {
    const selectedNodes = s2.getNodes().filter((n2) => n2.selected);
    return {
      ...getNodesBounds(selectedNodes, s2.nodeOrigin),
      transformString: `translate(${s2.transform[0]}px,${s2.transform[1]}px) scale(${s2.transform[2]})`,
      userSelectionActive: s2.userSelectionActive
    };
  };
  function NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {
    const store = useStoreApi();
    const { width, height: height2, x: left, y: top, transformString, userSelectionActive } = useStore(selector$7, shallow$1);
    const updatePositions = useUpdateNodePositions();
    const nodeRef = (0, import_react2.useRef)(null);
    (0, import_react2.useEffect)(() => {
      if (!disableKeyboardA11y) {
        nodeRef.current?.focus({
          preventScroll: true
        });
      }
    }, [disableKeyboardA11y]);
    useDrag({
      nodeRef
    });
    if (userSelectionActive || !width || !height2) {
      return null;
    }
    const onContextMenu = onSelectionContextMenu ? (event) => {
      const selectedNodes = store.getState().getNodes().filter((n2) => n2.selected);
      onSelectionContextMenu(event, selectedNodes);
    } : void 0;
    const onKeyDown = (event) => {
      if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {
        updatePositions({
          x: arrowKeyDiffs[event.key].x,
          y: arrowKeyDiffs[event.key].y,
          isShiftPressed: event.shiftKey
        });
      }
    };
    return import_react2.default.createElement(
      "div",
      { className: cc(["react-flow__nodesselection", "react-flow__container", noPanClassName]), style: {
        transform: transformString
      } },
      import_react2.default.createElement("div", { ref: nodeRef, className: "react-flow__nodesselection-rect", onContextMenu, tabIndex: disableKeyboardA11y ? void 0 : -1, onKeyDown: disableKeyboardA11y ? void 0 : onKeyDown, style: {
        width,
        height: height2,
        top,
        left
      } })
    );
  }
  var NodesSelection$1 = (0, import_react2.memo)(NodesSelection);
  var selector$6 = (s2) => s2.nodesSelectionActive;
  var FlowRenderer = ({ children: children3, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, deleteKeyCode, onMove, onMoveStart, onMoveEnd, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y }) => {
    const nodesSelectionActive = useStore(selector$6);
    const selectionKeyPressed = useKeyPress(selectionKeyCode);
    const panActivationKeyPressed = useKeyPress(panActivationKeyCode);
    const panOnDrag = panActivationKeyPressed || _panOnDrag;
    const panOnScroll = panActivationKeyPressed || _panOnScroll;
    const isSelecting = selectionKeyPressed || selectionOnDrag && panOnDrag !== true;
    useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode });
    return import_react2.default.createElement(
      ZoomPane,
      { onMove, onMoveStart, onMoveEnd, onPaneContextMenu, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: !selectionKeyPressed && panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling, noWheelClassName, noPanClassName },
      import_react2.default.createElement(
        Pane,
        { onSelectionStart, onSelectionEnd, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, panOnDrag, isSelecting: !!isSelecting, selectionMode },
        children3,
        nodesSelectionActive && import_react2.default.createElement(NodesSelection$1, { onSelectionContextMenu, noPanClassName, disableKeyboardA11y })
      )
    );
  };
  FlowRenderer.displayName = "FlowRenderer";
  var FlowRenderer$1 = (0, import_react2.memo)(FlowRenderer);
  function useVisibleNodes(onlyRenderVisible) {
    const nodes = useStore((0, import_react2.useCallback)((s2) => onlyRenderVisible ? getNodesInside(s2.nodeInternals, { x: 0, y: 0, width: s2.width, height: s2.height }, s2.transform, true) : s2.getNodes(), [onlyRenderVisible]));
    return nodes;
  }
  function createNodeTypes(nodeTypes) {
    const standardTypes = {
      input: wrapNode(nodeTypes.input || InputNode$1),
      default: wrapNode(nodeTypes.default || DefaultNode$1),
      output: wrapNode(nodeTypes.output || OutputNode$1),
      group: wrapNode(nodeTypes.group || GroupNode)
    };
    const wrappedTypes = {};
    const specialTypes = Object.keys(nodeTypes).filter((k2) => !["input", "default", "output", "group"].includes(k2)).reduce((res, key) => {
      res[key] = wrapNode(nodeTypes[key] || DefaultNode$1);
      return res;
    }, wrappedTypes);
    return {
      ...standardTypes,
      ...specialTypes
    };
  }
  var getPositionWithOrigin = ({ x: x2, y: y2, width, height: height2, origin }) => {
    if (!width || !height2) {
      return { x: x2, y: y2 };
    }
    if (origin[0] < 0 || origin[1] < 0 || origin[0] > 1 || origin[1] > 1) {
      return { x: x2, y: y2 };
    }
    return {
      x: x2 - width * origin[0],
      y: y2 - height2 * origin[1]
    };
  };
  var selector$5 = (s2) => ({
    nodesDraggable: s2.nodesDraggable,
    nodesConnectable: s2.nodesConnectable,
    nodesFocusable: s2.nodesFocusable,
    elementsSelectable: s2.elementsSelectable,
    updateNodeDimensions: s2.updateNodeDimensions,
    onError: s2.onError
  });
  var NodeRenderer = (props) => {
    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, updateNodeDimensions, onError } = useStore(selector$5, shallow$1);
    const nodes = useVisibleNodes(props.onlyRenderVisibleElements);
    const resizeObserverRef = (0, import_react2.useRef)();
    const resizeObserver = (0, import_react2.useMemo)(() => {
      if (typeof ResizeObserver === "undefined") {
        return null;
      }
      const observer = new ResizeObserver((entries) => {
        const updates = entries.map((entry) => ({
          id: entry.target.getAttribute("data-id"),
          nodeElement: entry.target,
          forceUpdate: true
        }));
        updateNodeDimensions(updates);
      });
      resizeObserverRef.current = observer;
      return observer;
    }, []);
    (0, import_react2.useEffect)(() => {
      return () => {
        resizeObserverRef?.current?.disconnect();
      };
    }, []);
    return import_react2.default.createElement("div", { className: "react-flow__nodes", style: containerStyle }, nodes.map((node) => {
      let nodeType = node.type || "default";
      if (!props.nodeTypes[nodeType]) {
        onError?.("003", errorMessages["error003"](nodeType));
        nodeType = "default";
      }
      const NodeComponent = props.nodeTypes[nodeType] || props.nodeTypes.default;
      const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === "undefined");
      const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === "undefined");
      const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === "undefined");
      const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === "undefined");
      const clampedPosition = props.nodeExtent ? clampPosition(node.positionAbsolute, props.nodeExtent) : node.positionAbsolute;
      const posX = clampedPosition?.x ?? 0;
      const posY = clampedPosition?.y ?? 0;
      const posOrigin = getPositionWithOrigin({
        x: posX,
        y: posY,
        width: node.width ?? 0,
        height: node.height ?? 0,
        origin: props.nodeOrigin
      });
      return import_react2.default.createElement(NodeComponent, { key: node.id, id: node.id, className: node.className, style: node.style, type: nodeType, data: node.data, sourcePosition: node.sourcePosition || Position.Bottom, targetPosition: node.targetPosition || Position.Top, hidden: node.hidden, xPos: posX, yPos: posY, xPosOrigin: posOrigin.x, yPosOrigin: posOrigin.y, selectNodesOnDrag: props.selectNodesOnDrag, onClick: props.onNodeClick, onMouseEnter: props.onNodeMouseEnter, onMouseMove: props.onNodeMouseMove, onMouseLeave: props.onNodeMouseLeave, onContextMenu: props.onNodeContextMenu, onDoubleClick: props.onNodeDoubleClick, selected: !!node.selected, isDraggable, isSelectable, isConnectable, isFocusable, resizeObserver, dragHandle: node.dragHandle, zIndex: node[internalsSymbol]?.z ?? 0, isParent: !!node[internalsSymbol]?.isParent, noDragClassName: props.noDragClassName, noPanClassName: props.noPanClassName, initialized: !!node.width && !!node.height, rfId: props.rfId, disableKeyboardA11y: props.disableKeyboardA11y, ariaLabel: node.ariaLabel, hasHandleBounds: !!node[internalsSymbol]?.handleBounds });
    }));
  };
  NodeRenderer.displayName = "NodeRenderer";
  var NodeRenderer$1 = (0, import_react2.memo)(NodeRenderer);
  var shiftX = (x2, shift, position2) => {
    if (position2 === Position.Left)
      return x2 - shift;
    if (position2 === Position.Right)
      return x2 + shift;
    return x2;
  };
  var shiftY = (y2, shift, position2) => {
    if (position2 === Position.Top)
      return y2 - shift;
    if (position2 === Position.Bottom)
      return y2 + shift;
    return y2;
  };
  var EdgeUpdaterClassName = "react-flow__edgeupdater";
  var EdgeAnchor = ({ position: position2, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) => import_react2.default.createElement("circle", { onMouseDown, onMouseEnter, onMouseOut, className: cc([EdgeUpdaterClassName, `${EdgeUpdaterClassName}-${type}`]), cx: shiftX(centerX, radius, position2), cy: shiftY(centerY, radius, position2), r: radius, stroke: "transparent", fill: "transparent" });
  var alwaysValidConnection = () => true;
  var wrapEdge = (EdgeComponent) => {
    const EdgeWrapper = ({ id: id2, className, type, data, onClick, onEdgeDoubleClick, selected, animated, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, source, target, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, elementsSelectable, hidden, sourceHandleId, targetHandleId, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, markerEnd, markerStart, rfId, ariaLabel, isFocusable, isReconnectable, pathOptions, interactionWidth, disableKeyboardA11y }) => {
      const edgeRef = (0, import_react2.useRef)(null);
      const [updateHover, setUpdateHover] = (0, import_react2.useState)(false);
      const [updating, setUpdating] = (0, import_react2.useState)(false);
      const store = useStoreApi();
      const markerStartUrl = (0, import_react2.useMemo)(() => `url('#${getMarkerId(markerStart, rfId)}')`, [markerStart, rfId]);
      const markerEndUrl = (0, import_react2.useMemo)(() => `url('#${getMarkerId(markerEnd, rfId)}')`, [markerEnd, rfId]);
      if (hidden) {
        return null;
      }
      const onEdgeClick = (event) => {
        const { edges, addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();
        const edge = edges.find((e2) => e2.id === id2);
        if (!edge) {
          return;
        }
        if (elementsSelectable) {
          store.setState({ nodesSelectionActive: false });
          if (edge.selected && multiSelectionActive) {
            unselectNodesAndEdges({ nodes: [], edges: [edge] });
            edgeRef.current?.blur();
          } else {
            addSelectedEdges([id2]);
          }
        }
        if (onClick) {
          onClick(event, edge);
        }
      };
      const onEdgeDoubleClickHandler = getMouseHandler$1(id2, store.getState, onEdgeDoubleClick);
      const onEdgeContextMenu = getMouseHandler$1(id2, store.getState, onContextMenu);
      const onEdgeMouseEnter = getMouseHandler$1(id2, store.getState, onMouseEnter);
      const onEdgeMouseMove = getMouseHandler$1(id2, store.getState, onMouseMove);
      const onEdgeMouseLeave = getMouseHandler$1(id2, store.getState, onMouseLeave);
      const handleEdgeUpdater = (event, isSourceHandle) => {
        if (event.button !== 0) {
          return;
        }
        const { edges, isValidConnection: isValidConnectionStore } = store.getState();
        const nodeId = isSourceHandle ? target : source;
        const handleId = (isSourceHandle ? targetHandleId : sourceHandleId) || null;
        const handleType = isSourceHandle ? "target" : "source";
        const isValidConnection = isValidConnectionStore || alwaysValidConnection;
        const isTarget = isSourceHandle;
        const edge = edges.find((e2) => e2.id === id2);
        setUpdating(true);
        onReconnectStart?.(event, edge, handleType);
        const _onReconnectEnd = (evt) => {
          setUpdating(false);
          onReconnectEnd?.(evt, edge, handleType);
        };
        const onConnectEdge = (connection) => onReconnect?.(edge, connection);
        handlePointerDown({
          event,
          handleId,
          nodeId,
          onConnect: onConnectEdge,
          isTarget,
          getState: store.getState,
          setState: store.setState,
          isValidConnection,
          edgeUpdaterType: handleType,
          onReconnectEnd: _onReconnectEnd
        });
      };
      const onEdgeUpdaterSourceMouseDown = (event) => handleEdgeUpdater(event, true);
      const onEdgeUpdaterTargetMouseDown = (event) => handleEdgeUpdater(event, false);
      const onEdgeUpdaterMouseEnter = () => setUpdateHover(true);
      const onEdgeUpdaterMouseOut = () => setUpdateHover(false);
      const inactive = !elementsSelectable && !onClick;
      const onKeyDown = (event) => {
        if (!disableKeyboardA11y && elementSelectionKeys.includes(event.key) && elementsSelectable) {
          const { unselectNodesAndEdges, addSelectedEdges, edges } = store.getState();
          const unselect = event.key === "Escape";
          if (unselect) {
            edgeRef.current?.blur();
            unselectNodesAndEdges({ edges: [edges.find((e2) => e2.id === id2)] });
          } else {
            addSelectedEdges([id2]);
          }
        }
      };
      return import_react2.default.createElement(
        "g",
        { className: cc([
          "react-flow__edge",
          `react-flow__edge-${type}`,
          className,
          { selected, animated, inactive, updating: updateHover }
        ]), onClick: onEdgeClick, onDoubleClick: onEdgeDoubleClickHandler, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave, onKeyDown: isFocusable ? onKeyDown : void 0, tabIndex: isFocusable ? 0 : void 0, role: isFocusable ? "button" : "img", "data-testid": `rf__edge-${id2}`, "aria-label": ariaLabel === null ? void 0 : ariaLabel ? ariaLabel : `Edge from ${source} to ${target}`, "aria-describedby": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : void 0, ref: edgeRef },
        !updating && import_react2.default.createElement(EdgeComponent, { id: id2, source, target, selected, animated, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, data, style: style2, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, sourceHandleId, targetHandleId, markerStart: markerStartUrl, markerEnd: markerEndUrl, pathOptions, interactionWidth }),
        isReconnectable && import_react2.default.createElement(
          import_react2.default.Fragment,
          null,
          (isReconnectable === "source" || isReconnectable === true) && import_react2.default.createElement(EdgeAnchor, { position: sourcePosition, centerX: sourceX, centerY: sourceY, radius: reconnectRadius, onMouseDown: onEdgeUpdaterSourceMouseDown, onMouseEnter: onEdgeUpdaterMouseEnter, onMouseOut: onEdgeUpdaterMouseOut, type: "source" }),
          (isReconnectable === "target" || isReconnectable === true) && import_react2.default.createElement(EdgeAnchor, { position: targetPosition, centerX: targetX, centerY: targetY, radius: reconnectRadius, onMouseDown: onEdgeUpdaterTargetMouseDown, onMouseEnter: onEdgeUpdaterMouseEnter, onMouseOut: onEdgeUpdaterMouseOut, type: "target" })
        )
      );
    };
    EdgeWrapper.displayName = "EdgeWrapper";
    return (0, import_react2.memo)(EdgeWrapper);
  };
  function createEdgeTypes(edgeTypes) {
    const standardTypes = {
      default: wrapEdge(edgeTypes.default || BezierEdge),
      straight: wrapEdge(edgeTypes.bezier || StraightEdge),
      step: wrapEdge(edgeTypes.step || StepEdge),
      smoothstep: wrapEdge(edgeTypes.step || SmoothStepEdge),
      simplebezier: wrapEdge(edgeTypes.simplebezier || SimpleBezierEdge)
    };
    const wrappedTypes = {};
    const specialTypes = Object.keys(edgeTypes).filter((k2) => !["default", "bezier"].includes(k2)).reduce((res, key) => {
      res[key] = wrapEdge(edgeTypes[key] || BezierEdge);
      return res;
    }, wrappedTypes);
    return {
      ...standardTypes,
      ...specialTypes
    };
  }
  function getHandlePosition(position2, nodeRect, handle = null) {
    const x2 = (handle?.x || 0) + nodeRect.x;
    const y2 = (handle?.y || 0) + nodeRect.y;
    const width = handle?.width || nodeRect.width;
    const height2 = handle?.height || nodeRect.height;
    switch (position2) {
      case Position.Top:
        return {
          x: x2 + width / 2,
          y: y2
        };
      case Position.Right:
        return {
          x: x2 + width,
          y: y2 + height2 / 2
        };
      case Position.Bottom:
        return {
          x: x2 + width / 2,
          y: y2 + height2
        };
      case Position.Left:
        return {
          x: x2,
          y: y2 + height2 / 2
        };
    }
  }
  function getHandle(bounds, handleId) {
    if (!bounds) {
      return null;
    }
    if (bounds.length === 1 || !handleId) {
      return bounds[0];
    } else if (handleId) {
      return bounds.find((d2) => d2.id === handleId) || null;
    }
    return null;
  }
  var getEdgePositions = (sourceNodeRect, sourceHandle, sourcePosition, targetNodeRect, targetHandle, targetPosition) => {
    const sourceHandlePos = getHandlePosition(sourcePosition, sourceNodeRect, sourceHandle);
    const targetHandlePos = getHandlePosition(targetPosition, targetNodeRect, targetHandle);
    return {
      sourceX: sourceHandlePos.x,
      sourceY: sourceHandlePos.y,
      targetX: targetHandlePos.x,
      targetY: targetHandlePos.y
    };
  };
  function isEdgeVisible({ sourcePos, targetPos, sourceWidth, sourceHeight, targetWidth, targetHeight, width, height: height2, transform: transform2 }) {
    const edgeBox = {
      x: Math.min(sourcePos.x, targetPos.x),
      y: Math.min(sourcePos.y, targetPos.y),
      x2: Math.max(sourcePos.x + sourceWidth, targetPos.x + targetWidth),
      y2: Math.max(sourcePos.y + sourceHeight, targetPos.y + targetHeight)
    };
    if (edgeBox.x === edgeBox.x2) {
      edgeBox.x2 += 1;
    }
    if (edgeBox.y === edgeBox.y2) {
      edgeBox.y2 += 1;
    }
    const viewBox = rectToBox({
      x: (0 - transform2[0]) / transform2[2],
      y: (0 - transform2[1]) / transform2[2],
      width: width / transform2[2],
      height: height2 / transform2[2]
    });
    const xOverlap = Math.max(0, Math.min(viewBox.x2, edgeBox.x2) - Math.max(viewBox.x, edgeBox.x));
    const yOverlap = Math.max(0, Math.min(viewBox.y2, edgeBox.y2) - Math.max(viewBox.y, edgeBox.y));
    const overlappingArea = Math.ceil(xOverlap * yOverlap);
    return overlappingArea > 0;
  }
  function getNodeData(node) {
    const handleBounds = node?.[internalsSymbol]?.handleBounds || null;
    const isValid = handleBounds && node?.width && node?.height && typeof node?.positionAbsolute?.x !== "undefined" && typeof node?.positionAbsolute?.y !== "undefined";
    return [
      {
        x: node?.positionAbsolute?.x || 0,
        y: node?.positionAbsolute?.y || 0,
        width: node?.width || 0,
        height: node?.height || 0
      },
      handleBounds,
      !!isValid
    ];
  }
  var defaultEdgeTree = [{ level: 0, isMaxLevel: true, edges: [] }];
  function groupEdgesByZLevel(edges, nodeInternals, elevateEdgesOnSelect = false) {
    let maxLevel = -1;
    const levelLookup = edges.reduce((tree, edge) => {
      const hasZIndex = isNumeric(edge.zIndex);
      let z = hasZIndex ? edge.zIndex : 0;
      if (elevateEdgesOnSelect) {
        const targetNode = nodeInternals.get(edge.target);
        const sourceNode = nodeInternals.get(edge.source);
        const edgeOrConnectedNodeSelected = edge.selected || targetNode?.selected || sourceNode?.selected;
        const selectedZIndex = Math.max(sourceNode?.[internalsSymbol]?.z || 0, targetNode?.[internalsSymbol]?.z || 0, 1e3);
        z = (hasZIndex ? edge.zIndex : 0) + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);
      }
      if (tree[z]) {
        tree[z].push(edge);
      } else {
        tree[z] = [edge];
      }
      maxLevel = z > maxLevel ? z : maxLevel;
      return tree;
    }, {});
    const edgeTree = Object.entries(levelLookup).map(([key, edges2]) => {
      const level = +key;
      return {
        edges: edges2,
        level,
        isMaxLevel: level === maxLevel
      };
    });
    if (edgeTree.length === 0) {
      return defaultEdgeTree;
    }
    return edgeTree;
  }
  function useVisibleEdges(onlyRenderVisible, nodeInternals, elevateEdgesOnSelect) {
    const edges = useStore((0, import_react2.useCallback)((s2) => {
      if (!onlyRenderVisible) {
        return s2.edges;
      }
      return s2.edges.filter((e2) => {
        const sourceNode = nodeInternals.get(e2.source);
        const targetNode = nodeInternals.get(e2.target);
        return sourceNode?.width && sourceNode?.height && targetNode?.width && targetNode?.height && isEdgeVisible({
          sourcePos: sourceNode.positionAbsolute || { x: 0, y: 0 },
          targetPos: targetNode.positionAbsolute || { x: 0, y: 0 },
          sourceWidth: sourceNode.width,
          sourceHeight: sourceNode.height,
          targetWidth: targetNode.width,
          targetHeight: targetNode.height,
          width: s2.width,
          height: s2.height,
          transform: s2.transform
        });
      });
    }, [onlyRenderVisible, nodeInternals]));
    return groupEdgesByZLevel(edges, nodeInternals, elevateEdgesOnSelect);
  }
  var ArrowSymbol = ({ color: color2 = "none", strokeWidth = 1 }) => {
    return import_react2.default.createElement("polyline", { style: {
      stroke: color2,
      strokeWidth
    }, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" });
  };
  var ArrowClosedSymbol = ({ color: color2 = "none", strokeWidth = 1 }) => {
    return import_react2.default.createElement("polyline", { style: {
      stroke: color2,
      fill: color2,
      strokeWidth
    }, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" });
  };
  var MarkerSymbols = {
    [MarkerType.Arrow]: ArrowSymbol,
    [MarkerType.ArrowClosed]: ArrowClosedSymbol
  };
  function useMarkerSymbol(type) {
    const store = useStoreApi();
    const symbol = (0, import_react2.useMemo)(() => {
      const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);
      if (!symbolExists) {
        store.getState().onError?.("009", errorMessages["error009"](type));
        return null;
      }
      return MarkerSymbols[type];
    }, [type]);
    return symbol;
  }
  var Marker = ({ id: id2, type, color: color2, width = 12.5, height: height2 = 12.5, markerUnits = "strokeWidth", strokeWidth, orient = "auto-start-reverse" }) => {
    const Symbol2 = useMarkerSymbol(type);
    if (!Symbol2) {
      return null;
    }
    return import_react2.default.createElement(
      "marker",
      { className: "react-flow__arrowhead", id: id2, markerWidth: `${width}`, markerHeight: `${height2}`, viewBox: "-10 -10 20 20", markerUnits, orient, refX: "0", refY: "0" },
      import_react2.default.createElement(Symbol2, { color: color2, strokeWidth })
    );
  };
  var markerSelector = ({ defaultColor: defaultColor2, rfId }) => (s2) => {
    const ids = [];
    return s2.edges.reduce((markers, edge) => {
      [edge.markerStart, edge.markerEnd].forEach((marker) => {
        if (marker && typeof marker === "object") {
          const markerId = getMarkerId(marker, rfId);
          if (!ids.includes(markerId)) {
            markers.push({ id: markerId, color: marker.color || defaultColor2, ...marker });
            ids.push(markerId);
          }
        }
      });
      return markers;
    }, []).sort((a2, b2) => a2.id.localeCompare(b2.id));
  };
  var MarkerDefinitions = ({ defaultColor: defaultColor2, rfId }) => {
    const markers = useStore(
      (0, import_react2.useCallback)(markerSelector({ defaultColor: defaultColor2, rfId }), [defaultColor2, rfId]),
      // the id includes all marker options, so we just need to look at that part of the marker
      (a2, b2) => !(a2.length !== b2.length || a2.some((m2, i2) => m2.id !== b2[i2].id))
    );
    return import_react2.default.createElement("defs", null, markers.map((marker) => import_react2.default.createElement(Marker, { id: marker.id, key: marker.id, type: marker.type, color: marker.color, width: marker.width, height: marker.height, markerUnits: marker.markerUnits, strokeWidth: marker.strokeWidth, orient: marker.orient })));
  };
  MarkerDefinitions.displayName = "MarkerDefinitions";
  var MarkerDefinitions$1 = (0, import_react2.memo)(MarkerDefinitions);
  var selector$4 = (s2) => ({
    nodesConnectable: s2.nodesConnectable,
    edgesFocusable: s2.edgesFocusable,
    edgesUpdatable: s2.edgesUpdatable,
    elementsSelectable: s2.elementsSelectable,
    width: s2.width,
    height: s2.height,
    connectionMode: s2.connectionMode,
    nodeInternals: s2.nodeInternals,
    onError: s2.onError
  });
  var EdgeRenderer = ({ defaultMarkerColor, onlyRenderVisibleElements, elevateEdgesOnSelect, rfId, edgeTypes, noPanClassName, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, onEdgeDoubleClick, onReconnect, onReconnectStart, onReconnectEnd, reconnectRadius, children: children3, disableKeyboardA11y }) => {
    const { edgesFocusable, edgesUpdatable, elementsSelectable, width, height: height2, connectionMode, nodeInternals, onError } = useStore(selector$4, shallow$1);
    const edgeTree = useVisibleEdges(onlyRenderVisibleElements, nodeInternals, elevateEdgesOnSelect);
    if (!width) {
      return null;
    }
    return import_react2.default.createElement(
      import_react2.default.Fragment,
      null,
      edgeTree.map(({ level, edges, isMaxLevel }) => import_react2.default.createElement(
        "svg",
        { key: level, style: { zIndex: level }, width, height: height2, className: "react-flow__edges react-flow__container" },
        isMaxLevel && import_react2.default.createElement(MarkerDefinitions$1, { defaultColor: defaultMarkerColor, rfId }),
        import_react2.default.createElement("g", null, edges.map((edge) => {
          const [sourceNodeRect, sourceHandleBounds, sourceIsValid] = getNodeData(nodeInternals.get(edge.source));
          const [targetNodeRect, targetHandleBounds, targetIsValid] = getNodeData(nodeInternals.get(edge.target));
          if (!sourceIsValid || !targetIsValid) {
            return null;
          }
          let edgeType = edge.type || "default";
          if (!edgeTypes[edgeType]) {
            onError?.("011", errorMessages["error011"](edgeType));
            edgeType = "default";
          }
          const EdgeComponent = edgeTypes[edgeType] || edgeTypes.default;
          const targetNodeHandles = connectionMode === ConnectionMode.Strict ? targetHandleBounds.target : (targetHandleBounds.target ?? []).concat(targetHandleBounds.source ?? []);
          const sourceHandle = getHandle(sourceHandleBounds.source, edge.sourceHandle);
          const targetHandle = getHandle(targetNodeHandles, edge.targetHandle);
          const sourcePosition = sourceHandle?.position || Position.Bottom;
          const targetPosition = targetHandle?.position || Position.Top;
          const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === "undefined");
          const edgeReconnectable = edge.reconnectable || edge.updatable;
          const isReconnectable = typeof onReconnect !== "undefined" && (edgeReconnectable || edgesUpdatable && typeof edgeReconnectable === "undefined");
          if (!sourceHandle || !targetHandle) {
            onError?.("008", errorMessages["error008"](sourceHandle, edge));
            return null;
          }
          const { sourceX, sourceY, targetX, targetY } = getEdgePositions(sourceNodeRect, sourceHandle, sourcePosition, targetNodeRect, targetHandle, targetPosition);
          return import_react2.default.createElement(EdgeComponent, { key: edge.id, id: edge.id, className: cc([edge.className, noPanClassName]), type: edgeType, data: edge.data, selected: !!edge.selected, animated: !!edge.animated, hidden: !!edge.hidden, label: edge.label, labelStyle: edge.labelStyle, labelShowBg: edge.labelShowBg, labelBgStyle: edge.labelBgStyle, labelBgPadding: edge.labelBgPadding, labelBgBorderRadius: edge.labelBgBorderRadius, style: edge.style, source: edge.source, target: edge.target, sourceHandleId: edge.sourceHandle, targetHandleId: edge.targetHandle, markerEnd: edge.markerEnd, markerStart: edge.markerStart, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, elementsSelectable, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave, onClick: onEdgeClick, onEdgeDoubleClick, onReconnect, onReconnectStart, onReconnectEnd, reconnectRadius, rfId, ariaLabel: edge.ariaLabel, isFocusable, isReconnectable, pathOptions: "pathOptions" in edge ? edge.pathOptions : void 0, interactionWidth: edge.interactionWidth, disableKeyboardA11y });
        }))
      )),
      children3
    );
  };
  EdgeRenderer.displayName = "EdgeRenderer";
  var EdgeRenderer$1 = (0, import_react2.memo)(EdgeRenderer);
  var selector$3 = (s2) => `translate(${s2.transform[0]}px,${s2.transform[1]}px) scale(${s2.transform[2]})`;
  function Viewport({ children: children3 }) {
    const transform2 = useStore(selector$3);
    return import_react2.default.createElement("div", { className: "react-flow__viewport react-flow__container", style: { transform: transform2 } }, children3);
  }
  function useOnInitHandler(onInit) {
    const rfInstance = useReactFlow();
    const isInitialized = (0, import_react2.useRef)(false);
    (0, import_react2.useEffect)(() => {
      if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {
        setTimeout(() => onInit(rfInstance), 1);
        isInitialized.current = true;
      }
    }, [onInit, rfInstance.viewportInitialized]);
  }
  var oppositePosition = {
    [Position.Left]: Position.Right,
    [Position.Right]: Position.Left,
    [Position.Top]: Position.Bottom,
    [Position.Bottom]: Position.Top
  };
  var ConnectionLine = ({ nodeId, handleType, style: style2, type = ConnectionLineType.Bezier, CustomComponent, connectionStatus }) => {
    const { fromNode, handleId, toX, toY, connectionMode } = useStore((0, import_react2.useCallback)((s2) => ({
      fromNode: s2.nodeInternals.get(nodeId),
      handleId: s2.connectionHandleId,
      toX: (s2.connectionPosition.x - s2.transform[0]) / s2.transform[2],
      toY: (s2.connectionPosition.y - s2.transform[1]) / s2.transform[2],
      connectionMode: s2.connectionMode
    }), [nodeId]), shallow$1);
    const fromHandleBounds = fromNode?.[internalsSymbol]?.handleBounds;
    let handleBounds = fromHandleBounds?.[handleType];
    if (connectionMode === ConnectionMode.Loose) {
      handleBounds = handleBounds ? handleBounds : fromHandleBounds?.[handleType === "source" ? "target" : "source"];
    }
    if (!fromNode || !handleBounds) {
      return null;
    }
    const fromHandle = handleId ? handleBounds.find((d2) => d2.id === handleId) : handleBounds[0];
    const fromHandleX = fromHandle ? fromHandle.x + fromHandle.width / 2 : (fromNode.width ?? 0) / 2;
    const fromHandleY = fromHandle ? fromHandle.y + fromHandle.height / 2 : fromNode.height ?? 0;
    const fromX = (fromNode.positionAbsolute?.x ?? 0) + fromHandleX;
    const fromY = (fromNode.positionAbsolute?.y ?? 0) + fromHandleY;
    const fromPosition = fromHandle?.position;
    const toPosition = fromPosition ? oppositePosition[fromPosition] : null;
    if (!fromPosition || !toPosition) {
      return null;
    }
    if (CustomComponent) {
      return import_react2.default.createElement(CustomComponent, { connectionLineType: type, connectionLineStyle: style2, fromNode, fromHandle, fromX, fromY, toX, toY, fromPosition, toPosition, connectionStatus });
    }
    let dAttr = "";
    const pathParams = {
      sourceX: fromX,
      sourceY: fromY,
      sourcePosition: fromPosition,
      targetX: toX,
      targetY: toY,
      targetPosition: toPosition
    };
    if (type === ConnectionLineType.Bezier) {
      [dAttr] = getBezierPath(pathParams);
    } else if (type === ConnectionLineType.Step) {
      [dAttr] = getSmoothStepPath({
        ...pathParams,
        borderRadius: 0
      });
    } else if (type === ConnectionLineType.SmoothStep) {
      [dAttr] = getSmoothStepPath(pathParams);
    } else if (type === ConnectionLineType.SimpleBezier) {
      [dAttr] = getSimpleBezierPath(pathParams);
    } else {
      dAttr = `M${fromX},${fromY} ${toX},${toY}`;
    }
    return import_react2.default.createElement("path", { d: dAttr, fill: "none", className: "react-flow__connection-path", style: style2 });
  };
  ConnectionLine.displayName = "ConnectionLine";
  var selector$2 = (s2) => ({
    nodeId: s2.connectionNodeId,
    handleType: s2.connectionHandleType,
    nodesConnectable: s2.nodesConnectable,
    connectionStatus: s2.connectionStatus,
    width: s2.width,
    height: s2.height
  });
  function ConnectionLineWrapper({ containerStyle: containerStyle2, style: style2, type, component }) {
    const { nodeId, handleType, nodesConnectable, width, height: height2, connectionStatus } = useStore(selector$2, shallow$1);
    const isValid = !!(nodeId && handleType && width && nodesConnectable);
    if (!isValid) {
      return null;
    }
    return import_react2.default.createElement(
      "svg",
      { style: containerStyle2, width, height: height2, className: "react-flow__edges react-flow__connectionline react-flow__container" },
      import_react2.default.createElement(
        "g",
        { className: cc(["react-flow__connection", connectionStatus]) },
        import_react2.default.createElement(ConnectionLine, { nodeId, handleType, style: style2, type, CustomComponent: component, connectionStatus })
      )
    );
  }
  function useNodeOrEdgeTypes(nodeOrEdgeTypes, createTypes) {
    const typesKeysRef = (0, import_react2.useRef)(null);
    const store = useStoreApi();
    const typesParsed = (0, import_react2.useMemo)(() => {
      if (false) {
        const typeKeys = Object.keys(nodeOrEdgeTypes);
        if (shallow$1(typesKeysRef.current, typeKeys)) {
          store.getState().onError?.("002", errorMessages["error002"]());
        }
        typesKeysRef.current = typeKeys;
      }
      return createTypes(nodeOrEdgeTypes);
    }, [nodeOrEdgeTypes]);
    return typesParsed;
  }
  var GraphView = ({ nodeTypes, edgeTypes, onMove, onMoveStart, onMoveEnd, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, selectNodesOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onReconnect, onReconnectStart, onReconnectEnd, reconnectRadius, noDragClassName, noWheelClassName, noPanClassName, elevateEdgesOnSelect, disableKeyboardA11y, nodeOrigin, nodeExtent, rfId }) => {
    const nodeTypesWrapped = useNodeOrEdgeTypes(nodeTypes, createNodeTypes);
    const edgeTypesWrapped = useNodeOrEdgeTypes(edgeTypes, createEdgeTypes);
    useOnInitHandler(onInit);
    return import_react2.default.createElement(
      FlowRenderer$1,
      { onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, onMove, onMoveStart, onMoveEnd, zoomOnScroll, zoomOnPinch, zoomOnDoubleClick, panOnScroll, panOnScrollSpeed, panOnScrollMode, panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, onSelectionContextMenu, preventScrolling, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y },
      import_react2.default.createElement(
        Viewport,
        null,
        import_react2.default.createElement(
          EdgeRenderer$1,
          { edgeTypes: edgeTypesWrapped, onEdgeClick, onEdgeDoubleClick, onlyRenderVisibleElements, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onReconnect, onReconnectStart, onReconnectEnd, reconnectRadius, defaultMarkerColor, noPanClassName, elevateEdgesOnSelect: !!elevateEdgesOnSelect, disableKeyboardA11y, rfId },
          import_react2.default.createElement(ConnectionLineWrapper, { style: connectionLineStyle, type: connectionLineType, component: connectionLineComponent, containerStyle: connectionLineContainerStyle })
        ),
        import_react2.default.createElement("div", { className: "react-flow__edgelabel-renderer" }),
        import_react2.default.createElement(NodeRenderer$1, { nodeTypes: nodeTypesWrapped, onNodeClick, onNodeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, selectNodesOnDrag, onlyRenderVisibleElements, noPanClassName, noDragClassName, disableKeyboardA11y, nodeOrigin, nodeExtent, rfId })
      )
    );
  };
  GraphView.displayName = "GraphView";
  var GraphView$1 = (0, import_react2.memo)(GraphView);
  var infiniteExtent = [
    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
  ];
  var initialState = {
    rfId: "1",
    width: 0,
    height: 0,
    transform: [0, 0, 1],
    nodeInternals: /* @__PURE__ */ new Map(),
    edges: [],
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: false,
    hasDefaultEdges: false,
    d3Zoom: null,
    d3Selection: null,
    d3ZoomHandler: void 0,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: infiniteExtent,
    nodeExtent: infiniteExtent,
    nodesSelectionActive: false,
    userSelectionActive: false,
    userSelectionRect: null,
    connectionNodeId: null,
    connectionHandleId: null,
    connectionHandleType: "source",
    connectionPosition: { x: 0, y: 0 },
    connectionStatus: null,
    connectionMode: ConnectionMode.Strict,
    domNode: null,
    paneDragging: false,
    noPanClassName: "nopan",
    nodeOrigin: [0, 0],
    nodeDragThreshold: 0,
    snapGrid: [15, 15],
    snapToGrid: false,
    nodesDraggable: true,
    nodesConnectable: true,
    nodesFocusable: true,
    edgesFocusable: true,
    edgesUpdatable: true,
    elementsSelectable: true,
    elevateNodesOnSelect: true,
    fitViewOnInit: false,
    fitViewOnInitDone: false,
    fitViewOnInitOptions: void 0,
    onSelectionChange: [],
    multiSelectionActive: false,
    connectionStartHandle: null,
    connectionEndHandle: null,
    connectionClickStartHandle: null,
    connectOnClick: true,
    ariaLiveMessage: "",
    autoPanOnConnect: true,
    autoPanOnNodeDrag: true,
    connectionRadius: 20,
    onError: devWarn,
    isValidConnection: void 0
  };
  var createRFStore = () => createWithEqualityFn((set3, get3) => ({
    ...initialState,
    setNodes: (nodes) => {
      const { nodeInternals, nodeOrigin, elevateNodesOnSelect } = get3();
      set3({ nodeInternals: createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect) });
    },
    getNodes: () => {
      return Array.from(get3().nodeInternals.values());
    },
    setEdges: (edges) => {
      const { defaultEdgeOptions = {} } = get3();
      set3({ edges: edges.map((e2) => ({ ...defaultEdgeOptions, ...e2 })) });
    },
    setDefaultNodesAndEdges: (nodes, edges) => {
      const hasDefaultNodes = typeof nodes !== "undefined";
      const hasDefaultEdges = typeof edges !== "undefined";
      const nodeInternals = hasDefaultNodes ? createNodeInternals(nodes, /* @__PURE__ */ new Map(), get3().nodeOrigin, get3().elevateNodesOnSelect) : /* @__PURE__ */ new Map();
      const nextEdges = hasDefaultEdges ? edges : [];
      set3({ nodeInternals, edges: nextEdges, hasDefaultNodes, hasDefaultEdges });
    },
    updateNodeDimensions: (updates) => {
      const { onNodesChange, nodeInternals, fitViewOnInit, fitViewOnInitDone, fitViewOnInitOptions, domNode, nodeOrigin } = get3();
      const viewportNode = domNode?.querySelector(".react-flow__viewport");
      if (!viewportNode) {
        return;
      }
      const style2 = window.getComputedStyle(viewportNode);
      const { m22: zoom } = new window.DOMMatrixReadOnly(style2.transform);
      const changes = updates.reduce((res, update) => {
        const node = nodeInternals.get(update.id);
        if (node?.hidden) {
          nodeInternals.set(node.id, {
            ...node,
            [internalsSymbol]: {
              ...node[internalsSymbol],
              // we need to reset the handle bounds when the node is hidden
              // in order to force a new observation when the node is shown again
              handleBounds: void 0
            }
          });
        } else if (node) {
          const dimensions = getDimensions(update.nodeElement);
          const doUpdate = !!(dimensions.width && dimensions.height && (node.width !== dimensions.width || node.height !== dimensions.height || update.forceUpdate));
          if (doUpdate) {
            nodeInternals.set(node.id, {
              ...node,
              [internalsSymbol]: {
                ...node[internalsSymbol],
                handleBounds: {
                  source: getHandleBounds(".source", update.nodeElement, zoom, nodeOrigin),
                  target: getHandleBounds(".target", update.nodeElement, zoom, nodeOrigin)
                }
              },
              ...dimensions
            });
            res.push({
              id: node.id,
              type: "dimensions",
              dimensions
            });
          }
        }
        return res;
      }, []);
      updateAbsoluteNodePositions(nodeInternals, nodeOrigin);
      const nextFitViewOnInitDone = fitViewOnInitDone || fitViewOnInit && !fitViewOnInitDone && fitView(get3, { initial: true, ...fitViewOnInitOptions });
      set3({ nodeInternals: new Map(nodeInternals), fitViewOnInitDone: nextFitViewOnInitDone });
      if (changes?.length > 0) {
        onNodesChange?.(changes);
      }
    },
    updateNodePositions: (nodeDragItems, positionChanged = true, dragging = false) => {
      const { triggerNodeChanges } = get3();
      const changes = nodeDragItems.map((node) => {
        const change = {
          id: node.id,
          type: "position",
          dragging
        };
        if (positionChanged) {
          change.positionAbsolute = node.positionAbsolute;
          change.position = node.position;
        }
        return change;
      });
      triggerNodeChanges(changes);
    },
    triggerNodeChanges: (changes) => {
      const { onNodesChange, nodeInternals, hasDefaultNodes, nodeOrigin, getNodes, elevateNodesOnSelect } = get3();
      if (changes?.length) {
        if (hasDefaultNodes) {
          const nodes = applyNodeChanges(changes, getNodes());
          const nextNodeInternals = createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect);
          set3({ nodeInternals: nextNodeInternals });
        }
        onNodesChange?.(changes);
      }
    },
    addSelectedNodes: (selectedNodeIds) => {
      const { multiSelectionActive, edges, getNodes } = get3();
      let changedNodes;
      let changedEdges = null;
      if (multiSelectionActive) {
        changedNodes = selectedNodeIds.map((nodeId) => createSelectionChange(nodeId, true));
      } else {
        changedNodes = getSelectionChanges(getNodes(), selectedNodeIds);
        changedEdges = getSelectionChanges(edges, []);
      }
      updateNodesAndEdgesSelections({
        changedNodes,
        changedEdges,
        get: get3,
        set: set3
      });
    },
    addSelectedEdges: (selectedEdgeIds) => {
      const { multiSelectionActive, edges, getNodes } = get3();
      let changedEdges;
      let changedNodes = null;
      if (multiSelectionActive) {
        changedEdges = selectedEdgeIds.map((edgeId) => createSelectionChange(edgeId, true));
      } else {
        changedEdges = getSelectionChanges(edges, selectedEdgeIds);
        changedNodes = getSelectionChanges(getNodes(), []);
      }
      updateNodesAndEdgesSelections({
        changedNodes,
        changedEdges,
        get: get3,
        set: set3
      });
    },
    unselectNodesAndEdges: ({ nodes, edges } = {}) => {
      const { edges: storeEdges, getNodes } = get3();
      const nodesToUnselect = nodes ? nodes : getNodes();
      const edgesToUnselect = edges ? edges : storeEdges;
      const changedNodes = nodesToUnselect.map((n2) => {
        n2.selected = false;
        return createSelectionChange(n2.id, false);
      });
      const changedEdges = edgesToUnselect.map((edge) => createSelectionChange(edge.id, false));
      updateNodesAndEdgesSelections({
        changedNodes,
        changedEdges,
        get: get3,
        set: set3
      });
    },
    setMinZoom: (minZoom) => {
      const { d3Zoom, maxZoom } = get3();
      d3Zoom?.scaleExtent([minZoom, maxZoom]);
      set3({ minZoom });
    },
    setMaxZoom: (maxZoom) => {
      const { d3Zoom, minZoom } = get3();
      d3Zoom?.scaleExtent([minZoom, maxZoom]);
      set3({ maxZoom });
    },
    setTranslateExtent: (translateExtent) => {
      get3().d3Zoom?.translateExtent(translateExtent);
      set3({ translateExtent });
    },
    resetSelectedElements: () => {
      const { edges, getNodes } = get3();
      const nodes = getNodes();
      const nodesToUnselect = nodes.filter((e2) => e2.selected).map((n2) => createSelectionChange(n2.id, false));
      const edgesToUnselect = edges.filter((e2) => e2.selected).map((e2) => createSelectionChange(e2.id, false));
      updateNodesAndEdgesSelections({
        changedNodes: nodesToUnselect,
        changedEdges: edgesToUnselect,
        get: get3,
        set: set3
      });
    },
    setNodeExtent: (nodeExtent) => {
      const { nodeInternals } = get3();
      nodeInternals.forEach((node) => {
        node.positionAbsolute = clampPosition(node.position, nodeExtent);
      });
      set3({
        nodeExtent,
        nodeInternals: new Map(nodeInternals)
      });
    },
    panBy: (delta) => {
      const { transform: transform2, width, height: height2, d3Zoom, d3Selection, translateExtent } = get3();
      if (!d3Zoom || !d3Selection || !delta.x && !delta.y) {
        return false;
      }
      const nextTransform = identity3.translate(transform2[0] + delta.x, transform2[1] + delta.y).scale(transform2[2]);
      const extent = [
        [0, 0],
        [width, height2]
      ];
      const constrainedTransform = d3Zoom?.constrain()(nextTransform, extent, translateExtent);
      d3Zoom.transform(d3Selection, constrainedTransform);
      const transformChanged = transform2[0] !== constrainedTransform.x || transform2[1] !== constrainedTransform.y || transform2[2] !== constrainedTransform.k;
      return transformChanged;
    },
    cancelConnection: () => set3({
      connectionNodeId: initialState.connectionNodeId,
      connectionHandleId: initialState.connectionHandleId,
      connectionHandleType: initialState.connectionHandleType,
      connectionStatus: initialState.connectionStatus,
      connectionStartHandle: initialState.connectionStartHandle,
      connectionEndHandle: initialState.connectionEndHandle
    }),
    reset: () => set3({ ...initialState })
  }), Object.is);
  var ReactFlowProvider = ({ children: children3 }) => {
    const storeRef = (0, import_react2.useRef)(null);
    if (!storeRef.current) {
      storeRef.current = createRFStore();
    }
    return import_react2.default.createElement(Provider$1, { value: storeRef.current }, children3);
  };
  ReactFlowProvider.displayName = "ReactFlowProvider";
  var Wrapper = ({ children: children3 }) => {
    const isWrapped = (0, import_react2.useContext)(StoreContext);
    if (isWrapped) {
      return import_react2.default.createElement(import_react2.default.Fragment, null, children3);
    }
    return import_react2.default.createElement(ReactFlowProvider, null, children3);
  };
  Wrapper.displayName = "ReactFlowWrapper";
  var defaultNodeTypes = {
    input: InputNode$1,
    default: DefaultNode$1,
    output: OutputNode$1,
    group: GroupNode
  };
  var defaultEdgeTypes = {
    default: BezierEdge,
    straight: StraightEdge,
    step: StepEdge,
    smoothstep: SmoothStepEdge,
    simplebezier: SimpleBezierEdge
  };
  var initNodeOrigin = [0, 0];
  var initSnapGrid = [15, 15];
  var initDefaultViewport = { x: 0, y: 0, zoom: 1 };
  var wrapperStyle = {
    width: "100%",
    height: "100%",
    overflow: "hidden",
    position: "relative",
    zIndex: 0
  };
  var ReactFlow = (0, import_react2.forwardRef)(({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes = defaultNodeTypes, edgeTypes = defaultEdgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionMode = ConnectionMode.Strict, connectionLineType = ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = "Backspace", selectionKeyCode = "Shift", selectionOnDrag = false, selectionMode = SelectionMode.Full, panActivationKeyCode = "Space", multiSelectionKeyCode = isMacOs() ? "Meta" : "Control", zoomActivationKeyCode = isMacOs() ? "Meta" : "Control", snapToGrid = false, snapGrid = initSnapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag = true, nodesDraggable, nodesConnectable, nodesFocusable, nodeOrigin = initNodeOrigin, edgesFocusable, edgesUpdatable, elementsSelectable, defaultViewport = initDefaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = "#b1b1b7", zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, children: children3, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeUpdate, onEdgeUpdateStart, onEdgeUpdateEnd, onReconnect, onReconnectStart, onReconnectEnd, reconnectRadius = 10, edgeUpdaterRadius = 10, onNodesChange, onEdgesChange, noDragClassName = "nodrag", noWheelClassName = "nowheel", noPanClassName = "nopan", fitView: fitView2 = false, fitViewOptions, connectOnClick = true, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect = true, elevateEdgesOnSelect = false, disableKeyboardA11y = false, autoPanOnConnect = true, autoPanOnNodeDrag = true, connectionRadius = 20, isValidConnection, onError, style: style2, id: id2, nodeDragThreshold, ...rest }, ref) => {
    const rfId = id2 || "1";
    return import_react2.default.createElement(
      "div",
      { ...rest, style: { ...style2, ...wrapperStyle }, ref, className: cc(["react-flow", className]), "data-testid": "rf__wrapper", id: id2 },
      import_react2.default.createElement(
        Wrapper,
        null,
        import_react2.default.createElement(GraphView$1, { onInit, onMove, onMoveStart, onMoveEnd, onNodeClick, onEdgeClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, nodeTypes, edgeTypes, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, deleteKeyCode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, onlyRenderVisibleElements, selectNodesOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, zoomOnScroll, zoomOnPinch, zoomOnDoubleClick, panOnScroll, panOnScrollSpeed, panOnScrollMode, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onReconnect: onReconnect ?? onEdgeUpdate, onReconnectStart: onReconnectStart ?? onEdgeUpdateStart, onReconnectEnd: onReconnectEnd ?? onEdgeUpdateEnd, reconnectRadius: reconnectRadius ?? edgeUpdaterRadius, defaultMarkerColor, noDragClassName, noWheelClassName, noPanClassName, elevateEdgesOnSelect, rfId, disableKeyboardA11y, nodeOrigin, nodeExtent }),
        import_react2.default.createElement(StoreUpdater, { nodes, edges, defaultNodes, defaultEdges, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, nodesDraggable, nodesConnectable, nodesFocusable, edgesFocusable, edgesUpdatable, elementsSelectable, elevateNodesOnSelect, minZoom, maxZoom, nodeExtent, onNodesChange, onEdgesChange, snapToGrid, snapGrid, connectionMode, translateExtent, connectOnClick, defaultEdgeOptions, fitView: fitView2, fitViewOptions, onNodesDelete, onEdgesDelete, onNodeDragStart, onNodeDrag, onNodeDragStop, onSelectionDrag, onSelectionDragStart, onSelectionDragStop, noPanClassName, nodeOrigin, rfId, autoPanOnConnect, autoPanOnNodeDrag, onError, connectionRadius, isValidConnection, nodeDragThreshold }),
        import_react2.default.createElement(Wrapper$1, { onSelectionChange }),
        children3,
        import_react2.default.createElement(Attribution, { proOptions, position: attributionPosition }),
        import_react2.default.createElement(A11yDescriptions, { rfId, disableKeyboardA11y })
      )
    );
  });
  ReactFlow.displayName = "ReactFlow";
  var selector$1 = (s2) => s2.domNode?.querySelector(".react-flow__edgelabel-renderer");
  function EdgeLabelRenderer({ children: children3 }) {
    const edgeLabelRenderer = useStore(selector$1);
    if (!edgeLabelRenderer) {
      return null;
    }
    return (0, import_react_dom.createPortal)(children3, edgeLabelRenderer);
  }
  function createUseItemsState(applyChanges2) {
    return (initialItems) => {
      const [items, setItems] = (0, import_react2.useState)(initialItems);
      const onItemsChange = (0, import_react2.useCallback)((changes) => setItems((items2) => applyChanges2(changes, items2)), []);
      return [items, setItems, onItemsChange];
    };
  }
  var useNodesState = createUseItemsState(applyNodeChanges);
  var useEdgesState = createUseItemsState(applyEdgeChanges);

  // node_modules/@reactflow/controls/dist/esm/index.mjs
  var import_react3 = __toESM(require_react(), 1);
  function PlusIcon() {
    return import_react3.default.createElement(
      "svg",
      { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32" },
      import_react3.default.createElement("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" })
    );
  }
  function MinusIcon() {
    return import_react3.default.createElement(
      "svg",
      { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5" },
      import_react3.default.createElement("path", { d: "M0 0h32v4.2H0z" })
    );
  }
  function FitViewIcon() {
    return import_react3.default.createElement(
      "svg",
      { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30" },
      import_react3.default.createElement("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" })
    );
  }
  function LockIcon() {
    return import_react3.default.createElement(
      "svg",
      { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32" },
      import_react3.default.createElement("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" })
    );
  }
  function UnlockIcon() {
    return import_react3.default.createElement(
      "svg",
      { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32" },
      import_react3.default.createElement("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" })
    );
  }
  var ControlButton = ({ children: children3, className, ...rest }) => import_react3.default.createElement("button", { type: "button", className: cc(["react-flow__controls-button", className]), ...rest }, children3);
  ControlButton.displayName = "ControlButton";
  var selector = (s2) => ({
    isInteractive: s2.nodesDraggable || s2.nodesConnectable || s2.elementsSelectable,
    minZoomReached: s2.transform[2] <= s2.minZoom,
    maxZoomReached: s2.transform[2] >= s2.maxZoom
  });
  var Controls = ({ style: style2, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children: children3, position: position2 = "bottom-left" }) => {
    const store = useStoreApi();
    const [isVisible, setIsVisible] = (0, import_react3.useState)(false);
    const { isInteractive, minZoomReached, maxZoomReached } = useStore(selector, shallow$1);
    const { zoomIn, zoomOut, fitView: fitView2 } = useReactFlow();
    (0, import_react3.useEffect)(() => {
      setIsVisible(true);
    }, []);
    if (!isVisible) {
      return null;
    }
    const onZoomInHandler = () => {
      zoomIn();
      onZoomIn?.();
    };
    const onZoomOutHandler = () => {
      zoomOut();
      onZoomOut?.();
    };
    const onFitViewHandler = () => {
      fitView2(fitViewOptions);
      onFitView?.();
    };
    const onToggleInteractivity = () => {
      store.setState({
        nodesDraggable: !isInteractive,
        nodesConnectable: !isInteractive,
        elementsSelectable: !isInteractive
      });
      onInteractiveChange?.(!isInteractive);
    };
    return import_react3.default.createElement(
      Panel,
      { className: cc(["react-flow__controls", className]), position: position2, style: style2, "data-testid": "rf__controls" },
      showZoom && import_react3.default.createElement(
        import_react3.default.Fragment,
        null,
        import_react3.default.createElement(
          ControlButton,
          { onClick: onZoomInHandler, className: "react-flow__controls-zoomin", title: "zoom in", "aria-label": "zoom in", disabled: maxZoomReached },
          import_react3.default.createElement(PlusIcon, null)
        ),
        import_react3.default.createElement(
          ControlButton,
          { onClick: onZoomOutHandler, className: "react-flow__controls-zoomout", title: "zoom out", "aria-label": "zoom out", disabled: minZoomReached },
          import_react3.default.createElement(MinusIcon, null)
        )
      ),
      showFitView && import_react3.default.createElement(
        ControlButton,
        { className: "react-flow__controls-fitview", onClick: onFitViewHandler, title: "fit view", "aria-label": "fit view" },
        import_react3.default.createElement(FitViewIcon, null)
      ),
      showInteractive && import_react3.default.createElement(ControlButton, { className: "react-flow__controls-interactive", onClick: onToggleInteractivity, title: "toggle interactivity", "aria-label": "toggle interactivity" }, isInteractive ? import_react3.default.createElement(UnlockIcon, null) : import_react3.default.createElement(LockIcon, null)),
      children3
    );
  };
  Controls.displayName = "Controls";
  var Controls$1 = (0, import_react3.memo)(Controls);

  // node_modules/@reactflow/background/dist/esm/index.mjs
  var import_react4 = __toESM(require_react(), 1);
  var BackgroundVariant;
  (function(BackgroundVariant2) {
    BackgroundVariant2["Lines"] = "lines";
    BackgroundVariant2["Dots"] = "dots";
    BackgroundVariant2["Cross"] = "cross";
  })(BackgroundVariant || (BackgroundVariant = {}));
  function LinePattern({ color: color2, dimensions, lineWidth }) {
    return import_react4.default.createElement("path", { stroke: color2, strokeWidth: lineWidth, d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}` });
  }
  function DotPattern({ color: color2, radius }) {
    return import_react4.default.createElement("circle", { cx: radius, cy: radius, r: radius, fill: color2 });
  }
  var defaultColor = {
    [BackgroundVariant.Dots]: "#91919a",
    [BackgroundVariant.Lines]: "#eee",
    [BackgroundVariant.Cross]: "#e2e2e2"
  };
  var defaultSize = {
    [BackgroundVariant.Dots]: 1,
    [BackgroundVariant.Lines]: 1,
    [BackgroundVariant.Cross]: 6
  };
  var selector2 = (s2) => ({ transform: s2.transform, patternId: `pattern-${s2.rfId}` });
  function Background({
    id: id2,
    variant = BackgroundVariant.Dots,
    // only used for dots and cross
    gap = 20,
    // only used for lines and cross
    size,
    lineWidth = 1,
    offset = 2,
    color: color2,
    style: style2,
    className
  }) {
    const ref = (0, import_react4.useRef)(null);
    const { transform: transform2, patternId } = useStore(selector2, shallow$1);
    const patternColor = color2 || defaultColor[variant];
    const patternSize = size || defaultSize[variant];
    const isDots = variant === BackgroundVariant.Dots;
    const isCross = variant === BackgroundVariant.Cross;
    const gapXY = Array.isArray(gap) ? gap : [gap, gap];
    const scaledGap = [gapXY[0] * transform2[2] || 1, gapXY[1] * transform2[2] || 1];
    const scaledSize = patternSize * transform2[2];
    const patternDimensions = isCross ? [scaledSize, scaledSize] : scaledGap;
    const patternOffset = isDots ? [scaledSize / offset, scaledSize / offset] : [patternDimensions[0] / offset, patternDimensions[1] / offset];
    return import_react4.default.createElement(
      "svg",
      { className: cc(["react-flow__background", className]), style: {
        ...style2,
        position: "absolute",
        width: "100%",
        height: "100%",
        top: 0,
        left: 0
      }, ref, "data-testid": "rf__background" },
      import_react4.default.createElement("pattern", { id: patternId + id2, x: transform2[0] % scaledGap[0], y: transform2[1] % scaledGap[1], width: scaledGap[0], height: scaledGap[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${patternOffset[0]},-${patternOffset[1]})` }, isDots ? import_react4.default.createElement(DotPattern, { color: patternColor, radius: scaledSize / offset }) : import_react4.default.createElement(LinePattern, { dimensions: patternDimensions, color: patternColor, lineWidth })),
      import_react4.default.createElement("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${patternId + id2})` })
    );
  }
  Background.displayName = "Background";
  var Background$1 = (0, import_react4.memo)(Background);

  // node_modules/@reactflow/node-toolbar/dist/esm/index.mjs
  var import_react5 = __toESM(require_react(), 1);
  var import_react_dom2 = __toESM(require_react_dom(), 1);

  // ../insight-maker-simulation/src/formula/ModelError.js
  var ModelError = class extends Error {
    /**
     * @param {string} message
     * @param {{ source?: string, primitive?: import('../api/Blocks.js').Primitive|import('../Primitives').SPrimitive|GraphNode, showEditor?: boolean, line?: number, details?: string, code: number }} config
     */
    constructor(message, config) {
      super(message);
      this.name = "ModelError";
      this.primitive = config.primitive;
      this.showEditor = config.showEditor;
      this.source = config.source;
      this.line = config.line;
      this.details = config.details;
      this.code = config.code;
    }
  };

  // ../insight-maker-simulation/src/Utilities.js
  function isTrue(item) {
    return item === 1 || item === "true" || item === true;
  }
  function toHTML(str) {
    return str.replace(
      /[&<>'"]/g,
      (tag) => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&#39;",
        '"': "&quot;",
        "`": "&#96;"
      })[tag]
    );
  }
  function commaStr(nStr, sanitize = true) {
    if (typeof nStr === "string") {
      return sanitize ? toHTML(nStr) : nStr;
    }
    if (typeof nStr === "boolean") {
      return nStr.toString();
    }
    if (nStr === void 0 || nStr === null) {
      return "";
    }
    if (nStr >= 1e9 || nStr <= 1e-9 && nStr !== 0) {
      return nStr.toPrecision(3);
    } else {
      nStr = round(nStr, 9) + "";
      let x2 = nStr.split(".");
      let x1 = x2[0];
      let x22 = x2.length > 1 ? "." + x2[1] : "";
      let reg = /(\d+)(\d{3})/;
      while (reg.test(x1)) {
        x1 = x1.replace(reg, "$1,$2");
      }
      return x1 + x22;
    }
  }
  function round(value, precision = 15) {
    return +value.toPrecision(precision);
  }

  // ../insight-maker-simulation/src/api/Blocks.js
  var Primitive = class {
    /**
     * @param {import("../ModelNode").ModelNode} node
     * @param {PrimitiveConfig} config
     */
    constructor(node, config) {
      this._node = node;
      this.model = null;
      for (let key in config) {
        if (key in this) {
          this[key] = config[key];
        } else {
          throw new Error("Unknown property: " + key);
        }
      }
    }
    delete() {
      let connectors = this.model.find((node) => node instanceof Flow || node instanceof Transition2 || node instanceof Link);
      let x2 = this._node;
      if (x2.parent.children.includes(x2)) {
        x2.parent.children.splice(x2.parent.children.indexOf(x2), 1);
      }
      connectors.forEach((c2) => {
        if (c2._node.source === x2) {
          c2._node.source = null;
          if (c2._node.target && c2._node.target.parent !== c2._node.parent) {
            c2.parent = /** @type {Container} */
            c2._node.target.parent.primitive(this.model);
          }
        }
        if (c2._node.target === x2) {
          c2._node.target = null;
          if (c2._node.source && c2._node.source.parent !== c2._node.parent) {
            c2.parent = /** @type {Container} */
            c2._node.source.parent.primitive(this.model);
          }
        }
      });
    }
    /**
     * @return {Container}
     */
    get parent() {
      let p2 = this._node.parent;
      if (p2.value && p2.value.nodeName === "root" || p2.id === "1") {
        return null;
      } else {
        return (
          /** @type {Container} */
          p2.primitive(this.model)
        );
      }
    }
    /**
     * @param {Container} parent
     */
    set parent(parent) {
      let p2;
      if (parent === null) {
        p2 = this.model._graph.children[0].children[0];
      } else {
        p2 = parent._node;
      }
      if (this._node.parent.children.includes(this._node)) {
        this._node.parent.children.splice(this._node.parent.children.indexOf(this._node), 1);
      }
      p2.addChild(this._node);
    }
    /**
     * @param {function(Container):boolean} selector
     *
     * @returns {Container}
     */
    getParent(selector3) {
      let parent = this.parent;
      if (!parent) {
        return null;
      }
      if (selector3(parent)) {
        return parent;
      }
      return parent.getParent(selector3);
    }
    isInAgent() {
      return !!this.getParent((x2) => x2 instanceof Agent);
    }
    neighbors() {
      let neighbors = [];
      let flows = this.model.findFlows();
      let links = this.model.findLinks();
      if (this instanceof Flow || this instanceof Link || this instanceof Transition2) {
        if (this.start) {
          neighbors.push({
            item: this.start,
            type: "direct"
          });
        }
        if (this.end) {
          neighbors.push({
            item: this.end,
            type: "direct"
          });
        }
      }
      if (this instanceof Population) {
        if (this.agentBase) {
          neighbors = neighbors.concat(getAgentItems(this));
        }
      }
      if (this instanceof Stock) {
        for (let i2 = 0; i2 < flows.length; i2++) {
          if (flows[i2].start === this) {
            neighbors.push({
              item: flows[i2],
              type: "direct",
              linkHidden: true
            });
          }
          if (flows[i2].end === this) {
            neighbors.push({
              item: flows[i2],
              type: "direct",
              linkHidden: true
            });
          }
        }
      }
      for (let i2 = 0; i2 < links.length; i2++) {
        if (links[i2].start === this && links[i2].end) {
          let linkHidden = !links[i2].biDirectional;
          neighbors.push({
            item: links[i2].end,
            type: "direct",
            linkHidden
          });
          neighbors = neighbors.concat(getAgentItems(links[i2].end, linkHidden));
        }
        if (links[i2].end === this && links[i2].start && !(links[i2].start.isInAgent() && !this.isInAgent())) {
          neighbors.push({
            item: links[i2].start,
            type: "direct"
          });
          neighbors = neighbors.concat(getAgentItems(links[i2].start));
        }
      }
      neighbors = neighbors.filter((x2) => !!x2);
      let res = [];
      for (let i2 = 0; i2 < neighbors.length; i2++) {
        if (neighbors[i2].linkHidden) {
          continue;
        }
        let found = false;
        for (let j = 0; j < res.length; j++) {
          if (res[j].type === neighbors[i2].type && res[j].item.id === neighbors[i2].item.id) {
            found = true;
            if (res[j].linkHidden && !neighbors[i2].linkHidden) {
              res[j].linkHidden = false;
            }
            break;
          }
        }
        if (!found) {
          if (neighbors[i2].item instanceof ValuedPrimitive || neighbors[i2].item instanceof Population) {
            res.push(neighbors[i2]);
          }
        }
      }
      return res;
      function getAgentItems(agent2, linkHidden) {
        let res2 = [];
        if (agent2 instanceof Population && agent2.agentBase) {
          let items = agent2.agentBase.children();
          items.forEach((x2) => {
            if (x2 instanceof ValuedPrimitive) {
              res2.push({
                item: x2,
                type: "agent",
                linkHidden,
                name: x2.name
              });
            }
          });
        }
        res2.sort((a2, b2) => {
          if (a2.name === b2.name) {
            return 0;
          } else if (a2.name > b2.name) {
            return 1;
          } else {
            return -1;
          }
        });
        return res2;
      }
    }
    /**
     * @return {string}
     */
    get id() {
      return this._node.id;
    }
    /**
     * @return {PrimitiveConfig["name"]}
     */
    get name() {
      return this._node.getAttribute("name");
    }
    /**
     * @param {PrimitiveConfig["name"]} value
     */
    set name(value) {
      this._node.setAttribute("name", value);
    }
    /**
     * @return {PrimitiveConfig["note"]}
     */
    get note() {
      return this._node.getAttribute("Note");
    }
    /**
     * @param {PrimitiveConfig["note"]} value
     */
    set note(value) {
      this._node.setAttribute("Note", value);
    }
  };
  var ValuedPrimitive = class extends Primitive {
    /**
     * @return {ValuedConfig["units"]}
     */
    get units() {
      return this._node.getAttribute("Units");
    }
    /**
     * @param {ValuedConfig["units"]} value
     */
    set units(value) {
      this._node.setAttribute("Units", value);
    }
    /**
     * @return {ValuedConfig["constraints"]}
     */
    get constraints() {
      let res = {};
      if (isTrue(this._node.getAttribute("MinConstraintUsed"))) {
        res.min = +this._node.getAttribute("MinConstraint");
      }
      if (isTrue(this._node.getAttribute("MaxConstraintUsed"))) {
        res.max = +this._node.getAttribute("MaxConstraint");
      }
      return res;
    }
    /**
     * @param {ValuedConfig["constraints"]} constraints
     */
    set constraints(constraints) {
      this._node.setAttribute("MinConstraint", constraints.min);
      this._node.setAttribute("MinConstraintUsed", "min" in constraints);
      this._node.setAttribute("MaxConstraint", constraints.max);
      this._node.setAttribute("MaxConstraintUsed", "max" in constraints);
    }
    /**
     * @return {ValuedConfig["external"]}
     */
    get external() {
      return isTrue(this._node.getAttribute("ShowSlider"));
    }
    /**
     * @param {ValuedConfig["external"]} value
     */
    set external(value) {
      this._node.setAttribute("ShowSlider", value);
    }
  };
  var Stock = class extends ValuedPrimitive {
    /**
     * @return {string}
     */
    get initial() {
      return this._node.getAttribute("InitialValue") || "";
    }
    /**
     * @param {StockConfig["initial"]} value
     */
    set initial(value) {
      this._node.setAttribute("InitialValue", "" + value);
    }
    /**
     * @return {StockConfig["type"]}
     */
    get type() {
      return (
        /** @type {any} */
        this._node.getAttribute("StockMode")
      );
    }
    /**
     * @param {StockConfig["type"]} value
     */
    set type(value) {
      this._node.setAttribute("StockMode", "" + value);
    }
    /**
     * @return {string}
     */
    get delay() {
      return this._node.getAttribute("Delay");
    }
    /**
     * @param {StockConfig["delay"]} value
     */
    set delay(value) {
      this._node.setAttribute("Delay", "" + value);
    }
    /**
     * @return {StockConfig["nonNegative"]}
     */
    get nonNegative() {
      return isTrue(this._node.getAttribute("NonNegative"));
    }
    /**
     * @param {StockConfig["nonNegative"]} value
     */
    set nonNegative(value) {
      this._node.setAttribute("NonNegative", value);
    }
  };
  var Variable = class extends ValuedPrimitive {
    /**
     * @return {string}
     */
    get value() {
      return this._node.getAttribute("Equation") || "";
    }
    /**
     * @param {VariableConfig["value"]} value
     */
    set value(value) {
      this._node.setAttribute("Equation", "" + value);
    }
  };
  var Converter = class extends ValuedPrimitive {
    /**
     * @return {ConverterConfig["interpolation"]}
     */
    get interpolation() {
      return (
        /** @type {any} */
        this._node.getAttribute("Interpolation")
      );
    }
    /**
     * @param {ConverterConfig["interpolation"]} value
     */
    set interpolation(value) {
      this._node.setAttribute("Interpolation", value);
    }
    /**
     * @return {ConverterConfig["values"]}
     */
    get values() {
      return this._node.getAttribute("Data").split(";").map((row2) => {
        let parts = row2.split(",");
        if (parts.length !== 2) {
          throw new ModelError(`Converter data point should have the form "x, y", got "${row2}"`, {
            primitive: this,
            code: 2100
          });
        }
        let res = {
          x: +parts[0],
          y: +parts[1]
        };
        if (isNaN(res.x) || isNaN(res.y)) {
          throw new ModelError(`Converter has invalid data "${row2}"`, {
            primitive: this,
            showEditor: true,
            code: 2101
          });
        }
        return res;
      });
    }
    /**
     * @param {ConverterConfig["values"]} value
     */
    set values(value) {
      this._node.setAttribute("Data", value.map((x2) => x2.x + "," + x2.y).join(";"));
    }
    /**
     * @return {ConverterConfig["input"]}
     */
    get input() {
      let v2 = this._node.getAttribute("Source");
      if (v2 === "Time") {
        return v2;
      }
      let p2 = null;
      try {
        p2 = this.model.getId(v2);
      } catch (_err) {
      }
      return (
        /** @type {ValuedPrimitive} */
        p2
      );
    }
    /**
     * @param {ConverterConfig["input"]} value
     */
    set input(value) {
      this._node.setAttribute("Source", value === "Time" ? value : value.id);
    }
  };
  var Flow = class extends ValuedPrimitive {
    /**
     * @return {string}
     */
    get rate() {
      return this._node.getAttribute("FlowRate") || "";
    }
    /**
     * @param {FlowConfig["rate"]} value
     */
    set rate(value) {
      this._node.setAttribute("FlowRate", "" + value);
    }
    /**
     * @return {FlowConfig["start"]}
     */
    get start() {
      return (
        /** @type {Stock} */
        this._node.source ? this._node.source.primitive(this.model) : null
      );
    }
    /**
     * @param {FlowConfig["start"]} node
     */
    set start(node) {
      this._node.source = node._node;
    }
    /**
     * @return {FlowConfig["end"]}
     */
    get end() {
      return (
        /** @type {Stock} */
        this._node.target ? this._node.target.primitive(this.model) : null
      );
    }
    /**
     * @param {FlowConfig["end"]} node
     */
    set end(node) {
      this._node.target = node._node;
    }
    /**
     * @return {FlowConfig["nonNegative"]}
     */
    get nonNegative() {
      return isTrue(this._node.getAttribute("OnlyPositive"));
    }
    /**
     * @param {FlowConfig["nonNegative"]} value
     */
    set nonNegative(value) {
      this._node.setAttribute("OnlyPositive", value);
    }
  };
  var Link = class extends Primitive {
    /**
     * @return {LinkConfig["biDirectional"]}
     */
    get biDirectional() {
      return isTrue(this._node.getAttribute("BiDirectional"));
    }
    /**
     * @param {LinkConfig["biDirectional"]} value
     */
    set biDirectional(value) {
      this._node.setAttribute("BiDirectional", value);
    }
    /**
     * @return {LinkConfig["start"]}
     */
    get start() {
      return this._node.source ? this._node.source.primitive(this.model) : null;
    }
    /**
     * @param {LinkConfig["start"]} node
     */
    set start(node) {
      this._node.source = node._node;
    }
    /**
     * @return {LinkConfig["end"]}
     */
    get end() {
      return this._node.target ? this._node.target.primitive(this.model) : null;
    }
    /**
     * @param {LinkConfig["end"]} node
     */
    set end(node) {
      this._node.target = node._node;
    }
  };
  var State = class extends ValuedPrimitive {
    /**
     * @return {StateConfig["startActive"]}
     */
    get startActive() {
      return this._node.getAttribute("Active");
    }
    /**
     * @param {StateConfig["startActive"]} value
     */
    set startActive(value) {
      this._node.setAttribute("Active", value);
    }
    /**
     * @return {string}
     */
    get residency() {
      return this._node.getAttribute("Residency");
    }
    /**
     * @param {StateConfig["residency"]} value
     */
    set residency(value) {
      this._node.setAttribute("Residency", value);
    }
  };
  var Transition2 = class extends ValuedPrimitive {
    /**
     * @return {TransitionConfig["value"]}
     */
    get value() {
      return this._node.getAttribute("Value") || "";
    }
    /**
     * @param {TransitionConfig["value"]} value
     */
    set value(value) {
      this._node.setAttribute("Value", "" + value);
    }
    /**
     * @return {TransitionConfig["start"]}
     */
    get start() {
      return (
        /** @type {State} */
        this._node.source ? this._node.source.primitive(this.model) : null
      );
    }
    /**
     * @param {TransitionConfig["start"]} node
     */
    set start(node) {
      this._node.source = node._node;
    }
    /**
     * @return {TransitionConfig["end"]}
     */
    get end() {
      return (
        /** @type {State} */
        this._node.target ? this._node.target.primitive(this.model) : null
      );
    }
    /**
     * @param {TransitionConfig["end"]} node
     */
    set end(node) {
      this._node.target = node._node;
    }
    /**
     * @return {TransitionConfig["recalculate"]}
     */
    get recalculate() {
      return isTrue(this._node.getAttribute("Recalculate"));
    }
    /**
     * @param {TransitionConfig["recalculate"]} value
     */
    set recalculate(value) {
      this._node.setAttribute("Recalculate", value);
    }
    /**
     * @return {TransitionConfig["repeat"]}
     */
    get repeat() {
      return isTrue(this._node.getAttribute("Repeat"));
    }
    /**
     * @param {TransitionConfig["repeat"]} value
     */
    set repeat(value) {
      this._node.setAttribute("Repeat", value);
    }
    /**
     * @return {TransitionConfig["trigger"]}
     */
    get trigger() {
      return (
        /** @type {any} */
        this._node.getAttribute("Trigger")
      );
    }
    /**
     * @param {TransitionConfig["trigger"]} value
     */
    set trigger(value) {
      this._node.setAttribute("Trigger", value);
    }
  };
  var Action = class extends Primitive {
    /**
     * @return {string}
     */
    get value() {
      return this._node.getAttribute("Value") || "";
    }
    /**
     * @param {ActionConfig["value"]} value
     */
    set value(value) {
      this._node.setAttribute("Value", "" + value);
    }
    /**
     * @return {ActionConfig["action"]}
     */
    get action() {
      return this._node.getAttribute("Action");
    }
    /**
       * @param {ActionConfig["action"]} value
       */
    set action(value) {
      this._node.setAttribute("Action", "" + value);
    }
    /**
     * @return {ActionConfig["recalculate"]}
     */
    get recalculate() {
      return isTrue(this._node.getAttribute("Recalculate"));
    }
    /**
     * @param {ActionConfig["recalculate"]} value
     */
    set recalculate(value) {
      this._node.setAttribute("Recalculate", value);
    }
    /**
     * @return {ActionConfig["repeat"]}
     */
    get repeat() {
      return isTrue(this._node.getAttribute("Repeat"));
    }
    /**
     * @param {ActionConfig["repeat"]} value
     */
    set repeat(value) {
      this._node.setAttribute("Repeat", value);
    }
    /**
     * @return {ActionConfig["trigger"]}
     */
    get trigger() {
      return (
        /** @type {any} */
        this._node.getAttribute("Trigger")
      );
    }
    /**
     * @param {ActionConfig["trigger"]} value
     */
    set trigger(value) {
      this._node.setAttribute("Trigger", value);
    }
  };
  var Population = class extends Primitive {
    /**
     * @return {PopulationConfig["agentBase"]}
     */
    get agentBase() {
      let targetId = this._node.getAttribute("Agent");
      if (!targetId) {
        return null;
      }
      let base = null;
      try {
        base = this.model.getId(targetId);
      } catch (_err) {
      }
      return (
        /** @type {Agent} */
        base
      );
    }
    /**
     * @param {PopulationConfig["agentBase"]} value
     */
    set agentBase(value) {
      this._node.setAttribute("Agent", value.id);
    }
    /**
     * @return {PopulationConfig["populationSize"]}
     */
    get populationSize() {
      return +this._node.getAttribute("Size");
    }
    /**
     * @param {PopulationConfig["populationSize"]} value
     */
    set populationSize(value) {
      this._node.setAttribute("Size", value);
    }
    /**
     * @return {PopulationConfig["geoUnits"]}
     */
    get geoUnits() {
      return this._node.getAttribute("GeoDimUnits");
    }
    /**
     * @param {PopulationConfig["geoUnits"]} value
     */
    set geoUnits(value) {
      this._node.setAttribute("GeoDimUnits", value);
    }
    /**
     * @return {string}
     */
    get geoWidth() {
      return this._node.getAttribute("GeoWidth");
    }
    /**
     * @param {PopulationConfig["geoWidth"]} value
     */
    set geoWidth(value) {
      this._node.setAttribute("GeoWidth", value);
    }
    /**
     * @return {string}
     */
    get geoHeight() {
      return this._node.getAttribute("GeoHeight");
    }
    /**
     * @param {PopulationConfig["geoHeight"]} value
     */
    set geoHeight(value) {
      this._node.setAttribute("GeoHeight", value);
    }
    /**
     * @return {PopulationConfig["geoWrapAround"]}
     */
    get geoWrapAround() {
      return isTrue(this._node.getAttribute("GeoWrap"));
    }
    /**
     * @param {PopulationConfig["geoWrapAround"]} value
     */
    set geoWrapAround(value) {
      this._node.setAttribute("GeoWrap", value);
    }
    /**
     * @return {PopulationConfig["geoPlacementType"]}
     */
    get geoPlacementType() {
      return (
        /** @type {any} */
        this._node.getAttribute("Placement")
      );
    }
    /**
     * @param {PopulationConfig["geoPlacementType"]} value
     */
    set geoPlacementType(value) {
      this._node.setAttribute("Placement", value);
    }
    /**
     * @return {PopulationConfig["geoPlacementFunction"]}
     */
    get geoPlacementFunction() {
      return this._node.getAttribute("PlacementFunction");
    }
    /**
     * @param {PopulationConfig["geoPlacementFunction"]} value
     */
    set geoPlacementFunction(value) {
      this._node.setAttribute("PlacementFunction", value);
    }
    /**
     * @return {PopulationConfig["networkType"]}
     */
    get networkType() {
      return (
        /** @type {any} */
        this._node.getAttribute("Network")
      );
    }
    /**
     * @param {PopulationConfig["networkType"]} value
     */
    set networkType(value) {
      this._node.setAttribute("Network", value);
    }
    /**
     * @return {PopulationConfig["networkFunction"]}
     */
    get networkFunction() {
      return this._node.getAttribute("NetworkFunction");
    }
    /**
     * @param {PopulationConfig["networkFunction"]} value
     */
    set networkFunction(value) {
      this._node.setAttribute("NetworkFunction", value);
    }
  };
  var Container = class _Container extends Primitive {
    children(recursive = true) {
      let children3 = this._node.children ? this._node.children.map((x2) => x2.primitive(this.model)) : [];
      if (recursive) {
        let childrenLength = children3.length;
        for (let i2 = 0; i2 < childrenLength; i2++) {
          let child = children3[i2];
          if (child instanceof _Container) {
            children3 = children3.concat(child.children(recursive));
          }
        }
      }
      return children3;
    }
    /**
     * @param {PrimitiveConfig & ValuedConfig & StockConfig} config
     */
    Stock(config = {}) {
      let stock = this.model.Stock(config);
      stock.parent = this;
      return stock;
    }
    /**
     * @param {PrimitiveConfig & ValuedConfig & VariableConfig} config
     */
    Variable(config = {}) {
      let variable = this.model.Variable(config);
      variable.parent = this;
      return variable;
    }
    /**
     * @param {PrimitiveConfig & ValuedConfig & ConverterConfig} config
     */
    Converter(config = {}) {
      let converter = this.model.Converter(config);
      converter.parent = this;
      return converter;
    }
    /**
     * @param {PrimitiveConfig & StateConfig} config
     */
    State(config = {}) {
      let state = this.model.State(config);
      state.parent = this;
      return state;
    }
    /**
     * @param {PrimitiveConfig & ActionConfig} config
     */
    Action(config = {}) {
      let action = this.model.Action(config);
      action.parent = this;
      return action;
    }
    /**
     * @param {PrimitiveConfig & PopulationConfig} config
     */
    Population(config = {}) {
      let population = this.model.Population(config);
      population.parent = this;
      return population;
    }
    /**
     * @param {Stock | null} start
     * @param {Stock | null} end
     * @param {(PrimitiveConfig & ValuedConfig & FlowConfig)=} config
     */
    Flow(start2, end, config = {}) {
      let flow = this.model.Flow(start2, end, config);
      flow.parent = this;
      return flow;
    }
    /**
     * @param {State | null} start
     * @param {State | null} end
     * @param {(PrimitiveConfig & TransitionConfig)=} config
     */
    Transition(start2, end, config = {}) {
      let transition2 = this.model.Transition(start2, end, config);
      transition2.parent = this;
      return transition2;
    }
    /**
     * @param {Primitive | null} start
     * @param {Primitive | null} end
     * @param {(PrimitiveConfig & LinkConfig)=} config
     */
    Link(start2, end, config = {}) {
      let link = this.model.Link(start2, end, config);
      link.parent = this;
      return link;
    }
    /**
     * @return {ContainerConfig["frozen"]}
     */
    get frozen() {
      return isTrue(this._node.getAttribute("Frozen"));
    }
    /**
     * @param {ContainerConfig["frozen"]} value
     */
    set frozen(value) {
      this._node.setAttribute("Frozen", value);
    }
    /**
     * @return {ContainerConfig["customTimeSettings"]}
     */
    get customTimeSettings() {
      let value = JSON.parse(this._node.getAttribute("Solver") || "{}");
      if (value.algorithm === "RK1") {
        value.algorithm = "Euler";
      }
      return value;
    }
    /**
     * @param {ContainerConfig["customTimeSettings"]} value
     */
    set customTimeSettings(value) {
      let newValue = Object.assign({}, value);
      if (newValue.algorithm === "Euler") {
        newValue.algorithm = "RK1";
      }
      this._node.setAttribute("Solver", JSON.stringify(newValue));
    }
  };
  var Folder = class extends Container {
  };
  var Agent = class extends Container {
    /**
     * @return {AgentConfig["agentParent"]}
     */
    get agentParent() {
      return this._node.getAttribute("AgentBase");
    }
    /**
     * @param {AgentConfig["agentParent"]} value
     */
    set agentParent(value) {
      this._node.setAttribute("AgentBase", value);
    }
  };

  // ../insight-maker-simulation/src/ModelNode.js
  function modelNodeClone(node, parent) {
    let obj = new ModelNode();
    obj.value = node.cloneNode(true);
    obj.parent = parent;
    let currIds = ["1"].concat(primitives(findRootParent(parent)).map((x2) => x2.id).filter((x2) => !!x2));
    if (node.attributes.length > 0) {
      for (let j = 0; j < node.attributes.length; j++) {
        let attribute = node.attributes.item(j);
        obj.setAttribute(attribute.nodeName, attribute.nodeValue);
      }
    }
    obj.setAttribute("id", "" + (Math.max.apply(null, currIds) + 1));
    return obj;
  }
  function findRootParent(node) {
    if (node.parent) {
      return findRootParent(node.parent);
    }
    return node;
  }
  var ModelNode = class {
    constructor() {
      this.attributes = /* @__PURE__ */ new Map();
      this.parent = null;
      this.children = [];
      this.id = null;
      this.value = { nodeName: null };
      this._primitive = void 0;
      this.source = null;
      this.target = null;
      this.geometry = {
        x: 0,
        y: 0,
        width: 40,
        height: 100,
        sourcePoint: null,
        targetPoint: null
      };
      this.style = null;
    }
    /**
     * @param {import("./api/Model").Model} model
     * @param {*} config
     * @returns {Primitive}
     */
    primitive(model, config = {}) {
      if (this._primitive === void 0) {
        if (this.value.nodeName === "Stock") {
          this._primitive = new Stock(this, config);
        } else if (this.value.nodeName === "Variable") {
          this._primitive = new Variable(this, config);
        } else if (this.value.nodeName === "Converter") {
          this._primitive = new Converter(this, config);
        } else if (this.value.nodeName === "State") {
          this._primitive = new State(this, config);
        } else if (this.value.nodeName === "Action") {
          this._primitive = new Action(this, config);
        } else if (this.value.nodeName === "Agents") {
          this._primitive = new Population(this, config);
        } else if (this.value.nodeName === "Flow") {
          this._primitive = new Flow(this, config);
        } else if (this.value.nodeName === "Transition") {
          this._primitive = new Transition2(this, config);
        } else if (this.value.nodeName === "Link") {
          this._primitive = new Link(this, config);
        } else if (this.value.nodeName === "Folder") {
          if (this.getAttribute("Type") === "Agent") {
            this._primitive = new Agent(this, config);
          } else {
            this._primitive = new Folder(this, config);
          }
        } else {
          this._primitive = null;
        }
        if (this._primitive && !this._primitive.model) {
          this._primitive.model = model;
        }
      }
      return this._primitive;
    }
    /**
     * @param {ModelNode} newChild
     */
    addChild(newChild) {
      if (newChild.parent) {
        let index = newChild.parent.children.indexOf(newChild);
        if (index > -1) {
          newChild.parent.children.splice(index, 1);
        }
      }
      this.children.push(newChild);
      newChild.parent = this;
    }
    /**
     * @param {string} x
     * @returns {string}
     */
    getAttribute(x2) {
      if (x2 === "id") {
        return this.id;
      }
      return this.attributes.get(x2);
    }
    setAttribute(x2, value) {
      if (x2 === "id") {
        this.id = "" + value;
        return;
      }
      this.attributes.set(x2, "" + value);
    }
    getValue() {
      return {
        removeAttribute: (name) => this.attributes.delete(name)
      };
    }
    toString(indent = 0) {
      let start2 = " ".repeat(indent) + `<${this.value.nodeName}${this.getAttribute("name") ? " [" + this.getAttribute("name") + "]" : ""}>`;
      let end = `</${this.value.nodeName}>`;
      return start2 + (this.children.length ? "\n" : "") + this.children.map((child) => " ".repeat(indent) + child.toString(indent + 2)).join("\n") + (this.children.length ? "\n" + " ".repeat(indent) : "") + end;
    }
  };
  function primitives(root2, type) {
    let myNodes = nodeChildren(root2.children[0]);
    if (!type) {
      return myNodes;
    } else {
      let targetNodes = [];
      for (let node of myNodes) {
        if (Array.isArray(type) ? type.includes(node.value.nodeName) : node.value.nodeName === type) {
          targetNodes.push(node);
        }
      }
      return targetNodes;
    }
  }
  function nodeChildren(node) {
    let children3 = node.children.slice();
    let childrenLength = children3.length;
    for (let i2 = 0; i2 < childrenLength; i2++) {
      let child = children3[i2];
      children3 = children3.concat(nodeChildren(child));
    }
    return children3;
  }

  // ../insight-maker-simulation/src/CalcMap.js
  var fn = {
    /**
     * @param {number} a
     * @param {number} b
     * @returns 
     */
    "+": function(a2, b2) {
      return a2 + b2;
    },
    /**
     * @param {number} a 
     * @param {number=} b 
     * @returns 
     */
    "-": function(a2, b2) {
      if (b2 !== void 0) {
        return a2 - b2;
      } else {
        return -a2;
      }
    },
    /**
     * @param {number} a 
     * @param {number} b 
     * @returns 
     */
    "*": function(a2, b2) {
      return a2 * b2;
    },
    /**
     * @param {number} a 
     * @param {number} b 
     * @returns 
     */
    "/": function(a2, b2) {
      return a2 / b2;
    },
    "=": function(a2, b2) {
      return a2 === b2;
    },
    /**
     * @param {number} a 
     * @param {number} b 
     * @returns 
     */
    "<": function(a2, b2) {
      return a2 < b2;
    },
    /**
     * @param {number} a 
     * @param {number} b 
     * @returns 
     */
    "<=": function(a2, b2) {
      return a2 <= b2;
    },
    /**
     * @param {number} a 
     * @param {number} b 
     * @returns 
     */
    ">": function(a2, b2) {
      return a2 > b2;
    },
    /**
     * @param {number} a 
     * @param {number} b 
     * @returns 
     */
    ">=": function(a2, b2) {
      return a2 >= b2;
    },
    /**
     * @param {number} a 
     * @param {number} b 
     * @returns 
     */
    "mod": function(a2, b2) {
      return a2 % b2;
    },
    /**
     * @param {number} a 
     * @param {number} b 
     * @returns 
     */
    "expt": function(a2, b2) {
      return Math.pow(a2, b2);
    },
    "abs": Math.abs,
    "sin": Math.sin,
    "asin": Math.asin,
    "cos": Math.cos,
    "acos": Math.acos,
    "tan": Math.tan,
    "atan": Math.atan,
    "sqrt": Math.sqrt,
    /**
     * @param {number} a 
     * @param {number=} b 
     * @returns 
     */
    "log": function(a2, b2) {
      if (b2 !== void 0) {
        return Math.log(a2) / Math.log(b2);
      } else {
        return Math.log(a2);
      }
    },
    "exp": Math.exp,
    "round": Math.round,
    "floor": Math.floor,
    "ceiling": Math.ceil
  };

  // ../insight-maker-simulation/src/formula/Units.js
  function sortAndCollapseUnits(names, exponents) {
    if (names.length <= 1) {
      if (names.length === 1) {
        names[0] = names[0].toLowerCase();
      }
    } else {
      let sorter = [];
      for (let i2 = 0; i2 < names.length; i2++) {
        sorter.push({
          name: names[i2].toLowerCase(),
          exponent: exponents[i2]
        });
      }
      sorter.sort((a2, b2) => {
        return a2.name.localeCompare(b2.name);
      });
      names = [];
      exponents = [];
      for (let i2 = 0; i2 < sorter.length; i2++) {
        names.push(sorter[i2].name);
        exponents.push(sorter[i2].exponent);
      }
      for (let i2 = 0; i2 < names.length; i2++) {
        for (let j = i2 + 1; j < names.length; j++) {
          if (names[i2] === names[j]) {
            exponents[i2] = exponents[i2] + exponents[j];
            names.splice(j, 1);
            exponents.splice(j, 1);
            j--;
          }
        }
        if (exponents[i2] === 0) {
          names.splice(i2, 1);
          exponents.splice(i2, 1);
          i2--;
        }
      }
    }
    return { names, exponents };
  }
  function getUnitsId(names, exponents) {
    return names.join(",") + exponents.join(",");
  }
  var UnitStore = class {
    /**
     * @param {UnitManager} manager
     * @param {string[]} names
     * @param {number[]} exponents
     */
    constructor(manager, names, exponents) {
      this.manager = manager;
      this.names = names;
      this.exponents = exponents;
      this.toBase = null;
      this.baseUnits = null;
      this.multiples = /* @__PURE__ */ new Map();
      this.divisions = /* @__PURE__ */ new Map();
      this.id = getUnitsId(this.names, this.exponents);
    }
    isUnitless() {
      return !this.exponents.find((x2) => x2 !== 0);
    }
    /**
     * Also check if the units would simplify to unitless.
     * 
     * @returns 
     */
    isDeepUnitless() {
      if (this.isUnitless()) {
        return true;
      }
      this.addBase();
      return !this.baseUnits.exponents.find((x2) => x2 !== 0);
    }
    addBase() {
      if (this.toBase !== null) {
        return;
      }
      this.toBase = 1;
      let names = this.names.slice();
      let exponents = this.exponents.slice();
      let modified = true;
      while (modified) {
        modified = false;
        for (let i2 = names.length - 1; i2 >= 0; i2--) {
          let u2 = this.manager.findSource(names[i2]);
          if (u2 !== null && !(u2.target.names.length === 1 && u2.target.names[0] === names[i2])) {
            this.toBase = fn["*"](this.toBase, fn.expt(u2.scale, exponents[i2]));
            names = names.concat(u2.target.names);
            names.splice(i2, 1);
            let exp = exponents[i2];
            exponents = exponents.concat(u2.target.exponents.map((x3) => {
              return x3 * exp;
            }));
            exponents.splice(i2, 1);
            modified = true;
            break;
          }
        }
      }
      let x2 = sortAndCollapseUnits(names, exponents);
      this.baseUnits = this.manager.getUnitStore(x2.names, x2.exponents, false, true);
    }
    /**
     * @param {number} exponent
     * @returns {UnitStore}
     */
    power(exponent) {
      let names = this.names.slice();
      let exponents = this.exponents.slice();
      for (let i2 = 0; i2 < exponents.length; i2++) {
        exponents[i2] = exponents[i2] * exponent;
      }
      return this.manager.getUnitStore(names, exponents);
    }
    /**
     * @returns {string}
     */
    toStringShort() {
      let den = [];
      let num = [];
      let s2 = "";
      for (let i2 = 0; i2 < this.names.length; i2++) {
        if (this.exponents[i2] > 0) {
          num.push({ name: this.names[i2], exponent: this.exponents[i2] });
        } else if (this.exponents[i2] < 0) {
          den.push({ name: this.names[i2], exponent: -this.exponents[i2] });
        }
      }
      if (num.length > 0) {
        s2 = num.map((x2) => x2.name + (x2.exponent !== 1 ? "^" + x2.exponent : "")).join("*");
      } else {
        s2 = "1";
      }
      if (den.length > 0) {
        s2 = s2 + "/" + den.map((x2) => x2.name + (x2.exponent !== 1 ? "^" + x2.exponent : "")).join("*");
      }
      return s2;
    }
    /**
     * @param {UnitStore} rhs
     * @param {boolean} multiplication (false if division)
     *
     * @returns {[number, UnitStore, boolean]}
     */
    multiply(rhs, multiplication) {
      let exponent = multiplication ? 1 : -1;
      let cache = multiplication ? this.multiples : this.divisions;
      if (!cache.has(rhs)) {
        let lhsUnits = (
          /** @type {UnitStore} */
          this
        );
        let rhsUnits = rhs;
        let lhsNames = null;
        let lhsExponents = null;
        let rhsNames = null;
        let rhsExponents = null;
        for (let i2 = 0; i2 < (lhsNames || lhsUnits.names).length; i2++) {
          let j = (rhsNames || rhsUnits.names).indexOf((lhsNames || lhsUnits.names)[i2]);
          if (j > -1 && (lhsExponents || lhsUnits.exponents)[i2] === -exponent * (rhsExponents || rhsUnits.exponents)[j]) {
            if (!lhsNames) {
              lhsNames = lhsUnits.names.slice();
              lhsExponents = lhsUnits.exponents.slice();
              rhsNames = rhsUnits.names.slice();
              rhsExponents = rhsUnits.exponents.slice();
            }
            lhsNames.splice(i2, 1);
            lhsExponents.splice(i2, 1);
            rhsNames.splice(j, 1);
            rhsExponents.splice(j, 1);
            i2--;
          }
        }
        if (lhsNames) {
          lhsUnits = lhsUnits.manager.getUnitStore(lhsNames, lhsExponents);
          rhsUnits = rhsUnits.manager.getUnitStore(rhsNames, rhsExponents);
        }
        if (!lhsUnits && !rhsUnits) {
          cache.set(rhs, [1, void 0, true]);
          return cache.get(rhs);
        } else if (!lhsUnits) {
          cache.set(rhs, [1, multiplication ? rhsUnits : rhsUnits.power(-1), true]);
          return cache.get(rhs);
        } else if (!rhsUnits) {
          cache.set(rhs, [1, lhsUnits, true]);
          return cache.get(rhs);
        }
        if (lhsUnits.toBase === null) {
          lhsUnits.addBase();
        }
        if (rhsUnits.toBase === null) {
          rhsUnits.addBase();
        }
        let lhsBaseUnits = lhsUnits.baseUnits.names;
        let rhsBaseUnits = rhsUnits.baseUnits.names;
        let overlap = false;
        for (let i2 = 0; i2 < lhsBaseUnits.length; i2++) {
          if (rhsBaseUnits.includes(lhsBaseUnits[i2])) {
            overlap = true;
            break;
          }
        }
        if (!overlap) {
          let newUnits2 = lhsUnits.manager.getUnitStore(
            lhsUnits.names.concat(rhsUnits.names),
            lhsUnits.exponents.concat(multiplication ? rhsUnits.exponents : rhsUnits.exponents.map((x2) => -x2))
          );
          cache.set(rhs, [1, newUnits2, true]);
          return cache.get(rhs);
        }
        let names;
        let exponents;
        if (lhsUnits.baseUnits) {
          names = lhsUnits.baseUnits.names.slice();
          exponents = lhsUnits.baseUnits.exponents.slice();
          if (rhsUnits.baseUnits) {
            for (let i2 = 0; i2 < rhsUnits.baseUnits.names.length; i2++) {
              let j = names.indexOf(rhsUnits.baseUnits.names[i2]);
              if (j !== -1) {
                exponents[j] = exponents[j] + rhsUnits.baseUnits.exponents[i2] * exponent;
              } else {
                let found = false;
                for (let k2 = 0; k2 < names.length; k2++) {
                  if (rhsUnits.baseUnits.names[i2] < names[k2]) {
                    names.splice(k2, 0, rhsUnits.baseUnits.names[i2]);
                    exponents.splice(k2, 0, rhsUnits.baseUnits.exponents[i2] * exponent);
                    found = true;
                    break;
                  }
                }
                if (!found) {
                  names.push(rhsUnits.baseUnits.names[i2]);
                  exponents.push(rhsUnits.baseUnits.exponents[i2] * exponent);
                }
              }
            }
            for (let i2 = exponents.length - 1; i2 >= 0; i2--) {
              if (exponents[i2] === 0) {
                exponents.splice(i2, 1);
                names.splice(i2, 1);
              }
            }
          }
        } else {
          names = rhsUnits.baseUnits.names.slice();
          exponents = rhsUnits.baseUnits.exponents.slice();
        }
        let newUnits = this.manager.getUnitStore(names, exponents);
        cache.set(rhs, [
          multiplication ? fn["*"](lhsUnits.toBase, rhsUnits.toBase) : fn["/"](lhsUnits.toBase, rhsUnits.toBase),
          newUnits,
          !newUnits
        ]);
      }
      return cache.get(rhs);
    }
    /**
     * @returns {string}
     */
    toString() {
      let n2 = "", den = "";
      let numItems = 0, denItems = 0;
      for (let i2 = 0; i2 < this.names.length; i2++) {
        if (this.names[i2] !== "") {
          let item = '<span class="unit">' + toHTML(toTitleCase(this.names[i2])) + "</span>";
          if (this.exponents[i2] !== 1 && this.exponents[i2] !== -1) {
            item = item + "<span class='markup'>^</span><sup>" + Math.abs(this.exponents[i2]) + "</sup>";
          }
          if (this.exponents[i2] > 0) {
            if (numItems > 0) {
              n2 = n2 + "<span class='markup'>*</span>";
            }
            n2 = n2 + item;
            numItems = numItems + 1;
          } else {
            if (denItems > 0) {
              den = den + "<span class='markup'>*</span>";
            }
            den = den + item;
            denItems = denItems + 1;
          }
        }
      }
      if (n2 === "") {
        n2 = "Unitless";
      }
      if (den === "") {
        return '<div class="units">' + n2 + "</div>";
      } else {
        if (n2 === "Unitless") {
          n2 = "1";
        }
        return '<span class="units">' + n2 + "<hr/><span class='markup'>/(</span>" + den + "<span class='markup'>)</span></span>";
      }
    }
  };
  var titleCaseReg = /\w\S*/g;
  function titleCaseFunc(txt) {
    return txt[0].toUpperCase() + txt.slice(1).toLowerCase();
  }
  function toTitleCase(str) {
    return str.replace(titleCaseReg, titleCaseFunc);
  }
  function convertUnits(source, target, allowUnitApplication = false) {
    if (source === target) {
      return 1;
    }
    let sourceUnitless = !source || source.isUnitless();
    let targetUnitless = !target || target.isUnitless();
    if (sourceUnitless && targetUnitless) {
      return 1;
    }
    if (!sourceUnitless && targetUnitless) {
      if (source.isDeepUnitless()) {
        return source.toBase;
      }
      return 0;
    }
    if (sourceUnitless && !targetUnitless) {
      if (allowUnitApplication) {
        return 1;
      }
      if (target.isDeepUnitless()) {
        return fn["/"](1, target.toBase);
      }
      return 0;
    }
    if (source.toBase === null) {
      source.addBase();
    }
    if (target.toBase === null) {
      target.addBase();
    }
    if (source.baseUnits !== target.baseUnits) {
      return 0;
    }
    return fn["/"](source.toBase, target.toBase);
  }
  var DEFAULT_UNITS = [
    {
      "source": /^Degree$/i,
      "targetString": "Degrees",
      "scale": 1
    },
    {
      "source": /^Radians?$/i,
      "targetString": "Degrees",
      "scale": 180 / Math.PI
    },
    {
      "source": /^Ampere$/i,
      "targetString": "Amperes",
      "scale": 1
    },
    {
      "source": /^Gram$/i,
      "targetString": "Grams",
      "scale": 1
    },
    {
      "source": /^Second$/i,
      "targetString": "Seconds",
      "scale": 1
    },
    {
      "source": /^Meter$/i,
      "targetString": "Meters",
      "scale": 1
    },
    {
      "source": /^(Meters? ?Squared?|Squared? ?Meters?)$/i,
      "targetString": "Meters^2",
      "scale": 1
    },
    {
      "source": /^(Centimeters? ?Squared?|Squared? ?Centimeters?)$/i,
      "targetString": "Centimeters^2",
      "scale": 1
    },
    {
      "source": /^(Centimeters? ?Cubed?|Cubic ?Centimeters?)$/i,
      "targetString": "Centimeters^3",
      "scale": 1
    },
    {
      "source": /^(Meters? Cubed?|Cubic ?Meters?)$/i,
      "targetString": "Meters^3",
      "scale": 1
    },
    {
      "source": /^(Kilometers? ?Cubed?|Cubic ?Kilometers?)$/i,
      "targetString": "Kilometers^3",
      "scale": 1
    },
    {
      "source": /^(Inches? Squared?|Squared? ?Inches?)$/i,
      "targetString": "Inches^2",
      "scale": 1
    },
    {
      "source": /^(Miles? ?Squared?|Squared? ?Miles?)$/i,
      "targetString": "Miles^2",
      "scale": 1
    },
    {
      "source": /^(Kilometers? Squared?|Squared? ?Kilometers?)$/i,
      "targetString": "Kilometers^2",
      "scale": 1
    },
    {
      "source": /^Acre? ?(Feet|Foot)$/i,
      "targetString": "Acres,Feet",
      "scale": 1
    },
    {
      "source": /^Meters? ?per ?Seconds?$/i,
      "targetString": "Meters,Seconds^-1",
      "scale": 1
    },
    {
      "source": /^Meters? ?per ?Seconds? ?Squared?$/i,
      "targetString": "Meters,Seconds^-2",
      "scale": 1
    },
    {
      "source": /^(Foot|Feet) ?per ?Seconds?$/i,
      "targetString": "Feet,Seconds^-1",
      "scale": 1
    },
    {
      "source": /^(Foot|Feet) ?per ?Seconds? ?Squared?$/i,
      "targetString": "Feet,Seconds^-2",
      "scale": 1
    },
    {
      "source": /^Miles? ?per ?Hours?$/i,
      "targetString": "Miles,Hours^-1",
      "scale": 1
    },
    {
      "source": /^Miles? ?per ?Hours? ?Squared?$/i,
      "targetString": "Miles,Hours^-2",
      "scale": 1
    },
    {
      "source": /^Kilometers? ?per ?Hours?$/i,
      "targetString": "Kilometers,Hours^-1",
      "scale": 1
    },
    {
      "source": /^Kilometers? ?per ?Hours? ?Squared?$/i,
      "targetString": "Kilometers,Hours^-2",
      "scale": 1
    },
    {
      "source": /^Liters? ?per ?Seconds?$/i,
      "targetString": "Liters,Seconds^-1",
      "scale": 1
    },
    {
      "source": /^(Cubic ?Meters?|Meters? ?Cubed?) ?per ?Seconds?$/i,
      "targetString": "Meters^3,Seconds^-1",
      "scale": 1
    },
    {
      "source": /^(Squared? ?Yards?|Yards? ?Squared?)$/i,
      "targetString": "Yards^2",
      "scale": 1
    },
    {
      "source": /^(Squared? ?(Feet|Foot)|(Feet|Foot) ?Squared?)$/i,
      "targetString": "Feet^2",
      "scale": 1
    },
    {
      "source": /^(Squared? Millimeters?|Millimeters? ?Squared?)$/i,
      "targetString": "Millimeters^2",
      "scale": 1
    },
    {
      "source": /^(Millimeters? ?Cubed?|Cubic ?Millimeters?)$/i,
      "targetString": "Millimeters^3",
      "scale": 1
    },
    {
      "source": /^Gallons? ?per ?Seconds?$/i,
      "targetString": "Gallons,Seconds^-1",
      "scale": 1
    },
    {
      "source": /^Gallons? ?per ?Minutes?$/i,
      "targetString": "Gallons,Minutes^-1",
      "scale": 1
    },
    {
      "source": /^Pounds? ?per ?Seconds?$/i,
      "targetString": "Pounds,Seconds^-1",
      "scale": 1
    },
    {
      "source": /^Kilograms? ?per ?Seconds?$/i,
      "targetString": "Kilograms,Seconds^-1",
      "scale": 1
    },
    {
      "source": /^Dollars? ?per ?Seconds?$/i,
      "targetString": "Dollars,Seconds^-1",
      "scale": 1
    },
    {
      "source": /^Dollars? ?per ?Hours?$/i,
      "targetString": "Dollars,Hours^-1",
      "scale": 1
    },
    {
      "source": /^Dollars? ?per ?Days?$/i,
      "targetString": "Dollars,Days^-1",
      "scale": 1
    },
    {
      "source": /^Dollars? ?per ?Weeks?$/i,
      "targetString": "Dollars,Weeks^-1",
      "scale": 1
    },
    {
      "source": /^Dollars? ?per ?Months?$/i,
      "targetString": "Dollars,Months^-1",
      "scale": 1
    },
    {
      "source": /^Dollars? ?per ?Quarters?$/i,
      "targetString": "Dollars,Quarters^-1",
      "scale": 1
    },
    {
      "source": /^Dollars? ?per ?Years?$/i,
      "targetString": "Dollars,Years^-1",
      "scale": 1
    },
    {
      "source": /^Euros? ?per ?Seconds?$/i,
      "targetString": "Euros,Seconds^-1",
      "scale": 1
    },
    {
      "source": /^Euros? ?per ?Hours?$/i,
      "targetString": "Euros,Hours^-1",
      "scale": 1
    },
    {
      "source": /^Euros? ?per ?Days?$/i,
      "targetString": "Euros,Days^-1",
      "scale": 1
    },
    {
      "source": /^Euros? ?per ?Weeks?$/i,
      "targetString": "Euros,Weeks^-1",
      "scale": 1
    },
    {
      "source": /^Euros? ?per ?Months?$/i,
      "targetString": "Euros,Months^-1",
      "scale": 1
    },
    {
      "source": /^Euros? ?per ?Quarters?$/i,
      "targetString": "Euros,Quarters^-1",
      "scale": 1
    },
    {
      "source": /^Euros? ?per ?Years?$/i,
      "targetString": "Euros,Years^-1",
      "scale": 1
    },
    {
      "source": /^Centimeters?$/i,
      "targetString": "Meters",
      "scale": 0.01
    },
    {
      "source": /^Millimeters?$/i,
      "targetString": "Meters",
      "scale": 1e-3
    },
    {
      "source": /^Kilometers?$/i,
      "targetString": "Meters",
      "scale": 1e3
    },
    {
      "source": /^Inch(es)?$/i,
      "targetString": "Meters",
      "scale": 0.0254
    },
    {
      "source": /^(Foot|Feet)$/i,
      "targetString": "Meters",
      "scale": 0.3048
    },
    {
      "source": /^Yards?$/i,
      "targetString": "Meters",
      "scale": 0.9144
    },
    {
      "source": /^Miles?$/i,
      "targetString": "Meters",
      "scale": 1609.344
    },
    {
      "source": /^Acres?$/i,
      "targetString": "Meters^2",
      "scale": 4046.85642
    },
    {
      "source": /^Hectares?$/i,
      "targetString": "Meters^2",
      "scale": 1e4
    },
    {
      "source": /^Liters?$/i,
      "targetString": "Meters^3",
      "scale": 1e-3
    },
    {
      "source": /^Gallons?$/i,
      "targetString": "Meters^3",
      "scale": 3785e-6
    },
    {
      "source": /^Quarts?$/i,
      "targetString": "Meters^3",
      "scale": 946e-6
    },
    {
      "source": /^Fluid ?Ounces?$/i,
      "targetString": "Meters^3",
      "scale": 3e-5
    },
    {
      "source": /^Years?$/i,
      "targetString": "Seconds",
      "scale": 31536e3
    },
    {
      "source": /^Quarters?$/i,
      "targetString": "Seconds",
      "scale": 7884e3
    },
    {
      "source": /^Months?$/i,
      "targetString": "Seconds",
      "scale": 2628e3
    },
    {
      "source": /^Weeks?$/i,
      "targetString": "Seconds",
      "scale": 604800
    },
    {
      "source": /^Days?$/i,
      "targetString": "Seconds",
      "scale": 86400
    },
    {
      "source": /^Hours?$/i,
      "targetString": "Seconds",
      "scale": 3600
    },
    {
      "source": /^Minutes?$/i,
      "targetString": "Seconds",
      "scale": 60
    },
    {
      "source": /^Kilograms?$/i,
      "targetString": "Grams",
      "scale": 1e3
    },
    {
      "source": /^Milligrams?$/i,
      "targetString": "Grams",
      "scale": 1e-3
    },
    {
      "source": /^Ounces?$/i,
      "targetString": "Grams",
      "scale": 28.349523
    },
    {
      "source": /^Pounds?$/i,
      "targetString": "Grams",
      "scale": 453.59237
    },
    {
      "source": /^Tonnes?$/i,
      "targetString": "Grams",
      "scale": 1e6
    },
    {
      "source": /^Tons?$/i,
      "targetString": "Grams",
      "scale": 907184.74
    },
    {
      "source": /^Watts?$/i,
      "targetString": "Joules,Seconds^-1",
      "scale": 1
    },
    {
      "source": /^Kilowatts?$/i,
      "targetString": "Watts",
      "scale": 1e3
    },
    {
      "source": /^Megawatts?$/i,
      "targetString": "Watts",
      "scale": 1e6
    },
    {
      "source": /^Gigawatts?$/i,
      "targetString": "Watts",
      "scale": 1e9
    },
    {
      "source": /^Calories?$/i,
      "targetString": "Joules",
      "scale": 4.184
    },
    {
      "source": /^Kilocalories?$/i,
      "targetString": "Joules",
      "scale": 4184
    },
    {
      "source": /^(BTUs?|British ?Thermal ?units?)$/i,
      "targetString": "Joules",
      "scale": 1055.05585
    },
    {
      "source": /^Kilojoules?$/i,
      "targetString": "Joules",
      "scale": 1e3
    },
    {
      "source": /^Joules?$/i,
      "targetString": "Newtons,Meters",
      "scale": 1
    },
    {
      "source": /^Coulombs?$/i,
      "targetString": "Amperes,Seconds",
      "scale": 1
    },
    {
      "source": /^Volts?$/i,
      "targetString": "Watts,Amperes^-1",
      "scale": 1
    },
    {
      "source": /^Millivolts?$/i,
      "targetString": "Volts",
      "scale": 1e-3
    },
    {
      "source": /^Kilovolts?$/i,
      "targetString": "Volts",
      "scale": 1e3
    },
    {
      "source": /^Newtons?$/i,
      "targetString": "Kilograms,Meters,Seconds^-2",
      "scale": 1
    },
    {
      "source": /^Pounds? ?Force$/i,
      "targetString": "Pounds,Feet per Second Squared",
      "scale": 32.17405
    },
    {
      "source": /^Atoms?$/i,
      "targetString": "Moles",
      "scale": 1 / 602214076e15
    },
    {
      "source": /^Molecules?$/i,
      "targetString": "Moles",
      "scale": 1 / 602214076e15
    },
    {
      "source": /^Farads?$/i,
      "targetString": "Joules,Volts^-2",
      "scale": 1
    },
    {
      "source": /^Pascals?$/i,
      "targetString": "Newton,Meters^-2",
      "scale": 1
    },
    {
      "source": /^Kilopascals?$/i,
      "targetString": "Pascals",
      "scale": 1e3
    },
    {
      "source": /^Bars?$/i,
      "targetString": "Pascals",
      "scale": 1e5
    },
    {
      "source": /^Atmospheres?$/i,
      "targetString": "Pascals",
      "scale": 101325
    },
    {
      "source": /^Pounds? ?per ?Squared? ?Inch(es)?$/i,
      "targetString": "Pascals",
      "scale": 6894
    }
  ];
  var UnitManager = class {
    constructor() {
      this.unitDefinitions = [];
      this.cachedUnits = /* @__PURE__ */ Object.create(null);
      this.unitsBank = /* @__PURE__ */ Object.create(null);
      this.addUnits(DEFAULT_UNITS);
    }
    /**
     * @param {UnitDefinition[]} units
     */
    addUnits(units) {
      for (let unit of units) {
        if (!unit.source) {
          unit.source = new RegExp("^" + unit.sourceString + "$", "i");
        }
        if (!unit.target) {
          unit.target = this.unitsFromString(unit.targetString.toLowerCase());
        }
      }
      this.unitDefinitions = units.concat(this.unitDefinitions);
    }
    /**
     * @param {string} name
     *
     * @returns {UnitDefinition}
     */
    findSource(name) {
      if (!(name in this.cachedUnits)) {
        this.cachedUnits[name] = null;
        for (let i2 = this.unitDefinitions.length - 1; i2 >= 0; i2--) {
          if (this.unitDefinitions[i2].source.test(name)) {
            this.cachedUnits[name] = this.unitDefinitions[i2];
            break;
          }
        }
      }
      return this.cachedUnits[name];
    }
    /**
     * @param {string[]} names
     * @param {number[]} exponents
     * @param {boolean=} checkNames
     * @param {boolean=} alwaysReturn - units must be returned, when calling setBase
     *
     * @returns {UnitStore}
     */
    getUnitStore(names, exponents, checkNames = false, alwaysReturn = false) {
      if (checkNames) {
        let x2 = sortAndCollapseUnits(names, exponents);
        names = x2.names;
        exponents = x2.exponents;
      }
      if (!alwaysReturn && !names.length) {
        return;
      }
      let id2 = getUnitsId(names, exponents);
      if (!this.unitsBank[id2]) {
        this.unitsBank[id2] = new UnitStore(this, names, exponents);
      }
      return this.unitsBank[id2];
    }
    /**
     * @param {string} expandString
     *
     * @returns {UnitStore}
     */
    unitsFromString(expandString) {
      let names = [];
      let exponents = [];
      if (expandString) {
        let expandItems = expandString.split(",");
        for (let j = 0; j < expandItems.length; j++) {
          names.push(expandItems[j].split("^")[0]);
          if (expandItems[j].indexOf("^") !== -1) {
            exponents.push(parseFloat(expandItems[j].split("^")[1]));
          } else {
            exponents.push(1);
          }
        }
      }
      return this.getUnitStore(names, exponents, true);
    }
  };

  // ../insight-maker-simulation/src/formula/Material.js
  var Material = class _Material {
    /**
     * @param {number} value
     * @param {import("./Units").UnitStore=} units
     * @param {boolean=} explicitUnits
     */
    constructor(value, units, explicitUnits = true) {
      this.value = value;
      this.units = units;
      this.explicitUnits = explicitUnits;
    }
    /**
     * @returns {Material}
     */
    toNum() {
      return this;
    }
    toString() {
      if (this.units && !this.units.isUnitless()) {
        return "{" + this.value + " " + this.units.toStringShort() + "}";
      } else {
        return this.value + "";
      }
    }
    fullClone() {
      return new _Material(this.value, this.units, this.explicitUnits);
    }
    /**
     * @param {import("./Units").UnitStore} newUnits
     *
     * @returns {Material}
     */
    forceUnits(newUnits) {
      if (!this.units) {
        this.units = newUnits;
      } else {
        let scale = convertUnits(this.units, newUnits);
        if (scale === 0) {
          unitAlert(this.units, newUnits, "conversion of units");
        } else {
          this.value = fn["*"](this.value, scale);
          this.units = newUnits;
        }
      }
      return this;
    }
  };
  function unitAlert(lhs, rhs, type, operator, lhsNode, rhsNode) {
    if (lhs instanceof UnitStore && rhs instanceof UnitStore) {
      throw new ModelError(`Incompatible units for the ${type} of ${lhs && !lhs.isUnitless() ? lhs.toString() : "unitless"} and ${rhs && !rhs.isUnitless() ? rhs.toString() : "unitless"}.`, {
        code: 5e3
      });
    } else if (lhs instanceof Material && rhs instanceof Material) {
      let lhsUnits = lhs.units;
      let rhsUnits = rhs.units;
      let msg = `Incompatible units for the ${type} of ${lhsUnits && !lhsUnits.isUnitless() ? lhsUnits.toString() : "unitless"} and ${rhsUnits && !rhsUnits.isUnitless() ? rhsUnits.toString() : "unitless"}.`;
      let formatMat = (mat) => {
        if (mat.units && !mat.units.isUnitless()) {
          return `{${mat.value} ${mat.units.toStringShort()}}`;
        } else {
          return mat.value;
        }
      };
      msg += `<br/><br/>Attempted ${type}: <b>${formatMat(lhs)} ${operator.replace("<", "&lt;").replace(">", "&gt;")} ${formatMat(rhs)}</b>`;
      if (!lhsUnits) {
        if (lhsNode instanceof Material) {
          let lhsSuggested = lhs.fullClone();
          lhsSuggested.units = rhsUnits;
          msg += `<br/><br/>Consider replacing <b>${formatMat(lhs)}</b> with <b>${formatMat(lhsSuggested)}</b>.`;
        } else if (lhsNode instanceof PrimitiveStore) {
          msg += "<br/><br/>Consider setting the units of <b>[" + lhsNode.primitive.dna.name + "]</b> to <b>" + rhsUnits.toStringShort() + "</b>.";
        }
      }
      if (!rhsUnits) {
        if (rhsNode instanceof Material) {
          let rhsSuggested = rhs.fullClone();
          rhsSuggested.units = lhsUnits;
          msg += `<br/><br/>Consider replacing <b>${formatMat(rhs)}</b> with <b>${formatMat(rhsSuggested)}</b>.`;
        } else if (rhsNode instanceof PrimitiveStore) {
          msg += "<br/><br/>Consider setting the units of <b>[" + rhsNode.primitive.dna.name + "]</b> to <b>" + lhsUnits.toStringShort() + "</b>.";
        }
      }
      throw new ModelError(msg, {
        code: 5e3
      });
    }
  }

  // ../insight-maker-simulation/vendor/avl/utils.js
  function print(root2, printNode = (n2) => n2.key) {
    let out = [];
    row(root2, "", true, (v2) => out.push(v2), printNode);
    return out.join("");
  }
  function row(root2, prefix, isTail, out, printNode) {
    if (root2) {
      out(`${prefix}${isTail ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 "}${printNode(root2)}
`);
      const indent = prefix + (isTail ? "    " : "\u2502   ");
      if (root2.left) row(root2.left, indent, false, out, printNode);
      if (root2.right) row(root2.right, indent, true, out, printNode);
    }
  }
  function isBalanced(root2) {
    if (root2 === null) return true;
    let lh = height(root2.left);
    let rh = height(root2.right);
    if (Math.abs(lh - rh) <= 1 && isBalanced(root2.left) && isBalanced(root2.right)) return true;
    return false;
  }
  function height(node) {
    return node ? 1 + Math.max(height(node.left), height(node.right)) : 0;
  }
  function loadRecursive(parent, keys, values, start2, end) {
    const size = end - start2;
    if (size > 0) {
      const middle = start2 + Math.floor(size / 2);
      const key = keys[middle];
      const data = values[middle];
      const node = { key, data, parent };
      node.left = loadRecursive(node, keys, values, start2, middle);
      node.right = loadRecursive(node, keys, values, middle + 1, end);
      return node;
    }
    return null;
  }
  function markBalance(node) {
    if (node === null) return 0;
    const lh = markBalance(node.left);
    const rh = markBalance(node.right);
    node.balanceFactor = lh - rh;
    return Math.max(lh, rh) + 1;
  }
  function sort(keys, values, left, right, compare2) {
    if (left >= right) return;
    const pivot = keys[left + right >> 1];
    let i2 = left - 1;
    let j = right + 1;
    while (true) {
      do
        i2++;
      while (compare2(keys[i2], pivot) < 0);
      do
        j--;
      while (compare2(keys[j], pivot) > 0);
      if (i2 >= j) break;
      let tmp = keys[i2];
      keys[i2] = keys[j];
      keys[j] = tmp;
      tmp = values[i2];
      values[i2] = values[j];
      values[j] = tmp;
    }
    sort(keys, values, left, j, compare2);
    sort(keys, values, j + 1, right, compare2);
  }

  // ../insight-maker-simulation/vendor/avl/avl.js
  function DEFAULT_COMPARE(a2, b2) {
    return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
  }
  function rotateLeft(node) {
    let rightNode = node.right;
    node.right = rightNode.left;
    if (rightNode.left) rightNode.left.parent = node;
    rightNode.parent = node.parent;
    if (rightNode.parent) {
      if (rightNode.parent.left === node) {
        rightNode.parent.left = rightNode;
      } else {
        rightNode.parent.right = rightNode;
      }
    }
    node.parent = rightNode;
    rightNode.left = node;
    node.balanceFactor += 1;
    if (rightNode.balanceFactor < 0) {
      node.balanceFactor -= rightNode.balanceFactor;
    }
    rightNode.balanceFactor += 1;
    if (node.balanceFactor > 0) {
      rightNode.balanceFactor += node.balanceFactor;
    }
    return rightNode;
  }
  function rotateRight(node) {
    let leftNode = node.left;
    node.left = leftNode.right;
    if (node.left) node.left.parent = node;
    leftNode.parent = node.parent;
    if (leftNode.parent) {
      if (leftNode.parent.left === node) {
        leftNode.parent.left = leftNode;
      } else {
        leftNode.parent.right = leftNode;
      }
    }
    node.parent = leftNode;
    leftNode.right = node;
    node.balanceFactor -= 1;
    if (leftNode.balanceFactor > 0) {
      node.balanceFactor -= leftNode.balanceFactor;
    }
    leftNode.balanceFactor -= 1;
    if (node.balanceFactor < 0) {
      leftNode.balanceFactor += node.balanceFactor;
    }
    return leftNode;
  }
  var AVLTree = class {
    /**
     * Callback for comparator
     * @callback comparatorCallback
     * @param {Key} a
     * @param {Key} b
     * @returns {number}
     */
    /**
     * @class AVLTree
     * @constructor
     * @param  {comparatorCallback} [comparator]
     * @param  {boolean}            [noDuplicates=false] Disallow duplicates
     */
    constructor(comparator, noDuplicates = false) {
      this._comparator = comparator || DEFAULT_COMPARE;
      this._root = null;
      this._size = 0;
      this._noDuplicates = !!noDuplicates;
    }
    /**
     * Clear the tree
     * @return {AVLTree}
     */
    destroy() {
      return this.clear();
    }
    /**
     * Clear the tree
     * @return {AVLTree}
     */
    clear() {
      this._root = null;
      this._size = 0;
      return this;
    }
    /**
     * Number of nodes
     * @return {number}
     */
    get size() {
      return this._size;
    }
    /**
     * Whether the tree contains a node with the given key
     * @param  {Key} key
     * @return {boolean} true/false
     */
    contains(key) {
      if (this._root) {
        let node = this._root;
        let comparator = this._comparator;
        while (node) {
          let cmp = comparator(key, node.key);
          if (cmp === 0) return true;
          else if (cmp < 0) node = node.left;
          else node = node.right;
        }
      }
      return false;
    }
    /* eslint-disable class-methods-use-this */
    /**
     * Successor node
     * @param  {Node} node
     * @return {?Node}
     */
    next(node) {
      let successor = node;
      if (successor) {
        if (successor.right) {
          successor = successor.right;
          while (successor.left) successor = successor.left;
        } else {
          successor = node.parent;
          while (successor && successor.right === node) {
            node = successor;
            successor = successor.parent;
          }
        }
      }
      return successor;
    }
    /**
     * Predecessor node
     * @param  {Node} node
     * @return {?Node}
     */
    prev(node) {
      let predecessor = node;
      if (predecessor) {
        if (predecessor.left) {
          predecessor = predecessor.left;
          while (predecessor.right) predecessor = predecessor.right;
        } else {
          predecessor = node.parent;
          while (predecessor && predecessor.left === node) {
            node = predecessor;
            predecessor = predecessor.parent;
          }
        }
      }
      return predecessor;
    }
    /* eslint-enable class-methods-use-this */
    /**
     * Callback for forEach
     * @callback forEachCallback
     * @param {Node} node
     * @param {number} index
     */
    /**
     * @param  {forEachCallback} callback
     * @return {AVLTree}
     */
    forEach(callback) {
      let current = this._root;
      let s2 = [], done = false, i2 = 0;
      while (!done) {
        if (current) {
          s2.push(current);
          current = current.left;
        } else {
          if (s2.length > 0) {
            current = s2.pop();
            callback(current, i2++);
            current = current.right;
          } else done = true;
        }
      }
      return this;
    }
    /**
     * Walk key range from `low` to `high`. Stops if `fn` returns a value.
     * @param  {Key}      low
     * @param  {Key}      high
     * @param  {Function} fn
     * @param  {*?}       ctx
     * @return {SplayTree}
     */
    range(low, high, fn2, ctx) {
      const Q = [];
      const compare2 = this._comparator;
      let node = this._root, cmp;
      while (Q.length !== 0 || node) {
        if (node) {
          Q.push(node);
          node = node.left;
        } else {
          node = Q.pop();
          cmp = compare2(node.key, high);
          if (cmp > 0) {
            break;
          } else if (compare2(node.key, low) >= 0) {
            if (fn2.call(ctx, node)) return this;
          }
          node = node.right;
        }
      }
      return this;
    }
    /**
     * Returns all keys in order
     * @return {Array<Key>}
     */
    keys() {
      let current = this._root;
      let s2 = [], r2 = [], done = false;
      while (!done) {
        if (current) {
          s2.push(current);
          current = current.left;
        } else {
          if (s2.length > 0) {
            current = s2.pop();
            r2.push(current.key);
            current = current.right;
          } else done = true;
        }
      }
      return r2;
    }
    /**
     * Returns `data` fields of all nodes in order.
     * @return {Array<Value>}
     */
    values() {
      let current = this._root;
      let s2 = [], r2 = [], done = false;
      while (!done) {
        if (current) {
          s2.push(current);
          current = current.left;
        } else {
          if (s2.length > 0) {
            current = s2.pop();
            r2.push(current.data);
            current = current.right;
          } else done = true;
        }
      }
      return r2;
    }
    /**
     * Returns node at given index
     * @param  {number} index
     * @return {?Node}
     */
    at(index) {
      let current = this._root;
      let s2 = [], done = false, i2 = 0;
      while (!done) {
        if (current) {
          s2.push(current);
          current = current.left;
        } else {
          if (s2.length > 0) {
            current = s2.pop();
            if (i2 === index) return current;
            i2++;
            current = current.right;
          } else done = true;
        }
      }
      return null;
    }
    /**
     * Returns node with the minimum key
     * @return {?Node}
     */
    minNode() {
      let node = this._root;
      if (!node) return null;
      while (node.left) node = node.left;
      return node;
    }
    /**
     * Returns node with the max key
     * @return {?Node}
     */
    maxNode() {
      let node = this._root;
      if (!node) return null;
      while (node.right) node = node.right;
      return node;
    }
    /**
     * Min key
     * @return {?Key}
     */
    min() {
      let node = this._root;
      if (!node) return null;
      while (node.left) node = node.left;
      return node.key;
    }
    /**
     * Max key
     * @return {?Key}
     */
    max() {
      let node = this._root;
      if (!node) return null;
      while (node.right) node = node.right;
      return node.key;
    }
    /**
     * @return {boolean} true/false
     */
    isEmpty() {
      return !this._root;
    }
    /**
     * Removes and returns the node with smallest key
     * @return {?Node}
     */
    pop() {
      let node = this._root, returnValue = null;
      if (node) {
        while (node.left) node = node.left;
        returnValue = { key: node.key, data: node.data };
        this.remove(node.key);
      }
      return returnValue;
    }
    /**
     * Removes and returns the node with highest key
     * @return {?Node}
     */
    popMax() {
      let node = this._root, returnValue = null;
      if (node) {
        while (node.right) node = node.right;
        returnValue = { key: node.key, data: node.data };
        this.remove(node.key);
      }
      return returnValue;
    }
    /**
     * Find node by key
     * @param  {Key} key
     * @return {?Node}
     */
    find(key) {
      let root2 = this._root;
      let subtree = root2, cmp;
      let compare2 = this._comparator;
      while (subtree) {
        cmp = compare2(key, subtree.key);
        if (cmp === 0) return subtree;
        else if (cmp < 0) subtree = subtree.left;
        else subtree = subtree.right;
      }
      return null;
    }
    /**
     * Insert a node into the tree
     * @param  {Key} key
     * @param  {Value} [data]
     * @return {?Node}
     */
    insert(key, data) {
      if (!this._root) {
        this._root = {
          parent: null,
          left: null,
          right: null,
          balanceFactor: 0,
          key,
          data
        };
        this._size++;
        return this._root;
      }
      let compare2 = this._comparator;
      let node = this._root;
      let parent = null;
      let cmp = 0;
      if (this._noDuplicates) {
        while (node) {
          cmp = compare2(key, node.key);
          parent = node;
          if (cmp === 0) return null;
          else if (cmp < 0) node = node.left;
          else node = node.right;
        }
      } else {
        while (node) {
          cmp = compare2(key, node.key);
          parent = node;
          if (cmp <= 0) node = node.left;
          else node = node.right;
        }
      }
      let newNode = {
        left: null,
        right: null,
        balanceFactor: 0,
        parent,
        key,
        data
      };
      let newRoot;
      if (cmp <= 0) parent.left = newNode;
      else parent.right = newNode;
      while (parent) {
        cmp = compare2(parent.key, key);
        if (cmp < 0) parent.balanceFactor -= 1;
        else parent.balanceFactor += 1;
        if (parent.balanceFactor === 0) break;
        else if (parent.balanceFactor < -1) {
          if (parent.right.balanceFactor === 1) rotateRight(parent.right);
          newRoot = rotateLeft(parent);
          if (parent === this._root) this._root = newRoot;
          break;
        } else if (parent.balanceFactor > 1) {
          if (parent.left.balanceFactor === -1) rotateLeft(parent.left);
          newRoot = rotateRight(parent);
          if (parent === this._root) this._root = newRoot;
          break;
        }
        parent = parent.parent;
      }
      this._size++;
      return newNode;
    }
    /**
     * Removes the node from the tree. If not found, returns null.
     * @param  {Key} key
     * @return {?Node}
     */
    remove(key) {
      if (!this._root) return null;
      let node = this._root;
      let compare2 = this._comparator;
      let cmp = 0;
      while (node) {
        cmp = compare2(key, node.key);
        if (cmp === 0) break;
        else if (cmp < 0) node = node.left;
        else node = node.right;
      }
      if (!node) return null;
      let returnValue = node.key;
      let max, min;
      if (node.left) {
        max = node.left;
        while (max.left || max.right) {
          while (max.right) max = max.right;
          node.key = max.key;
          node.data = max.data;
          if (max.left) {
            node = max;
            max = max.left;
          }
        }
        node.key = max.key;
        node.data = max.data;
        node = max;
      }
      if (node.right) {
        min = node.right;
        while (min.left || min.right) {
          while (min.left) min = min.left;
          node.key = min.key;
          node.data = min.data;
          if (min.right) {
            node = min;
            min = min.right;
          }
        }
        node.key = min.key;
        node.data = min.data;
        node = min;
      }
      let parent = node.parent;
      let pp = node;
      let newRoot;
      while (parent) {
        if (parent.left === pp) parent.balanceFactor -= 1;
        else parent.balanceFactor += 1;
        if (parent.balanceFactor < -1) {
          if (parent.right.balanceFactor === 1) rotateRight(parent.right);
          newRoot = rotateLeft(parent);
          if (parent === this._root) this._root = newRoot;
          parent = newRoot;
        } else if (parent.balanceFactor > 1) {
          if (parent.left.balanceFactor === -1) rotateLeft(parent.left);
          newRoot = rotateRight(parent);
          if (parent === this._root) this._root = newRoot;
          parent = newRoot;
        }
        if (parent.balanceFactor === -1 || parent.balanceFactor === 1) break;
        pp = parent;
        parent = parent.parent;
      }
      if (node.parent) {
        if (node.parent.left === node) node.parent.left = null;
        else node.parent.right = null;
      }
      if (node === this._root) this._root = null;
      this._size--;
      return returnValue;
    }
    /**
     * Bulk-load items
     * @param  {Array<Key>}  keys
     * @param  {Array<Value>}  [values]
     * @param {boolean=} presort
     * @return {AVLTree}
     */
    load(keys = [], values = [], presort = false) {
      if (this._size !== 0) throw new Error("bulk-load: tree is not empty");
      const size = keys.length;
      if (presort) sort(keys, values, 0, size - 1, this._comparator);
      this._root = loadRecursive(null, keys, values, 0, size);
      markBalance(this._root);
      this._size = size;
      return this;
    }
    /**
     * Returns true if the tree is balanced
     * @return {boolean}
     */
    isBalanced() {
      return isBalanced(this._root);
    }
    /**
     * String representation of the tree - primitive horizontal print-out
     * @param  {function(Node):string} [printNode]
     * @return {string}
     */
    toString(printNode) {
      return print(this._root, printNode);
    }
  };
  AVLTree.default = AVLTree;

  // ../insight-maker-simulation/src/TaskScheduler.js
  var TaskQueue = class {
    constructor(config) {
      config = config || {};
      this.tasks = new AVLTree(compare);
      this.onMoveEvents = [];
      this.setTime(config.start);
      this.debug = false;
      this.end = config.end;
      this.states = {};
      this.cursor = null;
    }
    print() {
      console.log("Current Time: " + this.time.value);
      let cursor = this.tasks.minNode();
      while (cursor) {
        console.log(cursor.key.name);
        console.log("    Time: " + cursor.key.time.value);
        console.log("    Priority: " + cursor.key.priority);
        if (cursor.key.expires !== void 0) {
          console.log("    Expires: " + cursor.key.expires);
        }
        cursor = this.tasks.next(cursor);
      }
    }
    /**
     * @param {(function(Material, Material, Material): void)} event
     */
    addEvent(event) {
      this.onMoveEvents.push(event);
    }
    /**
     * @param {Material} timeChange
     * @param {Material} oldTime
     * @param {Material} newTime
     */
    fireEvents(timeChange, oldTime, newTime) {
      if (this.debug) {
        console.log("Firing Events");
      }
      for (let i2 = 0; i2 < this.onMoveEvents.length; i2++) {
        this.onMoveEvents[i2](timeChange, oldTime, newTime);
      }
    }
    /**
     * @param {Material} t
     */
    setTime(t2) {
      if (this.time === void 0 || neq(t2, this.time)) {
        let oldTime = this.time;
        this.time = t2;
        if (oldTime !== void 0) {
          this.fireEvents(minus(t2, oldTime), oldTime, t2);
        }
      }
    }
    /**
     * @param {Material} newTime
     */
    moveTo(newTime) {
      if (eq(this.time, newTime)) {
        return;
      } else {
        if (this.debug) {
          console.log("Shifting time to: " + newTime.value);
        }
        if (this.cursor) {
          let maxTime = this.tasks.max().time;
          let minTime = this.tasks.min().time;
          while (lessThan(this.time, newTime) && !greaterThan(this.time, maxTime)) {
            this.step();
          }
          while (greaterThan(this.time, newTime) && greaterThan(this.time, minTime)) {
            this.stepBack();
          }
        }
        this.setTime(newTime);
        if (this.debug) {
          console.log("Time shift to  " + newTime.value + " completed.");
        }
      }
    }
    /**
     * @param {Task} task
     */
    add(task) {
      task.queue = this;
      this.tasks.insert(task);
    }
    goNext() {
      this.cursor = this.tasks.next(this.cursor);
    }
    goPrev() {
      this.cursor = this.tasks.prev(this.cursor);
    }
    step() {
      if (this.time === void 0) {
        this.cursor = this.tasks.minNode();
        this.setTime(this.cursor.key.time);
      }
      let current = this.cursor.key;
      if (current) {
        let dead = current.deadAction;
        current.execute();
        if (!dead && current.timeShift) {
          current.timeShift();
          return;
        }
        this.goNext();
      }
      if (this.cursor) {
        this.setTime(this.cursor.key.time);
      } else {
        this.goNext();
        this.setTime(mult(
          /** @type {Material} */
          this.tasks.max().time,
          new Material(10)
        ));
      }
    }
    stepBack() {
      if (this.time === void 0) {
        this.cursor = this.tasks.minNode();
        this.setTime(this.cursor.key.time);
        return;
      }
      if (!this.cursor) {
        this.cursor = this.tasks.maxNode();
      } else {
        this.goPrev();
      }
      let t2 = this.cursor.key.time;
      while (this.cursor && eq(t2, this.cursor.key.time)) {
        this.cursor.key.rollback();
        this.goPrev();
      }
      if (!this.cursor) {
        this.cursor = this.tasks.minNode();
      } else {
        this.goNext();
      }
      this.setTime(this.cursor.key.time);
    }
    /**
     * @returns {boolean}
     */
    atStart() {
      return this.time === void 0 || this.cursor.key === this.tasks.min();
    }
    /**
     * @returns {boolean}
     */
    completed() {
      return this.time !== void 0 && (greaterThan(this.time, this.end) || !this.cursor);
    }
    /**
     * @param {Task} task
     */
    remove(task) {
      if (task === this.cursor.key) {
        this.goNext();
      }
      this.tasks.remove(task);
    }
  };
  var taskIdCounter = 0;
  var Task = class {
    /**
     * @param {Object} config
     * @param {string} config.name
     * @param {Material} config.time
     * @param {(function(Task) : void) & {task?: Task, reverse?: Task}} config.action
     * @param {function=} config.rollback
     * @param {number=} config.priority
     * @param {number=} config.expires
     * @param {function=} config.timeShift
     * @param {any=} config.data
     * @param {string=} config.blocker
     */
    constructor(config) {
      this.id = taskIdCounter++;
      this.name = config.name;
      this.time = config.time;
      if (!this.time) {
        throw new TypeError("Task time is missing.");
      }
      if (isNaN(this.time.value)) {
        throw new TypeError("Task time is a NaN.");
      }
      this.action = config.action;
      this.reverse = config.rollback;
      this.priority = config.priority || 0;
      this.expires = config.expires;
      this.timeShift = config.timeShift;
      this.data = config.data;
      this.blocker = config.blocker;
      this.queue = void 0;
      this.deadAction = false;
      this.deadReverse = false;
      if (this.action) {
        this.action.task = this;
      }
      if (this.reverse) {
        this.action.reverse = this;
      }
    }
    execute() {
      if (this.action && !this.deadAction && (!this.blocker || !this.queue.states[this.blocker])) {
        if (this.queue.debug) {
          console.log("%c Executing: " + this.name + " (Time: " + this.time.value + ")", "color:blue");
        }
        if (this.expires !== void 0) {
          this.expires--;
          if (this.queue.debug) {
            console.log("    Current count before expire: " + this.expires);
          }
          if (this.expires <= 0) {
            if (this.queue.debug) {
              console.log("    Task expired.");
            }
            this.deadAction = true;
          }
        }
        this.action(this);
      }
    }
    rollback() {
      if (this.reverse && !this.deadReverse && (!this.blocker || !this.queue.states[this.blocker])) {
        if (this.queue.debug) {
          console.log("Rolling back: " + this.name + " (Time: " + this.time.value + ")");
        }
        if (this.expires !== void 0) {
          if (this.expires <= 0) {
            if (this.queue.debug) {
              console.log("    Rollback expired.");
            }
            this.deadReverse = true;
          }
        }
        this.reverse();
      }
    }
    /**
     * @param {Material} newTime
     */
    reschedule(newTime) {
      this.queue.remove(this);
      this.time = newTime;
      this.queue.add(this);
    }
    remove() {
      this.queue.remove(this);
    }
    kill() {
      this.deadAction = true;
      this.deadReverse = true;
    }
    /**
     * @param {string=} id
     */
    block(id2) {
      id2 = id2 || this.blocker;
      this.queue.states[id2] = true;
    }
    /**
     * @param {string=} id
     */
    unblock(id2) {
      id2 = id2 || this.blocker;
      this.queue.states[id2] = false;
    }
    toString() {
      return this.name + " - " + this.id;
    }
  };
  function compare(a2, b2) {
    if (eq(b2.time, a2.time)) {
      if (b2.priority === a2.priority) {
        if (b2.id === a2.id) {
          return 0;
        } else if (b2.id < a2.id) {
          return 1;
        } else {
          return -1;
        }
      } else if (b2.priority < a2.priority) {
        return 1;
      } else {
        return -1;
      }
    } else {
      if (lessThan(b2.time, a2.time)) {
        return 1;
      } else {
        return -1;
      }
    }
  }

  // ../insight-maker-simulation/vendor/jstat/jstat.js
  var jStat = {};
  (function(_window, factory) {
    Object.assign(jStat, factory());
  })(void 0, function() {
    var jStat2 = (function(Math2, undefined2) {
      var concat = Array.prototype.concat;
      var slice = Array.prototype.slice;
      var toString = Object.prototype.toString;
      function calcRdx(n2, m2) {
        var val = n2 > m2 ? n2 : m2;
        return Math2.pow(
          10,
          17 - ~~(Math2.log(val > 0 ? val : -val) * Math2.LOG10E)
        );
      }
      var isArray = Array.isArray || function isArray2(arg) {
        return toString.call(arg) === "[object Array]";
      };
      function isFunction(arg) {
        return toString.call(arg) === "[object Function]";
      }
      function isNumber(num) {
        return typeof num === "number" ? num - num === 0 : false;
      }
      function toVector(arr) {
        return concat.apply([], arr);
      }
      function jStat3() {
        return new jStat3._init(arguments);
      }
      jStat3.fn = jStat3.prototype;
      jStat3._init = function _init(args) {
        if (isArray(args[0])) {
          if (isArray(args[0][0])) {
            if (isFunction(args[1]))
              args[0] = jStat3.map(args[0], args[1]);
            for (var i2 = 0; i2 < args[0].length; i2++)
              this[i2] = args[0][i2];
            this.length = args[0].length;
          } else {
            this[0] = isFunction(args[1]) ? jStat3.map(args[0], args[1]) : args[0];
            this.length = 1;
          }
        } else if (isNumber(args[0])) {
          this[0] = jStat3.seq.apply(null, args);
          this.length = 1;
        } else if (args[0] instanceof jStat3) {
          return jStat3(args[0].toArray());
        } else {
          this[0] = [];
          this.length = 1;
        }
        return this;
      };
      jStat3._init.prototype = jStat3.prototype;
      jStat3._init.constructor = jStat3;
      jStat3.utils = {
        calcRdx,
        isArray,
        isFunction,
        isNumber,
        toVector
      };
      jStat3._random_fn = Math2.random;
      jStat3.setRandom = function setRandom(fn2) {
        if (typeof fn2 !== "function")
          throw new TypeError("fn is not a function");
        jStat3._random_fn = fn2;
      };
      jStat3.extend = function extend2(obj) {
        var i2, j;
        if (arguments.length === 1) {
          for (j in obj)
            jStat3[j] = obj[j];
          return this;
        }
        for (i2 = 1; i2 < arguments.length; i2++) {
          for (j in arguments[i2])
            obj[j] = arguments[i2][j];
        }
        return obj;
      };
      jStat3.rows = function rows(arr) {
        return arr.length || 1;
      };
      jStat3.cols = function cols(arr) {
        return arr[0].length || 1;
      };
      jStat3.dimensions = function dimensions(arr) {
        return {
          rows: jStat3.rows(arr),
          cols: jStat3.cols(arr)
        };
      };
      jStat3.row = function row2(arr, index) {
        if (isArray(index)) {
          return index.map(function(i2) {
            return jStat3.row(arr, i2);
          });
        }
        return arr[index];
      };
      jStat3.rowa = function rowa(arr, i2) {
        return jStat3.row(arr, i2);
      };
      jStat3.col = function col(arr, index) {
        if (isArray(index)) {
          var submat = jStat3.arange(arr.length).map(function() {
            return new Array(index.length);
          });
          index.forEach(function(ind, i3) {
            jStat3.arange(arr.length).forEach(function(j) {
              submat[j][i3] = arr[j][ind];
            });
          });
          return submat;
        }
        var column = new Array(arr.length);
        for (var i2 = 0; i2 < arr.length; i2++)
          column[i2] = [arr[i2][index]];
        return column;
      };
      jStat3.cola = function cola(arr, i2) {
        return jStat3.col(arr, i2).map(function(a2) {
          return a2[0];
        });
      };
      jStat3.diag = function diag(arr) {
        var nrow = jStat3.rows(arr);
        var res = new Array(nrow);
        for (var row2 = 0; row2 < nrow; row2++)
          res[row2] = [arr[row2][row2]];
        return res;
      };
      jStat3.antidiag = function antidiag(arr) {
        var nrow = jStat3.rows(arr) - 1;
        var res = new Array(nrow);
        for (var i2 = 0; nrow >= 0; nrow--, i2++)
          res[i2] = [arr[i2][nrow]];
        return res;
      };
      jStat3.transpose = function transpose(arr) {
        var obj = [];
        var objArr, rows, cols, j, i2;
        if (!isArray(arr[0]))
          arr = [arr];
        rows = arr.length;
        cols = arr[0].length;
        for (i2 = 0; i2 < cols; i2++) {
          objArr = new Array(rows);
          for (j = 0; j < rows; j++)
            objArr[j] = arr[j][i2];
          obj.push(objArr);
        }
        return obj.length === 1 ? obj[0] : obj;
      };
      jStat3.map = function map(arr, func, toAlter) {
        var row2, nrow, ncol, res, col;
        if (!isArray(arr[0]))
          arr = [arr];
        nrow = arr.length;
        ncol = arr[0].length;
        res = toAlter ? arr : new Array(nrow);
        for (row2 = 0; row2 < nrow; row2++) {
          if (!res[row2])
            res[row2] = new Array(ncol);
          for (col = 0; col < ncol; col++)
            res[row2][col] = func(arr[row2][col], row2, col);
        }
        return res.length === 1 ? res[0] : res;
      };
      jStat3.cumreduce = function cumreduce(arr, func, toAlter) {
        var row2, nrow, ncol, res, col;
        if (!isArray(arr[0]))
          arr = [arr];
        nrow = arr.length;
        ncol = arr[0].length;
        res = toAlter ? arr : new Array(nrow);
        for (row2 = 0; row2 < nrow; row2++) {
          if (!res[row2])
            res[row2] = new Array(ncol);
          if (ncol > 0)
            res[row2][0] = arr[row2][0];
          for (col = 1; col < ncol; col++)
            res[row2][col] = func(res[row2][col - 1], arr[row2][col]);
        }
        return res.length === 1 ? res[0] : res;
      };
      jStat3.alter = function alter(arr, func) {
        return jStat3.map(arr, func, true);
      };
      jStat3.create = function create2(rows, cols, func) {
        var res = new Array(rows);
        var i2, j;
        if (isFunction(cols)) {
          func = cols;
          cols = rows;
        }
        for (i2 = 0; i2 < rows; i2++) {
          res[i2] = new Array(cols);
          for (j = 0; j < cols; j++)
            res[i2][j] = func(i2, j);
        }
        return res;
      };
      function retZero() {
        return 0;
      }
      jStat3.zeros = function zeros(rows, cols) {
        if (!isNumber(cols))
          cols = rows;
        return jStat3.create(rows, cols, retZero);
      };
      function retOne() {
        return 1;
      }
      jStat3.ones = function ones(rows, cols) {
        if (!isNumber(cols))
          cols = rows;
        return jStat3.create(rows, cols, retOne);
      };
      jStat3.rand = function rand(rows, cols) {
        if (!isNumber(cols))
          cols = rows;
        return jStat3.create(rows, cols, jStat3._random_fn);
      };
      function retIdent(i2, j) {
        return i2 === j ? 1 : 0;
      }
      jStat3.identity = function identity4(rows, cols) {
        if (!isNumber(cols))
          cols = rows;
        return jStat3.create(rows, cols, retIdent);
      };
      jStat3.symmetric = function symmetric(arr) {
        var size = arr.length;
        var row2, col;
        if (arr.length !== arr[0].length)
          return false;
        for (row2 = 0; row2 < size; row2++) {
          for (col = 0; col < size; col++)
            if (arr[col][row2] !== arr[row2][col])
              return false;
        }
        return true;
      };
      jStat3.clear = function clear(arr) {
        return jStat3.alter(arr, retZero);
      };
      jStat3.seq = function seq(min, max, length, func) {
        if (!isFunction(func))
          func = false;
        var arr = [];
        var hival = calcRdx(min, max);
        var step = (max * hival - min * hival) / ((length - 1) * hival);
        var current = min;
        var cnt;
        for (cnt = 0; current <= max && cnt < length; cnt++, current = (min * hival + step * hival * cnt) / hival) {
          arr.push(func ? func(current, cnt) : current);
        }
        return arr;
      };
      jStat3.arange = function arange(start2, end, step) {
        var rl = [];
        var i2;
        step = step || 1;
        if (end === undefined2) {
          end = start2;
          start2 = 0;
        }
        if (start2 === end || step === 0) {
          return [];
        }
        if (start2 < end && step < 0) {
          return [];
        }
        if (start2 > end && step > 0) {
          return [];
        }
        if (step > 0) {
          for (i2 = start2; i2 < end; i2 += step) {
            rl.push(i2);
          }
        } else {
          for (i2 = start2; i2 > end; i2 += step) {
            rl.push(i2);
          }
        }
        return rl;
      };
      jStat3.slice = /* @__PURE__ */ (function() {
        function _slice(list, start2, end, step) {
          var i2;
          var rl = [];
          var length = list.length;
          if (start2 === undefined2 && end === undefined2 && step === undefined2) {
            return jStat3.copy(list);
          }
          start2 = start2 || 0;
          end = end || list.length;
          start2 = start2 >= 0 ? start2 : length + start2;
          end = end >= 0 ? end : length + end;
          step = step || 1;
          if (start2 === end || step === 0) {
            return [];
          }
          if (start2 < end && step < 0) {
            return [];
          }
          if (start2 > end && step > 0) {
            return [];
          }
          if (step > 0) {
            for (i2 = start2; i2 < end; i2 += step) {
              rl.push(list[i2]);
            }
          } else {
            for (i2 = start2; i2 > end; i2 += step) {
              rl.push(list[i2]);
            }
          }
          return rl;
        }
        function slice2(list, rcSlice) {
          var colSlice, rowSlice;
          rcSlice = rcSlice || {};
          if (isNumber(rcSlice.row)) {
            if (isNumber(rcSlice.col))
              return list[rcSlice.row][rcSlice.col];
            var row2 = jStat3.rowa(list, rcSlice.row);
            colSlice = rcSlice.col || {};
            return _slice(row2, colSlice.start, colSlice.end, colSlice.step);
          }
          if (isNumber(rcSlice.col)) {
            var col = jStat3.cola(list, rcSlice.col);
            rowSlice = rcSlice.row || {};
            return _slice(col, rowSlice.start, rowSlice.end, rowSlice.step);
          }
          rowSlice = rcSlice.row || {};
          colSlice = rcSlice.col || {};
          var rows = _slice(list, rowSlice.start, rowSlice.end, rowSlice.step);
          return rows.map(function(row3) {
            return _slice(row3, colSlice.start, colSlice.end, colSlice.step);
          });
        }
        return slice2;
      })();
      jStat3.sliceAssign = function sliceAssign(A2, rcSlice, B) {
        var nl, ml;
        if (isNumber(rcSlice.row)) {
          if (isNumber(rcSlice.col))
            return A2[rcSlice.row][rcSlice.col] = B;
          rcSlice.col = rcSlice.col || {};
          rcSlice.col.start = rcSlice.col.start || 0;
          rcSlice.col.end = rcSlice.col.end || A2[0].length;
          rcSlice.col.step = rcSlice.col.step || 1;
          nl = jStat3.arange(
            rcSlice.col.start,
            Math2.min(A2.length, rcSlice.col.end),
            rcSlice.col.step
          );
          var m2 = rcSlice.row;
          nl.forEach(function(n3, i2) {
            A2[m2][n3] = B[i2];
          });
          return A2;
        }
        if (isNumber(rcSlice.col)) {
          rcSlice.row = rcSlice.row || {};
          rcSlice.row.start = rcSlice.row.start || 0;
          rcSlice.row.end = rcSlice.row.end || A2.length;
          rcSlice.row.step = rcSlice.row.step || 1;
          ml = jStat3.arange(
            rcSlice.row.start,
            Math2.min(A2[0].length, rcSlice.row.end),
            rcSlice.row.step
          );
          var n2 = rcSlice.col;
          ml.forEach(function(m3, j) {
            A2[m3][n2] = B[j];
          });
          return A2;
        }
        if (B[0].length === undefined2) {
          B = [B];
        }
        rcSlice.row.start = rcSlice.row.start || 0;
        rcSlice.row.end = rcSlice.row.end || A2.length;
        rcSlice.row.step = rcSlice.row.step || 1;
        rcSlice.col.start = rcSlice.col.start || 0;
        rcSlice.col.end = rcSlice.col.end || A2[0].length;
        rcSlice.col.step = rcSlice.col.step || 1;
        ml = jStat3.arange(
          rcSlice.row.start,
          Math2.min(A2.length, rcSlice.row.end),
          rcSlice.row.step
        );
        nl = jStat3.arange(
          rcSlice.col.start,
          Math2.min(A2[0].length, rcSlice.col.end),
          rcSlice.col.step
        );
        ml.forEach(function(m3, i2) {
          nl.forEach(function(n3, j) {
            A2[m3][n3] = B[i2][j];
          });
        });
        return A2;
      };
      jStat3.diagonal = function diagonal(diagArray) {
        var mat = jStat3.zeros(diagArray.length, diagArray.length);
        diagArray.forEach(function(t2, i2) {
          mat[i2][i2] = t2;
        });
        return mat;
      };
      jStat3.copy = function copy2(A2) {
        return A2.map(function(row2) {
          if (isNumber(row2))
            return row2;
          return row2.map(function(t2) {
            return t2;
          });
        });
      };
      var jProto = jStat3.prototype;
      jProto.length = 0;
      jProto.push = Array.prototype.push;
      jProto.sort = Array.prototype.sort;
      jProto.splice = Array.prototype.splice;
      jProto.slice = Array.prototype.slice;
      jProto.toArray = function toArray() {
        return this.length > 1 ? slice.call(this) : slice.call(this)[0];
      };
      jProto.map = function map(func, toAlter) {
        return jStat3(jStat3.map(this, func, toAlter));
      };
      jProto.cumreduce = function cumreduce(func, toAlter) {
        return jStat3(jStat3.cumreduce(this, func, toAlter));
      };
      jProto.alter = function alter(func) {
        jStat3.alter(this, func);
        return this;
      };
      (function(funcs) {
        for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
          jProto[passfunc] = function(func) {
            var self2 = this, results;
            if (func) {
              setTimeout(function() {
                func.call(self2, jProto[passfunc].call(self2));
              });
              return this;
            }
            results = jStat3[passfunc](this);
            return isArray(results) ? jStat3(results) : results;
          };
        })(funcs[i2]);
      })("transpose clear symmetric rows cols dimensions diag antidiag".split(" "));
      (function(funcs) {
        for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
          jProto[passfunc] = function(index, func) {
            var self2 = this;
            if (func) {
              setTimeout(function() {
                func.call(self2, jProto[passfunc].call(self2, index));
              });
              return this;
            }
            return jStat3(jStat3[passfunc](this, index));
          };
        })(funcs[i2]);
      })("row col".split(" "));
      (function(funcs) {
        for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
          jProto[passfunc] = function() {
            return jStat3(jStat3[passfunc].apply(null, arguments));
          };
        })(funcs[i2]);
      })("create zeros ones rand identity".split(" "));
      return jStat3;
    })(Math);
    (function(jStat3, Math2) {
      var isFunction = jStat3.utils.isFunction;
      function ascNum(a2, b2) {
        return a2 - b2;
      }
      function clip(arg, min, max) {
        return Math2.max(min, Math2.min(arg, max));
      }
      jStat3.sum = function sum(arr) {
        var sum2 = 0;
        var i2 = arr.length;
        while (--i2 >= 0)
          sum2 += arr[i2];
        return sum2;
      };
      jStat3.sumsqrd = function sumsqrd(arr) {
        var sum = 0;
        var i2 = arr.length;
        while (--i2 >= 0)
          sum += arr[i2] * arr[i2];
        return sum;
      };
      jStat3.sumsqerr = function sumsqerr(arr) {
        var mean = jStat3.mean(arr);
        var sum = 0;
        var i2 = arr.length;
        var tmp;
        while (--i2 >= 0) {
          tmp = arr[i2] - mean;
          sum += tmp * tmp;
        }
        return sum;
      };
      jStat3.sumrow = function sumrow(arr) {
        var sum = 0;
        var i2 = arr.length;
        while (--i2 >= 0)
          sum += arr[i2];
        return sum;
      };
      jStat3.product = function product(arr) {
        var prod = 1;
        var i2 = arr.length;
        while (--i2 >= 0)
          prod *= arr[i2];
        return prod;
      };
      jStat3.min = function min(arr) {
        var low = arr[0];
        var i2 = 0;
        while (++i2 < arr.length)
          if (arr[i2] < low)
            low = arr[i2];
        return low;
      };
      jStat3.max = function max(arr) {
        var high = arr[0];
        var i2 = 0;
        while (++i2 < arr.length)
          if (arr[i2] > high)
            high = arr[i2];
        return high;
      };
      jStat3.unique = function unique(arr) {
        var hash = {}, _arr = [];
        for (var i2 = 0; i2 < arr.length; i2++) {
          if (!hash[arr[i2]]) {
            hash[arr[i2]] = true;
            _arr.push(arr[i2]);
          }
        }
        return _arr;
      };
      jStat3.mean = function mean(arr) {
        return jStat3.sum(arr) / arr.length;
      };
      jStat3.meansqerr = function meansqerr(arr) {
        return jStat3.sumsqerr(arr) / arr.length;
      };
      jStat3.geomean = function geomean(arr) {
        return Math2.pow(jStat3.product(arr), 1 / arr.length);
      };
      jStat3.median = function median(arr) {
        var arrlen = arr.length;
        var _arr = arr.slice().sort(ascNum);
        return !(arrlen & 1) ? (_arr[arrlen / 2 - 1] + _arr[arrlen / 2]) / 2 : _arr[arrlen / 2 | 0];
      };
      jStat3.cumsum = function cumsum(arr) {
        return jStat3.cumreduce(arr, function(a2, b2) {
          return a2 + b2;
        });
      };
      jStat3.cumprod = function cumprod(arr) {
        return jStat3.cumreduce(arr, function(a2, b2) {
          return a2 * b2;
        });
      };
      jStat3.diff = function diff(arr) {
        var diffs = [];
        var arrLen = arr.length;
        var i2;
        for (i2 = 1; i2 < arrLen; i2++)
          diffs.push(arr[i2] - arr[i2 - 1]);
        return diffs;
      };
      jStat3.rank = function(arr) {
        var i2;
        var distinctNumbers = [];
        var numberCounts = {};
        for (i2 = 0; i2 < arr.length; i2++) {
          var number = arr[i2];
          if (numberCounts[number]) {
            numberCounts[number]++;
          } else {
            numberCounts[number] = 1;
            distinctNumbers.push(number);
          }
        }
        var sortedDistinctNumbers = distinctNumbers.sort(ascNum);
        var numberRanks = {};
        var currentRank = 1;
        for (i2 = 0; i2 < sortedDistinctNumbers.length; i2++) {
          var number = sortedDistinctNumbers[i2];
          var count = numberCounts[number];
          var first = currentRank;
          var last = currentRank + count - 1;
          var rank = (first + last) / 2;
          numberRanks[number] = rank;
          currentRank += count;
        }
        return arr.map(function(number2) {
          return numberRanks[number2];
        });
      };
      jStat3.mode = function mode(arr) {
        var arrLen = arr.length;
        var _arr = arr.slice().sort(ascNum);
        var count = 1;
        var maxCount = 0;
        var numMaxCount = 0;
        var mode_arr = [];
        var i2;
        for (i2 = 0; i2 < arrLen; i2++) {
          if (_arr[i2] === _arr[i2 + 1]) {
            count++;
          } else {
            if (count > maxCount) {
              mode_arr = [_arr[i2]];
              maxCount = count;
              numMaxCount = 0;
            } else if (count === maxCount) {
              mode_arr.push(_arr[i2]);
              numMaxCount++;
            }
            count = 1;
          }
        }
        return numMaxCount === 0 ? mode_arr[0] : mode_arr;
      };
      jStat3.range = function range(arr) {
        return jStat3.max(arr) - jStat3.min(arr);
      };
      jStat3.variance = function variance(arr, flag) {
        return jStat3.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
      };
      jStat3.pooledvariance = function pooledvariance(arr) {
        var sumsqerr = arr.reduce(function(a2, samples) {
          return a2 + jStat3.sumsqerr(samples);
        }, 0);
        var count = arr.reduce(function(a2, samples) {
          return a2 + samples.length;
        }, 0);
        return sumsqerr / (count - arr.length);
      };
      jStat3.deviation = function(arr) {
        var mean = jStat3.mean(arr);
        var arrlen = arr.length;
        var dev = new Array(arrlen);
        for (var i2 = 0; i2 < arrlen; i2++) {
          dev[i2] = arr[i2] - mean;
        }
        return dev;
      };
      jStat3.stdev = function stdev(arr, flag) {
        return Math2.sqrt(jStat3.variance(arr, flag));
      };
      jStat3.pooledstdev = function pooledstdev(arr) {
        return Math2.sqrt(jStat3.pooledvariance(arr));
      };
      jStat3.meandev = function meandev(arr) {
        var mean = jStat3.mean(arr);
        var a2 = [];
        for (var i2 = arr.length - 1; i2 >= 0; i2--) {
          a2.push(Math2.abs(arr[i2] - mean));
        }
        return jStat3.mean(a2);
      };
      jStat3.meddev = function meddev(arr) {
        var median = jStat3.median(arr);
        var a2 = [];
        for (var i2 = arr.length - 1; i2 >= 0; i2--) {
          a2.push(Math2.abs(arr[i2] - median));
        }
        return jStat3.median(a2);
      };
      jStat3.coeffvar = function coeffvar(arr) {
        return jStat3.stdev(arr) / jStat3.mean(arr);
      };
      jStat3.quartiles = function quartiles(arr) {
        var arrlen = arr.length;
        var _arr = arr.slice().sort(ascNum);
        return [
          _arr[Math2.round(arrlen / 4) - 1],
          _arr[Math2.round(arrlen / 2) - 1],
          _arr[Math2.round(arrlen * 3 / 4) - 1]
        ];
      };
      jStat3.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {
        var sortedArray = arr.slice().sort(ascNum);
        var quantileVals = [quantilesArray.length];
        var n2 = arr.length;
        var i2, p2, m2, aleph, k2, gamma2;
        if (typeof alphap === "undefined")
          alphap = 3 / 8;
        if (typeof betap === "undefined")
          betap = 3 / 8;
        for (i2 = 0; i2 < quantilesArray.length; i2++) {
          p2 = quantilesArray[i2];
          m2 = alphap + p2 * (1 - alphap - betap);
          aleph = n2 * p2 + m2;
          k2 = Math2.floor(clip(aleph, 1, n2 - 1));
          gamma2 = clip(aleph - k2, 0, 1);
          quantileVals[i2] = (1 - gamma2) * sortedArray[k2 - 1] + gamma2 * sortedArray[k2];
        }
        return quantileVals;
      };
      jStat3.percentile = function percentile(arr, k2, exclusive) {
        var _arr = arr.slice().sort(ascNum);
        var realIndex = k2 * (_arr.length + (exclusive ? 1 : -1)) + (exclusive ? 0 : 1);
        var index = parseInt(realIndex);
        var frac = realIndex - index;
        if (index + 1 < _arr.length) {
          return _arr[index - 1] + frac * (_arr[index] - _arr[index - 1]);
        } else {
          return _arr[index - 1];
        }
      };
      jStat3.percentileOfScore = function percentileOfScore(arr, score, kind) {
        var counter = 0;
        var len = arr.length;
        var strict = false;
        var value, i2;
        if (kind === "strict")
          strict = true;
        for (i2 = 0; i2 < len; i2++) {
          value = arr[i2];
          if (strict && value < score || !strict && value <= score) {
            counter++;
          }
        }
        return counter / len;
      };
      jStat3.histogram = function histogram(arr, binCnt) {
        binCnt = binCnt || 4;
        var first = jStat3.min(arr);
        var binWidth = (jStat3.max(arr) - first) / binCnt;
        var len = arr.length;
        var bins = [];
        var i2;
        for (i2 = 0; i2 < binCnt; i2++)
          bins[i2] = 0;
        for (i2 = 0; i2 < len; i2++)
          bins[Math2.min(Math2.floor((arr[i2] - first) / binWidth), binCnt - 1)] += 1;
        return bins;
      };
      jStat3.covariance = function covariance(arr1, arr2) {
        var u2 = jStat3.mean(arr1);
        var v2 = jStat3.mean(arr2);
        var arr1Len = arr1.length;
        var sq_dev = new Array(arr1Len);
        var i2;
        for (i2 = 0; i2 < arr1Len; i2++)
          sq_dev[i2] = (arr1[i2] - u2) * (arr2[i2] - v2);
        return jStat3.sum(sq_dev) / (arr1Len - 1);
      };
      jStat3.corrcoeff = function corrcoeff(arr1, arr2) {
        return jStat3.covariance(arr1, arr2) / jStat3.stdev(arr1, 1) / jStat3.stdev(arr2, 1);
      };
      jStat3.spearmancoeff = function(arr1, arr2) {
        arr1 = jStat3.rank(arr1);
        arr2 = jStat3.rank(arr2);
        return jStat3.corrcoeff(arr1, arr2);
      };
      jStat3.stanMoment = function stanMoment(arr, n2) {
        var mu = jStat3.mean(arr);
        var sigma = jStat3.stdev(arr);
        var len = arr.length;
        var skewSum = 0;
        for (var i2 = 0; i2 < len; i2++)
          skewSum += Math2.pow((arr[i2] - mu) / sigma, n2);
        return skewSum / arr.length;
      };
      jStat3.skewness = function skewness(arr) {
        return jStat3.stanMoment(arr, 3);
      };
      jStat3.kurtosis = function kurtosis(arr) {
        return jStat3.stanMoment(arr, 4) - 3;
      };
      var jProto = jStat3.prototype;
      (function(funcs) {
        for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
          jProto[passfunc] = function(fullbool, func) {
            var arr = [];
            var i3 = 0;
            var tmpthis = this;
            if (isFunction(fullbool)) {
              func = fullbool;
              fullbool = false;
            }
            if (func) {
              setTimeout(function() {
                func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
              });
              return this;
            }
            if (this.length > 1) {
              tmpthis = fullbool === true ? this : this.transpose();
              for (; i3 < tmpthis.length; i3++)
                arr[i3] = jStat3[passfunc](tmpthis[i3]);
              return arr;
            }
            return jStat3[passfunc](this[0], fullbool);
          };
        })(funcs[i2]);
      })("cumsum cumprod".split(" "));
      (function(funcs) {
        for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
          jProto[passfunc] = function(fullbool, func) {
            var arr = [];
            var i3 = 0;
            var tmpthis = this;
            if (isFunction(fullbool)) {
              func = fullbool;
              fullbool = false;
            }
            if (func) {
              setTimeout(function() {
                func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
              });
              return this;
            }
            if (this.length > 1) {
              if (passfunc !== "sumrow")
                tmpthis = fullbool === true ? this : this.transpose();
              for (; i3 < tmpthis.length; i3++)
                arr[i3] = jStat3[passfunc](tmpthis[i3]);
              return fullbool === true ? jStat3[passfunc](jStat3.utils.toVector(arr)) : arr;
            }
            return jStat3[passfunc](this[0], fullbool);
          };
        })(funcs[i2]);
      })("sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr geomean median diff rank mode range variance deviation stdev meandev meddev coeffvar quartiles histogram skewness kurtosis".split(" "));
      (function(funcs) {
        for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
          jProto[passfunc] = function() {
            var arr = [];
            var i3 = 0;
            var tmpthis = this;
            var args = Array.prototype.slice.call(arguments);
            var callbackFunction;
            if (isFunction(args[args.length - 1])) {
              callbackFunction = args[args.length - 1];
              var argsToPass = args.slice(0, args.length - 1);
              setTimeout(function() {
                callbackFunction.call(
                  tmpthis,
                  jProto[passfunc].apply(tmpthis, argsToPass)
                );
              });
              return this;
            } else {
              callbackFunction = void 0;
              var curriedFunction = function curriedFunction2(vector) {
                return jStat3[passfunc].apply(tmpthis, [vector].concat(args));
              };
            }
            if (this.length > 1) {
              tmpthis = tmpthis.transpose();
              for (; i3 < tmpthis.length; i3++)
                arr[i3] = curriedFunction(tmpthis[i3]);
              return arr;
            }
            return curriedFunction(this[0]);
          };
        })(funcs[i2]);
      })("quantiles percentileOfScore".split(" "));
    })(jStat2, Math);
    (function(jStat3, Math2) {
      jStat3.gammaln = function gammaln(x2) {
        var j = 0;
        var cof = [
          76.18009172947146,
          -86.50532032941678,
          24.01409824083091,
          -1.231739572450155,
          0.001208650973866179,
          -5395239384953e-18
        ];
        var ser = 1.000000000190015;
        var xx, y2, tmp;
        tmp = (y2 = xx = x2) + 5.5;
        tmp -= (xx + 0.5) * Math2.log(tmp);
        for (; j < 6; j++)
          ser += cof[j] / ++y2;
        return Math2.log(2.5066282746310007 * ser / xx) - tmp;
      };
      jStat3.loggam = function loggam(x2) {
        var x0, x22, xp, gl, gl0;
        var k2, n2;
        var a2 = [
          0.08333333333333333,
          -0.002777777777777778,
          7936507936507937e-19,
          -5952380952380952e-19,
          8417508417508418e-19,
          -0.001917526917526918,
          0.00641025641025641,
          -0.02955065359477124,
          0.1796443723688307,
          -1.3924322169059
        ];
        x0 = x2;
        n2 = 0;
        if (x2 == 1 || x2 == 2) {
          return 0;
        }
        if (x2 <= 7) {
          n2 = Math2.floor(7 - x2);
          x0 = x2 + n2;
        }
        x22 = 1 / (x0 * x0);
        xp = 2 * Math2.PI;
        gl0 = a2[9];
        for (k2 = 8; k2 >= 0; k2--) {
          gl0 *= x22;
          gl0 += a2[k2];
        }
        gl = gl0 / x0 + 0.5 * Math2.log(xp) + (x0 - 0.5) * Math2.log(x0) - x0;
        if (x2 <= 7) {
          for (k2 = 1; k2 <= n2; k2++) {
            gl -= Math2.log(x0 - 1);
            x0 -= 1;
          }
        }
        return gl;
      };
      jStat3.gammafn = function gammafn(x2) {
        var p2 = [
          -1.716185138865495,
          24.76565080557592,
          -379.80425647094563,
          629.3311553128184,
          866.9662027904133,
          -31451.272968848367,
          -36144.413418691176,
          66456.14382024054
        ];
        var q = [
          -30.8402300119739,
          315.35062697960416,
          -1015.1563674902192,
          -3107.771671572311,
          22538.11842098015,
          4755.846277527881,
          -134659.9598649693,
          -115132.2596755535
        ];
        var fact = false;
        var n2 = 0;
        var xden = 0;
        var xnum = 0;
        var y2 = x2;
        var i2, z, yi, res;
        if (x2 > 171.6243769536076) {
          return Infinity;
        }
        if (y2 <= 0) {
          res = y2 % 1 + 36e-17;
          if (res) {
            fact = (!(y2 & 1) ? 1 : -1) * Math2.PI / Math2.sin(Math2.PI * res);
            y2 = 1 - y2;
          } else {
            return Infinity;
          }
        }
        yi = y2;
        if (y2 < 1) {
          z = y2++;
        } else {
          z = (y2 -= n2 = (y2 | 0) - 1) - 1;
        }
        for (i2 = 0; i2 < 8; ++i2) {
          xnum = (xnum + p2[i2]) * z;
          xden = xden * z + q[i2];
        }
        res = xnum / xden + 1;
        if (yi < y2) {
          res /= yi;
        } else if (yi > y2) {
          for (i2 = 0; i2 < n2; ++i2) {
            res *= y2;
            y2++;
          }
        }
        if (fact) {
          res = fact / res;
        }
        return res;
      };
      jStat3.gammap = function gammap(a2, x2) {
        return jStat3.lowRegGamma(a2, x2) * jStat3.gammafn(a2);
      };
      jStat3.lowRegGamma = function lowRegGamma(a2, x2) {
        var aln = jStat3.gammaln(a2);
        var ap = a2;
        var sum = 1 / a2;
        var del = sum;
        var b2 = x2 + 1 - a2;
        var c2 = 1 / 1e-30;
        var d2 = 1 / b2;
        var h2 = d2;
        var i2 = 1;
        var ITMAX = -~(Math2.log(a2 >= 1 ? a2 : 1 / a2) * 8.5 + a2 * 0.4 + 17);
        var an;
        if (x2 < 0 || a2 <= 0) {
          return NaN;
        } else if (x2 < a2 + 1) {
          for (; i2 <= ITMAX; i2++) {
            sum += del *= x2 / ++ap;
          }
          return sum * Math2.exp(-x2 + a2 * Math2.log(x2) - aln);
        }
        for (; i2 <= ITMAX; i2++) {
          an = -i2 * (i2 - a2);
          b2 += 2;
          d2 = an * d2 + b2;
          c2 = b2 + an / c2;
          d2 = 1 / d2;
          h2 *= d2 * c2;
        }
        return 1 - h2 * Math2.exp(-x2 + a2 * Math2.log(x2) - aln);
      };
      jStat3.factorialln = function factorialln(n2) {
        return n2 < 0 ? NaN : jStat3.gammaln(n2 + 1);
      };
      jStat3.factorial = function factorial2(n2) {
        return n2 < 0 ? NaN : jStat3.gammafn(n2 + 1);
      };
      jStat3.combination = function combination(n2, m2) {
        return n2 > 170 || m2 > 170 ? Math2.exp(jStat3.combinationln(n2, m2)) : jStat3.factorial(n2) / jStat3.factorial(m2) / jStat3.factorial(n2 - m2);
      };
      jStat3.combinationln = function combinationln(n2, m2) {
        return jStat3.factorialln(n2) - jStat3.factorialln(m2) - jStat3.factorialln(n2 - m2);
      };
      jStat3.permutation = function permutation(n2, m2) {
        return jStat3.factorial(n2) / jStat3.factorial(n2 - m2);
      };
      jStat3.betafn = function betafn(x2, y2) {
        if (x2 <= 0 || y2 <= 0)
          return void 0;
        return x2 + y2 > 170 ? Math2.exp(jStat3.betaln(x2, y2)) : jStat3.gammafn(x2) * jStat3.gammafn(y2) / jStat3.gammafn(x2 + y2);
      };
      jStat3.betaln = function betaln(x2, y2) {
        return jStat3.gammaln(x2) + jStat3.gammaln(y2) - jStat3.gammaln(x2 + y2);
      };
      jStat3.betacf = function betacf(x2, a2, b2) {
        var fpmin = 1e-30;
        var m2 = 1;
        var qab = a2 + b2;
        var qap = a2 + 1;
        var qam = a2 - 1;
        var c2 = 1;
        var d2 = 1 - qab * x2 / qap;
        var m22, aa, del, h2;
        if (Math2.abs(d2) < fpmin)
          d2 = fpmin;
        d2 = 1 / d2;
        h2 = d2;
        for (; m2 <= 100; m2++) {
          m22 = 2 * m2;
          aa = m2 * (b2 - m2) * x2 / ((qam + m22) * (a2 + m22));
          d2 = 1 + aa * d2;
          if (Math2.abs(d2) < fpmin)
            d2 = fpmin;
          c2 = 1 + aa / c2;
          if (Math2.abs(c2) < fpmin)
            c2 = fpmin;
          d2 = 1 / d2;
          h2 *= d2 * c2;
          aa = -(a2 + m2) * (qab + m2) * x2 / ((a2 + m22) * (qap + m22));
          d2 = 1 + aa * d2;
          if (Math2.abs(d2) < fpmin)
            d2 = fpmin;
          c2 = 1 + aa / c2;
          if (Math2.abs(c2) < fpmin)
            c2 = fpmin;
          d2 = 1 / d2;
          del = d2 * c2;
          h2 *= del;
          if (Math2.abs(del - 1) < 3e-7)
            break;
        }
        return h2;
      };
      jStat3.gammapinv = function gammapinv(p2, a2) {
        var j = 0;
        var a1 = a2 - 1;
        var EPS = 1e-8;
        var gln = jStat3.gammaln(a2);
        var x2, err, t2, u2, pp, lna1, afac;
        if (p2 >= 1)
          return Math2.max(100, a2 + 100 * Math2.sqrt(a2));
        if (p2 <= 0)
          return 0;
        if (a2 > 1) {
          lna1 = Math2.log(a1);
          afac = Math2.exp(a1 * (lna1 - 1) - gln);
          pp = p2 < 0.5 ? p2 : 1 - p2;
          t2 = Math2.sqrt(-2 * Math2.log(pp));
          x2 = (2.30753 + t2 * 0.27061) / (1 + t2 * (0.99229 + t2 * 0.04481)) - t2;
          if (p2 < 0.5)
            x2 = -x2;
          x2 = Math2.max(
            1e-3,
            a2 * Math2.pow(1 - 1 / (9 * a2) - x2 / (3 * Math2.sqrt(a2)), 3)
          );
        } else {
          t2 = 1 - a2 * (0.253 + a2 * 0.12);
          if (p2 < t2)
            x2 = Math2.pow(p2 / t2, 1 / a2);
          else
            x2 = 1 - Math2.log(1 - (p2 - t2) / (1 - t2));
        }
        for (; j < 12; j++) {
          if (x2 <= 0)
            return 0;
          err = jStat3.lowRegGamma(a2, x2) - p2;
          if (a2 > 1)
            t2 = afac * Math2.exp(-(x2 - a1) + a1 * (Math2.log(x2) - lna1));
          else
            t2 = Math2.exp(-x2 + a1 * Math2.log(x2) - gln);
          u2 = err / t2;
          x2 -= t2 = u2 / (1 - 0.5 * Math2.min(1, u2 * ((a2 - 1) / x2 - 1)));
          if (x2 <= 0)
            x2 = 0.5 * (x2 + t2);
          if (Math2.abs(t2) < EPS * x2)
            break;
        }
        return x2;
      };
      jStat3.erf = function erf(x2) {
        var cof = [
          -1.3026537197817094,
          0.6419697923564902,
          0.019476473204185836,
          -0.00956151478680863,
          -946595344482036e-18,
          366839497852761e-18,
          42523324806907e-18,
          -20278578112534e-18,
          -1624290004647e-18,
          130365583558e-17,
          15626441722e-18,
          -85238095915e-18,
          6529054439e-18,
          5059343495e-18,
          -991364156e-18,
          -227365122e-18,
          96467911e-18,
          2394038e-18,
          -6886027e-18,
          894487e-18,
          313092e-18,
          -112708e-18,
          381e-18,
          7106e-18,
          -1523e-18,
          -94e-18,
          121e-18,
          -28e-18
        ];
        var j = cof.length - 1;
        var isneg = false;
        var d2 = 0;
        var dd = 0;
        var t2, ty, tmp, res;
        if (x2 < 0) {
          x2 = -x2;
          isneg = true;
        }
        t2 = 2 / (2 + x2);
        ty = 4 * t2 - 2;
        for (; j > 0; j--) {
          tmp = d2;
          d2 = ty * d2 - dd + cof[j];
          dd = tmp;
        }
        res = t2 * Math2.exp(-x2 * x2 + 0.5 * (cof[0] + ty * d2) - dd);
        return isneg ? res - 1 : 1 - res;
      };
      jStat3.erfc = function erfc(x2) {
        return 1 - jStat3.erf(x2);
      };
      jStat3.erfcinv = function erfcinv(p2) {
        var j = 0;
        var x2, err, t2, pp;
        if (p2 >= 2)
          return -100;
        if (p2 <= 0)
          return 100;
        pp = p2 < 1 ? p2 : 2 - p2;
        t2 = Math2.sqrt(-2 * Math2.log(pp / 2));
        x2 = -0.70711 * ((2.30753 + t2 * 0.27061) / (1 + t2 * (0.99229 + t2 * 0.04481)) - t2);
        for (; j < 2; j++) {
          err = jStat3.erfc(x2) - pp;
          x2 += err / (1.1283791670955126 * Math2.exp(-x2 * x2) - x2 * err);
        }
        return p2 < 1 ? x2 : -x2;
      };
      jStat3.ibetainv = function ibetainv(p2, a2, b2) {
        var EPS = 1e-8;
        var a1 = a2 - 1;
        var b1 = b2 - 1;
        var j = 0;
        var lna, lnb, pp, t2, u2, err, x2, al, h2, w2, afac;
        if (p2 <= 0)
          return 0;
        if (p2 >= 1)
          return 1;
        if (a2 >= 1 && b2 >= 1) {
          pp = p2 < 0.5 ? p2 : 1 - p2;
          t2 = Math2.sqrt(-2 * Math2.log(pp));
          x2 = (2.30753 + t2 * 0.27061) / (1 + t2 * (0.99229 + t2 * 0.04481)) - t2;
          if (p2 < 0.5)
            x2 = -x2;
          al = (x2 * x2 - 3) / 6;
          h2 = 2 / (1 / (2 * a2 - 1) + 1 / (2 * b2 - 1));
          w2 = x2 * Math2.sqrt(al + h2) / h2 - (1 / (2 * b2 - 1) - 1 / (2 * a2 - 1)) * (al + 5 / 6 - 2 / (3 * h2));
          x2 = a2 / (a2 + b2 * Math2.exp(2 * w2));
        } else {
          lna = Math2.log(a2 / (a2 + b2));
          lnb = Math2.log(b2 / (a2 + b2));
          t2 = Math2.exp(a2 * lna) / a2;
          u2 = Math2.exp(b2 * lnb) / b2;
          w2 = t2 + u2;
          if (p2 < t2 / w2)
            x2 = Math2.pow(a2 * w2 * p2, 1 / a2);
          else
            x2 = 1 - Math2.pow(b2 * w2 * (1 - p2), 1 / b2);
        }
        afac = -jStat3.gammaln(a2) - jStat3.gammaln(b2) + jStat3.gammaln(a2 + b2);
        for (; j < 10; j++) {
          if (x2 === 0 || x2 === 1)
            return x2;
          err = jStat3.ibeta(x2, a2, b2) - p2;
          t2 = Math2.exp(a1 * Math2.log(x2) + b1 * Math2.log(1 - x2) + afac);
          u2 = err / t2;
          x2 -= t2 = u2 / (1 - 0.5 * Math2.min(1, u2 * (a1 / x2 - b1 / (1 - x2))));
          if (x2 <= 0)
            x2 = 0.5 * (x2 + t2);
          if (x2 >= 1)
            x2 = 0.5 * (x2 + t2 + 1);
          if (Math2.abs(t2) < EPS * x2 && j > 0)
            break;
        }
        return x2;
      };
      jStat3.ibeta = function ibeta(x2, a2, b2) {
        var bt = x2 === 0 || x2 === 1 ? 0 : Math2.exp(jStat3.gammaln(a2 + b2) - jStat3.gammaln(a2) - jStat3.gammaln(b2) + a2 * Math2.log(x2) + b2 * Math2.log(1 - x2));
        if (x2 < 0 || x2 > 1)
          return false;
        if (x2 < (a2 + 1) / (a2 + b2 + 2))
          return bt * jStat3.betacf(x2, a2, b2) / a2;
        return 1 - bt * jStat3.betacf(1 - x2, b2, a2) / b2;
      };
      jStat3.randn = function randn(n2, m2) {
        var u2, v2, x2, y2, q;
        if (!m2)
          m2 = n2;
        if (n2)
          return jStat3.create(n2, m2, function() {
            return jStat3.randn();
          });
        do {
          u2 = jStat3._random_fn();
          v2 = 1.7156 * (jStat3._random_fn() - 0.5);
          x2 = u2 - 0.449871;
          y2 = Math2.abs(v2) + 0.386595;
          q = x2 * x2 + y2 * (0.196 * y2 - 0.25472 * x2);
        } while (q > 0.27597 && (q > 0.27846 || v2 * v2 > -4 * Math2.log(u2) * u2 * u2));
        return v2 / u2;
      };
      jStat3.randg = function randg(shape, n2, m2) {
        var oalph = shape;
        var a1, a2, u2, v2, x2, mat;
        if (!m2)
          m2 = n2;
        if (!shape)
          shape = 1;
        if (n2) {
          mat = jStat3.zeros(n2, m2);
          mat.alter(function() {
            return jStat3.randg(shape);
          });
          return mat;
        }
        if (shape < 1)
          shape += 1;
        a1 = shape - 1 / 3;
        a2 = 1 / Math2.sqrt(9 * a1);
        do {
          do {
            x2 = jStat3.randn();
            v2 = 1 + a2 * x2;
          } while (v2 <= 0);
          v2 = v2 * v2 * v2;
          u2 = jStat3._random_fn();
        } while (u2 > 1 - 0.331 * Math2.pow(x2, 4) && Math2.log(u2) > 0.5 * x2 * x2 + a1 * (1 - v2 + Math2.log(v2)));
        if (shape == oalph)
          return a1 * v2;
        do {
          u2 = jStat3._random_fn();
        } while (u2 === 0);
        return Math2.pow(u2, 1 / oalph) * a1 * v2;
      };
      (function(funcs) {
        for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
          jStat3.fn[passfunc] = function() {
            return jStat3(
              jStat3.map(this, function(value) {
                return jStat3[passfunc](value);
              })
            );
          };
        })(funcs[i2]);
      })("gammaln gammafn factorial factorialln".split(" "));
      (function(funcs) {
        for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
          jStat3.fn[passfunc] = function() {
            return jStat3(jStat3[passfunc].apply(null, arguments));
          };
        })(funcs[i2]);
      })("randn".split(" "));
    })(jStat2, Math);
    (function(jStat3, Math2) {
      (function(list) {
        for (var i2 = 0; i2 < list.length; i2++) (function(func) {
          jStat3[func] = function f2(a2, b2, c2) {
            if (!(this instanceof f2))
              return new f2(a2, b2, c2);
            this._a = a2;
            this._b = b2;
            this._c = c2;
            return this;
          };
          jStat3.fn[func] = function(a2, b2, c2) {
            var newthis = jStat3[func](a2, b2, c2);
            newthis.data = this;
            return newthis;
          };
          jStat3[func].prototype.sample = function(arr) {
            var a2 = this._a;
            var b2 = this._b;
            var c2 = this._c;
            if (arr)
              return jStat3.alter(arr, function() {
                return jStat3[func].sample(a2, b2, c2);
              });
            else
              return jStat3[func].sample(a2, b2, c2);
          };
          (function(vals) {
            for (var i3 = 0; i3 < vals.length; i3++) (function(fnfunc) {
              jStat3[func].prototype[fnfunc] = function(x2) {
                var a2 = this._a;
                var b2 = this._b;
                var c2 = this._c;
                if (!x2 && x2 !== 0)
                  x2 = this.data;
                if (typeof x2 !== "number") {
                  return jStat3.fn.map.call(x2, function(x3) {
                    return jStat3[func][fnfunc](x3, a2, b2, c2);
                  });
                }
                return jStat3[func][fnfunc](x2, a2, b2, c2);
              };
            })(vals[i3]);
          })("pdf cdf inv".split(" "));
          (function(vals) {
            for (var i3 = 0; i3 < vals.length; i3++) (function(fnfunc) {
              jStat3[func].prototype[fnfunc] = function() {
                return jStat3[func][fnfunc](this._a, this._b, this._c);
              };
            })(vals[i3]);
          })("mean median mode variance".split(" "));
        })(list[i2]);
      })("beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy laplace lognormal noncentralt normal pareto studentt weibull uniform binomial negbin hypgeom poisson triangular tukey arcsine".split(" "));
      jStat3.extend(jStat3.beta, {
        pdf: function pdf(x2, alpha, beta) {
          if (x2 > 1 || x2 < 0)
            return 0;
          if (alpha == 1 && beta == 1)
            return 1;
          if (alpha < 512 && beta < 512) {
            return Math2.pow(x2, alpha - 1) * Math2.pow(1 - x2, beta - 1) / jStat3.betafn(alpha, beta);
          } else {
            return Math2.exp((alpha - 1) * Math2.log(x2) + (beta - 1) * Math2.log(1 - x2) - jStat3.betaln(alpha, beta));
          }
        },
        cdf: function cdf(x2, alpha, beta) {
          return x2 > 1 || x2 < 0 ? (x2 > 1) * 1 : jStat3.ibeta(x2, alpha, beta);
        },
        inv: function inv(x2, alpha, beta) {
          return jStat3.ibetainv(x2, alpha, beta);
        },
        mean: function mean(alpha, beta) {
          return alpha / (alpha + beta);
        },
        median: function median(alpha, beta) {
          return jStat3.ibetainv(0.5, alpha, beta);
        },
        mode: function mode(alpha, beta) {
          return (alpha - 1) / (alpha + beta - 2);
        },
        // return a random sample
        sample: function sample(alpha, beta) {
          var u2 = jStat3.randg(alpha);
          return u2 / (u2 + jStat3.randg(beta));
        },
        variance: function variance(alpha, beta) {
          return alpha * beta / (Math2.pow(alpha + beta, 2) * (alpha + beta + 1));
        }
      });
      jStat3.extend(jStat3.centralF, {
        // This implementation of the pdf function avoids float overflow
        // See the way that R calculates this value:
        // https://svn.r-project.org/R/trunk/src/nmath/df.c
        pdf: function pdf(x2, df1, df2) {
          var p2, q, f2;
          if (x2 < 0)
            return 0;
          if (df1 <= 2) {
            if (x2 === 0 && df1 < 2) {
              return Infinity;
            }
            if (x2 === 0 && df1 === 2) {
              return 1;
            }
            return 1 / jStat3.betafn(df1 / 2, df2 / 2) * Math2.pow(df1 / df2, df1 / 2) * Math2.pow(x2, df1 / 2 - 1) * Math2.pow(1 + df1 / df2 * x2, -(df1 + df2) / 2);
          }
          p2 = df1 * x2 / (df2 + x2 * df1);
          q = df2 / (df2 + x2 * df1);
          f2 = df1 * q / 2;
          return f2 * jStat3.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p2);
        },
        cdf: function cdf(x2, df1, df2) {
          if (x2 < 0)
            return 0;
          return jStat3.ibeta(df1 * x2 / (df1 * x2 + df2), df1 / 2, df2 / 2);
        },
        inv: function inv(x2, df1, df2) {
          return df2 / (df1 * (1 / jStat3.ibetainv(x2, df1 / 2, df2 / 2) - 1));
        },
        mean: function mean(df1, df2) {
          return df2 > 2 ? df2 / (df2 - 2) : void 0;
        },
        mode: function mode(df1, df2) {
          return df1 > 2 ? df2 * (df1 - 2) / (df1 * (df2 + 2)) : void 0;
        },
        // return a random sample
        sample: function sample(df1, df2) {
          var x1 = jStat3.randg(df1 / 2) * 2;
          var x2 = jStat3.randg(df2 / 2) * 2;
          return x1 / df1 / (x2 / df2);
        },
        variance: function variance(df1, df2) {
          if (df2 <= 4)
            return void 0;
          return 2 * df2 * df2 * (df1 + df2 - 2) / (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));
        }
      });
      jStat3.extend(jStat3.cauchy, {
        pdf: function pdf(x2, local, scale) {
          if (scale < 0) {
            return 0;
          }
          return scale / (Math2.pow(x2 - local, 2) + Math2.pow(scale, 2)) / Math2.PI;
        },
        cdf: function cdf(x2, local, scale) {
          return Math2.atan((x2 - local) / scale) / Math2.PI + 0.5;
        },
        inv: function(p2, local, scale) {
          return local + scale * Math2.tan(Math2.PI * (p2 - 0.5));
        },
        median: function median(local) {
          return local;
        },
        mode: function mode(local) {
          return local;
        },
        sample: function sample(local, scale) {
          return jStat3.randn() * Math2.sqrt(1 / (2 * jStat3.randg(0.5))) * scale + local;
        }
      });
      jStat3.extend(jStat3.chisquare, {
        pdf: function pdf(x2, dof) {
          if (x2 < 0)
            return 0;
          return x2 === 0 && dof === 2 ? 0.5 : Math2.exp((dof / 2 - 1) * Math2.log(x2) - x2 / 2 - dof / 2 * Math2.log(2) - jStat3.gammaln(dof / 2));
        },
        cdf: function cdf(x2, dof) {
          if (x2 < 0)
            return 0;
          return jStat3.lowRegGamma(dof / 2, x2 / 2);
        },
        inv: function(p2, dof) {
          return 2 * jStat3.gammapinv(p2, 0.5 * dof);
        },
        mean: function(dof) {
          return dof;
        },
        // TODO: this is an approximation (is there a better way?)
        median: function median(dof) {
          return dof * Math2.pow(1 - 2 / (9 * dof), 3);
        },
        mode: function mode(dof) {
          return dof - 2 > 0 ? dof - 2 : 0;
        },
        sample: function sample(dof) {
          return jStat3.randg(dof / 2) * 2;
        },
        variance: function variance(dof) {
          return 2 * dof;
        }
      });
      jStat3.extend(jStat3.exponential, {
        pdf: function pdf(x2, rate) {
          return x2 < 0 ? 0 : rate * Math2.exp(-rate * x2);
        },
        cdf: function cdf(x2, rate) {
          return x2 < 0 ? 0 : 1 - Math2.exp(-rate * x2);
        },
        inv: function(p2, rate) {
          return -Math2.log(1 - p2) / rate;
        },
        mean: function(rate) {
          return 1 / rate;
        },
        median: function(rate) {
          return 1 / rate * Math2.log(2);
        },
        mode: function mode() {
          return 0;
        },
        sample: function sample(rate) {
          return -1 / rate * Math2.log(jStat3._random_fn());
        },
        variance: function(rate) {
          return Math2.pow(rate, -2);
        }
      });
      jStat3.extend(jStat3.gamma, {
        pdf: function pdf(x2, shape, scale) {
          if (x2 < 0)
            return 0;
          return x2 === 0 && shape === 1 ? 1 / scale : Math2.exp((shape - 1) * Math2.log(x2) - x2 / scale - jStat3.gammaln(shape) - shape * Math2.log(scale));
        },
        cdf: function cdf(x2, shape, scale) {
          if (x2 < 0)
            return 0;
          return jStat3.lowRegGamma(shape, x2 / scale);
        },
        inv: function(p2, shape, scale) {
          return jStat3.gammapinv(p2, shape) * scale;
        },
        mean: function(shape, scale) {
          return shape * scale;
        },
        mode: function mode(shape, scale) {
          if (shape > 1) return (shape - 1) * scale;
          return void 0;
        },
        sample: function sample(shape, scale) {
          return jStat3.randg(shape) * scale;
        },
        variance: function variance(shape, scale) {
          return shape * scale * scale;
        }
      });
      jStat3.extend(jStat3.invgamma, {
        pdf: function pdf(x2, shape, scale) {
          if (x2 <= 0)
            return 0;
          return Math2.exp(-(shape + 1) * Math2.log(x2) - scale / x2 - jStat3.gammaln(shape) + shape * Math2.log(scale));
        },
        cdf: function cdf(x2, shape, scale) {
          if (x2 <= 0)
            return 0;
          return 1 - jStat3.lowRegGamma(shape, scale / x2);
        },
        inv: function(p2, shape, scale) {
          return scale / jStat3.gammapinv(1 - p2, shape);
        },
        mean: function(shape, scale) {
          return shape > 1 ? scale / (shape - 1) : void 0;
        },
        mode: function mode(shape, scale) {
          return scale / (shape + 1);
        },
        sample: function sample(shape, scale) {
          return scale / jStat3.randg(shape);
        },
        variance: function variance(shape, scale) {
          if (shape <= 2)
            return void 0;
          return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));
        }
      });
      jStat3.extend(jStat3.kumaraswamy, {
        pdf: function pdf(x2, alpha, beta) {
          if (x2 === 0 && alpha === 1)
            return beta;
          else if (x2 === 1 && beta === 1)
            return alpha;
          return Math2.exp(Math2.log(alpha) + Math2.log(beta) + (alpha - 1) * Math2.log(x2) + (beta - 1) * Math2.log(1 - Math2.pow(x2, alpha)));
        },
        cdf: function cdf(x2, alpha, beta) {
          if (x2 < 0)
            return 0;
          else if (x2 > 1)
            return 1;
          return 1 - Math2.pow(1 - Math2.pow(x2, alpha), beta);
        },
        inv: function inv(p2, alpha, beta) {
          return Math2.pow(1 - Math2.pow(1 - p2, 1 / beta), 1 / alpha);
        },
        mean: function(alpha, beta) {
          return beta * jStat3.gammafn(1 + 1 / alpha) * jStat3.gammafn(beta) / jStat3.gammafn(1 + 1 / alpha + beta);
        },
        median: function median(alpha, beta) {
          return Math2.pow(1 - Math2.pow(2, -1 / beta), 1 / alpha);
        },
        mode: function mode(alpha, beta) {
          if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))
            return void 0;
          return Math2.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);
        },
        variance: function variance() {
          throw new Error("variance not yet implemented");
        }
      });
      jStat3.extend(jStat3.lognormal, {
        pdf: function pdf(x2, mu, sigma) {
          if (x2 <= 0)
            return 0;
          return Math2.exp(-Math2.log(x2) - 0.5 * Math2.log(2 * Math2.PI) - Math2.log(sigma) - Math2.pow(Math2.log(x2) - mu, 2) / (2 * sigma * sigma));
        },
        cdf: function cdf(x2, mu, sigma) {
          if (x2 < 0)
            return 0;
          return 0.5 + 0.5 * jStat3.erf((Math2.log(x2) - mu) / Math2.sqrt(2 * sigma * sigma));
        },
        inv: function(p2, mu, sigma) {
          return Math2.exp(-1.4142135623730951 * sigma * jStat3.erfcinv(2 * p2) + mu);
        },
        mean: function mean(mu, sigma) {
          return Math2.exp(mu + sigma * sigma / 2);
        },
        median: function median(mu) {
          return Math2.exp(mu);
        },
        mode: function mode(mu, sigma) {
          return Math2.exp(mu - sigma * sigma);
        },
        sample: function sample(mu, sigma) {
          return Math2.exp(jStat3.randn() * sigma + mu);
        },
        variance: function variance(mu, sigma) {
          return (Math2.exp(sigma * sigma) - 1) * Math2.exp(2 * mu + sigma * sigma);
        }
      });
      jStat3.extend(jStat3.noncentralt, {
        pdf: function pdf(x2, dof, ncp) {
          var tol = 1e-14;
          if (Math2.abs(ncp) < tol)
            return jStat3.studentt.pdf(x2, dof);
          if (Math2.abs(x2) < tol) {
            return Math2.exp(jStat3.gammaln((dof + 1) / 2) - ncp * ncp / 2 - 0.5 * Math2.log(Math2.PI * dof) - jStat3.gammaln(dof / 2));
          }
          return dof / x2 * (jStat3.noncentralt.cdf(x2 * Math2.sqrt(1 + 2 / dof), dof + 2, ncp) - jStat3.noncentralt.cdf(x2, dof, ncp));
        },
        cdf: function cdf(x2, dof, ncp) {
          var tol = 1e-14;
          var min_iterations = 200;
          if (Math2.abs(ncp) < tol)
            return jStat3.studentt.cdf(x2, dof);
          var flip = false;
          if (x2 < 0) {
            flip = true;
            ncp = -ncp;
          }
          var prob = jStat3.normal.cdf(-ncp, 0, 1);
          var value = tol + 1;
          var lastvalue = value;
          var y2 = x2 * x2 / (x2 * x2 + dof);
          var j = 0;
          var p2 = Math2.exp(-ncp * ncp / 2);
          var q = Math2.exp(-ncp * ncp / 2 - 0.5 * Math2.log(2) - jStat3.gammaln(3 / 2)) * ncp;
          while (j < min_iterations || lastvalue > tol || value > tol) {
            lastvalue = value;
            if (j > 0) {
              p2 *= ncp * ncp / (2 * j);
              q *= ncp * ncp / (2 * (j + 1 / 2));
            }
            value = p2 * jStat3.beta.cdf(y2, j + 0.5, dof / 2) + q * jStat3.beta.cdf(y2, j + 1, dof / 2);
            prob += 0.5 * value;
            j++;
          }
          return flip ? 1 - prob : prob;
        }
      });
      jStat3.extend(jStat3.normal, {
        pdf: function pdf(x2, mean, std) {
          return Math2.exp(-0.5 * Math2.log(2 * Math2.PI) - Math2.log(std) - Math2.pow(x2 - mean, 2) / (2 * std * std));
        },
        cdf: function cdf(x2, mean, std) {
          return 0.5 * (1 + jStat3.erf((x2 - mean) / Math2.sqrt(2 * std * std)));
        },
        inv: function(p2, mean, std) {
          return -1.4142135623730951 * std * jStat3.erfcinv(2 * p2) + mean;
        },
        mean: function(mean) {
          return mean;
        },
        median: function median(mean) {
          return mean;
        },
        mode: function(mean) {
          return mean;
        },
        sample: function sample(mean, std) {
          return jStat3.randn() * std + mean;
        },
        variance: function(mean, std) {
          return std * std;
        }
      });
      jStat3.extend(jStat3.pareto, {
        pdf: function pdf(x2, scale, shape) {
          if (x2 < scale)
            return 0;
          return shape * Math2.pow(scale, shape) / Math2.pow(x2, shape + 1);
        },
        cdf: function cdf(x2, scale, shape) {
          if (x2 < scale)
            return 0;
          return 1 - Math2.pow(scale / x2, shape);
        },
        inv: function inv(p2, scale, shape) {
          return scale / Math2.pow(1 - p2, 1 / shape);
        },
        mean: function mean(scale, shape) {
          if (shape <= 1)
            return void 0;
          return shape * Math2.pow(scale, shape) / (shape - 1);
        },
        median: function median(scale, shape) {
          return scale * (shape * Math2.SQRT2);
        },
        mode: function mode(scale) {
          return scale;
        },
        variance: function(scale, shape) {
          if (shape <= 2)
            return void 0;
          return scale * scale * shape / (Math2.pow(shape - 1, 2) * (shape - 2));
        }
      });
      jStat3.extend(jStat3.studentt, {
        pdf: function pdf(x2, dof) {
          dof = dof > 1e100 ? 1e100 : dof;
          return 1 / (Math2.sqrt(dof) * jStat3.betafn(0.5, dof / 2)) * Math2.pow(1 + x2 * x2 / dof, -((dof + 1) / 2));
        },
        cdf: function cdf(x2, dof) {
          var dof2 = dof / 2;
          return jStat3.ibeta((x2 + Math2.sqrt(x2 * x2 + dof)) / (2 * Math2.sqrt(x2 * x2 + dof)), dof2, dof2);
        },
        inv: function(p2, dof) {
          var x2 = jStat3.ibetainv(2 * Math2.min(p2, 1 - p2), 0.5 * dof, 0.5);
          x2 = Math2.sqrt(dof * (1 - x2) / x2);
          return p2 > 0.5 ? x2 : -x2;
        },
        mean: function mean(dof) {
          return dof > 1 ? 0 : void 0;
        },
        median: function median() {
          return 0;
        },
        mode: function mode() {
          return 0;
        },
        sample: function sample(dof) {
          return jStat3.randn() * Math2.sqrt(dof / (2 * jStat3.randg(dof / 2)));
        },
        variance: function variance(dof) {
          return dof > 2 ? dof / (dof - 2) : dof > 1 ? Infinity : void 0;
        }
      });
      jStat3.extend(jStat3.weibull, {
        pdf: function pdf(x2, scale, shape) {
          if (x2 < 0 || scale < 0 || shape < 0)
            return 0;
          return shape / scale * Math2.pow(x2 / scale, shape - 1) * Math2.exp(-Math2.pow(x2 / scale, shape));
        },
        cdf: function cdf(x2, scale, shape) {
          return x2 < 0 ? 0 : 1 - Math2.exp(-Math2.pow(x2 / scale, shape));
        },
        inv: function(p2, scale, shape) {
          return scale * Math2.pow(-Math2.log(1 - p2), 1 / shape);
        },
        mean: function(scale, shape) {
          return scale * jStat3.gammafn(1 + 1 / shape);
        },
        median: function median(scale, shape) {
          return scale * Math2.pow(Math2.log(2), 1 / shape);
        },
        mode: function mode(scale, shape) {
          if (shape <= 1)
            return 0;
          return scale * Math2.pow((shape - 1) / shape, 1 / shape);
        },
        sample: function sample(scale, shape) {
          return scale * Math2.pow(-Math2.log(jStat3._random_fn()), 1 / shape);
        },
        variance: function variance(scale, shape) {
          return scale * scale * jStat3.gammafn(1 + 2 / shape) - Math2.pow(jStat3.weibull.mean(scale, shape), 2);
        }
      });
      jStat3.extend(jStat3.uniform, {
        pdf: function pdf(x2, a2, b2) {
          return x2 < a2 || x2 > b2 ? 0 : 1 / (b2 - a2);
        },
        cdf: function cdf(x2, a2, b2) {
          if (x2 < a2)
            return 0;
          else if (x2 < b2)
            return (x2 - a2) / (b2 - a2);
          return 1;
        },
        inv: function(p2, a2, b2) {
          return a2 + p2 * (b2 - a2);
        },
        mean: function mean(a2, b2) {
          return 0.5 * (a2 + b2);
        },
        median: function median(a2, b2) {
          return jStat3.mean(a2, b2);
        },
        mode: function mode() {
          throw new Error("mode is not yet implemented");
        },
        sample: function sample(a2, b2) {
          return a2 / 2 + b2 / 2 + (b2 / 2 - a2 / 2) * (2 * jStat3._random_fn() - 1);
        },
        variance: function variance(a2, b2) {
          return Math2.pow(b2 - a2, 2) / 12;
        }
      });
      function betinc(x2, a2, b2, eps) {
        var a0 = 0;
        var b0 = 1;
        var a1 = 1;
        var b1 = 1;
        var m9 = 0;
        var a22 = 0;
        var c9;
        while (Math2.abs((a1 - a22) / a1) > eps) {
          a22 = a1;
          c9 = -(a2 + m9) * (a2 + b2 + m9) * x2 / (a2 + 2 * m9) / (a2 + 2 * m9 + 1);
          a0 = a1 + c9 * a0;
          b0 = b1 + c9 * b0;
          m9 = m9 + 1;
          c9 = m9 * (b2 - m9) * x2 / (a2 + 2 * m9 - 1) / (a2 + 2 * m9);
          a1 = a0 + c9 * a1;
          b1 = b0 + c9 * b1;
          a0 = a0 / b1;
          b0 = b0 / b1;
          a1 = a1 / b1;
          b1 = 1;
        }
        return a1 / a2;
      }
      jStat3.extend(jStat3.binomial, {
        pdf: function pdf(k2, n2, p2) {
          return p2 === 0 || p2 === 1 ? n2 * p2 === k2 ? 1 : 0 : jStat3.combination(n2, k2) * Math2.pow(p2, k2) * Math2.pow(1 - p2, n2 - k2);
        },
        cdf: function cdf(x2, n2, p2) {
          var betacdf;
          var eps = 1e-10;
          if (x2 < 0)
            return 0;
          if (x2 >= n2)
            return 1;
          if (p2 < 0 || p2 > 1 || n2 <= 0)
            return NaN;
          x2 = Math2.floor(x2);
          var z = p2;
          var a2 = x2 + 1;
          var b2 = n2 - x2;
          var s2 = a2 + b2;
          var bt = Math2.exp(jStat3.gammaln(s2) - jStat3.gammaln(b2) - jStat3.gammaln(a2) + a2 * Math2.log(z) + b2 * Math2.log(1 - z));
          if (z < (a2 + 1) / (s2 + 2))
            betacdf = bt * betinc(z, a2, b2, eps);
          else
            betacdf = 1 - bt * betinc(1 - z, b2, a2, eps);
          return Math2.round((1 - betacdf) * (1 / eps)) / (1 / eps);
        }
      });
      jStat3.extend(jStat3.negbin, {
        pdf: function pdf(k2, r2, p2) {
          if (k2 !== k2 >>> 0)
            return false;
          if (k2 < 0)
            return 0;
          return jStat3.combination(k2 + r2 - 1, r2 - 1) * Math2.pow(1 - p2, k2) * Math2.pow(p2, r2);
        },
        cdf: function cdf(x2, r2, p2) {
          var sum = 0, k2 = 0;
          if (x2 < 0) return 0;
          for (; k2 <= x2; k2++) {
            sum += jStat3.negbin.pdf(k2, r2, p2);
          }
          return sum;
        }
      });
      jStat3.extend(jStat3.hypgeom, {
        pdf: function pdf(k2, N2, m2, n2) {
          if (k2 !== k2 | 0) {
            return false;
          } else if (k2 < 0 || k2 < m2 - (N2 - n2)) {
            return 0;
          } else if (k2 > n2 || k2 > m2) {
            return 0;
          } else if (m2 * 2 > N2) {
            if (n2 * 2 > N2) {
              return jStat3.hypgeom.pdf(N2 - m2 - n2 + k2, N2, N2 - m2, N2 - n2);
            } else {
              return jStat3.hypgeom.pdf(n2 - k2, N2, N2 - m2, n2);
            }
          } else if (n2 * 2 > N2) {
            return jStat3.hypgeom.pdf(m2 - k2, N2, m2, N2 - n2);
          } else if (m2 < n2) {
            return jStat3.hypgeom.pdf(k2, N2, n2, m2);
          } else {
            var scaledPDF = 1;
            var samplesDone = 0;
            for (var i2 = 0; i2 < k2; i2++) {
              while (scaledPDF > 1 && samplesDone < n2) {
                scaledPDF *= 1 - m2 / (N2 - samplesDone);
                samplesDone++;
              }
              scaledPDF *= (n2 - i2) * (m2 - i2) / ((i2 + 1) * (N2 - m2 - n2 + i2 + 1));
            }
            for (; samplesDone < n2; samplesDone++) {
              scaledPDF *= 1 - m2 / (N2 - samplesDone);
            }
            return Math2.min(1, Math2.max(0, scaledPDF));
          }
        },
        cdf: function cdf(x2, N2, m2, n2) {
          if (x2 < 0 || x2 < m2 - (N2 - n2)) {
            return 0;
          } else if (x2 >= n2 || x2 >= m2) {
            return 1;
          } else if (m2 * 2 > N2) {
            if (n2 * 2 > N2) {
              return jStat3.hypgeom.cdf(N2 - m2 - n2 + x2, N2, N2 - m2, N2 - n2);
            } else {
              return 1 - jStat3.hypgeom.cdf(n2 - x2 - 1, N2, N2 - m2, n2);
            }
          } else if (n2 * 2 > N2) {
            return 1 - jStat3.hypgeom.cdf(m2 - x2 - 1, N2, m2, N2 - n2);
          } else if (m2 < n2) {
            return jStat3.hypgeom.cdf(x2, N2, n2, m2);
          } else {
            var scaledCDF = 1;
            var scaledPDF = 1;
            var samplesDone = 0;
            for (var i2 = 0; i2 < x2; i2++) {
              while (scaledCDF > 1 && samplesDone < n2) {
                var factor = 1 - m2 / (N2 - samplesDone);
                scaledPDF *= factor;
                scaledCDF *= factor;
                samplesDone++;
              }
              scaledPDF *= (n2 - i2) * (m2 - i2) / ((i2 + 1) * (N2 - m2 - n2 + i2 + 1));
              scaledCDF += scaledPDF;
            }
            for (; samplesDone < n2; samplesDone++) {
              scaledCDF *= 1 - m2 / (N2 - samplesDone);
            }
            return Math2.min(1, Math2.max(0, scaledCDF));
          }
        }
      });
      jStat3.extend(jStat3.poisson, {
        pdf: function pdf(k2, l2) {
          if (l2 < 0 || k2 % 1 !== 0 || k2 < 0) {
            return 0;
          }
          return Math2.pow(l2, k2) * Math2.exp(-l2) / jStat3.factorial(k2);
        },
        cdf: function cdf(x2, l2) {
          var sumarr = [], k2 = 0;
          if (x2 < 0) return 0;
          for (; k2 <= x2; k2++) {
            sumarr.push(jStat3.poisson.pdf(k2, l2));
          }
          return jStat3.sum(sumarr);
        },
        mean: function(l2) {
          return l2;
        },
        variance: function(l2) {
          return l2;
        },
        sampleSmall: function sampleSmall(l2) {
          var p2 = 1, k2 = 0, L2 = Math2.exp(-l2);
          do {
            k2++;
            p2 *= jStat3._random_fn();
          } while (p2 > L2);
          return k2 - 1;
        },
        sampleLarge: function sampleLarge(l2) {
          var lam = l2;
          var k2;
          var U, V, slam, loglam, a2, b2, invalpha, vr, us;
          slam = Math2.sqrt(lam);
          loglam = Math2.log(lam);
          b2 = 0.931 + 2.53 * slam;
          a2 = -0.059 + 0.02483 * b2;
          invalpha = 1.1239 + 1.1328 / (b2 - 3.4);
          vr = 0.9277 - 3.6224 / (b2 - 2);
          while (1) {
            U = Math2.random() - 0.5;
            V = Math2.random();
            us = 0.5 - Math2.abs(U);
            k2 = Math2.floor((2 * a2 / us + b2) * U + lam + 0.43);
            if (us >= 0.07 && V <= vr) {
              return k2;
            }
            if (k2 < 0 || us < 0.013 && V > us) {
              continue;
            }
            if (Math2.log(V) + Math2.log(invalpha) - Math2.log(a2 / (us * us) + b2) <= -lam + k2 * loglam - jStat3.loggam(k2 + 1)) {
              return k2;
            }
          }
        },
        sample: function sample(l2) {
          if (l2 < 10)
            return this.sampleSmall(l2);
          else
            return this.sampleLarge(l2);
        }
      });
      jStat3.extend(jStat3.triangular, {
        pdf: function pdf(x2, a2, b2, c2) {
          if (b2 <= a2 || c2 < a2 || c2 > b2) {
            return NaN;
          } else {
            if (x2 < a2 || x2 > b2) {
              return 0;
            } else if (x2 < c2) {
              return 2 * (x2 - a2) / ((b2 - a2) * (c2 - a2));
            } else if (x2 === c2) {
              return 2 / (b2 - a2);
            } else {
              return 2 * (b2 - x2) / ((b2 - a2) * (b2 - c2));
            }
          }
        },
        cdf: function cdf(x2, a2, b2, c2) {
          if (b2 <= a2 || c2 < a2 || c2 > b2)
            return NaN;
          if (x2 <= a2)
            return 0;
          else if (x2 >= b2)
            return 1;
          if (x2 <= c2)
            return Math2.pow(x2 - a2, 2) / ((b2 - a2) * (c2 - a2));
          else
            return 1 - Math2.pow(b2 - x2, 2) / ((b2 - a2) * (b2 - c2));
        },
        inv: function inv(p2, a2, b2, c2) {
          if (b2 <= a2 || c2 < a2 || c2 > b2) {
            return NaN;
          } else {
            if (p2 <= (c2 - a2) / (b2 - a2)) {
              return a2 + (b2 - a2) * Math2.sqrt(p2 * ((c2 - a2) / (b2 - a2)));
            } else {
              return a2 + (b2 - a2) * (1 - Math2.sqrt((1 - p2) * (1 - (c2 - a2) / (b2 - a2))));
            }
          }
        },
        mean: function mean(a2, b2, c2) {
          return (a2 + b2 + c2) / 3;
        },
        median: function median(a2, b2, c2) {
          if (c2 <= (a2 + b2) / 2) {
            return b2 - Math2.sqrt((b2 - a2) * (b2 - c2)) / Math2.sqrt(2);
          } else if (c2 > (a2 + b2) / 2) {
            return a2 + Math2.sqrt((b2 - a2) * (c2 - a2)) / Math2.sqrt(2);
          }
        },
        mode: function mode(a2, b2, c2) {
          return c2;
        },
        sample: function sample(a2, b2, c2) {
          var u2 = jStat3._random_fn();
          if (u2 < (c2 - a2) / (b2 - a2))
            return a2 + Math2.sqrt(u2 * (b2 - a2) * (c2 - a2));
          return b2 - Math2.sqrt((1 - u2) * (b2 - a2) * (b2 - c2));
        },
        variance: function variance(a2, b2, c2) {
          return (a2 * a2 + b2 * b2 + c2 * c2 - a2 * b2 - a2 * c2 - b2 * c2) / 18;
        }
      });
      jStat3.extend(jStat3.arcsine, {
        pdf: function pdf(x2, a2, b2) {
          if (b2 <= a2) return NaN;
          return x2 <= a2 || x2 >= b2 ? 0 : 2 / Math2.PI * Math2.pow(Math2.pow(b2 - a2, 2) - Math2.pow(2 * x2 - a2 - b2, 2), -0.5);
        },
        cdf: function cdf(x2, a2, b2) {
          if (x2 < a2)
            return 0;
          else if (x2 < b2)
            return 2 / Math2.PI * Math2.asin(Math2.sqrt((x2 - a2) / (b2 - a2)));
          return 1;
        },
        inv: function(p2, a2, b2) {
          return a2 + (0.5 - 0.5 * Math2.cos(Math2.PI * p2)) * (b2 - a2);
        },
        mean: function mean(a2, b2) {
          if (b2 <= a2) return NaN;
          return (a2 + b2) / 2;
        },
        median: function median(a2, b2) {
          if (b2 <= a2) return NaN;
          return (a2 + b2) / 2;
        },
        mode: function mode() {
          throw new Error("mode is not yet implemented");
        },
        sample: function sample(a2, b2) {
          return (a2 + b2) / 2 + (b2 - a2) / 2 * Math2.sin(2 * Math2.PI * jStat3.uniform.sample(0, 1));
        },
        variance: function variance(a2, b2) {
          if (b2 <= a2) return NaN;
          return Math2.pow(b2 - a2, 2) / 8;
        }
      });
      function laplaceSign(x2) {
        return x2 / Math2.abs(x2);
      }
      jStat3.extend(jStat3.laplace, {
        pdf: function pdf(x2, mu, b2) {
          return b2 <= 0 ? 0 : Math2.exp(-Math2.abs(x2 - mu) / b2) / (2 * b2);
        },
        cdf: function cdf(x2, mu, b2) {
          if (b2 <= 0) {
            return 0;
          }
          if (x2 < mu) {
            return 0.5 * Math2.exp((x2 - mu) / b2);
          } else {
            return 1 - 0.5 * Math2.exp(-(x2 - mu) / b2);
          }
        },
        mean: function(mu) {
          return mu;
        },
        median: function(mu) {
          return mu;
        },
        mode: function(mu) {
          return mu;
        },
        variance: function(mu, b2) {
          return 2 * b2 * b2;
        },
        sample: function sample(mu, b2) {
          var u2 = jStat3._random_fn() - 0.5;
          return mu - b2 * laplaceSign(u2) * Math2.log(1 - 2 * Math2.abs(u2));
        }
      });
      function tukeyWprob(w2, rr, cc2) {
        var nleg = 12;
        var ihalf = 6;
        var C1 = -30;
        var C2 = -50;
        var C3 = 60;
        var bb = 8;
        var wlar = 3;
        var wincr1 = 2;
        var wincr2 = 3;
        var xleg = [
          0.9815606342467192,
          0.9041172563704749,
          0.7699026741943047,
          0.5873179542866175,
          0.3678314989981802,
          0.1252334085114689
        ];
        var aleg = [
          0.04717533638651183,
          0.10693932599531843,
          0.16007832854334622,
          0.20316742672306592,
          0.2334925365383548,
          0.24914704581340277
        ];
        var qsqz = w2 * 0.5;
        if (qsqz >= bb)
          return 1;
        var pr_w = 2 * jStat3.normal.cdf(qsqz, 0, 1, 1, 0) - 1;
        if (pr_w >= Math2.exp(C2 / cc2))
          pr_w = Math2.pow(pr_w, cc2);
        else
          pr_w = 0;
        var wincr;
        if (w2 > wlar)
          wincr = wincr1;
        else
          wincr = wincr2;
        var blb = qsqz;
        var binc = (bb - qsqz) / wincr;
        var bub = blb + binc;
        var einsum = 0;
        var cc1 = cc2 - 1;
        for (var wi = 1; wi <= wincr; wi++) {
          var elsum = 0;
          var a2 = 0.5 * (bub + blb);
          var b2 = 0.5 * (bub - blb);
          for (var jj = 1; jj <= nleg; jj++) {
            var j, xx;
            if (ihalf < jj) {
              j = nleg - jj + 1;
              xx = xleg[j - 1];
            } else {
              j = jj;
              xx = -xleg[j - 1];
            }
            var c2 = b2 * xx;
            var ac = a2 + c2;
            var qexpo = ac * ac;
            if (qexpo > C3)
              break;
            var pplus = 2 * jStat3.normal.cdf(ac, 0, 1, 1, 0);
            var pminus = 2 * jStat3.normal.cdf(ac, w2, 1, 1, 0);
            var rinsum = pplus * 0.5 - pminus * 0.5;
            if (rinsum >= Math2.exp(C1 / cc1)) {
              rinsum = aleg[j - 1] * Math2.exp(-(0.5 * qexpo)) * Math2.pow(rinsum, cc1);
              elsum += rinsum;
            }
          }
          elsum *= 2 * b2 * cc2 / Math2.sqrt(2 * Math2.PI);
          einsum += elsum;
          blb = bub;
          bub += binc;
        }
        pr_w += einsum;
        if (pr_w <= Math2.exp(C1 / rr))
          return 0;
        pr_w = Math2.pow(pr_w, rr);
        if (pr_w >= 1)
          return 1;
        return pr_w;
      }
      function tukeyQinv(p2, c2, v2) {
        var p0 = 0.322232421088;
        var q0 = 0.099348462606;
        var p1 = -1;
        var q1 = 0.588581570495;
        var p22 = -0.342242088547;
        var q2 = 0.531103462366;
        var p3 = -0.204231210125;
        var q3 = 0.10353775285;
        var p4 = -453642210148e-16;
        var q4 = 0.0038560700634;
        var c1 = 0.8832;
        var c22 = 0.2368;
        var c3 = 1.214;
        var c4 = 1.208;
        var c5 = 1.4142;
        var vmax = 120;
        var ps = 0.5 - 0.5 * p2;
        var yi = Math2.sqrt(Math2.log(1 / (ps * ps)));
        var t2 = yi + ((((yi * p4 + p3) * yi + p22) * yi + p1) * yi + p0) / ((((yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);
        if (v2 < vmax) t2 += (t2 * t2 * t2 + t2) / v2 / 4;
        var q = c1 - c22 * t2;
        if (v2 < vmax) q += -c3 / v2 + c4 * t2 / v2;
        return t2 * (q * Math2.log(c2 - 1) + c5);
      }
      jStat3.extend(jStat3.tukey, {
        cdf: function cdf(q, nmeans, df) {
          var rr = 1;
          var cc2 = nmeans;
          var nlegq = 16;
          var ihalfq = 8;
          var eps1 = -30;
          var eps2 = 1e-14;
          var dhaf = 100;
          var dquar = 800;
          var deigh = 5e3;
          var dlarg = 25e3;
          var ulen1 = 1;
          var ulen2 = 0.5;
          var ulen3 = 0.25;
          var ulen4 = 0.125;
          var xlegq = [
            0.9894009349916499,
            0.9445750230732326,
            0.8656312023878318,
            0.755404408355003,
            0.6178762444026438,
            0.45801677765722737,
            0.2816035507792589,
            0.09501250983763744
          ];
          var alegq = [
            0.027152459411754096,
            0.062253523938647894,
            0.09515851168249279,
            0.12462897125553388,
            0.14959598881657674,
            0.16915651939500254,
            0.18260341504492358,
            0.1894506104550685
          ];
          if (q <= 0)
            return 0;
          if (df < 2 || rr < 1 || cc2 < 2) return NaN;
          if (!Number.isFinite(q))
            return 1;
          if (df > dlarg)
            return tukeyWprob(q, rr, cc2);
          var f2 = df * 0.5;
          var f2lf = f2 * Math2.log(df) - df * Math2.log(2) - jStat3.gammaln(f2);
          var f21 = f2 - 1;
          var ff4 = df * 0.25;
          var ulen;
          if (df <= dhaf) ulen = ulen1;
          else if (df <= dquar) ulen = ulen2;
          else if (df <= deigh) ulen = ulen3;
          else ulen = ulen4;
          f2lf += Math2.log(ulen);
          var ans = 0;
          for (var i2 = 1; i2 <= 50; i2++) {
            var otsum = 0;
            var twa1 = (2 * i2 - 1) * ulen;
            for (var jj = 1; jj <= nlegq; jj++) {
              var j, t1;
              if (ihalfq < jj) {
                j = jj - ihalfq - 1;
                t1 = f2lf + f21 * Math2.log(twa1 + xlegq[j] * ulen) - (xlegq[j] * ulen + twa1) * ff4;
              } else {
                j = jj - 1;
                t1 = f2lf + f21 * Math2.log(twa1 - xlegq[j] * ulen) + (xlegq[j] * ulen - twa1) * ff4;
              }
              var qsqz;
              if (t1 >= eps1) {
                if (ihalfq < jj) {
                  qsqz = q * Math2.sqrt((xlegq[j] * ulen + twa1) * 0.5);
                } else {
                  qsqz = q * Math2.sqrt((-(xlegq[j] * ulen) + twa1) * 0.5);
                }
                var wprb = tukeyWprob(qsqz, rr, cc2);
                var rotsum = wprb * alegq[j] * Math2.exp(t1);
                otsum += rotsum;
              }
            }
            if (i2 * ulen >= 1 && otsum <= eps2)
              break;
            ans += otsum;
          }
          if (otsum > eps2) {
            throw new Error("tukey.cdf failed to converge");
          }
          if (ans > 1)
            ans = 1;
          return ans;
        },
        inv: function(p2, nmeans, df) {
          var rr = 1;
          var cc2 = nmeans;
          var eps = 1e-4;
          var maxiter = 50;
          if (df < 2 || rr < 1 || cc2 < 2) return NaN;
          if (p2 < 0 || p2 > 1) return NaN;
          if (p2 === 0) return 0;
          if (p2 === 1) return Infinity;
          var x0 = tukeyQinv(p2, cc2, df);
          var valx0 = jStat3.tukey.cdf(x0, nmeans, df) - p2;
          var x1;
          if (valx0 > 0)
            x1 = Math2.max(0, x0 - 1);
          else
            x1 = x0 + 1;
          var valx1 = jStat3.tukey.cdf(x1, nmeans, df) - p2;
          var ans;
          for (var iter = 1; iter < maxiter; iter++) {
            ans = x1 - valx1 * (x1 - x0) / (valx1 - valx0);
            valx0 = valx1;
            x0 = x1;
            if (ans < 0) {
              ans = 0;
              valx1 = -p2;
            }
            valx1 = jStat3.tukey.cdf(ans, nmeans, df) - p2;
            x1 = ans;
            var xabs = Math2.abs(x1 - x0);
            if (xabs < eps)
              return ans;
          }
          throw new Error("tukey.inv failed to converge");
        }
      });
    })(jStat2, Math);
    (function(jStat3, Math2) {
      var push = Array.prototype.push;
      var isArray = jStat3.utils.isArray;
      function isUsable(arg) {
        return isArray(arg) || arg instanceof jStat3;
      }
      jStat3.extend({
        // add a vector/matrix to a vector/matrix or scalar
        add: function add(arr, arg) {
          if (isUsable(arg)) {
            if (!isUsable(arg[0])) arg = [arg];
            return jStat3.map(arr, function(value, row2, col) {
              return value + arg[row2][col];
            });
          }
          return jStat3.map(arr, function(value) {
            return value + arg;
          });
        },
        // subtract a vector or scalar from the vector
        subtract: function subtract(arr, arg) {
          if (isUsable(arg)) {
            if (!isUsable(arg[0])) arg = [arg];
            return jStat3.map(arr, function(value, row2, col) {
              return value - arg[row2][col] || 0;
            });
          }
          return jStat3.map(arr, function(value) {
            return value - arg;
          });
        },
        // matrix division
        divide: function divide(arr, arg) {
          if (isUsable(arg)) {
            if (!isUsable(arg[0])) arg = [arg];
            return jStat3.multiply(arr, jStat3.inv(arg));
          }
          return jStat3.map(arr, function(value) {
            return value / arg;
          });
        },
        // matrix multiplication
        multiply: function multiply(arr, arg) {
          var row2, col, nrescols, sum, nrow, ncol, res, rescols;
          if (arr.length === void 0 && arg.length === void 0) {
            return arr * arg;
          }
          nrow = arr.length, ncol = arr[0].length, res = jStat3.zeros(nrow, nrescols = isUsable(arg) ? arg[0].length : ncol), rescols = 0;
          if (isUsable(arg)) {
            for (; rescols < nrescols; rescols++) {
              for (row2 = 0; row2 < nrow; row2++) {
                sum = 0;
                for (col = 0; col < ncol; col++)
                  sum += arr[row2][col] * arg[col][rescols];
                res[row2][rescols] = sum;
              }
            }
            return nrow === 1 && rescols === 1 ? res[0][0] : res;
          }
          return jStat3.map(arr, function(value) {
            return value * arg;
          });
        },
        // outer([1,2,3],[4,5,6])
        // ===
        // [[1],[2],[3]] times [[4,5,6]]
        // ->
        // [[4,5,6],[8,10,12],[12,15,18]]
        outer: function outer(A2, B) {
          return jStat3.multiply(A2.map(function(t2) {
            return [t2];
          }), [B]);
        },
        // Returns the dot product of two matricies
        dot: function dot(arr, arg) {
          if (!isUsable(arr[0])) arr = [arr];
          if (!isUsable(arg[0])) arg = [arg];
          var left = arr[0].length === 1 && arr.length !== 1 ? jStat3.transpose(arr) : arr, right = arg[0].length === 1 && arg.length !== 1 ? jStat3.transpose(arg) : arg, res = [], row2 = 0, nrow = left.length, ncol = left[0].length, sum, col;
          for (; row2 < nrow; row2++) {
            res[row2] = [];
            sum = 0;
            for (col = 0; col < ncol; col++)
              sum += left[row2][col] * right[row2][col];
            res[row2] = sum;
          }
          return res.length === 1 ? res[0] : res;
        },
        // raise every element by a scalar
        pow: function pow(arr, arg) {
          return jStat3.map(arr, function(value) {
            return Math2.pow(value, arg);
          });
        },
        // exponentiate every element
        exp: function exp(arr) {
          return jStat3.map(arr, function(value) {
            return Math2.exp(value);
          });
        },
        // generate the natural log of every element
        log: function exp(arr) {
          return jStat3.map(arr, function(value) {
            return Math2.log(value);
          });
        },
        // generate the absolute values of the vector
        abs: function abs(arr) {
          return jStat3.map(arr, function(value) {
            return Math2.abs(value);
          });
        },
        // computes the p-norm of the vector
        // In the case that a matrix is passed, uses the first row as the vector
        norm: function norm(arr, p2) {
          var nnorm = 0, i2 = 0;
          if (isNaN(p2)) p2 = 2;
          if (isUsable(arr[0])) arr = arr[0];
          for (; i2 < arr.length; i2++) {
            nnorm += Math2.pow(Math2.abs(arr[i2]), p2);
          }
          return Math2.pow(nnorm, 1 / p2);
        },
        // computes the angle between two vectors in rads
        // In case a matrix is passed, this uses the first row as the vector
        angle: function angle(arr, arg) {
          return Math2.acos(jStat3.dot(arr, arg) / (jStat3.norm(arr) * jStat3.norm(arg)));
        },
        // augment one matrix by another
        // Note: this function returns a matrix, not a jStat object
        aug: function aug(a2, b2) {
          var newarr = [];
          var i2;
          for (i2 = 0; i2 < a2.length; i2++) {
            newarr.push(a2[i2].slice());
          }
          for (i2 = 0; i2 < newarr.length; i2++) {
            push.apply(newarr[i2], b2[i2]);
          }
          return newarr;
        },
        // The inv() function calculates the inverse of a matrix
        // Create the inverse by augmenting the matrix by the identity matrix of the
        // appropriate size, and then use G-J elimination on the augmented matrix.
        inv: function inv(a2) {
          var rows = a2.length;
          var cols = a2[0].length;
          var b2 = jStat3.identity(rows, cols);
          var c2 = jStat3.gauss_jordan(a2, b2);
          var result = [];
          var i2 = 0;
          var j;
          for (; i2 < rows; i2++) {
            result[i2] = [];
            for (j = cols; j < c2[0].length; j++)
              result[i2][j - cols] = c2[i2][j];
          }
          return result;
        },
        // calculate the determinant of a matrix
        det: function det(a2) {
          var alen = a2.length, alend = alen * 2, vals = new Array(alend), rowshift = alen - 1, colshift = alend - 1, mrow = rowshift - alen + 1, mcol = colshift, i2 = 0, result = 0, j;
          if (alen === 2) {
            return a2[0][0] * a2[1][1] - a2[0][1] * a2[1][0];
          }
          for (; i2 < alend; i2++) {
            vals[i2] = 1;
          }
          for (i2 = 0; i2 < alen; i2++) {
            for (j = 0; j < alen; j++) {
              vals[mrow < 0 ? mrow + alen : mrow] *= a2[i2][j];
              vals[mcol < alen ? mcol + alen : mcol] *= a2[i2][j];
              mrow++;
              mcol--;
            }
            mrow = --rowshift - alen + 1;
            mcol = --colshift;
          }
          for (i2 = 0; i2 < alen; i2++) {
            result += vals[i2];
          }
          for (; i2 < alend; i2++) {
            result -= vals[i2];
          }
          return result;
        },
        gauss_elimination: function gauss_elimination(a2, b2) {
          var i2 = 0, j = 0, n2 = a2.length, m2 = a2[0].length, factor = 1, sum = 0, x2 = [], maug, pivot, temp, k2;
          a2 = jStat3.aug(a2, b2);
          maug = a2[0].length;
          for (i2 = 0; i2 < n2; i2++) {
            pivot = a2[i2][i2];
            j = i2;
            for (k2 = i2 + 1; k2 < m2; k2++) {
              if (pivot < Math2.abs(a2[k2][i2])) {
                pivot = a2[k2][i2];
                j = k2;
              }
            }
            if (j != i2) {
              for (k2 = 0; k2 < maug; k2++) {
                temp = a2[i2][k2];
                a2[i2][k2] = a2[j][k2];
                a2[j][k2] = temp;
              }
            }
            for (j = i2 + 1; j < n2; j++) {
              factor = a2[j][i2] / a2[i2][i2];
              for (k2 = i2; k2 < maug; k2++) {
                a2[j][k2] = a2[j][k2] - factor * a2[i2][k2];
              }
            }
          }
          for (i2 = n2 - 1; i2 >= 0; i2--) {
            sum = 0;
            for (j = i2 + 1; j <= n2 - 1; j++) {
              sum = sum + x2[j] * a2[i2][j];
            }
            x2[i2] = (a2[i2][maug - 1] - sum) / a2[i2][i2];
          }
          return x2;
        },
        gauss_jordan: function gauss_jordan(a2, b2) {
          var m2 = jStat3.aug(a2, b2);
          var h2 = m2.length;
          var w2 = m2[0].length;
          var c2 = 0;
          var x2, y2, y22;
          for (y2 = 0; y2 < h2; y2++) {
            var maxrow = y2;
            for (y22 = y2 + 1; y22 < h2; y22++) {
              if (Math2.abs(m2[y22][y2]) > Math2.abs(m2[maxrow][y2]))
                maxrow = y22;
            }
            var tmp = m2[y2];
            m2[y2] = m2[maxrow];
            m2[maxrow] = tmp;
            for (y22 = y2 + 1; y22 < h2; y22++) {
              c2 = m2[y22][y2] / m2[y2][y2];
              for (x2 = y2; x2 < w2; x2++) {
                m2[y22][x2] -= m2[y2][x2] * c2;
              }
            }
          }
          for (y2 = h2 - 1; y2 >= 0; y2--) {
            c2 = m2[y2][y2];
            for (y22 = 0; y22 < y2; y22++) {
              for (x2 = w2 - 1; x2 > y2 - 1; x2--) {
                m2[y22][x2] -= m2[y2][x2] * m2[y22][y2] / c2;
              }
            }
            m2[y2][y2] /= c2;
            for (x2 = h2; x2 < w2; x2++) {
              m2[y2][x2] /= c2;
            }
          }
          return m2;
        },
        // solve equation
        // Ax=b
        // A is upper triangular matrix
        // A=[[1,2,3],[0,4,5],[0,6,7]]
        // b=[1,2,3]
        // triaUpSolve(A,b) // -> [2.666,0.1666,1.666]
        // if you use matrix style
        // A=[[1,2,3],[0,4,5],[0,6,7]]
        // b=[[1],[2],[3]]
        // will return [[2.666],[0.1666],[1.666]]
        triaUpSolve: function triaUpSolve(A2, b2) {
          var size = A2[0].length;
          var x2 = jStat3.zeros(1, size)[0];
          var parts;
          var matrix_mode = false;
          if (b2[0].length != void 0) {
            b2 = b2.map(function(i2) {
              return i2[0];
            });
            matrix_mode = true;
          }
          jStat3.arange(size - 1, -1, -1).forEach(function(i2) {
            parts = jStat3.arange(i2 + 1, size).map(function(j) {
              return x2[j] * A2[i2][j];
            });
            x2[i2] = (b2[i2] - jStat3.sum(parts)) / A2[i2][i2];
          });
          if (matrix_mode)
            return x2.map(function(i2) {
              return [i2];
            });
          return x2;
        },
        triaLowSolve: function triaLowSolve(A2, b2) {
          var size = A2[0].length;
          var x2 = jStat3.zeros(1, size)[0];
          var parts;
          var matrix_mode = false;
          if (b2[0].length != void 0) {
            b2 = b2.map(function(i2) {
              return i2[0];
            });
            matrix_mode = true;
          }
          jStat3.arange(size).forEach(function(i2) {
            parts = jStat3.arange(i2).map(function(j) {
              return A2[i2][j] * x2[j];
            });
            x2[i2] = (b2[i2] - jStat3.sum(parts)) / A2[i2][i2];
          });
          if (matrix_mode)
            return x2.map(function(i2) {
              return [i2];
            });
          return x2;
        },
        // A -> [L,U]
        // A=LU
        // L is lower triangular matrix
        // U is upper triangular matrix
        lu: function lu(A2) {
          var size = A2.length;
          var L2 = jStat3.identity(size);
          var R2 = jStat3.zeros(A2.length, A2[0].length);
          var parts;
          jStat3.arange(size).forEach(function(t2) {
            R2[0][t2] = A2[0][t2];
          });
          jStat3.arange(1, size).forEach(function(l2) {
            jStat3.arange(l2).forEach(function(i2) {
              parts = jStat3.arange(i2).map(function(jj) {
                return L2[l2][jj] * R2[jj][i2];
              });
              L2[l2][i2] = (A2[l2][i2] - jStat3.sum(parts)) / R2[i2][i2];
            });
            jStat3.arange(l2, size).forEach(function(j) {
              parts = jStat3.arange(l2).map(function(jj) {
                return L2[l2][jj] * R2[jj][j];
              });
              R2[l2][j] = A2[parts.length][j] - jStat3.sum(parts);
            });
          });
          return [L2, R2];
        },
        // A -> T
        // A=TT'
        // T is lower triangular matrix
        cholesky: function cholesky(A2) {
          var size = A2.length;
          var T2 = jStat3.zeros(A2.length, A2[0].length);
          var parts;
          jStat3.arange(size).forEach(function(i2) {
            parts = jStat3.arange(i2).map(function(t2) {
              return Math2.pow(T2[i2][t2], 2);
            });
            T2[i2][i2] = Math2.sqrt(A2[i2][i2] - jStat3.sum(parts));
            jStat3.arange(i2 + 1, size).forEach(function(j) {
              parts = jStat3.arange(i2).map(function(t2) {
                return T2[i2][t2] * T2[j][t2];
              });
              T2[j][i2] = (A2[i2][j] - jStat3.sum(parts)) / T2[i2][i2];
            });
          });
          return T2;
        },
        gauss_jacobi: function gauss_jacobi(a2, b2, x2, r2) {
          var i2 = 0;
          var j = 0;
          var n2 = a2.length;
          var l2 = [];
          var u2 = [];
          var d2 = [];
          var xv, c2, h2, xk;
          for (; i2 < n2; i2++) {
            l2[i2] = [];
            u2[i2] = [];
            d2[i2] = [];
            for (j = 0; j < n2; j++) {
              if (i2 > j) {
                l2[i2][j] = a2[i2][j];
                u2[i2][j] = d2[i2][j] = 0;
              } else if (i2 < j) {
                u2[i2][j] = a2[i2][j];
                l2[i2][j] = d2[i2][j] = 0;
              } else {
                d2[i2][j] = a2[i2][j];
                l2[i2][j] = u2[i2][j] = 0;
              }
            }
          }
          h2 = jStat3.multiply(jStat3.multiply(jStat3.inv(d2), jStat3.add(l2, u2)), -1);
          c2 = jStat3.multiply(jStat3.inv(d2), b2);
          xv = x2;
          xk = jStat3.add(jStat3.multiply(h2, x2), c2);
          i2 = 2;
          while (Math2.abs(jStat3.norm(jStat3.subtract(xk, xv))) > r2) {
            xv = xk;
            xk = jStat3.add(jStat3.multiply(h2, xv), c2);
            i2++;
          }
          return xk;
        },
        gauss_seidel: function gauss_seidel(a2, b2, x2, r2) {
          var i2 = 0;
          var n2 = a2.length;
          var l2 = [];
          var u2 = [];
          var d2 = [];
          var j, xv, c2, h2, xk;
          for (; i2 < n2; i2++) {
            l2[i2] = [];
            u2[i2] = [];
            d2[i2] = [];
            for (j = 0; j < n2; j++) {
              if (i2 > j) {
                l2[i2][j] = a2[i2][j];
                u2[i2][j] = d2[i2][j] = 0;
              } else if (i2 < j) {
                u2[i2][j] = a2[i2][j];
                l2[i2][j] = d2[i2][j] = 0;
              } else {
                d2[i2][j] = a2[i2][j];
                l2[i2][j] = u2[i2][j] = 0;
              }
            }
          }
          h2 = jStat3.multiply(jStat3.multiply(jStat3.inv(jStat3.add(d2, l2)), u2), -1);
          c2 = jStat3.multiply(jStat3.inv(jStat3.add(d2, l2)), b2);
          xv = x2;
          xk = jStat3.add(jStat3.multiply(h2, x2), c2);
          i2 = 2;
          while (Math2.abs(jStat3.norm(jStat3.subtract(xk, xv))) > r2) {
            xv = xk;
            xk = jStat3.add(jStat3.multiply(h2, xv), c2);
            i2 = i2 + 1;
          }
          return xk;
        },
        SOR: function SOR(a2, b2, x2, r2, w2) {
          var i2 = 0;
          var n2 = a2.length;
          var l2 = [];
          var u2 = [];
          var d2 = [];
          var j, xv, c2, h2, xk;
          for (; i2 < n2; i2++) {
            l2[i2] = [];
            u2[i2] = [];
            d2[i2] = [];
            for (j = 0; j < n2; j++) {
              if (i2 > j) {
                l2[i2][j] = a2[i2][j];
                u2[i2][j] = d2[i2][j] = 0;
              } else if (i2 < j) {
                u2[i2][j] = a2[i2][j];
                l2[i2][j] = d2[i2][j] = 0;
              } else {
                d2[i2][j] = a2[i2][j];
                l2[i2][j] = u2[i2][j] = 0;
              }
            }
          }
          h2 = jStat3.multiply(
            jStat3.inv(jStat3.add(d2, jStat3.multiply(l2, w2))),
            jStat3.subtract(
              jStat3.multiply(d2, 1 - w2),
              jStat3.multiply(u2, w2)
            )
          );
          c2 = jStat3.multiply(jStat3.multiply(jStat3.inv(jStat3.add(
            d2,
            jStat3.multiply(l2, w2)
          )), b2), w2);
          xv = x2;
          xk = jStat3.add(jStat3.multiply(h2, x2), c2);
          i2 = 2;
          while (Math2.abs(jStat3.norm(jStat3.subtract(xk, xv))) > r2) {
            xv = xk;
            xk = jStat3.add(jStat3.multiply(h2, xv), c2);
            i2++;
          }
          return xk;
        },
        householder: function householder(a2) {
          var m2 = a2.length;
          var n2 = a2[0].length;
          var i2 = 0;
          var w2 = [];
          var p2 = [];
          var alpha, r2, k2, j, factor;
          for (; i2 < m2 - 1; i2++) {
            alpha = 0;
            for (j = i2 + 1; j < n2; j++)
              alpha += a2[j][i2] * a2[j][i2];
            factor = a2[i2 + 1][i2] > 0 ? -1 : 1;
            alpha = factor * Math2.sqrt(alpha);
            r2 = Math2.sqrt((alpha * alpha - a2[i2 + 1][i2] * alpha) / 2);
            w2 = jStat3.zeros(m2, 1);
            w2[i2 + 1][0] = (a2[i2 + 1][i2] - alpha) / (2 * r2);
            for (k2 = i2 + 2; k2 < m2; k2++) w2[k2][0] = a2[k2][i2] / (2 * r2);
            p2 = jStat3.subtract(
              jStat3.identity(m2, n2),
              jStat3.multiply(jStat3.multiply(w2, jStat3.transpose(w2)), 2)
            );
            a2 = jStat3.multiply(p2, jStat3.multiply(a2, p2));
          }
          return a2;
        },
        // A -> [Q,R]
        // Q is orthogonal matrix
        // R is upper triangular
        QR: (function() {
          var sum = jStat3.sum;
          var range = jStat3.arange;
          function qr2(x2) {
            var n2 = x2.length;
            var p2 = x2[0].length;
            var r2 = jStat3.zeros(p2, p2);
            x2 = jStat3.copy(x2);
            var i2, j, k2;
            for (j = 0; j < p2; j++) {
              r2[j][j] = Math2.sqrt(sum(range(n2).map(function(i3) {
                return x2[i3][j] * x2[i3][j];
              })));
              for (i2 = 0; i2 < n2; i2++) {
                x2[i2][j] = x2[i2][j] / r2[j][j];
              }
              for (k2 = j + 1; k2 < p2; k2++) {
                r2[j][k2] = sum(range(n2).map(function(i3) {
                  return x2[i3][j] * x2[i3][k2];
                }));
                for (i2 = 0; i2 < n2; i2++) {
                  x2[i2][k2] = x2[i2][k2] - x2[i2][j] * r2[j][k2];
                }
              }
            }
            return [x2, r2];
          }
          return qr2;
        })(),
        lstsq: /* @__PURE__ */ (function() {
          function R_I(A2) {
            A2 = jStat3.copy(A2);
            var size = A2.length;
            var I2 = jStat3.identity(size);
            jStat3.arange(size - 1, -1, -1).forEach(function(i2) {
              jStat3.sliceAssign(
                I2,
                { row: i2 },
                jStat3.divide(jStat3.slice(I2, { row: i2 }), A2[i2][i2])
              );
              jStat3.sliceAssign(
                A2,
                { row: i2 },
                jStat3.divide(jStat3.slice(A2, { row: i2 }), A2[i2][i2])
              );
              jStat3.arange(i2).forEach(function(j) {
                var c2 = jStat3.multiply(A2[j][i2], -1);
                var Aj = jStat3.slice(A2, { row: j });
                var cAi = jStat3.multiply(jStat3.slice(A2, { row: i2 }), c2);
                jStat3.sliceAssign(A2, { row: j }, jStat3.add(Aj, cAi));
                var Ij = jStat3.slice(I2, { row: j });
                var cIi = jStat3.multiply(jStat3.slice(I2, { row: i2 }), c2);
                jStat3.sliceAssign(I2, { row: j }, jStat3.add(Ij, cIi));
              });
            });
            return I2;
          }
          function qr_solve(A2, b2) {
            var array_mode = false;
            if (b2[0].length === void 0) {
              b2 = b2.map(function(x3) {
                return [x3];
              });
              array_mode = true;
            }
            var QR = jStat3.QR(A2);
            var Q = QR[0];
            var R2 = QR[1];
            var attrs = A2[0].length;
            var Q1 = jStat3.slice(Q, { col: { end: attrs } });
            var R1 = jStat3.slice(R2, { row: { end: attrs } });
            var RI = R_I(R1);
            var Q2 = jStat3.transpose(Q1);
            if (Q2[0].length === void 0) {
              Q2 = [Q2];
            }
            var x2 = jStat3.multiply(jStat3.multiply(RI, Q2), b2);
            if (x2.length === void 0) {
              x2 = [[x2]];
            }
            if (array_mode)
              return x2.map(function(i2) {
                return i2[0];
              });
            return x2;
          }
          return qr_solve;
        })(),
        jacobi: function jacobi(a2) {
          var condition = 1;
          var n2 = a2.length;
          var e2 = jStat3.identity(n2, n2);
          var ev = [];
          var b2, i2, j, p2, q, maxim, theta, s2;
          while (condition === 1) {
            maxim = a2[0][1];
            p2 = 0;
            q = 1;
            for (i2 = 0; i2 < n2; i2++) {
              for (j = 0; j < n2; j++) {
                if (i2 != j) {
                  if (maxim < Math2.abs(a2[i2][j])) {
                    maxim = Math2.abs(a2[i2][j]);
                    p2 = i2;
                    q = j;
                  }
                }
              }
            }
            if (a2[p2][p2] === a2[q][q])
              theta = a2[p2][q] > 0 ? Math2.PI / 4 : -Math2.PI / 4;
            else
              theta = Math2.atan(2 * a2[p2][q] / (a2[p2][p2] - a2[q][q])) / 2;
            s2 = jStat3.identity(n2, n2);
            s2[p2][p2] = Math2.cos(theta);
            s2[p2][q] = -Math2.sin(theta);
            s2[q][p2] = Math2.sin(theta);
            s2[q][q] = Math2.cos(theta);
            e2 = jStat3.multiply(e2, s2);
            b2 = jStat3.multiply(jStat3.multiply(jStat3.inv(s2), a2), s2);
            a2 = b2;
            condition = 0;
            for (i2 = 1; i2 < n2; i2++) {
              for (j = 1; j < n2; j++) {
                if (i2 != j && Math2.abs(a2[i2][j]) > 1e-3) {
                  condition = 1;
                }
              }
            }
          }
          for (i2 = 0; i2 < n2; i2++) ev.push(a2[i2][i2]);
          return [e2, ev];
        },
        rungekutta: function rungekutta(f2, h2, p2, t_j, u_j, order) {
          var k1, k2, u_j1, k3, k4;
          if (order === 2) {
            while (t_j <= p2) {
              k1 = h2 * f2(t_j, u_j);
              k2 = h2 * f2(t_j + h2, u_j + k1);
              u_j1 = u_j + (k1 + k2) / 2;
              u_j = u_j1;
              t_j = t_j + h2;
            }
          }
          if (order === 4) {
            while (t_j <= p2) {
              k1 = h2 * f2(t_j, u_j);
              k2 = h2 * f2(t_j + h2 / 2, u_j + k1 / 2);
              k3 = h2 * f2(t_j + h2 / 2, u_j + k2 / 2);
              k4 = h2 * f2(t_j + h2, u_j + k3);
              u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;
              u_j = u_j1;
              t_j = t_j + h2;
            }
          }
          return u_j;
        },
        romberg: function romberg(f2, a2, b2, order) {
          var i2 = 0;
          var h2 = (b2 - a2) / 2;
          var x2 = [];
          var h1 = [];
          var g2 = [];
          var m2, a1, j, k2, I2;
          while (i2 < order / 2) {
            I2 = f2(a2);
            for (j = a2, k2 = 0; j <= b2; j = j + h2, k2++) x2[k2] = j;
            m2 = x2.length;
            for (j = 1; j < m2 - 1; j++) {
              I2 += (j % 2 !== 0 ? 4 : 2) * f2(x2[j]);
            }
            I2 = h2 / 3 * (I2 + f2(b2));
            g2[i2] = I2;
            h2 /= 2;
            i2++;
          }
          a1 = g2.length;
          m2 = 1;
          while (a1 !== 1) {
            for (j = 0; j < a1 - 1; j++)
              h1[j] = (Math2.pow(4, m2) * g2[j + 1] - g2[j]) / (Math2.pow(4, m2) - 1);
            a1 = h1.length;
            g2 = h1;
            h1 = [];
            m2++;
          }
          return g2;
        },
        richardson: function richardson(X, f2, x2, h2) {
          function pos(X2, x3) {
            var i3 = 0;
            var n2 = X2.length;
            var p2;
            for (; i3 < n2; i3++)
              if (X2[i3] === x3) p2 = i3;
            return p2;
          }
          var h_min = Math2.abs(x2 - X[pos(X, x2) + 1]);
          var i2 = 0;
          var g2 = [];
          var h1 = [];
          var y1, y2, m2, a2, j;
          while (h2 >= h_min) {
            y1 = pos(X, x2 + h2);
            y2 = pos(X, x2);
            g2[i2] = (f2[y1] - 2 * f2[y2] + f2[2 * y2 - y1]) / (h2 * h2);
            h2 /= 2;
            i2++;
          }
          a2 = g2.length;
          m2 = 1;
          while (a2 != 1) {
            for (j = 0; j < a2 - 1; j++)
              h1[j] = (Math2.pow(4, m2) * g2[j + 1] - g2[j]) / (Math2.pow(4, m2) - 1);
            a2 = h1.length;
            g2 = h1;
            h1 = [];
            m2++;
          }
          return g2;
        },
        simpson: function simpson(f2, a2, b2, n2) {
          var h2 = (b2 - a2) / n2;
          var I2 = f2(a2);
          var x2 = [];
          var j = a2;
          var k2 = 0;
          var i2 = 1;
          var m2;
          for (; j <= b2; j = j + h2, k2++)
            x2[k2] = j;
          m2 = x2.length;
          for (; i2 < m2 - 1; i2++) {
            I2 += (i2 % 2 !== 0 ? 4 : 2) * f2(x2[i2]);
          }
          return h2 / 3 * (I2 + f2(b2));
        },
        hermite: function hermite(X, F2, dF, value) {
          var n2 = X.length;
          var p2 = 0;
          var i2 = 0;
          var l2 = [];
          var dl = [];
          var A2 = [];
          var B = [];
          var j;
          for (; i2 < n2; i2++) {
            l2[i2] = 1;
            for (j = 0; j < n2; j++) {
              if (i2 != j) l2[i2] *= (value - X[j]) / (X[i2] - X[j]);
            }
            dl[i2] = 0;
            for (j = 0; j < n2; j++) {
              if (i2 != j) dl[i2] += 1 / (X[i2] - X[j]);
            }
            A2[i2] = (1 - 2 * (value - X[i2]) * dl[i2]) * (l2[i2] * l2[i2]);
            B[i2] = (value - X[i2]) * (l2[i2] * l2[i2]);
            p2 += A2[i2] * F2[i2] + B[i2] * dF[i2];
          }
          return p2;
        },
        lagrange: function lagrange(X, F2, value) {
          var p2 = 0;
          var i2 = 0;
          var j, l2;
          var n2 = X.length;
          for (; i2 < n2; i2++) {
            l2 = F2[i2];
            for (j = 0; j < n2; j++) {
              if (i2 != j) l2 *= (value - X[j]) / (X[i2] - X[j]);
            }
            p2 += l2;
          }
          return p2;
        },
        cubic_spline: function cubic_spline(X, F2, value) {
          var n2 = X.length;
          var i2 = 0, j;
          var A2 = [];
          var B = [];
          var alpha = [];
          var c2 = [];
          var h2 = [];
          var b2 = [];
          var d2 = [];
          for (; i2 < n2 - 1; i2++)
            h2[i2] = X[i2 + 1] - X[i2];
          alpha[0] = 0;
          for (i2 = 1; i2 < n2 - 1; i2++) {
            alpha[i2] = 3 / h2[i2] * (F2[i2 + 1] - F2[i2]) - 3 / h2[i2 - 1] * (F2[i2] - F2[i2 - 1]);
          }
          for (i2 = 1; i2 < n2 - 1; i2++) {
            A2[i2] = [];
            B[i2] = [];
            A2[i2][i2 - 1] = h2[i2 - 1];
            A2[i2][i2] = 2 * (h2[i2 - 1] + h2[i2]);
            A2[i2][i2 + 1] = h2[i2];
            B[i2][0] = alpha[i2];
          }
          c2 = jStat3.multiply(jStat3.inv(A2), B);
          for (j = 0; j < n2 - 1; j++) {
            b2[j] = (F2[j + 1] - F2[j]) / h2[j] - h2[j] * (c2[j + 1][0] + 2 * c2[j][0]) / 3;
            d2[j] = (c2[j + 1][0] - c2[j][0]) / (3 * h2[j]);
          }
          for (j = 0; j < n2; j++) {
            if (X[j] > value) break;
          }
          j -= 1;
          return F2[j] + (value - X[j]) * b2[j] + jStat3.sq(value - X[j]) * c2[j] + (value - X[j]) * jStat3.sq(value - X[j]) * d2[j];
        },
        gauss_quadrature: function gauss_quadrature() {
          throw new Error("gauss_quadrature not yet implemented");
        },
        PCA: function PCA(X) {
          var m2 = X.length;
          var n2 = X[0].length;
          var i2 = 0;
          var j, temp1;
          var u2 = [];
          var D2 = [];
          var result = [];
          var temp2 = [];
          var Y = [];
          var Bt = [];
          var B = [];
          var C2 = [];
          var V = [];
          var Vt = [];
          for (i2 = 0; i2 < m2; i2++) {
            u2[i2] = jStat3.sum(X[i2]) / n2;
          }
          for (i2 = 0; i2 < n2; i2++) {
            B[i2] = [];
            for (j = 0; j < m2; j++) {
              B[i2][j] = X[j][i2] - u2[j];
            }
          }
          B = jStat3.transpose(B);
          for (i2 = 0; i2 < m2; i2++) {
            C2[i2] = [];
            for (j = 0; j < m2; j++) {
              C2[i2][j] = jStat3.dot([B[i2]], [B[j]]) / (n2 - 1);
            }
          }
          result = jStat3.jacobi(C2);
          V = result[0];
          D2 = result[1];
          Vt = jStat3.transpose(V);
          for (i2 = 0; i2 < D2.length; i2++) {
            for (j = i2; j < D2.length; j++) {
              if (D2[i2] < D2[j]) {
                temp1 = D2[i2];
                D2[i2] = D2[j];
                D2[j] = temp1;
                temp2 = Vt[i2];
                Vt[i2] = Vt[j];
                Vt[j] = temp2;
              }
            }
          }
          Bt = jStat3.transpose(B);
          for (i2 = 0; i2 < m2; i2++) {
            Y[i2] = [];
            for (j = 0; j < Bt.length; j++) {
              Y[i2][j] = jStat3.dot([Vt[i2]], [Bt[j]]);
            }
          }
          return [X, D2, Vt, Y];
        }
      });
      (function(funcs) {
        for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
          jStat3.fn[passfunc] = function(arg, func) {
            var tmpthis = this;
            if (func) {
              setTimeout(function() {
                func.call(tmpthis, jStat3.fn[passfunc].call(tmpthis, arg));
              }, 15);
              return this;
            }
            if (typeof jStat3[passfunc](this, arg) === "number")
              return jStat3[passfunc](this, arg);
            else
              return jStat3(jStat3[passfunc](this, arg));
          };
        })(funcs[i2]);
      })("add divide multiply subtract dot pow exp log abs norm angle".split(" "));
    })(jStat2, Math);
    (function(jStat3, Math2) {
      var slice = [].slice;
      var isNumber = jStat3.utils.isNumber;
      var isArray = jStat3.utils.isArray;
      jStat3.extend({
        // 2 different parameter lists:
        // (value, mean, sd)
        // (value, array, flag)
        zscore: function zscore() {
          var args = slice.call(arguments);
          if (isNumber(args[1])) {
            return (args[0] - args[1]) / args[2];
          }
          return (args[0] - jStat3.mean(args[1])) / jStat3.stdev(args[1], args[2]);
        },
        // 3 different paramter lists:
        // (value, mean, sd, sides)
        // (zscore, sides)
        // (value, array, sides, flag)
        ztest: function ztest() {
          var args = slice.call(arguments);
          var z;
          if (isArray(args[1])) {
            z = jStat3.zscore(args[0], args[1], args[3]);
            return args[2] === 1 ? jStat3.normal.cdf(-Math2.abs(z), 0, 1) : jStat3.normal.cdf(-Math2.abs(z), 0, 1) * 2;
          } else {
            if (args.length > 2) {
              z = jStat3.zscore(args[0], args[1], args[2]);
              return args[3] === 1 ? jStat3.normal.cdf(-Math2.abs(z), 0, 1) : jStat3.normal.cdf(-Math2.abs(z), 0, 1) * 2;
            } else {
              z = args[0];
              return args[1] === 1 ? jStat3.normal.cdf(-Math2.abs(z), 0, 1) : jStat3.normal.cdf(-Math2.abs(z), 0, 1) * 2;
            }
          }
        }
      });
      jStat3.extend(jStat3.fn, {
        zscore: function zscore(value, flag) {
          return (value - this.mean()) / this.stdev(flag);
        },
        ztest: function ztest(value, sides, flag) {
          var zscore = Math2.abs(this.zscore(value, flag));
          return sides === 1 ? jStat3.normal.cdf(-zscore, 0, 1) : jStat3.normal.cdf(-zscore, 0, 1) * 2;
        }
      });
      jStat3.extend({
        // 2 parameter lists
        // (value, mean, sd, n)
        // (value, array)
        tscore: function tscore() {
          var args = slice.call(arguments);
          return args.length === 4 ? (args[0] - args[1]) / (args[2] / Math2.sqrt(args[3])) : (args[0] - jStat3.mean(args[1])) / (jStat3.stdev(args[1], true) / Math2.sqrt(args[1].length));
        },
        // 3 different paramter lists:
        // (value, mean, sd, n, sides)
        // (tscore, n, sides)
        // (value, array, sides)
        ttest: function ttest() {
          var args = slice.call(arguments);
          var tscore;
          if (args.length === 5) {
            tscore = Math2.abs(jStat3.tscore(args[0], args[1], args[2], args[3]));
            return args[4] === 1 ? jStat3.studentt.cdf(-tscore, args[3] - 1) : jStat3.studentt.cdf(-tscore, args[3] - 1) * 2;
          }
          if (isNumber(args[1])) {
            tscore = Math2.abs(args[0]);
            return args[2] == 1 ? jStat3.studentt.cdf(-tscore, args[1] - 1) : jStat3.studentt.cdf(-tscore, args[1] - 1) * 2;
          }
          tscore = Math2.abs(jStat3.tscore(args[0], args[1]));
          return args[2] == 1 ? jStat3.studentt.cdf(-tscore, args[1].length - 1) : jStat3.studentt.cdf(-tscore, args[1].length - 1) * 2;
        }
      });
      jStat3.extend(jStat3.fn, {
        tscore: function tscore(value) {
          return (value - this.mean()) / (this.stdev(true) / Math2.sqrt(this.cols()));
        },
        ttest: function ttest(value, sides) {
          return sides === 1 ? 1 - jStat3.studentt.cdf(Math2.abs(this.tscore(value)), this.cols() - 1) : jStat3.studentt.cdf(-Math2.abs(this.tscore(value)), this.cols() - 1) * 2;
        }
      });
      jStat3.extend({
        // Paramter list is as follows:
        // (array1, array2, array3, ...)
        // or it is an array of arrays
        // array of arrays conversion
        anovafscore: function anovafscore() {
          var args = slice.call(arguments), expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i2, j;
          if (args.length === 1) {
            tmpargs = new Array(args[0].length);
            for (i2 = 0; i2 < args[0].length; i2++) {
              tmpargs[i2] = args[0][i2];
            }
            args = tmpargs;
          }
          sample = new Array();
          for (i2 = 0; i2 < args.length; i2++) {
            sample = sample.concat(args[i2]);
          }
          sampMean = jStat3.mean(sample);
          expVar = 0;
          for (i2 = 0; i2 < args.length; i2++) {
            expVar = expVar + args[i2].length * Math2.pow(jStat3.mean(args[i2]) - sampMean, 2);
          }
          expVar /= args.length - 1;
          unexpVar = 0;
          for (i2 = 0; i2 < args.length; i2++) {
            sampSampMean = jStat3.mean(args[i2]);
            for (j = 0; j < args[i2].length; j++) {
              unexpVar += Math2.pow(args[i2][j] - sampSampMean, 2);
            }
          }
          unexpVar /= sample.length - args.length;
          return expVar / unexpVar;
        },
        // 2 different paramter setups
        // (array1, array2, array3, ...)
        // (anovafscore, df1, df2)
        anovaftest: function anovaftest() {
          var args = slice.call(arguments), df1, df2, n2, i2;
          if (isNumber(args[0])) {
            return 1 - jStat3.centralF.cdf(args[0], args[1], args[2]);
          }
          var anovafscore = jStat3.anovafscore(args);
          df1 = args.length - 1;
          n2 = 0;
          for (i2 = 0; i2 < args.length; i2++) {
            n2 = n2 + args[i2].length;
          }
          df2 = n2 - df1 - 1;
          return 1 - jStat3.centralF.cdf(anovafscore, df1, df2);
        },
        ftest: function ftest(fscore, df1, df2) {
          return 1 - jStat3.centralF.cdf(fscore, df1, df2);
        }
      });
      jStat3.extend(jStat3.fn, {
        anovafscore: function anovafscore() {
          return jStat3.anovafscore(this.toArray());
        },
        anovaftes: function anovaftes() {
          var n2 = 0;
          var i2;
          for (i2 = 0; i2 < this.length; i2++) {
            n2 = n2 + this[i2].length;
          }
          return jStat3.ftest(this.anovafscore(), this.length - 1, n2 - this.length);
        }
      });
      jStat3.extend({
        // 2 parameter lists
        // (mean1, mean2, n1, n2, sd)
        // (array1, array2, sd)
        qscore: function qscore() {
          var args = slice.call(arguments);
          var mean1, mean2, n1, n2, sd;
          if (isNumber(args[0])) {
            mean1 = args[0];
            mean2 = args[1];
            n1 = args[2];
            n2 = args[3];
            sd = args[4];
          } else {
            mean1 = jStat3.mean(args[0]);
            mean2 = jStat3.mean(args[1]);
            n1 = args[0].length;
            n2 = args[1].length;
            sd = args[2];
          }
          return Math2.abs(mean1 - mean2) / (sd * Math2.sqrt((1 / n1 + 1 / n2) / 2));
        },
        // 3 different parameter lists:
        // (qscore, n, k)
        // (mean1, mean2, n1, n2, sd, n, k)
        // (array1, array2, sd, n, k)
        qtest: function qtest() {
          var args = slice.call(arguments);
          var qscore;
          if (args.length === 3) {
            qscore = args[0];
            args = args.slice(1);
          } else if (args.length === 7) {
            qscore = jStat3.qscore(args[0], args[1], args[2], args[3], args[4]);
            args = args.slice(5);
          } else {
            qscore = jStat3.qscore(args[0], args[1], args[2]);
            args = args.slice(3);
          }
          var n2 = args[0];
          var k2 = args[1];
          return 1 - jStat3.tukey.cdf(qscore, k2, n2 - k2);
        },
        tukeyhsd: function tukeyhsd(arrays) {
          var sd = jStat3.pooledstdev(arrays);
          var means = arrays.map(function(arr) {
            return jStat3.mean(arr);
          });
          var n2 = arrays.reduce(function(n3, arr) {
            return n3 + arr.length;
          }, 0);
          var results = [];
          for (var i2 = 0; i2 < arrays.length; ++i2) {
            for (var j = i2 + 1; j < arrays.length; ++j) {
              var p2 = jStat3.qtest(means[i2], means[j], arrays[i2].length, arrays[j].length, sd, n2, arrays.length);
              results.push([[i2, j], p2]);
            }
          }
          return results;
        }
      });
      jStat3.extend({
        // 2 different parameter setups
        // (value, alpha, sd, n)
        // (value, alpha, array)
        normalci: function normalci() {
          var args = slice.call(arguments), ans = new Array(2), change;
          if (args.length === 4) {
            change = Math2.abs(jStat3.normal.inv(args[1] / 2, 0, 1) * args[2] / Math2.sqrt(args[3]));
          } else {
            change = Math2.abs(jStat3.normal.inv(args[1] / 2, 0, 1) * jStat3.stdev(args[2]) / Math2.sqrt(args[2].length));
          }
          ans[0] = args[0] - change;
          ans[1] = args[0] + change;
          return ans;
        },
        // 2 different parameter setups
        // (value, alpha, sd, n)
        // (value, alpha, array)
        tci: function tci() {
          var args = slice.call(arguments), ans = new Array(2), change;
          if (args.length === 4) {
            change = Math2.abs(jStat3.studentt.inv(args[1] / 2, args[3] - 1) * args[2] / Math2.sqrt(args[3]));
          } else {
            change = Math2.abs(jStat3.studentt.inv(args[1] / 2, args[2].length - 1) * jStat3.stdev(args[2], true) / Math2.sqrt(args[2].length));
          }
          ans[0] = args[0] - change;
          ans[1] = args[0] + change;
          return ans;
        },
        significant: function significant(pvalue, alpha) {
          return pvalue < alpha;
        }
      });
      jStat3.extend(jStat3.fn, {
        normalci: function normalci(value, alpha) {
          return jStat3.normalci(value, alpha, this.toArray());
        },
        tci: function tci(value, alpha) {
          return jStat3.tci(value, alpha, this.toArray());
        }
      });
      function differenceOfProportions(p1, n1, p2, n2) {
        if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {
          throw new Error("Proportions should be greater than 0 and less than 1");
        }
        var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);
        var se = Math2.sqrt(pooled * (1 - pooled) * (1 / n1 + 1 / n2));
        return (p1 - p2) / se;
      }
      jStat3.extend(jStat3.fn, {
        oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {
          var z = differenceOfProportions(p1, n1, p2, n2);
          return jStat3.ztest(z, 1);
        },
        twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {
          var z = differenceOfProportions(p1, n1, p2, n2);
          return jStat3.ztest(z, 2);
        }
      });
    })(jStat2, Math);
    jStat2.models = /* @__PURE__ */ (function() {
      function sub_regress(exog) {
        var var_count = exog[0].length;
        var modelList = jStat2.arange(var_count).map(function(endog_index) {
          var exog_index = jStat2.arange(var_count).filter(function(i2) {
            return i2 !== endog_index;
          });
          return ols(
            jStat2.col(exog, endog_index).map(function(x2) {
              return x2[0];
            }),
            jStat2.col(exog, exog_index)
          );
        });
        return modelList;
      }
      function ols(endog, exog) {
        var nobs = endog.length;
        var df_model = exog[0].length - 1;
        var df_resid = nobs - df_model - 1;
        var coef = jStat2.lstsq(exog, endog);
        var predict = jStat2.multiply(exog, coef.map(function(x2) {
          return [x2];
        })).map(function(p2) {
          return p2[0];
        });
        var resid = jStat2.subtract(endog, predict);
        var ybar = jStat2.mean(endog);
        var SSE = jStat2.sum(predict.map(function(f2) {
          return Math.pow(f2 - ybar, 2);
        }));
        var SSR = jStat2.sum(endog.map(function(y2, i2) {
          return Math.pow(y2 - predict[i2], 2);
        }));
        var SST = SSE + SSR;
        var R2 = SSE / SST;
        return {
          exog,
          endog,
          nobs,
          df_model,
          df_resid,
          coef,
          predict,
          resid,
          ybar,
          SST,
          SSE,
          SSR,
          R2
        };
      }
      function t_test(model) {
        var subModelList = sub_regress(model.exog);
        var sigmaHat = Math.sqrt(model.SSR / model.df_resid);
        var seBetaHat = subModelList.map(function(mod) {
          var SST = mod.SST;
          var R2 = mod.R2;
          return sigmaHat / Math.sqrt(SST * (1 - R2));
        });
        var tStatistic = model.coef.map(function(coef, i2) {
          return (coef - 0) / seBetaHat[i2];
        });
        var pValue = tStatistic.map(function(t2) {
          var leftppf = jStat2.studentt.cdf(t2, model.df_resid);
          return (leftppf > 0.5 ? 1 - leftppf : leftppf) * 2;
        });
        var c2 = jStat2.studentt.inv(0.975, model.df_resid);
        var interval95 = model.coef.map(function(coef, i2) {
          var d2 = c2 * seBetaHat[i2];
          return [coef - d2, coef + d2];
        });
        return {
          se: seBetaHat,
          t: tStatistic,
          p: pValue,
          sigmaHat,
          interval95
        };
      }
      function F_test(model) {
        var F_statistic = model.R2 / model.df_model / ((1 - model.R2) / model.df_resid);
        var fcdf = function(x2, n1, n2) {
          return jStat2.beta.cdf(x2 / (n2 / n1 + x2), n1 / 2, n2 / 2);
        };
        var pvalue = 1 - fcdf(F_statistic, model.df_model, model.df_resid);
        return { F_statistic, pvalue };
      }
      function ols_wrap(endog, exog) {
        var model = ols(endog, exog);
        var ttest = t_test(model);
        var ftest = F_test(model);
        var adjust_R2 = 1 - (1 - model.R2) * ((model.nobs - 1) / model.df_resid);
        model.t = ttest;
        model.f = ftest;
        model.adjust_R2 = adjust_R2;
        return model;
      }
      return { ols: ols_wrap };
    })();
    jStat2.extend({
      buildxmatrix: function buildxmatrix() {
        var matrixRows = new Array(arguments.length);
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var array2 = [1];
          matrixRows[i2] = array2.concat(arguments[i2]);
        }
        return jStat2(matrixRows);
      },
      builddxmatrix: function builddxmatrix() {
        var matrixRows = new Array(arguments[0].length);
        for (var i2 = 0; i2 < arguments[0].length; i2++) {
          var array2 = [1];
          matrixRows[i2] = array2.concat(arguments[0][i2]);
        }
        return jStat2(matrixRows);
      },
      buildjxmatrix: function buildjxmatrix(jMat) {
        var pass = new Array(jMat.length);
        for (var i2 = 0; i2 < jMat.length; i2++) {
          pass[i2] = jMat[i2];
        }
        return jStat2.builddxmatrix(pass);
      },
      buildymatrix: function buildymatrix(array2) {
        return jStat2(array2).transpose();
      },
      buildjymatrix: function buildjymatrix(jMat) {
        return jMat.transpose();
      },
      matrixmult: function matrixmult(A2, B) {
        var i2, j, k2, result, sum;
        if (A2.cols() == B.rows()) {
          if (B.rows() > 1) {
            result = [];
            for (i2 = 0; i2 < A2.rows(); i2++) {
              result[i2] = [];
              for (j = 0; j < B.cols(); j++) {
                sum = 0;
                for (k2 = 0; k2 < A2.cols(); k2++) {
                  sum += A2.toArray()[i2][k2] * B.toArray()[k2][j];
                }
                result[i2][j] = sum;
              }
            }
            return jStat2(result);
          }
          result = [];
          for (i2 = 0; i2 < A2.rows(); i2++) {
            result[i2] = [];
            for (j = 0; j < B.cols(); j++) {
              sum = 0;
              for (k2 = 0; k2 < A2.cols(); k2++) {
                sum += A2.toArray()[i2][k2] * B.toArray()[j];
              }
              result[i2][j] = sum;
            }
          }
          return jStat2(result);
        }
      },
      //regress and regresst to be fixed
      regress: function regress(jMatX, jMatY) {
        var innerinv = jStat2.xtranspxinv(jMatX);
        var xtransp = jMatX.transpose();
        var next = jStat2.matrixmult(jStat2(innerinv), xtransp);
        return jStat2.matrixmult(next, jMatY);
      },
      regresst: function regresst(jMatX, jMatY, sides) {
        var beta = jStat2.regress(jMatX, jMatY);
        var compile = {};
        compile.anova = {};
        var jMatYBar = jStat2.jMatYBar(jMatX, beta);
        compile.yBar = jMatYBar;
        var yAverage = jMatY.mean();
        compile.anova.residuals = jStat2.residuals(jMatY, jMatYBar);
        compile.anova.ssr = jStat2.ssr(jMatYBar, yAverage);
        compile.anova.msr = compile.anova.ssr / (jMatX[0].length - 1);
        compile.anova.sse = jStat2.sse(jMatY, jMatYBar);
        compile.anova.mse = compile.anova.sse / (jMatY.length - (jMatX[0].length - 1) - 1);
        compile.anova.sst = jStat2.sst(jMatY, yAverage);
        compile.anova.mst = compile.anova.sst / (jMatY.length - 1);
        compile.anova.r2 = 1 - compile.anova.sse / compile.anova.sst;
        if (compile.anova.r2 < 0) compile.anova.r2 = 0;
        compile.anova.fratio = compile.anova.msr / compile.anova.mse;
        compile.anova.pvalue = jStat2.anovaftest(
          compile.anova.fratio,
          jMatX[0].length - 1,
          jMatY.length - (jMatX[0].length - 1) - 1
        );
        compile.anova.rmse = Math.sqrt(compile.anova.mse);
        compile.anova.r2adj = 1 - compile.anova.mse / compile.anova.mst;
        if (compile.anova.r2adj < 0) compile.anova.r2adj = 0;
        compile.stats = new Array(jMatX[0].length);
        var covar = jStat2.xtranspxinv(jMatX);
        var sds, ts, ps;
        for (var i2 = 0; i2 < beta.length; i2++) {
          sds = Math.sqrt(compile.anova.mse * Math.abs(covar[i2][i2]));
          ts = Math.abs(beta[i2] / sds);
          ps = jStat2.ttest(ts, jMatY.length - jMatX[0].length - 1, sides);
          compile.stats[i2] = [beta[i2], sds, ts, ps];
        }
        compile.regress = beta;
        return compile;
      },
      xtranspx: function xtranspx(jMatX) {
        return jStat2.matrixmult(jMatX.transpose(), jMatX);
      },
      xtranspxinv: function xtranspxinv(jMatX) {
        var inner = jStat2.matrixmult(jMatX.transpose(), jMatX);
        var innerinv = jStat2.inv(inner);
        return innerinv;
      },
      jMatYBar: function jMatYBar(jMatX, beta) {
        var yBar = jStat2.matrixmult(jMatX, beta);
        return new jStat2(yBar);
      },
      residuals: function residuals(jMatY, jMatYBar) {
        return jStat2.matrixsubtract(jMatY, jMatYBar);
      },
      ssr: function ssr(jMatYBar, yAverage) {
        var ssr2 = 0;
        for (var i2 = 0; i2 < jMatYBar.length; i2++) {
          ssr2 += Math.pow(jMatYBar[i2] - yAverage, 2);
        }
        return ssr2;
      },
      sse: function sse(jMatY, jMatYBar) {
        var sse2 = 0;
        for (var i2 = 0; i2 < jMatY.length; i2++) {
          sse2 += Math.pow(jMatY[i2] - jMatYBar[i2], 2);
        }
        return sse2;
      },
      sst: function sst(jMatY, yAverage) {
        var sst2 = 0;
        for (var i2 = 0; i2 < jMatY.length; i2++) {
          sst2 += Math.pow(jMatY[i2] - yAverage, 2);
        }
        return sst2;
      },
      matrixsubtract: function matrixsubtract(A2, B) {
        var ans = new Array(A2.length);
        for (var i2 = 0; i2 < A2.length; i2++) {
          ans[i2] = new Array(A2[i2].length);
          for (var j = 0; j < A2[i2].length; j++) {
            ans[i2][j] = A2[i2][j] - B[i2][j];
          }
        }
        return jStat2(ans);
      }
    });
    jStat2.jStat = jStat2;
    return jStat2;
  });

  // ../insight-maker-simulation/src/formula/Rand.js
  var RandList = class {
    /**
     * @param {import("../Simulator").Simulator} simulate
     */
    constructor(simulate) {
      this.simulate = simulate;
      this.vals = [];
    }
    /**
     * @param {number} i
     *
     * @returns {number}
     */
    get(i2) {
      if (i2 > this.vals.length - 1) {
        for (let j = this.vals.length; j <= i2; j++) {
          if (this.simulate.random) {
            this.vals.push(this.simulate.random());
          } else {
            this.vals.push(Math.random());
          }
        }
      }
      return this.vals[i2];
    }
  };
  function getRandPos(simulate) {
    return Math.floor((simulate.time().value - simulate.timeStart.value) / simulate.timeStep.value);
  }
  function Rand(simulate, minVal = null, maxVal = null) {
    simulate.stochastic = true;
    if (minVal !== null && minVal !== void 0) {
      isNormalNumber(minVal, "Rand", "Minimum");
      isNormalNumber(maxVal, "Rand", "Maximum");
      return Rand(simulate) * (maxVal - minVal) + (0 + minVal);
    }
    if (simulate.RKOrder === 1) {
      if (simulate.random) {
        return simulate.random();
      } else {
        return Math.random();
      }
    }
    let RandPos = getRandPos(simulate);
    if (RandPos !== simulate.lastRandPos) {
      simulate.randLoc = -1;
      simulate.lastRandPos = RandPos;
    }
    while (simulate.previousRandLists.length <= RandPos) {
      simulate.previousRandLists.push(new RandList(simulate));
    }
    simulate.randLoc = simulate.randLoc + 1;
    return simulate.previousRandLists[RandPos].get(simulate.randLoc);
  }
  function RandNormal(simulate, mu = null, sigma = null) {
    if (mu === null) {
      mu = 0;
    }
    if (sigma === null) {
      sigma = 1;
    }
    isNormalNumber(mu, "RandNormal", "mu");
    isNormalNumber(sigma, "RandNormal", "sigma");
    let z = Math.sqrt(-2 * Math.log(1 - Rand(simulate))) * Math.cos(Rand(simulate) * 2 * Math.PI);
    return z * sigma + mu;
  }
  function RandExp(simulate, lambda = null) {
    if (lambda === null) {
      lambda = 1;
    }
    if (lambda < 0) {
      throw new ModelError(`Lambda for RandExp must be greater than or equal to 0; got ${lambda}.`, {
        code: 4e3
      });
    }
    isNormalNumber(lambda, "RandExp", "lambda");
    return -Math.log(Rand(simulate)) / lambda;
  }
  function RandLognormal(simulate, mu, sigma) {
    isNormalNumber(mu, "RandLognormal", "mu");
    isNormalNumber(sigma, "RandLognormal", "sigma");
    if (mu <= 0) {
      throw new ModelError(`<i>Mu</i> for RandLognormal() must be greater than 0; got ${mu}.`, {
        code: 4001
      });
    }
    if (sigma <= 0) {
      throw new ModelError(`<i>Sigma</i> for RandLognormal() must be greater than 0; got ${sigma}.`, {
        code: 4002
      });
    }
    let lmu = Math.log(mu) - 0.5 * Math.log(1 + Math.pow(sigma / mu, 2));
    let lsigma = Math.sqrt(Math.log(1 + Math.pow(sigma / mu, 2)));
    return Math.exp(RandNormal(simulate, lmu, lsigma));
  }
  function RandBinomial(simulate, count, probability) {
    isNormalNumber(count, "RandBinomial", "count");
    isNormalNumber(probability, "RandBinomial", "probability");
    if (count < 0) {
      throw new ModelError(`<i>Count</i> for RandBinomial() must be greater than or equal to 0; got ${count}.`, {
        code: 4003
      });
    }
    if (probability < 0 || probability > 1) {
      throw new ModelError(`<i>Probability</i> for RandBinomial() must be between 0 and 1 (inclusive); got ${probability}.`, {
        code: 4004
      });
    }
    if (count === 0 || probability === 0) {
      return 0;
    }
    if (probability <= 0.5) {
      if (probability * count <= 30) {
        return randomBinomialInversion(simulate, count, probability);
      } else {
        return randomBinomialBtpe(simulate, count, probability);
      }
    } else {
      let q = 1 - probability;
      if (q * count <= 30) {
        return count - randomBinomialInversion(simulate, count, q);
      } else {
        return count - randomBinomialBtpe(simulate, count, q);
      }
    }
  }
  function randomBinomialBtpe(simulate, n2, p2) {
    let r2, q, fm, p1, xm, xl, xr, c2, laml, lamr, p22, p3, p4;
    let a2, u2, v2, s2, F2, rho, t2, A2, nrq, x1, x2, f1, f2, z, z2, w2, w22, x3;
    let m2, y2, k2, i2;
    r2 = Math.min(p2, 1 - p2);
    q = 1 - r2;
    fm = n2 * r2 + r2;
    m2 = Math.floor(fm);
    p1 = Math.floor(2.195 * Math.sqrt(n2 * r2 * q) - 4.6 * q) + 0.5;
    xm = m2 + 0.5;
    xl = xm - p1;
    xr = xm + p1;
    c2 = 0.134 + 20.5 / (15.3 + m2);
    a2 = (fm - xl) / (fm - xl * r2);
    laml = a2 * (1 + a2 / 2);
    a2 = (xr - fm) / (xr * q);
    lamr = a2 * (1 + a2 / 2);
    p22 = p1 * (1 + 2 * c2);
    p3 = p22 + c2 / laml;
    p4 = p3 + c2 / lamr;
    while (true) {
      nrq = n2 * r2 * q;
      u2 = Rand(simulate) * p4;
      v2 = Rand(simulate);
      if (!(u2 > p1)) {
        y2 = Math.floor(xm - p1 * v2 + u2);
        break;
      }
      if (!(u2 > p22)) {
        x3 = xl + (u2 - p1) / c2;
        v2 = v2 * c2 + 1 - Math.abs(m2 - x3 + 0.5) / p1;
        if (v2 > 1) {
          continue;
        }
        y2 = Math.floor(x3);
      } else if (!(u2 > p3)) {
        y2 = Math.floor(xl + Math.log(v2) / laml);
        if (y2 < 0 || v2 === 0) {
          continue;
        }
        v2 = v2 * (u2 - p22) * laml;
      } else {
        y2 = Math.floor(xr - Math.log(v2) / lamr);
        if (y2 > n2 || v2 === 0) {
          continue;
        }
        v2 = v2 * (u2 - p3) * lamr;
      }
      k2 = Math.abs(y2 - m2);
      if (!(k2 > 20 && k2 < nrq / 2 - 1)) {
        s2 = r2 / q;
        a2 = s2 * (n2 + 1);
        F2 = 1;
        if (m2 < y2) {
          for (i2 = m2 + 1; i2 <= y2; i2++) {
            F2 *= a2 / i2 - s2;
          }
        } else if (m2 > y2) {
          for (i2 = y2 + 1; i2 <= m2; i2++) {
            F2 /= a2 / i2 - s2;
          }
        }
        if (v2 > F2) {
          continue;
        }
        break;
      } else {
        rho = k2 / nrq * ((k2 * (k2 / 3 + 0.625) + 0.16666666666666666) / nrq + 0.5);
        t2 = -k2 * k2 / (2 * nrq);
        A2 = Math.log(v2);
        if (A2 < t2 - rho) {
          break;
        }
        if (A2 > t2 + rho) {
          continue;
        }
        x1 = y2 + 1;
        f1 = m2 + 1;
        z = n2 + 1 - m2;
        w2 = n2 - y2 + 1;
        x2 = x1 * x1;
        f2 = f1 * f1;
        z2 = z * z;
        w22 = w2 * w2;
        if (A2 > xm * Math.log(f1 / x1) + (n2 - m2 + 0.5) * Math.log(z / w2) + (y2 - m2) * Math.log(w2 * r2 / (x1 * q)) + (13680 - (462 - (132 - (99 - 140 / f2) / f2) / f2) / f2) / f1 / 166320 + (13680 - (462 - (132 - (99 - 140 / z2) / z2) / z2) / z2) / z / 166320 + (13680 - (462 - (132 - (99 - 140 / x2) / x2) / x2) / x2) / x1 / 166320 + (13680 - (462 - (132 - (99 - 140 / w22) / w22) / w22) / w22) / w2 / 166320) {
          continue;
        }
      }
    }
    if (p2 > 0.5) {
      y2 = n2 - y2;
    }
    return y2;
  }
  function randomBinomialInversion(simulate, n2, p2) {
    let q, qn, np, px, U;
    let X, bound;
    q = 1 - p2;
    qn = Math.exp(n2 * Math.log(q));
    np = n2 * p2;
    bound = Math.min(n2, np + 10 * Math.sqrt(np * q + 1));
    X = 0;
    px = qn;
    U = Rand(simulate);
    while (U > px) {
      X++;
      if (X > bound) {
        X = 0;
        px = qn;
        U = Rand(simulate);
      } else {
        U -= px;
        px = (n2 - X + 1) * p2 * px / (X * q);
      }
    }
    return X;
  }
  function RandNegativeBinomial(simulate, successes, probability) {
    isNormalNumber(successes, "RandNegativeBinomial", "successes");
    isNormalNumber(probability, "RandNegativeBinomial", "probability");
    if (successes < 0) {
      throw new ModelError(`<i>Successes</i> for RandNegativeBinomial() must be greater than or equal to 0; got ${successes}.`, {
        code: 4005
      });
    }
    if (probability < 0 || probability > 1) {
      throw new ModelError(`<i>Probability</i> for RandNegativeBinomial() must be between 0 and 1 (inclusive); got ${probability}.`, {
        code: 4006
      });
    }
    if (successes === 0) {
      return 0;
    }
    if (probability === 1) {
      return successes;
    }
    if (probability === 0) {
      throw new ModelError("<i>Probability</i> for RandNegativeBinomial() cannot be 0 when <i>successes</i> > 0.", {
        code: 4021
      });
    }
    let i2 = 0;
    let s2 = 0;
    while (s2 < successes) {
      if (Rand(simulate) <= probability) {
        s2 = s2 + 1;
      }
      i2 = i2 + 1;
    }
    return i2;
  }
  function RandPoisson(simulate, lambda) {
    isNormalNumber(lambda, "RandPoisson", "lambda");
    if (lambda < 0) {
      throw new ModelError(`<i>Lambda</i> for RandPoisson() must be greater than or equal to 0; got ${lambda}.`, {
        code: 4007
      });
    }
    if (lambda < 50) {
      let L2 = Math.exp(-lambda);
      let k2 = 0;
      let p2 = 1;
      while (true) {
        k2 = k2 + 1;
        p2 = p2 * Rand(simulate);
        if (!(p2 > L2)) {
          break;
        }
      }
      return k2 - 1;
    } else {
      let c2 = 0.767 - 3.36 / lambda;
      let beta = Math.PI / Math.sqrt(3 * lambda);
      let alpha = beta * lambda;
      let k2 = Math.log(c2) - lambda - Math.log(beta);
      while (true) {
        let u2 = Rand(simulate);
        let x2 = (alpha - Math.log((1 - u2) / u2)) / beta;
        let n2 = Math.floor(x2 + 0.5);
        if (n2 < 0) {
          continue;
        }
        let v2 = Rand(simulate);
        let y2 = alpha - beta * x2;
        let lhs = y2 + Math.log(v2 / Math.pow(1 + Math.exp(y2), 2));
        let rhs = k2 + n2 * Math.log(lambda) - jStat.gammaln(n2 + 1);
        if (lhs <= rhs) {
          return n2;
        }
      }
    }
  }
  function RandGamma(simulate, alpha, beta) {
    isNormalNumber(alpha, "RandGamma", "alpha");
    isNormalNumber(beta, "RandGamma", "beta");
    if (alpha <= 0) {
      throw new ModelError(`<i>Alpha</i> (shape parameter) for RandGamma() must be greater than 0; got ${alpha}.`, {
        code: 4008
      });
    }
    if (beta <= 0) {
      throw new ModelError(`<i>Beta</i> (scale parameter) for RandGamma() must be greater than 0; got ${beta}.`, {
        code: 4009
      });
    }
    function gammaShapeGe1(a2) {
      const d2 = a2 - 1 / 3;
      const c2 = 1 / Math.sqrt(9 * d2);
      while (true) {
        const z = RandNormal(simulate, 0, 1);
        if (!Number.isFinite(z)) continue;
        const t2 = 1 + c2 * z;
        if (t2 <= 0) continue;
        const v2 = t2 * t2 * t2;
        const u2 = Rand(simulate);
        if (!(u2 > 0 && u2 < 1)) continue;
        const z2 = z * z;
        if (u2 < 1 - 0.0331 * z2 * z2) return d2 * v2;
        if (Math.log(u2) < 0.5 * z2 + d2 * (1 - v2 + Math.log(v2))) return d2 * v2;
      }
    }
    let x2;
    if (alpha >= 1) {
      x2 = gammaShapeGe1(alpha);
    } else {
      const g2 = gammaShapeGe1(alpha + 1);
      const u2 = Math.max(Rand(simulate), Number.EPSILON);
      x2 = g2 * Math.pow(u2, 1 / alpha);
    }
    return x2 * beta;
  }
  function RandBeta(simulate, alpha, beta) {
    isNormalNumber(alpha, "RandBeta", "alpha");
    isNormalNumber(beta, "RandBeta", "beta");
    if (alpha <= 0) {
      throw new ModelError(`<i>Alpha</i> for RandBeta() must be greater than 0; got ${alpha}.`, {
        code: 4010
      });
    }
    if (beta <= 0) {
      throw new ModelError(`<i>Beta</i> for RandBeta() must be greater than 0; got ${beta}.`, {
        code: 4011
      });
    }
    let x2 = RandGamma(simulate, alpha, 1);
    let y2 = RandGamma(simulate, beta, 1);
    return x2 / (x2 + y2);
  }
  function RandTriangular(simulate, minimum, maximum, peak) {
    isNormalNumber(minimum, "RandTriangular", "minimum");
    isNormalNumber(maximum, "RandTriangular", "maximum");
    isNormalNumber(peak, "RandTriangular", "peak");
    let a2 = 0 + minimum;
    let b2 = 0 + maximum;
    let c2 = 0 + peak;
    if (a2 === b2) {
      throw new ModelError("Maximum can't equal the minimum for the triangular distribution.", {
        code: 4012
      });
    }
    if (c2 < a2 || c2 > b2) {
      throw new ModelError("The peak must be within the maximum and minimum for the triangular distribution.", {
        code: 4013
      });
    }
    let fc = (c2 - a2) / (b2 - a2);
    let u2 = Rand(simulate);
    if (u2 < fc) {
      return a2 + Math.sqrt(u2 * (b2 - a2) * (c2 - a2));
    } else {
      return b2 - Math.sqrt((1 - u2) * (b2 - a2) * (b2 - c2));
    }
  }
  function RandDist(simulate, x2, y2) {
    if (x2.length !== y2.length) {
      throw new ModelError("The lengths of the 'x' and 'y' vectors must be the same.", {
        code: 4014
      });
    }
    if (x2.length < 2) {
      throw new ModelError("There must be at least 2 points in a distribution to generate a random number.", {
        code: 4015
      });
    }
    for (let i2 = 0; i2 < x2.length; i2++) {
      isNormalNumber(x2[i2], "RandDist", "x");
      isNormalNumber(y2[i2], "RandDist", "y");
      if (y2[i2] < 0) {
        throw new ModelError("The y values of RandDist cannot be negative.", {
          code: 4016
        });
      }
    }
    let area = 0;
    for (let i2 = 0; i2 < x2.length - 1; i2++) {
      area += (x2[i2 + 1] - x2[i2]) * (y2[i2 + 1] + y2[i2]) / 2;
    }
    if (area === 0) {
      throw new ModelError("The area of the distribution in RandDist cannot be 0.", {
        code: 4017
      });
    }
    let a2 = area * Rand(simulate);
    area = 0;
    for (let i2 = 0; i2 < x2.length - 1; i2++) {
      let nextArea = (x2[i2 + 1] - x2[i2]) * (y2[i2 + 1] + y2[i2]) / 2;
      if (a2 >= area && a2 <= area + nextArea) {
        let neededArea = a2 - area;
        let slope = (y2[i2 + 1] - y2[i2]) / (x2[i2 + 1] - x2[i2]);
        let dist;
        if (slope === 0) {
          dist = neededArea / y2[i2];
        } else {
          dist = (-y2[i2] + Math.sqrt(Math.pow(y2[i2], 2) + 2 * slope * neededArea)) / slope;
        }
        return x2[i2] + dist;
      }
      area += nextArea;
    }
  }
  function isNormalNumber(x2, name, v2) {
    if (x2 === null) {
      throw new ModelError(`The <i>${v2}</i> passed to ${name}() was not a number.`, {
        code: 4018
      });
    }
    if (isNaN(x2)) {
      throw new ModelError(`The <i>${v2}</i> passed to ${name}() was not a number.`, {
        code: 4018
      });
    }
    if (!isFinite(x2)) {
      throw new ModelError(`The <i>${v2}</i> passed to ${name}() must not be infinite.`, {
        code: 4019
      });
    }
    if (x2 > 1e15) {
      throw new ModelError(`The <i>${v2}</i> passed to ${name}() must not be greater than 1e15 (got ${x2}).`, {
        code: 4020
      });
    }
  }

  // ../insight-maker-simulation/src/formula/Utilities.js
  function stringify(x2, simulate) {
    if (x2 instanceof Vector) {
      return x2.recurseApply((x3) => stringify(x3, simulate));
    }
    let res = new String(x2);
    res.parent = simulate.coreBank.get("stringbase");
    return res;
  }
  function selectFromMatrix(mat, simulate, items, fill) {
    let selectorCount = items.length;
    function vectorize(m3) {
      if (!(m3 instanceof Vector)) {
        if (items[0] === "*") {
          if (m3 instanceof Material) {
            throw new ModelError("Can't use * selector on a number.", {
              code: 3e3
            });
          } else if (m3 instanceof Boolean || typeof m3 === "boolean") {
            throw new ModelError("Can't use * selector on a boolean.", {
              code: 3001
            });
          } else if (m3 instanceof String || typeof m3 === "string") {
            throw new ModelError("Can't use * selector on a string.", {
              code: 3002
            });
          } else {
            throw new ModelError("Can't use * selector on an object.", {
              code: 3003
            });
          }
        }
        if (m3.vector) {
          m3 = m3.vector;
        } else if (m3.parent) {
          m3 = new Vector([], simulate, [], m3.parent);
        }
      }
      if (fill === void 0 && m3.fullClone) {
        m3 = m3.fullClone();
      }
      return m3;
    }
    let m2 = vectorize(mat);
    let root2 = selectFromVector(m2, simulate, items.shift(), !items.length ? fill : void 0, fill !== void 0);
    let children3 = [];
    if (root2.collapsed) {
      children3 = [root2.data];
    } else {
      if (!root2.data.items) {
        throw new ModelError(`No element available for selector ${selectorCount - items.length + 1}`, {
          code: 3004
        });
      }
      children3 = root2.data.items;
    }
    while (items.length) {
      let newChildren = [];
      let selector3 = items.shift();
      for (let i2 = 0; i2 < children3.length; i2++) {
        if (!(children3[i2] instanceof Vector)) {
          throw new ModelError(`No element available for selector ${selectorCount - items.length}`, {
            code: 3005
          });
        }
        let vec = selectFromVector(children3[i2], simulate, selector3, !items.length ? fill : void 0);
        if (vec.collapsed) {
          if (fill === void 0) {
            children3[i2].items = [vec.data];
            children3[i2].names = ["!!BREAKOUT DATA"];
          }
          newChildren = newChildren.concat(vec.data);
        } else {
          newChildren = newChildren.concat(vec.data.items);
          if (fill === void 0) {
            children3[i2].items = vec.data.items;
            children3[i2].names = vec.data.names;
          }
        }
      }
      children3 = newChildren;
    }
    return doBreakouts(root2.data);
  }
  function doBreakouts(vec) {
    if (!(vec instanceof Vector)) {
      return vec;
    }
    if (vec.items.length === 1 && vec.names && vec.names[0] === "!!BREAKOUT DATA") {
      return doBreakouts(vec.items[0]);
    }
    for (let i2 = 0; i2 < vec.items.length; i2++) {
      vec.items[i2] = doBreakouts(vec.items[i2]);
    }
    return vec;
  }
  function selectFromVector(vec, simulate, items, fill, doNotClone) {
    if (items === "*") {
      return { data: vec };
    } else if (typeof items === "function") {
      return { data: items([vec]), collapsed: true };
    } else if (items === "parent") {
      if (vec.parent) {
        return { data: doNotClone ? vec.parent : vec.parent.fullClone(), collapsed: true };
      } else {
        throw new ModelError("Vector does not have a parent.", {
          code: 3006
        });
      }
    }
    if (items instanceof Vector) {
      let res = [];
      let names = vec.names ? [] : void 0;
      for (let i2 = 0; i2 < items.items.length; i2++) {
        let v2 = items.items[i2];
        let shouldSelect = true;
        if (typeof v2 === "boolean") {
          if (v2) {
            v2 = new Material(i2 + 1);
          } else {
            shouldSelect = false;
          }
        }
        if (shouldSelect) {
          let r2 = selectElementFromVector(vec, v2, fill);
          res.push(r2.value);
          if (names) {
            names.push(r2.name);
          }
        }
      }
      return { collapsed: false, parent: vec, data: new Vector(res, simulate, names, vec.parent) };
    } else {
      return { collapsed: true, parent: vec, data: selectElementFromVector(vec, items, fill).value };
    }
  }
  function selectElementFromVector(vec, item, fill) {
    let name = void 0;
    let value = void 0;
    let index;
    if (typeof item === "string" || item instanceof String) {
      try {
        if (fill === void 0) {
          if (!vec.names) {
            if (vec.parent) {
              return selectElementFromVector(vec.parent, item, fill);
            } else {
              throw new ModelError(`Key '${item}' not in vector.`, {
                code: 3007
              });
            }
          }
        }
        if (vec.names) {
          index = -1;
          let lc = item.toLowerCase();
          for (let i2 = 0; i2 < vec.names.length; i2++) {
            if (vec.names[i2] && vec.names[i2].toLowerCase() === lc) {
              index = i2;
              break;
            }
          }
          if (index < 0) {
            index = vec.names.indexOf("*");
          }
        }
        if (index < 0 || index === void 0) {
          if (fill === void 0) {
            if (vec.parent) {
              return selectElementFromVector(vec.parent, item, fill);
            } else {
              throw new ModelError(`Key '${item}' not in vector.`, {
                code: 3008
              });
            }
          } else {
            index = item;
          }
        }
      } catch (err) {
        if (vec.parent) {
          return selectElementFromVector(vec.parent, item, fill);
        } else {
          throw err;
        }
      }
    } else {
      index = parseFloat(toNum(item)) - 1;
    }
    if (index instanceof String || typeof index === "string") {
      if (!vec.names) {
        vec.names = [];
        for (let i2 = 0; i2 < vec.items.length; i2++) {
          vec.names.push(void 0);
        }
      }
      vec.items.push(fill);
      vec.names.push(index.valueOf());
      value = fill;
      name = index;
    } else {
      if (index < 0 || !vec.items || index >= vec.items.length || index % 1 !== 0) {
        throw new ModelError("Index " + (1 + index) + " is not in the vector.", {
          code: 3009
        });
      }
      if (fill !== void 0) {
        vec.items[index] = fill;
      }
      value = vec.items[index];
      if (vec.names) {
        name = vec.names[index];
      }
    }
    return { name, value };
  }
  function strictEquals(a2, b2) {
    if (a2 instanceof SAgent || b2 instanceof SAgent) {
      if (a2 instanceof SAgent && b2 instanceof SAgent) {
        if (a2.instanceId === b2.instanceId) {
          return true;
        }
      }
    } else if (a2 instanceof Vector || b2 instanceof Vector) {
      if (a2 instanceof Vector && b2 instanceof Vector) {
        if (a2.equals(b2)) {
          return true;
        }
      }
    } else if (eq(a2, b2)) {
      return true;
    }
    return false;
  }

  // ../insight-maker-simulation/src/formula/Vector.js
  function truncate(string, maxLength) {
    if (string.length > maxLength + 2) {
      return string.substring(0, maxLength - 3) + "...";
    }
    return string;
  }
  function keysMatch(thisNames, keys) {
    if (!keys.includes("*")) {
      for (let i2 = 0; i2 < thisNames.length; i2++) {
        if (thisNames[i2] !== "*") {
          if (thisNames[i2] === void 0) {
            return false;
          }
          if (!keys.includes(thisNames[i2])) {
            return false;
          }
        }
      }
    }
    if (!thisNames.includes("*")) {
      for (let i2 = 0; i2 < keys.length; i2++) {
        if (keys[i2] !== "*") {
          if (keys[i2] === void 0) {
            return false;
          }
          if (!thisNames.includes(keys[i2])) {
            return false;
          }
        }
      }
    }
    return true;
  }
  var Vector = class _Vector {
    /**
     * @param {T[]} items
     * @param {import("../Simulator").Simulator} simulate
     * @param {string[]=} names
     * @param {Vector=} parent
     */
    constructor(items, simulate, names, parent) {
      this.simulate = simulate;
      this.parent = parent ? parent : simulate.coreBank.get("vectorbase");
      this.items = items;
      this.names = names;
      this.namesLC = void 0;
      this.isNum = void 0;
      this.terminateApply = void 0;
      if (names) {
        this.namesLC = [];
        for (let name of names) {
          if (name) {
            this.namesLC.push(name.toLowerCase());
          } else {
            this.namesLC.push(void 0);
          }
        }
      }
    }
    toNum() {
      if (this.isNum) {
        return this;
      }
      let v2 = this.fullClone();
      for (let i2 = 0; i2 < v2.items.length; i2++) {
        v2.items[i2] = toNum(v2.items[i2]);
      }
      v2.isNum = true;
      return v2;
    }
    /**
     * @returns {string}
     */
    toString() {
      let items = [];
      for (let i2 = 0; i2 < this.items.length; i2++) {
        try {
          let str = toNum(this.items[i2]).toString();
          if (this.names && this.names[i2]) {
            str = this.names[i2] + ": " + str;
          }
          items.push(str);
        } catch (err) {
          items.push("{Cannot convert value to string}");
        }
      }
      return "{" + items.join(", ") + "}";
    }
    /**
     * @returns {number}
     */
    length() {
      return this.items.length;
    }
    cloneCombine(other, operation, rhs, noSwitch) {
      return this.fullClone().combine(other, operation, rhs, noSwitch);
    }
    combine(other, operation, rhs, noSwitch) {
      if (other instanceof _Vector) {
        if (this.length() !== other.length() && (!this.names || !other.names)) {
          throw new ModelError(`Vectors must have equal length when combined. Got lengths of ${this.length()} and ${other.length()}.`, {
            code: 2001
          });
        }
      }
      if (other instanceof _Vector && (this.names && other.names)) {
        if (!noSwitch && other.depth() > this.depth()) {
          return other.combine(this, operation, !rhs);
        }
        if (!this.keysMatch(other.namesLC)) {
          if (this.items[0] instanceof _Vector) {
            for (let i2 = 0; i2 < this.items.length; i2++) {
              this.items[i2].combine(other, operation, rhs, true);
            }
            return this;
          } else {
            throw new ModelError(`Keys do not match for vector operation. Got keys {${truncate(this.names.map((x2) => '"' + x2 + '"').join(", "), 36)}} and {${truncate(other.names.map((x2) => '"' + x2 + '"').join(", "), 36)}}.`, {
              code: 2e3
            });
          }
        }
      }
      for (let i2 = 0; i2 < this.length(); i2++) {
        let x2;
        if (other instanceof _Vector) {
          if (this.names && other.names) {
            let index = other.namesLC.indexOf(this.namesLC[i2]);
            if (this.names.length === 1 && this.names[0] === "*") {
              index = -2;
            }
            if (index === -1) {
              index = other.names.indexOf("*");
            }
            if (index === -1) {
              throw new ModelError("Mismatched keys for vector operation.", {
                code: 2002
              });
            }
            if (index === -2) {
              x2 = void 0;
            } else {
              x2 = other.items[index];
            }
          } else {
            x2 = other.items[i2];
          }
        } else {
          x2 = other;
        }
        if (x2 !== void 0) {
          if (rhs) {
            this.items[i2] = operation(x2, this.items[i2]);
          } else {
            this.items[i2] = operation(this.items[i2], x2);
          }
        }
      }
      if (this.names && this.names.includes("*") && other instanceof _Vector && other.names) {
        let starred = this.items[this.names.indexOf("*")];
        for (let i2 = 0; i2 < other.names.length; i2++) {
          if (other.names[i2] && !this.namesLC.includes(other.namesLC[i2])) {
            if (rhs) {
              this.items.push(operation(other.items[i2], starred));
            } else {
              this.items.push(operation(starred, other.items[i2]));
            }
            this.names.push(other.names[i2]);
            this.namesLC.push(other.namesLC[i2]);
          }
        }
      }
      return this;
    }
    collapseDimensions(target) {
      if (target instanceof _Vector) {
        if (this.depth() === target.depth()) {
          return this;
        } else {
          let selector3 = [];
          let base = this;
          let targetLevel = target;
          for (let i2 = 0; i2 < this.depth(); i2++) {
            if (!(targetLevel instanceof _Vector)) {
              selector3.push((x2) => {
                return this.simulate.coreBank.get("sum")(x2[0].items);
              });
              base = /** @type {Vector} */
              base.items[0];
            } else if (base.namesLC === void 0 && targetLevel.namesLC === void 0 || base.namesLC !== void 0 && targetLevel.namesLC !== void 0 && keysMatch(base.namesLC, targetLevel.namesLC)) {
              selector3.push("*");
              base = /** @type {Vector} */
              base.items[0];
              targetLevel = /** @type {Vector} */
              targetLevel.items[0];
            } else {
              selector3.push((x2) => {
                return this.simulate.coreBank.get("sum")(x2[0].items);
              });
              base = /** @type {Vector} */
              base.items[0];
            }
          }
          if (targetLevel.items) {
            throw new ModelError("Keys do not match for vector collapsing.", {
              code: 2003
            });
          }
          return selectFromMatrix(this, this.simulate, selector3);
        }
      } else {
        return this.simulate.coreBank.get("sum")([this.simulate.coreBank.get("flatten")([this])]);
      }
    }
    /**
     * @returns {number}
     */
    depth() {
      if (!this.items.length) {
        return 1;
      }
      let firstItem = this.items[0];
      if (firstItem instanceof _Vector) {
        return firstItem.depth() + 1;
      }
      return 1;
    }
    /**
     * @param {string[]} keys
     */
    keysMatch(keys) {
      if (this.names && keys) {
        return keysMatch(this.namesLC, keys);
      }
      return false;
    }
    /**
     * @param {function} operation
     * @returns
     */
    cloneApply(operation) {
      return this.fullClone().apply(operation);
    }
    /**
     * @param {function} operation
     * @returns
     */
    apply(operation) {
      for (let i2 = 0; i2 < this.items.length; i2++) {
        this.items[i2] = operation(this.items[i2], this.names ? this.names[i2] : void 0);
      }
      return this;
    }
    /**
     * @param {function(Vector): any} operation
     *
     * @returns {Vector}
     */
    stackApply(operation) {
      if (this.depth() === 1) {
        return operation(this);
      }
      let s2 = this.stack();
      return s2.recurseApply(operation);
    }
    /**
     * @param {any[]=} selector
     *
     * @returns
     */
    stack(selector3) {
      let res = [];
      selector3 = selector3 || [0];
      let base = (
        /** @type {Vector} */
        this.select(selector3)
      );
      for (let i2 = 1; i2 < this.items.length; i2++) {
        selector3[0] = i2;
        let alt = this.select(selector3);
        if (base instanceof _Vector && alt instanceof _Vector) {
          if (base.names && !alt.names || alt.names && !base.names) {
            throw new ModelError("Mismatched keys for vector collapsing.", {
              code: 2004
            });
          } else if (base.items.length !== alt.items.length) {
            throw new ModelError("Vectors of unequal size.", {
              code: 2005
            });
          }
        } else if (!(base instanceof _Vector || alt instanceof _Vector)) {
          throw new ModelError("Mismatched keys for vector collapsing.", {
            code: 2006
          });
        }
      }
      selector3[0] = 0;
      selector3.push(0);
      for (let i2 = 0; i2 < base.items.length; i2++) {
        selector3[selector3.length - 1] = base.names ? base.namesLC[i2] : i2;
        if (base.items[i2] instanceof _Vector) {
          res.push(this.stack(selector3.slice()));
        } else {
          let vecs = [];
          for (let j = 0; j < this.items.length; j++) {
            let newSelector = selector3.slice();
            newSelector[0] = j;
            let item = this.select(newSelector);
            if (item instanceof _Vector) {
              throw new ModelError("Number where vector expected in vector collapsing.", {
                code: 2007
              });
            }
            vecs.push(item);
          }
          let v2 = new _Vector(vecs, this.simulate);
          v2.terminateApply = true;
          res.push(v2);
        }
      }
      return new _Vector(res, this.simulate, base.names ? base.names.slice() : void 0);
    }
    select(selector3) {
      let b2 = this;
      for (let s2 = 0; s2 < selector3.length; s2++) {
        if (!(b2 instanceof _Vector)) {
          throw new ModelError("Number where vector expected in vector collapsing.", {
            code: 2008
          });
        }
        if (selector3[s2] instanceof String || typeof selector3[s2] === "string") {
          let ind = b2.namesLC.indexOf(selector3[s2].valueOf());
          if (ind === -1) {
            throw new ModelError("Mismatched keys for vector collapsing.", {
              code: 2009
            });
          }
          b2 = b2.items[ind];
        } else {
          b2 = b2.items[selector3[s2]];
        }
      }
      return b2;
    }
    /**
     * @param {function} operation
     *
     * @returns {Vector}
     */
    recurseApply(operation) {
      for (let i2 = 0; i2 < this.items.length; i2++) {
        let item = this.items[i2];
        if (item instanceof _Vector && !item.terminateApply) {
          this.items[i2] = /** @type {any} */
          item.recurseApply(operation);
        } else {
          this.items[i2] = operation(this.items[i2]);
        }
      }
      return this;
    }
    /**
     * @returns {any[]}
     */
    fullNames() {
      let firstElement = this.items[0];
      if (firstElement instanceof _Vector && firstElement.names) {
        let subn = firstElement.fullNames();
        let n2 = [];
        for (let i2 = 0; i2 < this.names.length; i2++) {
          for (let j = 0; j < subn.length; j++) {
            n2.push([this.names[i2]].concat(subn[j]));
          }
        }
        return n2;
      } else {
        return this.names.map((name) => [name]);
      }
    }
    /**
     * @returns {Vector}
     */
    clone() {
      let newItems = [];
      for (let item of this.items) {
        if (item instanceof _Vector) {
          newItems.push(item.clone());
        } else {
          newItems.push(item);
        }
      }
      return new _Vector(newItems, this.simulate, this.names ? this.names.slice() : void 0, this.parent);
    }
    /**
     * @returns {Vector}
     */
    fullClone() {
      let newItems = [];
      for (let item of this.items) {
        if (item instanceof _Vector || item instanceof Material) {
          newItems.push(item.fullClone());
        } else {
          newItems.push(item);
        }
      }
      return new _Vector(newItems, this.simulate, this.names ? this.names.slice() : void 0, this.parent);
    }
    /**
     * @param {Vector} vec
     *
     * @returns {boolean}
     */
    equals(vec) {
      if (this.length() !== vec.length()) {
        return false;
      }
      for (let i2 = 0; i2 < this.items.length; i2++) {
        if (!strictEquals(this.items[i2], vec.items[i2])) {
          return false;
        }
      }
      return true;
    }
  };

  // ../insight-maker-simulation/vendor/bigjs/big.js
  var DP = 20;
  var RM = 1;
  var MAX_DP = 1e6;
  var MAX_POWER = 1e6;
  var NE = -7;
  var PE = 21;
  var STRICT = false;
  var NAME = "[big.js] ";
  var INVALID = NAME + "Invalid ";
  var INVALID_DP = INVALID + "decimal places";
  var INVALID_RM = INVALID + "rounding mode";
  var DIV_BY_ZERO = NAME + "Division by zero";
  var P = {};
  var UNDEFINED = void 0;
  var NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  function _Big_() {
    function Big2(n2) {
      let x2 = this;
      if (!(x2 instanceof Big2)) return n2 === UNDEFINED ? _Big_() : new Big2(n2);
      if (n2 instanceof Big2) {
        x2.s = n2.s;
        x2.e = n2.e;
        x2.c = n2.c.slice();
      } else {
        if (typeof n2 !== "string") {
          if (Big2.strict === true) {
            throw TypeError(INVALID + "number");
          }
          n2 = n2 === 0 && 1 / n2 < 0 ? "-0" : String(n2);
        }
        parse(x2, n2);
      }
      x2.constructor = Big2;
    }
    Big2.prototype = P;
    Big2.DP = DP;
    Big2.RM = RM;
    Big2.NE = NE;
    Big2.PE = PE;
    Big2.strict = STRICT;
    Big2.roundDown = 0;
    Big2.roundHalfUp = 1;
    Big2.roundHalfEven = 2;
    Big2.roundUp = 3;
    return Big2;
  }
  function parse(x2, n2) {
    let e2, i2, nl;
    if (!NUMERIC.test(n2)) {
      throw Error(INVALID + "number");
    }
    x2.s = n2.charAt(0) == "-" ? (n2 = n2.slice(1), -1) : 1;
    if ((e2 = n2.indexOf(".")) > -1) n2 = n2.replace(".", "");
    if ((i2 = n2.search(/e/i)) > 0) {
      if (e2 < 0) e2 = i2;
      e2 += +n2.slice(i2 + 1);
      n2 = n2.substring(0, i2);
    } else if (e2 < 0) {
      e2 = n2.length;
    }
    nl = n2.length;
    for (i2 = 0; i2 < nl && n2.charAt(i2) == "0"; ) ++i2;
    if (i2 == nl) {
      x2.c = [x2.e = 0];
    } else {
      for (; nl > 0 && n2.charAt(--nl) == "0"; ) ;
      x2.e = e2 - i2 - 1;
      x2.c = [];
      for (e2 = 0; i2 <= nl; ) x2.c[e2++] = +n2.charAt(i2++);
    }
    return x2;
  }
  function round2(x2, sd, rm, more) {
    let xc = x2.c;
    if (rm === UNDEFINED) rm = x2.constructor.RM;
    if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
      throw Error(INVALID_RM);
    }
    if (sd < 1) {
      more = rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 || rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));
      xc.length = 1;
      if (more) {
        x2.e = x2.e - sd + 1;
        xc[0] = 1;
      } else {
        xc[0] = x2.e = 0;
      }
    } else if (sd < xc.length) {
      more = rm === 1 && xc[sd] >= 5 || rm === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm === 3 && (more || !!xc[0]);
      xc.length = sd--;
      if (more) {
        for (; ++xc[sd] > 9; ) {
          xc[sd] = 0;
          if (!sd--) {
            ++x2.e;
            xc.unshift(1);
          }
        }
      }
      for (sd = xc.length; !xc[--sd]; ) xc.pop();
    }
    return x2;
  }
  function stringify2(x2, doExponential, isNonzero) {
    let e2 = x2.e, s2 = x2.c.join(""), n2 = s2.length;
    if (doExponential) {
      s2 = s2.charAt(0) + (n2 > 1 ? "." + s2.slice(1) : "") + (e2 < 0 ? "e" : "e+") + e2;
    } else if (e2 < 0) {
      for (; ++e2; ) s2 = "0" + s2;
      s2 = "0." + s2;
    } else if (e2 > 0) {
      if (++e2 > n2) {
        for (e2 -= n2; e2--; ) s2 += "0";
      } else if (e2 < n2) {
        s2 = s2.slice(0, e2) + "." + s2.slice(e2);
      }
    } else if (n2 > 1) {
      s2 = s2.charAt(0) + "." + s2.slice(1);
    }
    return x2.s < 0 && isNonzero ? "-" + s2 : s2;
  }
  P.abs = function() {
    let x2 = new this.constructor(this);
    x2.s = 1;
    return x2;
  };
  P.cmp = function(y2) {
    let isneg, x2 = this, xc = x2.c, yc = (y2 = new x2.constructor(y2)).c, i2 = x2.s, j = y2.s, k2 = x2.e, l2 = y2.e;
    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i2;
    if (i2 != j) return i2;
    isneg = i2 < 0;
    if (k2 != l2) return k2 > l2 ^ isneg ? 1 : -1;
    j = (k2 = xc.length) < (l2 = yc.length) ? k2 : l2;
    for (i2 = -1; ++i2 < j; ) {
      if (xc[i2] != yc[i2]) return xc[i2] > yc[i2] ^ isneg ? 1 : -1;
    }
    return k2 == l2 ? 0 : k2 > l2 ^ isneg ? 1 : -1;
  };
  P.div = function(y2) {
    let x2 = this, Big2 = x2.constructor, a2 = x2.c, b2 = (y2 = new Big2(y2)).c, k2 = x2.s == y2.s ? 1 : -1, dp = Big2.DP;
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    if (!b2[0]) {
      throw Error(DIV_BY_ZERO);
    }
    if (!a2[0]) {
      y2.s = k2;
      y2.c = [y2.e = 0];
      return y2;
    }
    let bl, bt, n2, cmp, ri, bz = b2.slice(), ai = bl = b2.length, al = a2.length, r2 = a2.slice(0, bl), rl = r2.length, q = y2, qc = q.c = [], qi = 0, p2 = dp + (q.e = x2.e - y2.e) + 1;
    q.s = k2;
    k2 = p2 < 0 ? 0 : p2;
    bz.unshift(0);
    for (; rl++ < bl; ) r2.push(0);
    do {
      for (n2 = 0; n2 < 10; n2++) {
        if (bl != (rl = r2.length)) {
          cmp = bl > rl ? 1 : -1;
        } else {
          for (ri = -1, cmp = 0; ++ri < bl; ) {
            if (b2[ri] != r2[ri]) {
              cmp = b2[ri] > r2[ri] ? 1 : -1;
              break;
            }
          }
        }
        if (cmp < 0) {
          for (bt = rl == bl ? b2 : bz; rl; ) {
            if (r2[--rl] < bt[rl]) {
              ri = rl;
              for (; ri && !r2[--ri]; ) r2[ri] = 9;
              --r2[ri];
              r2[rl] += 10;
            }
            r2[rl] -= bt[rl];
          }
          for (; !r2[0]; ) r2.shift();
        } else {
          break;
        }
      }
      qc[qi++] = cmp ? n2 : ++n2;
      if (r2[0] && cmp) r2[rl] = a2[ai] || 0;
      else r2 = [a2[ai]];
    } while ((ai++ < al || r2[0] !== UNDEFINED) && k2--);
    if (!qc[0] && qi != 1) {
      qc.shift();
      q.e--;
      p2--;
    }
    if (qi > p2) round2(q, p2, Big2.RM, r2[0] !== UNDEFINED);
    return q;
  };
  P.eq = function(y2) {
    return this.cmp(y2) === 0;
  };
  P.gt = function(y2) {
    return this.cmp(y2) > 0;
  };
  P.gte = function(y2) {
    return this.cmp(y2) > -1;
  };
  P.lt = function(y2) {
    return this.cmp(y2) < 0;
  };
  P.lte = function(y2) {
    return this.cmp(y2) < 1;
  };
  P.minus = P.sub = function(y2) {
    let i2, j, t2, xlty, x2 = this, Big2 = x2.constructor, a2 = x2.s, b2 = (y2 = new Big2(y2)).s;
    if (a2 != b2) {
      y2.s = -b2;
      return x2.plus(y2);
    }
    let xc = x2.c.slice(), xe = x2.e, yc = y2.c, ye = y2.e;
    if (!xc[0] || !yc[0]) {
      if (yc[0]) {
        y2.s = -b2;
      } else if (xc[0]) {
        y2 = new Big2(x2);
      } else {
        y2.s = 1;
      }
      return y2;
    }
    if (a2 = xe - ye) {
      if (xlty = a2 < 0) {
        a2 = -a2;
        t2 = xc;
      } else {
        ye = xe;
        t2 = yc;
      }
      t2.reverse();
      for (b2 = a2; b2--; ) t2.push(0);
      t2.reverse();
    } else {
      j = ((xlty = xc.length < yc.length) ? xc : yc).length;
      for (a2 = b2 = 0; b2 < j; b2++) {
        if (xc[b2] != yc[b2]) {
          xlty = xc[b2] < yc[b2];
          break;
        }
      }
    }
    if (xlty) {
      t2 = xc;
      xc = yc;
      yc = t2;
      y2.s = -y2.s;
    }
    if ((b2 = (j = yc.length) - (i2 = xc.length)) > 0) for (; b2--; ) xc[i2++] = 0;
    for (b2 = i2; j > a2; ) {
      if (xc[--j] < yc[j]) {
        for (i2 = j; i2 && !xc[--i2]; ) xc[i2] = 9;
        --xc[i2];
        xc[j] += 10;
      }
      xc[j] -= yc[j];
    }
    for (; xc[--b2] === 0; ) xc.pop();
    for (; xc[0] === 0; ) {
      xc.shift();
      --ye;
    }
    if (!xc[0]) {
      y2.s = 1;
      xc = [ye = 0];
    }
    y2.c = xc;
    y2.e = ye;
    return y2;
  };
  P.mod = function(y2) {
    let ygtx, x2 = this, Big2 = x2.constructor, a2 = x2.s, b2 = (y2 = new Big2(y2)).s;
    if (!y2.c[0]) {
      throw Error(DIV_BY_ZERO);
    }
    x2.s = y2.s = 1;
    ygtx = y2.cmp(x2) == 1;
    x2.s = a2;
    y2.s = b2;
    if (ygtx) return new Big2(x2);
    a2 = Big2.DP;
    b2 = Big2.RM;
    Big2.DP = Big2.RM = 0;
    x2 = x2.div(y2);
    Big2.DP = a2;
    Big2.RM = b2;
    return this.minus(x2.times(y2));
  };
  P.plus = P.add = function(y2) {
    let e2, k2, t2, x2 = this, Big2 = x2.constructor;
    y2 = new Big2(y2);
    if (x2.s != y2.s) {
      y2.s = -y2.s;
      return x2.minus(y2);
    }
    let xe = x2.e, xc = x2.c, ye = y2.e, yc = y2.c;
    if (!xc[0] || !yc[0]) {
      if (!yc[0]) {
        if (xc[0]) {
          y2 = new Big2(x2);
        } else {
          y2.s = x2.s;
        }
      }
      return y2;
    }
    xc = xc.slice();
    if (e2 = xe - ye) {
      if (e2 > 0) {
        ye = xe;
        t2 = yc;
      } else {
        e2 = -e2;
        t2 = xc;
      }
      t2.reverse();
      for (; e2--; ) t2.push(0);
      t2.reverse();
    }
    if (xc.length - yc.length < 0) {
      t2 = yc;
      yc = xc;
      xc = t2;
    }
    e2 = yc.length;
    for (k2 = 0; e2; xc[e2] %= 10) k2 = (xc[--e2] = xc[e2] + yc[e2] + k2) / 10 | 0;
    if (k2) {
      xc.unshift(k2);
      ++ye;
    }
    for (e2 = xc.length; xc[--e2] === 0; ) xc.pop();
    y2.c = xc;
    y2.e = ye;
    return y2;
  };
  P.pow = function(n2) {
    let x2 = this, one2 = new x2.constructor("1"), y2 = one2, isneg = n2 < 0;
    if (n2 !== ~~n2 || n2 < -MAX_POWER || n2 > MAX_POWER) {
      throw Error(INVALID + "exponent");
    }
    if (isneg) n2 = -n2;
    for (; ; ) {
      if (n2 & 1) y2 = y2.times(x2);
      n2 >>= 1;
      if (!n2) break;
      x2 = x2.times(x2);
    }
    return isneg ? one2.div(y2) : y2;
  };
  P.prec = function(sd, rm) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + "precision");
    }
    return round2(new this.constructor(this), sd, rm);
  };
  P.round = function(dp, rm) {
    if (dp === UNDEFINED) dp = 0;
    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    return round2(new this.constructor(this), dp + this.e + 1, rm);
  };
  P.sqrt = function() {
    let r2, c2, t2, x2 = this, Big2 = x2.constructor, s2 = x2.s, e2 = x2.e, half = new Big2("0.5");
    if (!x2.c[0]) return new Big2(x2);
    if (s2 < 0) {
      throw Error(NAME + "No square root");
    }
    s2 = Math.sqrt(x2 + "");
    if (s2 === 0 || s2 === 1 / 0) {
      c2 = x2.c.join("");
      if (!(c2.length + e2 & 1)) c2 += "0";
      s2 = Math.sqrt(c2);
      e2 = ((e2 + 1) / 2 | 0) - (e2 < 0 || e2 & 1);
      r2 = new Big2((s2 == 1 / 0 ? "5e" : (s2 = s2.toExponential()).slice(0, s2.indexOf("e") + 1)) + e2);
    } else {
      r2 = new Big2(s2 + "");
    }
    e2 = r2.e + (Big2.DP += 4);
    do {
      t2 = r2;
      r2 = half.times(t2.plus(x2.div(t2)));
    } while (t2.c.slice(0, e2).join("") !== r2.c.slice(0, e2).join(""));
    return round2(r2, (Big2.DP -= 4) + r2.e + 1, Big2.RM);
  };
  P.times = P.mul = function(y2) {
    let c2, x2 = this, Big2 = x2.constructor, xc = x2.c, yc = (y2 = new Big2(y2)).c, a2 = xc.length, b2 = yc.length, i2 = x2.e, j = y2.e;
    y2.s = x2.s == y2.s ? 1 : -1;
    if (!xc[0] || !yc[0]) {
      y2.c = [y2.e = 0];
      return y2;
    }
    y2.e = i2 + j;
    if (a2 < b2) {
      c2 = xc;
      xc = yc;
      yc = c2;
      j = a2;
      a2 = b2;
      b2 = j;
    }
    for (c2 = new Array(j = a2 + b2); j--; ) c2[j] = 0;
    for (i2 = b2; i2--; ) {
      b2 = 0;
      for (j = a2 + i2; j > i2; ) {
        b2 = c2[j] + yc[i2] * xc[j - i2 - 1] + b2;
        c2[j--] = b2 % 10;
        b2 = b2 / 10 | 0;
      }
      c2[j] = b2;
    }
    if (b2) ++y2.e;
    else c2.shift();
    for (i2 = c2.length; !c2[--i2]; ) c2.pop();
    y2.c = c2;
    return y2;
  };
  P.toExponential = function(dp, rm) {
    let x2 = this, n2 = x2.c[0];
    if (dp !== UNDEFINED) {
      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
        throw Error(INVALID_DP);
      }
      x2 = round2(new x2.constructor(x2), ++dp, rm);
      for (; x2.c.length < dp; ) x2.c.push(0);
    }
    return stringify2(x2, true, !!n2);
  };
  P.toFixed = function(dp, rm) {
    let x2 = this, n2 = x2.c[0];
    if (dp !== UNDEFINED) {
      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
        throw Error(INVALID_DP);
      }
      x2 = round2(new x2.constructor(x2), dp + x2.e + 1, rm);
      for (dp = dp + x2.e + 1; x2.c.length < dp; ) x2.c.push(0);
    }
    return stringify2(x2, false, !!n2);
  };
  P.toJSON = P.toString = function() {
    let x2 = this, Big2 = x2.constructor;
    return stringify2(x2, x2.e <= Big2.NE || x2.e >= Big2.PE, !!x2.c[0]);
  };
  P.toNumber = function() {
    let n2 = Number(stringify2(this, true, true));
    if (this.constructor.strict === true && !this.eq(n2.toString())) {
      throw Error(NAME + "Imprecise conversion");
    }
    return n2;
  };
  P.toPrecision = function(sd, rm) {
    let x2 = this, Big2 = x2.constructor, n2 = x2.c[0];
    if (sd !== UNDEFINED) {
      if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
        throw Error(INVALID + "precision");
      }
      x2 = round2(new Big2(x2), sd, rm);
      for (; x2.c.length < sd; ) x2.c.push(0);
    }
    return stringify2(x2, sd <= x2.e || x2.e <= Big2.NE || x2.e >= Big2.PE, !!n2);
  };
  P.valueOf = function() {
    let x2 = this, Big2 = x2.constructor;
    if (Big2.strict === true) {
      throw Error(NAME + "valueOf disallowed");
    }
    return stringify2(x2, x2.e <= Big2.NE || x2.e >= Big2.PE, true);
  };
  var Big = _Big_();
  var big_default = Big;

  // ../insight-maker-simulation/src/Primitives.js
  var SPrimitive = class {
    /**
     * @param {import("./Simulator").Simulator} simulate
     */
    constructor(simulate) {
      this.id = null;
      this.agentId = null;
      this.index = null;
      this.instanceId = null;
      this.container = null;
      this.constructorFunction = null;
      this.dna = null;
      this.DNAs = null;
      this.equation = null;
      this.cachedValue = void 0;
      this.pastValues = [];
      this.frozen = false;
      this.simulate = simulate;
      this.unitToVariableUnits = /* @__PURE__ */ new Map();
      this.neighborProxyPrimitive = null;
      this.parent = simulate.coreBank.get("primitivebase");
    }
    orig() {
      return this.neighborProxyPrimitive || this;
    }
    /**
     * @param {import("./formula/Units").UnitStore} u
     *
     * @returns
     */
    matchPrimitiveUnits(u2) {
      if (!u2) {
        return 1;
      }
      if (this.unitToVariableUnits.has(u2)) {
        return this.unitToVariableUnits.get(u2);
      }
      let timer2 = this.dna.toBase;
      if (this instanceof SFlow && this.dna.flowUnitless) {
        timer2 = fn["*"](timer2 || 1, this.simulate.timeUnits.toBase);
      }
      if (!this.dna.units) {
        if (u2.isDeepUnitless()) {
          this.unitToVariableUnits.set(u2, u2.toBase);
          return u2.toBase;
        }
      }
      u2.addBase();
      timer2 = fn["/"](u2.toBase, timer2);
      this.unitToVariableUnits.set(u2, timer2);
      return timer2;
    }
    clone() {
      let p2 = new this.constructorFunction(this.simulate);
      p2.dna = this.dna;
      p2.container = this.container;
      p2.agentId = this.agentId;
      p2.index = this.index;
      p2.id = this.id;
      p2.createIds();
      p2.pastValues = this.pastValues.slice();
      p2.neighborProxyPrimitive = this.neighborProxyPrimitive;
      if (this.dna.slider) {
        if (this.simulate.sliders[this.dna.id]) {
          this.simulate.sliders[this.dna.id].push(p2);
        } else {
          this.simulate.sliders[this.dna.id] = [p2];
        }
      }
      p2.cachedValue = this.cachedValue ? this.cachedValue.fullClone() : this.cachedValue;
      this.innerClone(p2);
      return p2;
    }
    // eslint-disable-next-line
    innerClone(_p) {
    }
    clearCached() {
      this.cachedValue = void 0;
    }
    storeValue() {
      if (this.cachedValue === void 0) {
        this.value();
      }
      this.pastValues.push(this.cachedValue);
    }
    toNum() {
      let oldPosition = this.simulate.evaluatingPosition;
      let val = this.value();
      if (typeof val === "string") {
        this.simulate.evaluatingPosition = oldPosition;
        return stringify(val, this.simulate);
      }
      this.simulate.evaluatingPosition = oldPosition;
      return val;
    }
    /**
     * @return {ValueType}
     */
    calculateValue() {
      throw new ModelError(`<i>[${toHTML(this.dna.name)}]</i> does not have a value and can not be used as a value in an equation.`, {
        code: 1080
      });
    }
    createIds() {
      this.instanceId = this.simulate.getID(this.agentId + "-" + this.index);
    }
    /**
     * @param {Material} length
     *
     * @return {ValueType[]}
     */
    getPastValues(length) {
      let items = this.pastValues.slice();
      let bins = Math.ceil(div(this.simulate.time(), this.dna.solver.userTimeStep).value) + 1;
      if (items.length < bins) {
        items.push(this.value());
      }
      let res;
      if (length === void 0) {
        res = items.map((x2) => x2.fullClone());
      } else {
        let bins2 = Math.ceil(div(length.forceUnits(this.simulate.timeUnits), this.dna.solver.userTimeStep).value);
        res = [];
        for (let i2 = Math.max(0, items.length - 1 - bins2); i2 < items.length; i2++) {
          res.push(items[i2].fullClone());
        }
      }
      return res;
    }
    /**
     * @param {Material} delay
     * @param {ValueType=} defaultValue
     *
     * @returns {ValueType}
     */
    pastValue(delay, defaultValue = null) {
      let periods;
      if (this.pastValues.length - 1 < Math.round((this.simulate.time().value - this.simulate.timeStart.value) / this.dna.solver.userTimeStep.value)) {
        periods = div(delay.forceUnits(this.simulate.timeUnits), this.dna.solver.userTimeStep).value;
      } else {
        periods = div(delay.forceUnits(this.simulate.timeUnits), this.dna.solver.userTimeStep).value + 1;
      }
      if (periods === 0) {
        return this.value();
      }
      if (Math.ceil(periods) > this.pastValues.length) {
        if (defaultValue === null) {
          if (this.pastValues.length > 0) {
            return this.pastValues[0].fullClone();
          } else {
            return this.value();
          }
        } else {
          return defaultValue;
        }
      }
      if (periods === Math.round(periods)) {
        return this.pastValues[this.pastValues.length - periods].fullClone();
      }
      let fraction = periods - Math.floor(periods);
      let entry = Math.floor(periods);
      let firstPeriod, secondPeriod;
      if (entry === 0) {
        firstPeriod = this.value();
      } else {
        firstPeriod = this.pastValues[this.pastValues.length - entry];
      }
      secondPeriod = this.pastValues[this.pastValues.length - 1 - entry];
      return plus(mult(firstPeriod, new Material(1 - fraction)), mult(secondPeriod, new Material(fraction)));
    }
    /**
     * @param {ValueType} m
     * @param {boolean=} ignoreFlow
     */
    testUnits(m2, ignoreFlow) {
      if (m2 instanceof Vector) {
        m2.recurseApply((x2) => {
          this.testUnits(x2, ignoreFlow);
          return x2;
        });
        return;
      }
      if (this.dna.adoptUnits) {
        if (!m2.units) {
          m2.units = this.simulate.unitManager.getUnitStore([], [], false, true);
        }
        this.dna.units = m2.units;
        this.dna.flowUnitless = false;
      }
      if (!this.dna.units && m2.units && m2.units.isDeepUnitless()) {
        m2.units.addBase();
        m2.value = m2.value * m2.units.toBase;
        m2.units = null;
        m2.explicitUnits = true;
      }
      if (!this.dna.units && m2.units && !m2.units.isUnitless()) {
        throw new ModelError(`Wrong units generated for <i>[${toHTML(this.dna.name)}]</i>. Expected no units and got <i>${m2.units.toString()}</i>. Either specify units for the primitive or adjust the equation.`, {
          primitive: this.orig(),
          showEditor: true,
          code: 1081
        });
      } else if (this.dna.units !== m2.units) {
        if (typeof m2 === "boolean" || typeof m2 === "string" || m2 instanceof String || m2 instanceof Boolean) {
          if (!this.dna.units) {
            return;
          }
          throw new ModelError(`Cannot add units to a String or Boolean in <i>[${toHTML(this.dna.name)}]</i>.`, {
            primitive: this.orig(),
            showEditor: true,
            code: 1082
          });
        }
        let scale = convertUnits(m2.units, this.dna.units, true);
        if (scale === 0) {
          throw new ModelError(`Wrong units generated for <i>[${toHTML(this.dna.name)}]</i>. Expected <i>${this.dna.units ? this.dna.units.toString() : "unitless"}</i>, and got <i>${m2.units ? m2.units.toString() : "unitless"}</i>.`, {
            primitive: this.orig(),
            showEditor: true,
            code: 1083
          });
        } else {
          m2.value = m2.value * scale;
          m2.units = this.dna.units;
          m2.explicitUnits = true;
        }
      } else if (this.dna.units && this.dna.units === m2.units && !m2.explicitUnits) {
        m2.explicitUnits = true;
      }
      if (this instanceof SFlow && ignoreFlow !== true && this.dna.flowUnitless) {
        let x2 = mult(m2, new Material(1, this.simulate.timeUnits));
        m2.value = x2.value;
        m2.units = x2.units;
        m2.explicitUnits = true;
      }
    }
    setValue(_v) {
      throw new ModelError("You cannot set the value for that primitive.", {
        code: 1084
      });
    }
    /**
     * @returns {ValueType}
     */
    value() {
      if (this.cachedValue === void 0 && this.frozen && this.pastValues.length > 0) {
        let v2 = this.pastValues[this.pastValues.length - 1];
        if (v2.fullClone) {
          this.cachedValue = v2.fullClone();
        } else {
          this.cachedValue = v2;
        }
      }
      if (this.cachedValue === void 0) {
        if (this.simulate.evaluatedPrimitives.has(this)) {
          let arrayed = [...this.simulate.evaluatedPrimitives.values()];
          throw new ModelError(`Circular equation loop identified including the primitives: ${toHTML(arrayed.slice(arrayed.indexOf(this)).map((x3) => x3.dna.name).join(", "))}`, {
            primitive: this.orig(),
            showEditor: true,
            code: 1085
          });
        }
        this.simulate.evaluatedPrimitives.add(this);
        let x2;
        try {
          x2 = toNum(this.calculateValue());
          if (x2 instanceof Material && !isFinite(x2.value)) {
            if (this instanceof SStock) {
              throw new ModelError("The stock has become infinite in size. Check the flows into it for rapid growth.", {
                primitive: this.orig(),
                showEditor: true,
                code: 1086
              });
            } else {
              throw new ModelError("The result of this calculation is not finite (are you dividing by 0?).", {
                primitive: this.orig(),
                showEditor: true,
                code: 1087
              });
            }
          }
        } catch (err) {
          if (err instanceof ModelError) {
            if (err.primitive && err.showEditor) {
              throw err;
            }
            throw new ModelError(err.message, {
              primitive: this.orig(),
              showEditor: true,
              code: 1088
            });
          } else {
            throw err;
          }
        }
        if (!(this instanceof SState)) {
          this.testUnits(x2);
          this.testConstraints(x2);
        }
        this.cachedValue = x2;
      }
      if (this.cachedValue.fullClone) {
        return this.cachedValue.fullClone();
      } else {
        return this.cachedValue;
      }
    }
    testConstraints(x2) {
      let test = (x3) => {
        if (this.dna.useMaxConstraint && x3.value > this.dna.maxConstraint) {
          constraintAlert(this, "max", x3, this.simulate);
        }
        if (this.dna.useMinConstraint && x3.value < this.dna.minConstraint) {
          constraintAlert(this, "min", x3, this.simulate);
        }
        return x3;
      };
      if (x2 instanceof Vector) {
        x2.recurseApply(test);
      } else {
        test(x2);
      }
    }
    /**
     * @param {any} tree 
     * @param {Map} neighborhood 
     */
    setEquation(tree, neighborhood) {
      try {
        this.equation = trimTree(tree, neighborhood, this.simulate);
      } catch (err) {
        if (err instanceof ModelError) {
          if (err.primitive && err.showEditor) {
            throw err;
          }
          throw new ModelError(err.message, {
            primitive: this.orig(),
            showEditor: true,
            code: 1089
          });
        } else {
          throw err;
        }
      }
    }
  };
  var Placeholder = class extends SPrimitive {
    /**
     * @param {import("./DNA").DNA} dna
     * @param {SPrimitive | SPopulation} primitive
     * @param {import("./Simulator").Simulator} simulate
     */
    constructor(dna, primitive, simulate) {
      super(simulate);
      this.dna = dna;
      this.id = dna.id;
      this.primitive = primitive;
    }
    // @ts-ignore
    calculateValue() {
      throw new ModelError(`<i>[${toHTML(this.dna.name)}]</i> is a placeholder and cannot be used as a direct value in equations.`, {
        primitive: this.primitive.dna.primitive,
        showEditor: true,
        code: 1091
      });
    }
  };
  var SState = class _SState extends SPrimitive {
    constructor(simulate) {
      super(simulate);
      this.active = null;
      this.downStreamTransitions = [];
      this.constructorFunction = _SState;
    }
    innerClone(p2) {
      p2.setValue(this.active);
    }
    /**
     * @param {Material|Vector} value
     */
    setValue(value) {
      this.setActive(trueValue(value));
      this.cachedValue = void 0;
      this.simulate.evaluatedPrimitives.clear();
      this.value();
      if (this.agentId) {
        this.container.updateStates();
      }
    }
    calculateValue() {
      if (this.active === null) {
        this.setInitialActive(true);
      }
      if (this.active) {
        return new Material(1);
      } else {
        return new Material(0);
      }
    }
    /**
     * @param {boolean=} suppress
     */
    setInitialActive(suppress) {
      let init2;
      try {
        init2 = toNum(evaluateTree(this.equation, localVars(this, this.simulate), this.simulate));
      } catch (err) {
        if (err instanceof ModelError) {
          if (err.primitive && err.showEditor) {
            throw err;
          }
          throw new ModelError(err.message, {
            primitive: this.orig(),
            showEditor: true,
            code: 1092
          });
        } else {
          throw err;
        }
      }
      this.setActive(trueValue(init2), suppress);
      if (this.agentId) {
        this.container.updateStates();
      }
    }
    setActive(active, suppress) {
      this.active = active;
      if (!active || this.dna.residency === null) {
        if (!suppress) {
          if (active) {
            if (!this.simulate.transitionPrimitives) {
              this.simulate.transitionPrimitives = [];
            }
            if (this.simulate.transitionPrimitives.length > 1200 && this.simulate.transitionPrimitives.includes(this)) {
              throw new ModelError(`Circular fully active transition loop identified including the states: ${toHTML(this.simulate.transitionPrimitives.slice(0, 5).map((x2) => "[" + x2.dna.name + "]").join(", "))}`, {
                code: 1105
              });
            }
            this.simulate.transitionPrimitives.push(this);
          }
          for (let transition2 of this.downStreamTransitions) {
            scheduleTrigger.call(transition2);
          }
          if (active) {
            this.simulate.transitionPrimitives = [];
          }
        }
      } else {
        this.simulate.tasks.add(new Task({
          name: "State Residency",
          time: plus(this.simulate.time(), this.dna.residency),
          priority: 5,
          expires: 1,
          action: (_task) => {
            for (let transition2 of this.downStreamTransitions) {
              scheduleTrigger.call(transition2);
            }
          }
        }));
      }
    }
    /**
     * @returns {boolean}
     */
    getActive() {
      if (this.active === null) {
        this.setInitialActive(true);
      }
      return this.active;
    }
  };
  var STransition = class _STransition extends SPrimitive {
    constructor(simulate) {
      super(simulate);
      this.alpha = null;
      this.omega = null;
      this.scheduledTrigger = null;
      this.initialized = false;
      this.constructorFunction = _STransition;
    }
    innerClone() {
    }
    /**
     * @param {SState} alpha
     * @param {SState} omega
     */
    setEnds(alpha, omega) {
      this.alpha = alpha;
      this.omega = omega;
      if (alpha) {
        alpha.downStreamTransitions.push(this);
      }
    }
    /**
     * @returns {boolean}
     */
    canTrigger() {
      return !this.alpha || this.alpha && this.alpha.getActive() || this.dna.repeat && this.dna.trigger !== "Condition";
    }
    trigger() {
      this.scheduledTrigger = null;
      if (this.frozen) {
        return;
      }
      if (this.alpha) {
        this.alpha.setActive(false);
      }
      if (this.omega) {
        this.omega.setActive(true);
      }
      if (this.agentId) {
        this.container.updateStates();
      }
      if (this.dna.repeat && this.dna.trigger !== "Condition") {
        scheduleTrigger.call(this);
      }
    }
  };
  function scheduleTrigger() {
    updateTrigger.call(this, true);
  }
  function clearTrigger(force) {
    if (this.scheduledTrigger && (force || !this.dna.repeat)) {
      this.scheduledTrigger.kill();
      this.scheduledTrigger = null;
    }
  }
  function updateTrigger(clear) {
    this.initialized = true;
    if (clear) {
      clearTrigger.call(this);
    }
    if (this.canTrigger()) {
      let v2;
      try {
        v2 = toNum(evaluateTree(this.equation, localVars(this, this.simulate), this.simulate));
      } catch (err) {
        if (err instanceof ModelError) {
          if (err.primitive && err.showEditor) {
            throw err;
          }
          throw new ModelError(err.message, {
            primitive: this.orig(),
            showEditor: false,
            code: 1090
          });
        } else {
          throw err;
        }
      }
      try {
        if (this.dna.trigger === "Condition") {
          if (trueValue(v2)) {
            this.trigger();
          }
        } else {
          if (!(v2 instanceof Material)) {
            throw new ModelError(`The value of this trigger must evaluate to a number. Got <i>${toHTML("" + v2)}</i>.`, {
              primitive: this.orig(),
              showEditor: true,
              code: 1112
            });
          }
          let t2;
          if (this.dna.trigger === "Timeout") {
            if (!v2.units) {
              verifyValuedType(v2, this);
              v2.units = this.simulate.timeUnits;
            } else {
              v2.units.addBase();
              let base = (
                /** @type {import("./formula/Units").UnitStore} */
                v2.units.baseUnits
              );
              if (base.names.length !== 1 || base.names[0] !== "seconds" || base.exponents[0] !== 1) {
                throw new ModelError(`A trigger Timeout must have units of time, got <i>${v2.units.toString()}</i>.`, {
                  primitive: this.orig(),
                  showEditor: true,
                  code: 1113
                });
              }
            }
            if (this.scheduledTrigger && eq(v2, this.scheduledTrigger.data.value)) {
              return;
            }
            if (v2.value === 0) {
              if (this.dna.repeat) {
                throw new ModelError("A trigger Timeout of 0 with 'Repeat' set to true results in an infinite loop.", {
                  primitive: this.orig(),
                  showEditor: true,
                  code: 1114
                });
              } else {
                this.trigger();
                return;
              }
            }
            if (v2.value < 0) {
              throw new ModelError("The timeout for a transition cannot be less than 0.", {
                primitive: this.orig(),
                showEditor: true,
                code: 1115
              });
            }
            if (isNaN(v2.value)) {
              throw new ModelError("The timeout for the transition is not a valid number.", {
                primitive: this.orig(),
                showEditor: true,
                code: 1116
              });
            }
            t2 = v2;
          } else if (this.dna.trigger === "Probability") {
            if (v2.units && !v2.units.isUnitless()) {
              throw new ModelError(`The probability for the trigger had units of <i>${v2.units.toString()}</i>. Probabilities must be unitless.`, {
                primitive: this.orig(),
                showEditor: true,
                code: 1121
              });
            }
            if (isNaN(v2.value)) {
              throw new ModelError("The probability for the transition is not a valid number.", {
                primitive: this.orig(),
                showEditor: true,
                code: 1117
              });
            }
            v2 = v2.value;
            if (this.scheduledTrigger && eq(v2, this.scheduledTrigger.data.value)) {
              return;
            }
            if (v2 === 1) {
              if (this.dna.repeat) {
                throw new ModelError("A trigger probability of 1 with 'Repeat' as true results in an infinite loop.", {
                  primitive: this.orig(),
                  showEditor: true,
                  code: 1118
                });
              } else {
                this.trigger();
                return;
              }
            } else if (v2 > 1) {
              throw new ModelError("The probability for the trigger must be less than or equal to 1.", {
                primitive: this.orig(),
                showEditor: true,
                code: 1119
              });
            } else if (v2 < 0) {
              throw new ModelError("The probability for the trigger must be greater than or equal to 0.", {
                primitive: this.orig(),
                showEditor: true,
                code: 1120
              });
            } else if (v2 === 0) {
              if (!this.scheduledTrigger) {
                return;
              }
            } else {
              let l2 = -Math.log(1 - v2);
              t2 = new Material(RandExp(this.simulate, l2), this.simulate.timeUnits);
            }
          }
          let start2 = this.simulate.time();
          if (this.scheduledTrigger) {
            this.scheduledTrigger.kill();
            if (this.dna.trigger === "Timeout") {
              if (lessThanEq(t2, minus(this.simulate.time(), this.scheduledTrigger.data.start))) {
                this.scheduledTrigger = null;
                this.trigger();
                return;
              } else {
                start2 = this.scheduledTrigger.data.start;
                t2 = minus(t2, minus(this.simulate.time(), start2));
                this.scheduledTrigger = null;
              }
            } else if (this.dna.trigger === "Probability") {
              if (v2 === 0) {
                this.scheduledTrigger = null;
                return;
              }
              t2 = minus(this.scheduledTrigger.time, this.simulate.time());
              let v0 = this.scheduledTrigger.data.value;
              if (v0 !== v2) {
                let l0 = -Math.log(1 - v0);
                let l2 = -Math.log(1 - v2);
                t2 = mult(t2, new Material(l0 / l2));
              }
              start2 = this.scheduledTrigger.data.start;
              this.scheduledTrigger = null;
            }
          }
          t2 = plus(t2, this.simulate.time());
          this.scheduledTrigger = new Task({
            name: "Trigger",
            time: t2,
            priority: 5,
            expires: 1,
            action: (_task) => {
              this.trigger();
            },
            data: { start: start2, value: v2 }
          });
          this.simulate.tasks.add(this.scheduledTrigger);
        }
      } catch (err) {
        if (err instanceof ModelError) {
          if (err.primitive && err.showEditor) {
            throw err;
          }
          throw new ModelError(err.message, {
            primitive: this.orig(),
            showEditor: true,
            code: 1094
          });
        } else {
          throw err;
        }
      }
    }
  }
  var SAction = class _SAction extends SPrimitive {
    constructor(simulate) {
      super(simulate);
      this.action = null;
      this.scheduledTrigger = null;
      this.block = false;
      this.initialized = false;
      this.constructorFunction = _SAction;
    }
    innerClone() {
    }
    /**
     * @returns {boolean}
     */
    canTrigger() {
      return !this.block;
    }
    resetTimer() {
      scheduleTrigger.call(this);
    }
    trigger() {
      this.scheduledTrigger = null;
      if (this.frozen) {
        return;
      }
      try {
        evaluateTree(this.action, localVars(this, this.simulate), this.simulate);
        if (this.dna.repeat) {
          if (this.dna.trigger !== "Condition") {
            scheduleTrigger.call(this);
          }
        } else {
          this.block = true;
        }
      } catch (err) {
        if (err instanceof ModelError) {
          if (err.primitive && err.showEditor) {
            throw err;
          }
          throw new ModelError(err.message, {
            primitive: this.orig(),
            showEditor: true,
            code: 1096
          });
        } else {
          throw err;
        }
      }
    }
  };
  var SPopulation = class _SPopulation extends SPrimitive {
    constructor(simulate) {
      super(simulate);
      this.size = null;
      this.agents = null;
      this.geoWidth = null;
      this.geoHeight = null;
      this.halfWidth = null;
      this.halfHeight = null;
      this.geoDimUnits = null;
      this.geoDimUnitsObject = null;
      this.geoWrap = null;
      this.DNAs = null;
      this.stateIds = /* @__PURE__ */ new Set();
      this.placement = void 0;
      this.placementFunction = void 0;
      this.network = void 0;
      this.networkFunction = void 0;
      this.agentBase = void 0;
      this.constructorFunction = _SPopulation;
      this.vector = new Vector([], simulate, [], simulate.coreBank.get("primitivebase"));
    }
    collectData() {
      let x2 = [];
      for (let agent2 of this.agents) {
        x2.push({
          instanceId: agent2.instanceId,
          connected: agent2.connected.map((x3) => x3.instanceId),
          location: simpleNum(agent2.location.clone(), this.geoDimUnitsObject, this.simulate),
          state: agent2.states.length > 0 ? agent2.states.slice() : null
        });
      }
      return x2;
    }
    /**
     * @returns {Set<string>}
     */
    states() {
      return this.stateIds;
    }
    /**
     * @returns {Material}
     */
    toNum() {
      throw new ModelError(`<i>[${toHTML(this.dna.name)}]</i> is a population of agents and cannot be used as a direct value in equations.`, {
        code: 1107
      });
    }
    /**
     * @param {SAgent=} base
     * @returns
     */
    add(base) {
      this.size = 1 + this.size;
      let agent2;
      if (base) {
        agent2 = base.agentClone();
        agent2.agentId = this.agentId;
        agent2.setIndex(this.size - 1);
        agent2.createAgentIds();
        for (let i2 = 0; i2 < this.DNAs.length; i2++) {
          let x2 = agent2.children[i2];
          let dna = this.DNAs[i2];
          x2.container = agent2;
          linkPrimitive(x2, dna, this.simulate);
        }
        agent2.updateStates();
      } else {
        agent2 = new SAgent(this.simulate);
        agent2.container = this;
        agent2.children = [];
        agent2.childrenId = {};
        agent2.agentId = this.agentId;
        for (let dna of this.DNAs) {
          decodeDNA(dna, agent2, this.simulate, true);
        }
        agent2.setIndex(this.size - 1);
        agent2.createAgentIds();
        for (let i2 = 0; i2 < this.DNAs.length; i2++) {
          linkPrimitive(agent2.children[i2], this.DNAs[i2], this.simulate);
        }
        setAgentInitialValues(agent2);
        let neighbors = getPrimitiveNeighborhood(this, this.dna, this.simulate, []);
        if (this.placement === "Custom Function") {
          neighbors.set("self", agent2);
          agent2.location = simpleUnitsTest(
            /** @type {Vector} */
            simpleEquation(this.placementFunction, this.simulate, /* @__PURE__ */ new Map([
              [PARENT_SYMBOL, this.simulate.varBank],
              ["self", agent2]
            ]), neighbors),
            this.geoDimUnitsObject,
            this.simulate,
            null,
            null,
            "Agent placement functions must return a two element vector"
          );
          validateAgentLocation(agent2.location, this);
          if (!agent2.location.names) {
            agent2.location.names = ["x", "y"];
            agent2.location.namesLC = ["x", "y"];
          }
        } else {
          agent2.location = new Vector([mult(this.geoWidth, new Material(Rand(this.simulate))), mult(this.geoHeight, new Material(Rand(this.simulate)))], this.simulate, ["x", "y"]);
        }
        if (this.network === "Custom Function") {
          let tree = trimTree(createTree(this.networkFunction, "p:" + this.id + ":networkFunction", this.simulate), neighbors, this.simulate);
          for (let a2 of this.agents) {
            if (agent2 !== a2) {
              if (trueValue(simpleEquation(this.networkFunction, this.simulate, /* @__PURE__ */ new Map([
                [PARENT_SYMBOL, this.simulate.varBank],
                ["a", agent2],
                ["b", a2]
              ]), neighbors, tree))) {
                agent2.connect(a2);
              }
            }
          }
        }
      }
      this.simulate.tasks.add(new Task({
        priority: 10,
        expires: 1,
        name: "Add Agent",
        time: this.simulate.time(),
        action: (_task) => {
          this.agents.push(agent2);
          for (let i2 = 0; i2 < agent2.children.length; i2++) {
            let x2 = agent2.children[i2];
            let dna = this.DNAs[i2];
            if (x2 instanceof SAction || x2 instanceof STransition) {
              if (dna.trigger !== "Condition") {
                scheduleTrigger.call(x2);
              }
            }
            if (base) {
              if (x2 instanceof SAction) {
                dna.solver.actions.push(x2);
              } else if (x2 instanceof STransition) {
                dna.solver.transitions.push(x2);
              } else if (!(x2 instanceof _SPopulation)) {
                dna.solver.valued.push(x2);
                if (x2 instanceof SFlow) {
                  dna.solver.flows.push(x2);
                } else if (x2 instanceof SStock) {
                  dna.solver.stocks.push(x2);
                } else if (x2 instanceof SState) {
                  dna.solver.states.push(x2);
                }
              }
            }
          }
        }
      }));
      return agent2;
    }
  };
  var SAgent = class _SAgent {
    constructor(simulate) {
      this.agentId = null;
      this.instanceId = null;
      this.index = null;
      this.children = null;
      this.location = null;
      this.connected = [];
      this.connectedWeights = [];
      this.dead = false;
      this.constructorFunction = _SAgent;
      this.stateIDs = /* @__PURE__ */ new Set();
      this.states = [];
      this.container = void 0;
      this.dna = void 0;
      this.childrenId = void 0;
      this.simulate = simulate;
      this.vector = new Vector([], simulate, [], simulate.coreBank.get("agentbase"));
    }
    createIds() {
      this.instanceId = this.simulate.getID(this.agentId + "-" + this.index);
    }
    /**
     * @returns {string}
     */
    toString() {
      return "Agent " + (this.index + 1);
    }
    toNum() {
      return this;
    }
    updateStates() {
      this.states = [];
      this.stateIDs = /* @__PURE__ */ new Set();
      for (let child of this.children) {
        if (child instanceof SState) {
          if (child.active) {
            this.states.push(child);
            this.stateIDs.add(child.dna.id);
          }
        }
      }
    }
    /**
     * @returns {SAgent}
     */
    agentClone() {
      let agent2 = new _SAgent(this.simulate);
      agent2.dna = this.dna;
      agent2.children = [];
      agent2.childrenId = {};
      for (let child of this.children) {
        let newChild = child.clone();
        agent2.children.push(newChild);
        agent2.childrenId[child.dna.id] = newChild;
      }
      agent2.location = this.location.clone();
      agent2.connected = this.connected.slice();
      agent2.connectedWeights = this.connectedWeights.slice();
      agent2.container = this.container;
      return agent2;
    }
    /**
     * @param {number} index
     */
    setIndex(index) {
      this.index = index;
      for (let child of this.children) {
        child.index = index;
      }
    }
    createAgentIds() {
      this.createIds();
      for (let child of this.children) {
        child.createIds();
      }
    }
    die() {
      while (this.connected.length > 0) {
        this.unconnect(this.connected[0]);
      }
      for (let i2 = 0; i2 < this.container.agents.length; i2++) {
        if (this.container.agents[i2] === this) {
          this.container.agents.splice(i2, 1);
          break;
        }
      }
      for (let child of this.children) {
        let solver = child.dna.solver;
        if (child instanceof SAction) {
          solver.actions.splice(solver.actions.indexOf(child), 1);
          clearTrigger.call(child, true);
        } else if (child instanceof STransition) {
          solver.transitions.splice(solver.transitions.indexOf(child), 1);
          clearTrigger.call(child, true);
        } else if (!(child instanceof SPopulation)) {
          solver.valued.splice(solver.valued.indexOf(child), 1);
          if (child instanceof SFlow) {
            solver.flows.splice(solver.flows.indexOf(child), 1);
          } else if (child instanceof SStock) {
            solver.stocks.splice(solver.stocks.indexOf(child), 1);
          } else if (child instanceof SState) {
            solver.states.splice(solver.states.indexOf(child), 1);
          }
        }
      }
      this.dead = true;
    }
    /**
     * @param {SAgent} x
     * @param {Material=} weight
     */
    connect(x2, weight) {
      let w2 = weight === void 0 ? new Material(1) : weight;
      if (x2 !== this) {
        if (!this.connected.includes(x2)) {
          if (x2 instanceof _SAgent) {
            this.connected.push(x2);
            this.connectedWeights.push(w2);
            x2.connected.push(this);
            x2.connectedWeights.push(w2);
          } else {
            throw new ModelError("Only agents may be connected.", {
              code: 1106
            });
          }
        } else if (weight !== void 0) {
          this.connectedWeights[this.connected.indexOf(x2)] = weight;
          x2.connectedWeights[x2.connected.indexOf(this)] = weight;
        }
      }
    }
    /**
     * @param {SAgent} x
     */
    unconnect(x2) {
      if (x2 !== this) {
        let i2 = this.connected.indexOf(x2);
        if (i2 !== -1) {
          this.connected.splice(i2, 1);
          this.connectedWeights.splice(i2, 1);
          i2 = x2.connected.indexOf(this);
          x2.connected.splice(i2, 1);
          x2.connectedWeights.splice(i2, 1);
        }
      }
    }
    /**
     * @param {SAgent} x
     * @returns {Material}
     */
    connectionWeight(x2) {
      if (x2 !== this) {
        let i2 = this.connected.indexOf(x2);
        if (i2 !== -1) {
          return this.connectedWeights[i2].fullClone();
        }
      }
      throw new ModelError("Agents are not connected and so do not have a connection weight.", {
        code: 1108
      });
    }
    /**
     * @param {SAgent} x
     * @param {Material} w
     */
    setConnectionWeight(x2, w2) {
      let set3 = false;
      if (x2 !== this) {
        let i2 = this.connected.indexOf(x2);
        if (i2 !== -1) {
          set3 = true;
          this.connectedWeights[i2] = w2.fullClone();
        }
        let j = x2.connected.indexOf(this);
        if (j !== -1) {
          set3 = true;
          x2.connectedWeights[j] = w2.fullClone();
        }
      }
      if (!set3) {
        throw new ModelError("Agents are not connected and so do not have a connection weight.", {
          code: 1109
        });
      }
    }
  };
  function verifyValuedType(x2, primitive) {
    if (x2 instanceof Vector || x2 instanceof Material) {
      return;
    }
    throw new ModelError(`This value may only be numbers or vectors, found a ${typeof x2}.`, {
      primitive,
      showEditor: false,
      code: 1110
    });
  }
  var SStock = class _SStock extends SPrimitive {
    constructor(simulate) {
      super(simulate);
      this.level = null;
      this.constructorFunction = _SStock;
      this.delay = void 0;
      this.tasks = [];
      this.initRate = null;
      this.oldLevel = null;
    }
    innerClone(p2) {
      p2.level = this.level.fullClone();
      p2.oldLevel = this.oldLevel?.fullClone();
      p2.tasks = this.tasks.slice();
      p2.delay = this.delay?.fullClone();
    }
    /**
     * @param {Material|Vector} value
     */
    setValue(value) {
      this.level = value;
      this.cachedValue = void 0;
      this.simulate.evaluatedPrimitives.clear();
      this.value();
    }
    preserveLevel() {
      for (let i2 = this.tasks.length - 1; i2 >= 0; i2--) {
        this.tasks[i2].data.tentative = false;
      }
      this.oldLevel = this.level;
    }
    restoreLevel() {
      for (let i2 = this.tasks.length - 1; i2 >= 0; i2--) {
        if (this.tasks[i2].data.tentative) {
          this.tasks[i2].remove();
          this.tasks.splice(i2, 1);
        }
      }
      this.level = this.oldLevel;
    }
    /**
     * @param {Material=} delay
     */
    setDelay(delay) {
      delay = delay || this.dna.delay;
      this.delay = delay;
      if (this.delay?.value === 0) {
        this.delay = void 0;
      }
    }
    setInitialValue() {
      let init2;
      try {
        init2 = toNum(evaluateTree(this.equation, localVars(this, this.simulate), this.simulate));
      } catch (err) {
        if (err instanceof ModelError) {
          if (err.primitive && err.showEditor) {
            throw err;
          }
          throw new ModelError(err.message, {
            primitive: this.orig(),
            showEditor: true,
            code: 1098
          });
        } else {
          throw err;
        }
      }
      if (typeof init2 === "boolean") {
        if (init2) {
          init2 = new Material(1);
        } else {
          init2 = new Material(0);
        }
      }
      if (init2 instanceof Vector) {
        let d2 = this.dna;
        init2.recurseApply((x2) => {
          verifyValuedType(x2);
          if (d2.nonNegative && x2.value < 0) {
            x2 = new Material(0, d2.units);
          }
          if (!x2.units) {
            x2.units = d2.units;
          }
          return x2;
        });
      } else {
        verifyValuedType(init2);
        if (this.dna.nonNegative && init2.value < 0) {
          init2 = new Material(0, this.dna.units);
        }
        if (!init2.units) {
          init2.units = this.dna.units;
          init2.explicitUnits = true;
        }
      }
      if (this.delay === void 0 || lessThanEq(this.delay, this.simulate.timeStep.fullClone())) {
        this.level = init2;
      } else {
        this.initRate = div(init2, this.delay.forceUnits(this.simulate.timeUnits));
        let startValue = mult(this.initRate, this.simulate.userTimeStep.fullClone());
        this.level = startValue;
        this.simulate.tasks.addEvent((timeChange, oldTime, newTime) => {
          if (timeChange.value > 0) {
            let delaySpanEnd = minus(this.delay, this.simulate.userTimeStep);
            let eventSpan = [minus(oldTime, this.simulate.timeStart), minus(newTime, this.simulate.timeStart)];
            if (lessThan(delaySpanEnd, eventSpan[0])) {
              return;
            }
            let overlap = minus(this.simulate.coreBank.get("min")([delaySpanEnd, eventSpan[1]]), eventSpan[0]);
            this.level = plus(this.level, mult(overlap, this.initRate));
          }
        });
      }
    }
    /**
     * @param {ValueType} amnt
     */
    subtract(amnt) {
      this.level = minus(this.level, amnt);
      if (this.dna.nonNegative) {
        if (this.level instanceof Vector) {
          let d2 = this.dna;
          this.level.recurseApply((x2) => {
            if (x2.value < 0) {
              return new Material(0, d2.units);
            } else {
              return x2;
            }
          });
        } else if (this.level.value < 0) {
          this.level = new Material(0, this.dna.units);
        }
      }
    }
    /**
     * @param {ValueType} amnt
     * @param {Material} oldTime
     */
    add(amnt, oldTime) {
      let targetTime;
      if (this.delay !== void 0) {
        targetTime = new Material(big_default(oldTime.value).plus(this.delay.forceUnits(oldTime.units).value).toNumber(), oldTime.units);
      }
      if (this.delay === void 0 || lessThanEq(targetTime, this.simulate.time())) {
        this.level = plus(this.level, amnt);
        if (this.dna.nonNegative) {
          if (this.level instanceof Vector) {
            let d2 = this.dna;
            this.level.recurseApply((x2) => {
              if (x2.value < 0) {
                return new Material(0, d2.units);
              } else {
                return x2;
              }
            });
          } else if (this.level.value < 0) {
            this.level = new Material(0, this.dna.units);
          }
        }
      } else {
        this.scheduleAdd(amnt, targetTime);
      }
    }
    /**
     * @param {ValueType} amnt
     * @param {Material} targetTime
     */
    scheduleAdd(amnt, targetTime) {
      let oldLevel;
      let t2 = new Task({
        time: targetTime,
        data: {
          amnt,
          tentative: true
        },
        priority: -100,
        name: "Conveyor Add (" + this.dna.name + ")",
        action: (_task) => {
          oldLevel = this.level;
          this.level = plus(this.level, amnt);
          if (this.dna.nonNegative) {
            if (this.level instanceof Vector) {
              let d2 = this.dna;
              this.level.recurseApply((x2) => {
                if (x2.value < 0) {
                  return new Material(0, d2.units);
                } else {
                  return x2;
                }
              });
            } else if (this.level.value < 0) {
              this.level = new Material(0, this.dna.units);
            }
          }
        },
        rollback: () => {
          this.level = oldLevel;
        }
      });
      this.tasks.push(t2);
      this.simulate.tasks.add(t2);
    }
    /**
     * @returns {ValueType}
     */
    totalContents() {
      if (this.level === null) {
        this.setInitialValue();
      }
      if (this.delay !== void 0) {
        let res = this.level;
        let t2 = this.simulate.time();
        for (let i2 = this.tasks.length - 1; i2 >= 0; i2--) {
          if (greaterThan(this.tasks[i2].time, t2)) {
            res = plus(
              res,
              /** @type {ValueType} */
              this.tasks[i2].data.amnt
            );
          } else {
            break;
          }
        }
        let progressed = plus(this.simulate.timeProgressed(), this.simulate.userTimeStep);
        if (greaterThan(this.delay, progressed)) {
          let timeLeft = minus(this.delay, progressed);
          res = plus(res, mult(this.initRate, timeLeft));
        }
        return res;
      } else {
        return this.level;
      }
    }
    calculateValue() {
      if (this.level === null) {
        this.setInitialValue();
      }
      if (this.delay !== void 0 && this.dna.solver.RKOrder === 4) {
        let res = this.level;
        for (let i2 = 0; i2 < this.tasks.length; i2++) {
          if (greaterThan(this.tasks[i2].time, this.simulate.time()) && lessThanEq(this.tasks[i2].time, plus(this.simulate.time(), this.dna.solver.timeStep))) {
            res = plus(
              res,
              /** @type {ValueType} */
              this.tasks[i2].data.amnt
            );
          }
        }
        return res;
      } else {
        return this.level;
      }
    }
  };
  var SConverter = class _SConverter extends SPrimitive {
    constructor(simulate) {
      super(simulate);
      this.source = null;
      this.constructorFunction = _SConverter;
    }
    innerClone() {
    }
    /**
     * @param {SPrimitive|string} source
     */
    setSource(source) {
      this.source = source;
    }
    /**
     * @returns {Material|Vector}
     */
    getInputValue() {
      if (this.source === "*time") {
        return this.simulate.time();
      } else if (this.source instanceof SPrimitive) {
        let inp = toNum(this.source.value());
        if (!inp) {
          throw new ModelError("Undefined input value.", {
            primitive: this.orig(),
            showEditor: false,
            code: 1199
          });
        }
        if (!(inp instanceof Vector || inp instanceof Material)) {
          throw new ModelError("Converter inputs must be numbers or vectors.", {
            primitive: this.orig(),
            showEditor: false,
            code: 1200
          });
        }
        return inp;
      } else {
        console.error("Invalid source", this.source);
        throw new Error("Invalid source");
      }
    }
    calculateValue() {
      return this.getOutputValue();
    }
    /**
     * @returns {Material|Vector}
     */
    getOutputValue() {
      let input = this.getInputValue();
      let processItem = (inp) => {
        let processItemInner = (inp2) => {
          if (!this.dna.inputs.length) {
            return new Material(0);
          }
          for (let i2 = 0; i2 < this.dna.inputs.length; i2++) {
            if (this.dna.interpolation === "discrete") {
              if (greaterThan(this.dna.inputs[i2], inp2)) {
                if (i2 === 0) {
                  return this.dna.outputs[0];
                } else {
                  return this.dna.outputs[i2 - 1];
                }
              }
            } else if (this.dna.interpolation === "linear") {
              if (eq(this.dna.inputs[i2], inp2)) {
                return this.dna.outputs[i2];
              } else if (greaterThan(this.dna.inputs[i2], inp2)) {
                if (i2 === 0) {
                  return this.dna.outputs[0];
                } else {
                  let x2 = div(
                    plus(
                      mult(minus(inp2, this.dna.inputs[i2 - 1]), this.dna.outputs[i2]),
                      mult(minus(this.dna.inputs[i2], inp2), this.dna.outputs[i2 - 1])
                    ),
                    minus(this.dna.inputs[i2], this.dna.inputs[i2 - 1])
                  );
                  return x2;
                }
              }
            }
          }
          return new Material(this.dna.outputs[this.dna.outputs.length - 1].value);
        };
        let r2 = (
          /** @type {Material} */
          processItemInner(inp)
        );
        return new Material(r2.value, this.dna.units);
      };
      if (input instanceof Vector) {
        return input.clone().recurseApply(processItem);
      } else if (input instanceof Material) {
        return processItem(input);
      } else {
        throw new ModelError("Invalid input value.", {
          primitive: this.orig(),
          showEditor: false,
          code: 1199
        });
      }
    }
  };
  var SVariable = class _SVariable extends SPrimitive {
    constructor(simulate) {
      super(simulate);
      this.constructorFunction = _SVariable;
    }
    innerClone() {
    }
    calculateValue() {
      let x2 = evaluateTree(this.equation, localVars(this, this.simulate), this.simulate);
      if (typeof x2 === "boolean") {
        if (x2) {
          x2 = new Material(1);
        } else {
          x2 = new Material(0);
        }
      } else if (x2 instanceof Vector) {
        return x2;
      } else if (typeof x2 === "string") {
        return x2;
      }
      if (!x2.units) {
        x2.units = this.dna.units;
        x2.explicitUnits = true;
      }
      return x2;
    }
  };
  var SFlow = class _SFlow extends SPrimitive {
    constructor(simulate) {
      super(simulate);
      this.alpha = null;
      this.omega = null;
      this.rate = null;
      this.blendedRate = null;
      this.RKPrimary = [];
      this.constructorFunction = _SFlow;
    }
    innerClone() {
    }
    /**
     * @param {SStock} alpha
     * @param {SStock} omega
     */
    setEnds(alpha, omega) {
      this.alpha = alpha;
      this.omega = omega;
    }
    calculateValue() {
      this.predict();
      return this.rate.fullClone();
    }
    clean() {
      this.rate = null;
      this.blendedRate = null;
      this.RKPrimary = [];
    }
    doRK4Aggregation() {
      this.blendedRate = div(plus(plus(plus(this.RKPrimary[0], mult(new Material(2), this.RKPrimary[1])), mult(new Material(2), this.RKPrimary[2])), this.RKPrimary[3]), new Material(6));
      this.blendedRate = this.checkRate(this.blendedRate);
    }
    checkRate(rate) {
      let newRate = div(rate, this.dna.adoptUnits ? new Material(this.dna.solver.timeStep.value) : this.dna.solver.timeStep.fullClone());
      if (this.dna.nonNegative) {
        if (newRate instanceof Vector) {
          newRate.recurseApply((x2) => {
            if (x2.value >= 0) {
              return x2;
            } else {
              return new Material(0, x2.units);
            }
          });
        } else {
          if (newRate.value <= 0) {
            newRate = new Material(0, newRate.units);
          }
        }
      }
      return newRate;
    }
    /**
     * @param {boolean=} override
     */
    predict(override) {
      if (this.rate === null || override) {
        let x2;
        try {
          x2 = toNum(evaluateTree(this.equation, localVars(this, this.simulate), this.simulate));
          if (!(x2 instanceof Vector || isFinite(x2.value))) {
            verifyValuedType(x2, this);
            throw new ModelError("The result of this calculation is not finite. Flows must have finite values. Are you dividing by 0?", {
              primitive: this.orig(),
              showEditor: true,
              code: 1111
            });
          }
        } catch (err) {
          if (err instanceof ModelError) {
            if (err.primitive && err.showEditor) {
              throw err;
            }
            throw new ModelError(err.message, {
              primitive: this.orig(),
              showEditor: true,
              code: 1100
            });
          } else {
            throw err;
          }
        }
        if (typeof x2 === "boolean") {
          if (x2) {
            x2 = new Material(1);
          } else {
            x2 = new Material(0);
          }
        }
        this.rate = x2.fullClone();
        if (!this.dna.adoptUnits) {
          if (this.rate instanceof Vector) {
            let d2 = this.dna;
            this.rate.recurseApply((x3) => {
              verifyValuedType(x3, this);
              if (!x3.units) {
                x3.units = d2.units;
              }
              return x3;
            });
          } else if (!this.rate.units) {
            verifyValuedType(this.rate, this);
            this.rate.units = this.dna.units;
            this.rate.explicitUnits = true;
          }
        }
        this.testUnits(this.rate, true);
        this.rate = mult(this.rate, this.dna.adoptUnits ? new Material(this.dna.solver.timeStep.value) : this.dna.solver.timeStep.fullClone());
        if (override) {
          if (this.RKPrimary.length > 0) {
            this.RKPrimary[this.RKPrimary.length - 1] = this.rate;
          } else {
            this.RKPrimary.push(this.rate);
          }
        } else {
          this.RKPrimary.push(this.rate);
        }
        this.rate = this.checkRate(this.rate);
      }
    }
    /**
     * @param {Material} timeChange
     * @param {Material} oldTime
     *
     * @returns
     */
    apply(timeChange, oldTime) {
      try {
        if (this.rate === null && this.blendedRate === null) {
          return;
        }
        let rate = this.blendedRate ? this.blendedRate.fullClone() : this.rate.fullClone();
        rate = mult(rate, this.dna.adoptUnits ? new Material(timeChange.forceUnits(this.simulate.timeUnits).value) : timeChange);
        let inRate = rate;
        let outRate = rate;
        let collapsed = false;
        if (this.alpha !== null) {
          let v2 = this.alpha.level;
          if (rate instanceof Vector && (!(v2 instanceof Vector) || v2.depth() < rate.depth())) {
            inRate = rate.fullClone().collapseDimensions(v2);
            collapsed = true;
          } else if (v2 instanceof Vector && (!(rate instanceof Vector) || v2.depth() > rate.depth())) {
            throw new ModelError("The start of the flow is a vector with a higher order than the flow rate. There has to be at least one element in the flow rate for each element in the start.", {
              primitive: this.orig(),
              showEditor: true,
              code: 1201
            });
          }
        }
        if (this.omega !== null) {
          let v2 = this.omega.level;
          if (rate instanceof Vector && (!(v2 instanceof Vector) || v2.depth() < rate.depth())) {
            outRate = rate.fullClone().collapseDimensions(v2);
            collapsed = true;
          } else if (v2 instanceof Vector && (!(rate instanceof Vector) || v2.depth() > rate.depth())) {
            throw new ModelError("The end of the flow is a vector with a higher order than the flow rate. There has to be at least one element in the flow rate for each element in the end.", {
              primitive: this.orig(),
              showEditor: true,
              code: 1202
            });
          }
        }
        if (!collapsed) {
          if (this.omega !== null && this.omega.dna.nonNegative) {
            let modifier;
            try {
              modifier = plus(toNum(this.omega.level), rate);
            } catch (err) {
              throw new ModelError(`Incompatible units for flow <i>[${toHTML(this.dna.name)}]</i> and connected stock <i>[${toHTML(this.omega.dna.name)}]</i>. Stock has units of <i>${this.omega.dna.units ? this.omega.dna.units.toString() : "unitless"}</i>. The flow should have the equivalent units divided by some time unit such as Years.`, {
                primitive: this.orig(),
                showEditor: false,
                code: 1203
              });
            }
            if (modifier instanceof Vector) {
              modifier.recurseApply((x2) => {
                if (x2.value < 0) {
                  return x2;
                } else {
                  return new Material(0, x2.units);
                }
              });
              rate = minus(rate, modifier);
            } else {
              if (modifier.value < 0) {
                rate = negate(toNum(this.omega.level));
              }
            }
          }
          if (this.alpha !== null && this.alpha.dna.nonNegative) {
            let modifier;
            try {
              modifier = minus(toNum(this.alpha.level), rate);
            } catch (err) {
              throw new ModelError(`Incompatible units for flow <i>[${toHTML(this.dna.name)}]</i> and connected stock <i>[${toHTML(this.alpha.dna.name)}]</i>. Stock has units of <i>${this.alpha.dna.units ? this.alpha.dna.units.toString() : "unitless"}</i>. The flow should have the equivalent units divided by some time unit such as Years.`, {
                primitive: this.orig(),
                showEditor: false,
                code: 1204
              });
            }
            if (modifier instanceof Vector) {
              modifier.recurseApply((x2) => {
                if (x2.value < 0) {
                  return x2;
                } else {
                  return new Material(0, x2.units);
                }
              });
              rate = plus(rate, modifier);
            } else {
              if (modifier.value < 0) {
                rate = toNum(this.alpha.level);
              }
            }
          }
          if (this.omega && this.omega.dna.nonNegative) {
            if (rate instanceof Vector) {
              let vec = this.simulate.coreBank.get("flatten")([plus(toNum(this.omega.level), rate)]);
              for (let item of vec.items) {
                if (item instanceof Material && item.value < 0) {
                  throw new ModelError("Inconsistent non-negative constraints for flow.", {
                    primitive: this.orig(),
                    showEditor: false,
                    code: 1205
                  });
                }
              }
            } else {
              let n2 = plus(toNum(this.omega.level), rate);
              if (n2 instanceof Material && n2.value < 0) {
                throw new ModelError("Inconsistent non-negative constraints for flow.", {
                  primitive: this.orig(),
                  showEditor: false,
                  code: 1206
                });
              }
            }
          }
        } else {
          if (this.alpha && this.alpha.dna.nonNegative) {
            throw new ModelError("Cannot use non-negative stocks when the flow rate is a vector that needs to be collapsed.", {
              primitive: this.alpha.dna.primitive,
              showEditor: false,
              code: 1207
            });
          }
          if (this.omega && this.omega.dna.nonNegative) {
            throw new ModelError("Cannot use non-negative stocks when the flow rate is a vector that needs to be collapsed.", {
              primitive: this.omega.dna.primitive,
              showEditor: false,
              code: 1208
            });
          }
        }
        let additionTest = 0;
        try {
          if (this.omega !== null) {
            additionTest = 1;
            if (collapsed) {
              this.omega.add(outRate, oldTime);
            } else {
              this.omega.add(rate, oldTime);
            }
          }
          if (this.alpha !== null) {
            additionTest = 2;
            if (collapsed) {
              this.alpha.subtract(inRate);
            } else {
              this.alpha.subtract(rate);
            }
          }
        } catch (err) {
          let stock;
          if (additionTest === 1) {
            stock = this.omega;
          } else if (additionTest === 2) {
            stock = this.alpha;
          }
          if (err.code === 2e3 || err.code === 2001) {
            throw new ModelError(`Incompatible vector keys for flow <i>[${toHTML(this.dna.name)}]</i> and connected stock <i>[${toHTML(stock.dna.name)}]</i>.`, {
              primitive: this.orig(),
              showEditor: false,
              code: 1209
            });
          } else {
            throw new ModelError(`Incompatible units for flow <i>[${toHTML(this.dna.name)}]</i> and connected stock <i>[${toHTML(stock.dna.name)}]</i>. Stock has units of <i>${stock.dna.units ? stock.dna.units.toString() : "unitless"}</i>. The flow should have the equivalent units divided by some time unit such as Years.`, {
              primitive: this.orig(),
              showEditor: false,
              code: 1210
            });
          }
        }
      } catch (err) {
        if (err instanceof ModelError) {
          if (err.primitive && err.showEditor) {
            throw err;
          }
          throw new ModelError(err.message, {
            primitive: this.orig(),
            showEditor: true,
            code: 1102
          });
        } else {
          throw err;
        }
      }
    }
  };
  function localVars(primitive, simulate) {
    if (primitive instanceof SAgent) {
      return /* @__PURE__ */ new Map([
        [PARENT_SYMBOL, simulate.varBank],
        ["self", primitive]
      ]);
    } else if (primitive.container) {
      return /* @__PURE__ */ new Map([
        [PARENT_SYMBOL, simulate.varBank],
        ["self", primitive.container]
      ]);
    } else {
      return /* @__PURE__ */ new Map([
        [PARENT_SYMBOL, simulate.varBank]
      ]);
    }
  }
  function constraintAlert(item, type, val, simulate) {
    let msg = "The " + (type === "max" ? "maximum" : "minimum") + " constraint on the primitive [<i>" + toHTML(simulate.model.getId(item.id).name) + "</i>] has been violated. The primitive's value attempted to become " + toHTML("" + val.value) + " when the " + (type === "max" ? "maximum" : "minimum") + " allowed value is " + (type === "max" ? item.dna.maxConstraint : item.dna.minConstraint) + ".";
    throw new ModelError(msg, {
      primitive: item.dna.primitive,
      showEditor: false,
      code: 1150
    });
  }

  // ../insight-maker-simulation/src/AggregateSeries.js
  var AggregateSeries = class {
    /**
     * @param {import("./Simulator").Simulator} simulate
     * @param {Material} mSpacing
     */
    constructor(simulate, mSpacing) {
      this.simulate = simulate;
      this.spacing = mSpacing;
      this.oldValues = [];
    }
    get(data) {
      let index = 0;
      if (this.spacing === null) {
        index = 0;
      } else if (this.spacing.value < 0) {
        index = 0;
      } else if (this.spacing.value === 0) {
        index = Math.floor(div(minus(this.simulate.time(), this.simulate.timeStart), this.simulate.userTimeStep).value);
      } else {
        index = Math.floor(div(minus(this.simulate.time(), this.simulate.timeStart), this.spacing.forceUnits(this.simulate.timeUnits)).value);
      }
      while (this.oldValues.length - 1 < index) {
        let value = evaluateNode(data.node, data.scope, this.simulate);
        this.oldValues.push(toNum(value));
      }
      if (this.oldValues[index].fullClone) {
        return this.oldValues[index].fullClone();
      } else {
        return this.oldValues[index];
      }
    }
  };

  // ../insight-maker-simulation/src/Functions.js
  function createFunctions(simulate) {
    let AgentObject = {};
    let PrimitiveObject = {};
    defineFunction(simulate, "Stop", { params: [] }, () => {
      if (simulate.config.showNotification) {
        simulate.config.showNotification("Simulation ended early by a call to stop().");
      }
      throw {
        simulationCommand: "STOP"
      };
    });
    defineFunction(simulate, "Pause", { params: [] }, () => {
      simulate.sleep(true);
      return new Material(0);
    });
    defineFunction(simulate, "Time", { params: [] }, () => {
      return simulate.time().fullClone();
    });
    defineFunction(simulate, "TimeStep", { params: [] }, () => {
      return simulate.timeStep.fullClone();
    });
    defineFunction(simulate, "TimeLength", { params: [] }, () => {
      return simulate.timeLength.fullClone();
    });
    defineFunction(simulate, "TimeStart", { params: [] }, () => {
      return simulate.timeStart.fullClone();
    });
    defineFunction(simulate, "TimeEnd", { params: [] }, () => {
      return simulate.timeEnd.fullClone();
    });
    defineFunction(simulate, "Seconds", { params: [{ name: "Value", defaultVal: "time", vectorize: true }] }, (x2) => {
      let item;
      if (!x2.length) {
        item = simulate.time().fullClone();
      } else {
        item = toNum(x2[0]);
      }
      return mult(item, new Material(1, simulate.unitManager.getUnitStore(["seconds"], [-1])));
    });
    defineFunction(simulate, "Minutes", { params: [{ name: "Value", defaultVal: "time", vectorize: true }] }, (x2) => {
      let item;
      if (!x2.length) {
        item = simulate.time().fullClone();
      } else {
        item = toNum(x2[0]);
      }
      return mult(item, new Material(1, simulate.unitManager.getUnitStore(["minutes"], [-1])));
    });
    defineFunction(simulate, "Hours", { params: [{ name: "Value", defaultVal: "time", vectorize: true }] }, (x2) => {
      let item;
      if (!x2.length) {
        item = simulate.time().fullClone();
      } else {
        item = toNum(x2[0]);
      }
      return mult(item, new Material(1, simulate.unitManager.getUnitStore(["hours"], [-1])));
    });
    defineFunction(simulate, "Days", { params: [{ name: "Value", defaultVal: "time", vectorize: true }] }, (x2) => {
      let item;
      if (!x2.length) {
        item = simulate.time().fullClone();
      } else {
        item = toNum(x2[0]);
      }
      return mult(item, new Material(1, simulate.unitManager.getUnitStore(["days"], [-1])));
    });
    defineFunction(simulate, "Weeks", { params: [{ name: "Value", defaultVal: "time", vectorize: true }] }, (x2) => {
      let item;
      if (!x2.length) {
        item = simulate.time().fullClone();
      } else {
        item = toNum(x2[0]);
      }
      return mult(item, new Material(1, simulate.unitManager.getUnitStore(["weeks"], [-1])));
    });
    defineFunction(simulate, "Months", { params: [{ name: "Value", defaultVal: "time", vectorize: true }] }, (x2) => {
      let item;
      if (!x2.length) {
        item = simulate.time().fullClone();
      } else {
        item = toNum(x2[0]);
      }
      return mult(item, new Material(1, simulate.unitManager.getUnitStore(["months"], [-1])));
    });
    defineFunction(simulate, "Years", { params: [{ name: "Value", defaultVal: "time", vectorize: true }] }, (x2) => {
      let item;
      if (!x2.length) {
        item = simulate.time().fullClone();
      } else {
        item = toNum(x2[0]);
      }
      return mult(item, new Material(1, simulate.unitManager.getUnitStore(["years"], [-1])));
    });
    defineFunction(simulate, "Seasonal", { params: [{ name: "Peak", defaultVal: "0", vectorize: true }] }, (x2) => {
      let peak;
      if (!x2.length) {
        peak = new Material(0, simulate.timeUnits);
      } else {
        peak = toNum(x2[0]).fullClone();
        if (!peak.units) {
          peak.units = simulate.timeUnits;
        }
      }
      let position2 = minus(
        /** @type {Material} */
        simulate.coreBank.get("time")([]),
        peak
      );
      let dist = position2.forceUnits(createUnitStore("years", simulate)).value * 2 * Math.PI;
      return new Material(Math.cos(dist));
    });
    defineFunction(simulate, "Unitless", { params: [{ name: "Value", noVector: true }] }, (x2) => {
      return new Material(toNum(x2[0]).value);
    });
    defineFunction(simulate, "RemoveUnits", { params: [{ name: "Value", vectorize: true }, { name: "ExpectedUnits", needString: true }] }, (x2) => {
      let m2 = toNum(x2[0]).fullClone();
      return new Material(m2.forceUnits(createUnitStore(x2[1], simulate)).value);
    });
    defineFunction(simulate, "PastMean", { object: [simulate.varBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Past Range", defaultVal: "All Time", vectorize: true }] }, (x2) => {
      if (x2.length === 1) {
        return simulate.coreBank.get("mean")(x2[0].getPastValues());
      } else {
        return simulate.coreBank.get("mean")(x2[0].getPastValues(toNum(x2[1])));
      }
    });
    defineFunction(simulate, "PastMedian", { object: [simulate.varBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Past Range", defaultVal: "All Time", vectorize: true }] }, (x2) => {
      if (x2.length === 1) {
        return simulate.coreBank.get("median")(x2[0].getPastValues());
      } else {
        return simulate.coreBank.get("median")(x2[0].getPastValues(toNum(x2[1])));
      }
    });
    defineFunction(simulate, "PastValues", { object: [simulate.varBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Past Range", defaultVal: "All Time", vectorize: true }] }, (x2) => {
      let items;
      if (x2.length === 1) {
        items = x2[0].getPastValues();
      } else {
        items = x2[0].getPastValues(toNum(x2[1]));
      }
      return new Vector(items, simulate);
    });
    defineFunction(simulate, "PastStdDev", { object: [simulate.varBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Past Range", defaultVal: "All Time", vectorize: true }] }, (x2) => {
      let items;
      if (x2.length === 1) {
        items = x2[0].getPastValues();
      } else {
        items = x2[0].getPastValues(toNum(x2[1]));
      }
      if (items.length > 1) {
        return simulate.coreBank.get("stddev")(items);
      } else {
        return new Material(0);
      }
    });
    defineFunction(simulate, "PastCorrelation", { object: [simulate.varBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Past Range", vectorize: true, defaultVal: "All Time" }] }, (x2) => {
      let items1;
      let items2;
      if (x2.length === 2) {
        items1 = x2[0].getPastValues();
        items2 = x2[1].getPastValues();
      } else {
        items1 = x2[0].getPastValues(toNum(x2[2]));
        items2 = x2[1].getPastValues(toNum(x2[2]));
      }
      if (items1.length > 1) {
        return simulate.coreBank.get("correlation")([new Vector(items1, simulate), new Vector(items2, simulate)]);
      } else {
        return new Material(0);
      }
    });
    defineFunction(simulate, "PastMax", { object: [simulate.varBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Past Range", defaultVal: "All Time", vectorize: true }] }, (x2) => {
      if (x2.length === 1) {
        return simulate.coreBank.get("max")(x2[0].getPastValues());
      } else {
        return simulate.coreBank.get("max")(x2[0].getPastValues(toNum(x2[1])));
      }
    });
    defineFunction(simulate, "PastMin", { object: [simulate.varBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Past Range", defaultVal: "All Time", vectorize: true }] }, (x2) => {
      if (x2.length === 1) {
        return simulate.coreBank.get("min")(x2[0].getPastValues());
      } else {
        return simulate.coreBank.get("min")(x2[0].getPastValues(toNum(x2[1])));
      }
    });
    defineFunction(
      simulate,
      "Pulse",
      { params: [{ name: "Start Time", vectorize: true }, { name: "Height", vectorize: true, defaultVal: 1 }, { name: "Width", vectorize: true, defaultVal: 0 }, { name: "Repeat Period", vectorize: true, defaultVal: 0 }] },
      /**
       * @param {[Material, Material, Material, Material]} x
       */
      (x2) => {
        let start2 = toNum(x2[0]);
        let height2 = new Material(1);
        let width = new Material(0);
        let repeat = new Material(0);
        if (x2.length > 1) {
          height2 = toNum(x2[1]);
          if (x2.length > 2) {
            width = toNum(x2[2]);
            if (x2.length > 3) {
              repeat = toNum(x2[3]);
            }
          }
        }
        if (!start2.units) {
          start2.units = simulate.timeUnits;
        }
        if (!width.units) {
          width.units = simulate.timeUnits;
        }
        if (!repeat.units) {
          repeat.units = simulate.timeUnits;
        }
        if (repeat.value <= 0) {
          if (eq(simulate.time(), start2) || greaterThanEq(simulate.time(), start2) && lessThanEq(simulate.time(), plus(start2, width))) {
            return height2;
          }
        } else if (greaterThanEq(simulate.time(), start2)) {
          let x3 = minus(simulate.time(), mult(simulate.coreBank.get("floor")([div(minus(simulate.time(), start2), repeat)]), repeat));
          let dv = minus(simulate.time(), start2);
          if (minus(
            /** @type {Material} */
            simulate.coreBank.get("round")([div(dv, repeat)]),
            div(dv, repeat)
          ).value === 0 || greaterThanEq(x3, start2) && lessThanEq(x3, plus(start2, width))) {
            return height2;
          }
        }
        return new Material(0, height2.units);
      }
    );
    defineFunction(
      simulate,
      "Ramp",
      { params: [{ name: "Start Time", vectorize: true }, { name: "Finish Time", vectorize: true }, { name: "Height", vectorize: true, defaultVal: 1 }] },
      /**
       * @param {[Material, Material, Material]} x
       */
      (x2) => {
        let start2 = toNum(x2[0]);
        let finish = toNum(x2[1]);
        let height2 = new Material(1);
        if (x2.length === 3) {
          height2 = toNum(x2[2]);
        }
        if (!start2.units) {
          start2.units = simulate.timeUnits;
        }
        if (!finish.units) {
          finish.units = simulate.timeUnits;
        }
        if (greaterThanEq(simulate.time(), start2)) {
          let q = div(mult(simulate.coreBank.get("min")([minus(finish, start2), minus(simulate.time(), start2)]), height2), minus(finish, start2));
          return q;
        }
        return new Material(0, height2.units);
      }
    );
    defineFunction(
      simulate,
      "Step",
      { params: [{ name: "Start Time", vectorize: true }, { name: "Height", vectorize: true, defaultVal: 1 }] },
      /**
       * @param {[Material, Material]} x
       */
      (x2) => {
        let start2 = toNum(x2[0]);
        let height2 = new Material(1);
        if (x2.length === 2) {
          height2 = toNum(x2[1]);
        }
        if (!start2.units) {
          start2.units = simulate.timeUnits;
        }
        if (greaterThanEq(simulate.time(), start2)) {
          return height2;
        }
        return new Material(0, height2.units);
      }
    );
    simulate.varBank.set("staircase", simulate.coreBank.get("step"));
    simulate.coreBank.set("staircase", simulate.varBank.get("staircase"));
    defineFunction(
      simulate,
      "ConverterTable",
      { object: [simulate.varBank, PrimitiveObject], params: [{ name: "[Converter]", noVector: true, needPrimitive: true }] },
      /**
       * @param {[SPrimitive]} x
       *
       * @returns {Vector}
       */
      (x2) => {
        if (!(x2[0] instanceof SConverter)) {
          throw new ModelError("ConverterTable() requires a Converter primitive as its parameter.", {
            code: 1045
          });
        }
        let input = x2[0].dna.inputs;
        let outputs = x2[0].dna.outputs;
        let items = [];
        let clean = function(x3) {
          if (x3 instanceof Material) {
            return new Material(x3.value);
          }
          return new Material(x3);
        };
        for (let i2 = 0; i2 < input.length; i2++) {
          items.push(new Vector([clean(input[i2].value), clean(outputs[i2])], simulate, ["x", "y"]));
        }
        return new Vector(items, simulate);
      }
    );
    defineFunction(
      simulate,
      "Delay",
      { object: [simulate.varBank, PrimitiveObject], params: [{ name: "[Primitive]", noVector: true, needPrimitive: true }, { name: "Delay", vectorize: true }, { name: "Initial Value", defaultVal: "None" }] },
      /**
       * @param {[SPrimitive, Material, ValueType?]} x
       *
       * @returns {ValueType}
       */
      (x2) => {
        if (toNum(x2[1]).value < 0) {
          throw new ModelError("The delay must be greater than or equal to 0.", {
            code: 1026
          });
        }
        if (x2.length === 2) {
          return x2[0].pastValue(toNum(x2[1]));
        } else {
          return x2[0].pastValue(toNum(x2[1]), toNum(x2[2]));
        }
      }
    );
    defineFunction(
      simulate,
      "Smooth",
      { object: [simulate.varBank, PrimitiveObject], params: [{ name: "Expression", noVector: true }, { name: "Period", vectorize: true, needNum: true }, { name: "Initial Value", defaultVal: "None" }] },
      (_x) => {
        throw new ModelError("Smooth() may only be called in a top level primitive equation", {
          code: 1052
        });
      }
    );
    defineFunction(
      simulate,
      "SmoothN",
      { object: [simulate.varBank, PrimitiveObject], params: [
        { name: "Expression", noVector: true },
        { name: "Period", vectorize: true, needNum: true },
        { name: "Order", noUnits: true, noVector: true, needNum: true },
        { name: "Initial Value", defaultVal: "None" }
      ] },
      (_x) => {
        throw new ModelError("SmoothN() may only be called in a top level primitive equation", {
          code: 1052
        });
      }
    );
    defineFunction(
      simulate,
      "Delay1",
      { object: [simulate.varBank, PrimitiveObject], params: [{ name: "Expression", noVector: true }, { name: "Delay", vectorize: true, needNum: true }, { name: "Initial Value", defaultVal: "None" }] },
      (_x) => {
        throw new ModelError("Delay1() may only be called in a top level primitive equation", {
          code: 1053
        });
      }
    );
    defineFunction(
      simulate,
      "Delay3",
      { object: [simulate.varBank, PrimitiveObject], params: [{ name: "Expression", noVector: true }, { name: "Delay", vectorize: true, needNum: true }, { name: "Initial Value", defaultVal: "None" }] },
      (_x) => {
        throw new ModelError("Delay3() may only be called in a top level primitive equation", {
          code: 1054
        });
      }
    );
    defineFunction(
      simulate,
      "DelayN",
      { object: [simulate.varBank, PrimitiveObject], params: [
        { name: "Expression", noVector: true },
        { name: "Delay", vectorize: true, needNum: true },
        { name: "Order", noUnits: true, noVector: true, needNum: true },
        { name: "Initial Value", defaultVal: "None" }
      ] },
      (_x) => {
        throw new ModelError("DelayN() may only be called in a top level primitive equation", {
          code: 1075
        });
      }
    );
    simulate.varBank.set("fix", function(x2, id2) {
      testArgumentsSize(x2, "Fix", 1, 2);
      let spacing = null;
      if (x2.length === 2) {
        spacing = toNum(evaluateNode(x2[1].node, x2[1].scope, simulate));
        if (!(spacing instanceof Material)) {
          throw new ModelError("fix() requires a number for the parameter 'spacing'.", {
            code: 6058
          });
        }
      }
      let mySeries = simulate.aggregateSeries.get(id2);
      if (!mySeries) {
        mySeries = new AggregateSeries(simulate, spacing);
        simulate.aggregateSeries.set(id2, mySeries);
      }
      return mySeries.get(x2[0]);
    });
    simulate.varBank.get("fix").delayEvalParams = true;
    simulate.coreBank.set("fix", simulate.varBank.get("fix"));
    simulate.varBank.set("populationsize", function(x2) {
      testArgumentsSize(x2, "PopulationSize", 1, 1);
      if (x2[0] instanceof SPopulation) {
        return new Material(x2[0].agents.length);
      }
      throw new ModelError("PopulationSize must be passed an agent population as an argument.", {
        code: 1327
      });
    });
    PrimitiveObject["populationsize"] = simulate.varBank.get("populationsize");
    simulate.coreBank.set("populationsize", simulate.varBank.get("populationsize"));
    defineFunction(simulate, "Remove", { object: [simulate.varBank, AgentObject], params: [{ needAgent: true, name: "[Agent]" }] }, (x2) => {
      if (x2[0].dead) {
        throw new ModelError("Cannot remove an already removed agent.", {
          code: 1328
        });
      }
      simulate.tasks.add(new Task({
        time: simulate.time(),
        priority: 10,
        expires: 1,
        name: "Remove Agent",
        action: (_task) => {
          x2[0].die();
        }
      }));
      return new Material(1);
    });
    defineFunction(simulate, "Add", { object: [simulate.varBank, PrimitiveObject], params: [{ name: "[Agent Population]", allowOptionalPrimitive: true }, { needAgent: true, name: "[Base]", defaultVal: "Agent Base" }] }, (x2) => {
      while (!(x2[0] instanceof SPopulation) && !(x2[0].container === null || x2[0].container === void 0)) {
        x2[0] = x2[0].container;
      }
      if (!(x2[0] instanceof SPopulation)) {
        throw new ModelError("You must pass an agent population as the first argument to Add().", {
          code: 1029
        });
      }
      if (x2.length === 2) {
        return x2[0].add(x2[1]);
      } else {
        return x2[0].add();
      }
    });
    defineFunction(simulate, "FindAll", { object: [simulate.varBank, VectorObject, PrimitiveObject], params: [{ needPopulation: true, name: "[Agent Population]" }] }, (x2) => {
      return x2[0];
    });
    defineFunction(simulate, "ResetTimer", { object: [simulate.varBank, PrimitiveObject], params: [{ needPrimitive: true, name: "[Action]" }] }, (x2) => {
      if (!(x2[0] instanceof SAction)) {
        throw new ModelError("ResetTimer requires an Action primitive.", {
          code: 1030
        });
      }
      x2[0].resetTimer();
      return new Material(0);
    });
    defineFunction(simulate, "Transition", { object: [simulate.varBank, PrimitiveObject], params: [{ needPrimitive: true, name: "[Transition]" }] }, (x2) => {
      if (!(x2[0] instanceof STransition)) {
        throw new ModelError("Transition requires an Transition primitive.", {
          code: 1031
        });
      }
      x2[0].trigger();
      return new Material(0);
    });
    defineFunction(simulate, "Value", { object: [simulate.varBank, VectorObject, AgentObject], params: [{ name: "[Population]" }, { needPrimitive: true, name: "[Primitive]" }] }, (x2) => {
      let id2 = x2[1].id;
      let population = null;
      if (!(x2[0] instanceof SPopulation || x2[0] instanceof SAgent || x2[0] instanceof Vector || !x2[0])) {
        x2[0] = toNum(x2[0]);
      }
      if (x2[0] instanceof SPopulation) {
        population = getPopulation(x2[0], simulate);
      }
      if (x2[0] instanceof Vector) {
        population = x2[0];
      }
      if (population !== null) {
        let res = [];
        let q = -1;
        for (let item of population.items) {
          if (!(item instanceof SAgent)) {
            throw new ModelError('Cannot take "Value()" of vector that does not contain agents.', {
              code: 1172
            });
          }
          if (q !== -1) {
            res.push(item.children[q]);
          } else {
            for (let j = 0; j < item.children.length; j++) {
              if (item.children[j].id === id2) {
                res.push(item.children[j]);
                q = j;
                break;
              }
            }
          }
        }
        return new Vector(res, simulate);
      } else if (x2[0] instanceof SAgent) {
        for (let child of x2[0].children) {
          if (child.id === id2) {
            return child;
          }
        }
        throw new ModelError('Could not find referenced primitive for "Value()".', {
          code: 1032
        });
      }
      throw new ModelError('Invalid type for the first argument of "Value()".', {
        code: 1033
      });
    });
    defineFunction(simulate, "SetValue", { object: [simulate.varBank, VectorObject, PrimitiveObject, AgentObject], params: [{ name: "[Population]" }, { needPrimitive: true, name: "[Primitive]" }, { name: "Value", allowBoolean: true }] }, (x2) => {
      let id2 = x2[1].id;
      let population = null;
      if (x2[0] instanceof SPopulation) {
        population = getPopulation(x2[0], simulate);
      }
      if (x2[0] instanceof Vector) {
        population = x2[0];
      }
      if (population !== null) {
        for (let i2 = 0; i2 < population.length(); i2++) {
          for (let child of population.items[i2].children) {
            if (child.id === id2) {
              child.setValue(x2[2]);
            }
          }
        }
        return new Material(1);
      } else if (x2[0] instanceof SAgent) {
        for (let child of x2[0].children) {
          if (child.id === id2) {
            child.setValue(x2[2]);
            return new Material(1);
          }
        }
        throw new ModelError('Could not find referenced primitive for "SetValue()".', {
          code: 1034
        });
      }
      throw new ModelError('Invalid type for the first argument of "SetValue()".', {
        code: 1035
      });
    });
    defineFunction(
      simulate,
      "FindIndex",
      { object: [simulate.varBank, VectorObject, PrimitiveObject], params: [{ needPopulation: true, name: "[Agent Population]" }, { name: "Index", noVector: true, needNum: true, noUnits: true }] },
      /**
       * @param {[Vector, Material]} x
       *
       * @returns
       */
      (x2) => {
        let population = x2[0];
        for (let item of population.items) {
          if (item.index + 1 === x2[1].value) {
            return item;
          }
        }
        throw new ModelError("Index not found in population.", {
          code: 1036
        });
      }
    );
    defineFunction(
      simulate,
      "FindState",
      { object: [simulate.varBank, VectorObject, PrimitiveObject], params: [{ needPopulation: true, name: "[Agent Population]" }, { needPrimitive: true, name: "[State]" }] },
      /**
       * @param {[Vector, SPrimitive]} x
       *
       * @returns
       */
      (x2) => {
        let population = x2[0];
        if (!(x2[1] instanceof SState || x2[1].dna.primitive instanceof State)) {
          throw new ModelError("FindState() requires a State primitive as its argument.", {
            code: 1037
          });
        }
        let id2 = x2[1].id;
        let res = [];
        for (let i2 = 0; i2 < population.items.length; i2++) {
          if (population.items[i2].stateIDs.has(id2)) {
            res.push(population.items[i2]);
          }
        }
        return new Vector(res, simulate);
      }
    );
    defineFunction(
      simulate,
      "FindNotState",
      { object: [simulate.varBank, VectorObject, PrimitiveObject], params: [{ needPopulation: true, name: "[Agent Population]" }, { needPrimitive: true, name: "[State]" }] },
      /**
       * @param {[Vector, SPrimitive]} x
       *
       * @returns
       */
      (x2) => {
        let population = x2[0];
        if (!(x2[1] instanceof SState || x2[1].dna.primitive instanceof State)) {
          throw new ModelError("FindNotState() requires a State primitive as its argument.", {
            code: 1038
          });
        }
        let id2 = x2[1].id;
        let res = [];
        for (let item of population.items) {
          if (!item.stateIDs.has(id2)) {
            res.push(item);
          }
        }
        return new Vector(res, simulate);
      }
    );
    defineFunction(
      simulate,
      "FindNearby",
      { object: [simulate.varBank, VectorObject, PrimitiveObject], params: [{ needPopulation: true, name: "[Agent Population]" }, { name: "Target", allowOptionalPrimitive: true }, { name: "Distance Limit", needNum: true, noVector: true }] },
      /**
       * @param {[Vector, SPrimitive, Material]} x
       *
       * @returns
       */
      (x2) => {
        let population = x2[0];
        let loc = locationValue(x2[1]);
        let a2;
        try {
          a2 = agent(x2[1], simulate);
        } catch (err) {
        }
        let res = [];
        for (let i2 = 0; i2 < population.length(); i2++) {
          let item = agent(population.items[i2], simulate);
          if (item !== a2) {
            if (lessThanEq(distance2(loc, locationValue(item), simulate), x2[2])) {
              res.push(item);
            }
          }
        }
        return new Vector(res, simulate);
      }
    );
    defineFunction(
      simulate,
      "FindNearest",
      { object: [simulate.varBank, VectorObject, PrimitiveObject], params: [{ needPopulation: true, name: "[Agent Population]" }, { name: "Target", allowOptionalPrimitive: true }, { noUnits: true, noVector: true, needNum: true, defaultVal: 1, name: "Count" }] },
      /**
       * @param {[Vector, SPrimitive, Material]} x
       *
       * @returns
       */
      (x2) => {
        let population = x2[0];
        let count = 1;
        if (x2.length === 3) {
          count = x2[2].value;
          if (count < 1) {
            throw new ModelError("You must select at least one agent in FindNearest().", {
              code: 1039
            });
          }
          if (count !== Math.floor(count)) {
            throw new ModelError("Count must be an integer.", {
              code: 1040
            });
          }
        }
        let loc = locationValue(x2[1]);
        let a2;
        try {
          a2 = agent(x2[1], simulate);
        } catch (err) {
        }
        let res = [];
        for (let item of population.items) {
          item = agent(item, simulate);
          if (item !== a2) {
            res.push({
              distance: distance2(loc, locationValue(item), simulate),
              item
            });
          }
        }
        if (res.length < count) {
          throw new ModelError(`Can't find nearest ${count} agents of a population of size ${res.length}.`, {
            code: 1041
          });
        }
        let minItems = [res[0]];
        for (let i2 = 1; i2 < res.length; i2++) {
          let added = false;
          for (let j = 0; j < minItems.length; j++) {
            if (lessThan(res[i2].distance, minItems[j].distance)) {
              minItems.splice(j, 0, res[i2]);
              added = true;
              break;
            }
          }
          if (!added && minItems.length < count) {
            minItems.push(res[i2]);
          } else if (minItems.length > count) {
            minItems.length = count;
          }
        }
        if (minItems.length === 1) {
          return minItems[0].item;
        } else {
          return new Vector(minItems.map((x3) => x3.item), simulate);
        }
      }
    );
    defineFunction(
      simulate,
      "FindFurthest",
      { object: [simulate.varBank, VectorObject, PrimitiveObject], params: [{ needPopulation: true, name: "[Agent Population]" }, { name: "Target", allowOptionalPrimitive: true }, { noUnits: true, noVector: true, needNum: true, defaultVal: 1, name: "Count" }] },
      /**
       * @param {[Vector, SPrimitive, Material]} x
       * @returns
       */
      (x2) => {
        let population = x2[0];
        let count = 1;
        if (x2.length === 3) {
          count = x2[2].value;
          if (count < 1) {
            throw new ModelError("You must select at least one agent in FindFurthest().", {
              code: 1042
            });
          }
          if (count !== Math.floor(count)) {
            throw new ModelError("Count must be an integer.", {
              code: 1043
            });
          }
        }
        let loc = locationValue(x2[1]);
        let a2;
        try {
          a2 = agent(x2[1], simulate);
        } catch (err) {
        }
        let res = [];
        for (let i2 of population.items) {
          let item = agent(i2, simulate);
          if (item !== a2) {
            res.push({ distance: distance2(loc, locationValue(item), simulate), item });
          }
        }
        if (res.length < count) {
          throw new ModelError(`Can't find furthest ${count} agents of a population of size ${res.length}.`, {
            code: 1044
          });
        }
        let minItems = [res[0]];
        for (let i2 = 1; i2 < res.length; i2++) {
          let added = false;
          for (let j = 0; j < minItems.length; j++) {
            if (greaterThan(res[i2].distance, minItems[j].distance)) {
              minItems.splice(j, 0, res[i2]);
              added = true;
              break;
            }
          }
          if (!added && minItems.length < count) {
            minItems.push(res[i2]);
          } else if (minItems.length > count) {
            minItems.length = count;
          }
        }
        if (minItems.length === 1) {
          return minItems[0].item;
        } else {
          return new Vector(minItems.map((x3) => x3.item), simulate);
        }
      }
    );
    defineFunction(simulate, "Index", { object: [simulate.varBank, AgentObject], params: [{ noVector: true, needAgent: true, name: "[Agent]" }] }, (x2) => {
      return new Material(x2[0].index + 1);
    });
    defineFunction(
      simulate,
      "Connect",
      { object: [simulate.varBank, AgentObject], params: [{ needAgent: true, name: "[Agent 1]" }, { name: "[Agent 2]" }, { name: "Weight", defaultVal: "missing", needNum: true }] },
      /**
       * @param {[SAgent, SAgent, Material|"missing"]} x
       *
       * @returns
       */
      (x2) => {
        let weight = void 0;
        if (x2[2] !== "missing") {
          weight = x2[2];
        }
        if (x2[1] instanceof Vector) {
          x2[1].items.forEach((a2) => {
            x2[0].connect(a2, weight);
          });
        } else {
          x2[0].connect(x2[1], weight);
        }
        return new Material(1);
      }
    );
    defineFunction(
      simulate,
      "Unconnect",
      { object: [simulate.varBank, AgentObject], params: [{ needAgent: true, name: "[Agent 1]" }, { name: "[Agent 2]" }] },
      /**
       * @param {[SAgent, SAgent]} x
       *
       * @returns
       */
      (x2) => {
        if (x2[1] instanceof Vector) {
          x2[1].items.forEach((a2) => {
            x2[0].unconnect(a2);
          });
        } else {
          x2[0].unconnect(x2[1]);
        }
        return new Material(1);
      }
    );
    defineFunction(simulate, "Connected", { object: [simulate.varBank, AgentObject], params: [{ needAgent: true, name: "[Agent]" }] }, (x2) => {
      return new Vector(x2[0].connected.slice(), simulate);
    });
    defineFunction(simulate, "ConnectionWeight", { object: [simulate.varBank, AgentObject], params: [{ needAgent: true, name: "[Agent 1]" }, { name: "[Agent 2]" }] }, (x2) => {
      if (x2[1] instanceof Vector) {
        return new Vector(x2[1].items.map((a2) => {
          return x2[0].connectionWeight(a2);
        }), simulate);
      } else {
        return x2[0].connectionWeight(x2[1]);
      }
    });
    defineFunction(
      simulate,
      "SetConnectionWeight",
      { object: [simulate.varBank, AgentObject], params: [{ needAgent: true, name: "[Agent 1]" }, { name: "[Agent 2]" }, { name: "Weight", needNum: true }] },
      /**
       * @param {[SAgent, SAgent|Vector, Material]} x
       */
      (x2) => {
        if (x2[1] instanceof Vector) {
          x2[1].items.forEach((a2) => {
            x2[0].setConnectionWeight(a2, x2[2]);
          });
        } else {
          x2[0].setConnectionWeight(x2[1], x2[2]);
        }
        return new Material(1);
      }
    );
    simulate.varBank.set("print", function(x2) {
      function makePrimitiveString(x3) {
        if (x3 instanceof String) {
          x3 = "" + x3;
        }
        return x3;
      }
      if (x2.length === 2) {
        console.log(makePrimitiveString(x2[0].value.toString()));
        console.log(makePrimitiveString(x2[1]));
        return x2[1];
      } else {
        console.log(makePrimitiveString(x2[0]));
        return x2[0];
      }
    });
    simulate.coreBank.set("print", simulate.varBank.get("print"));
    defineFunction(simulate, "Width", { params: [{ needAgents: true, name: "[Agent Population]" }] }, (x2) => {
      return x2[0].geoWidth;
    });
    defineFunction(simulate, "Height", { params: [{ needAgents: true, name: "[Agent Population]" }] }, (x2) => {
      return x2[0].geoHeight;
    });
    defineFunction(simulate, "Distance", { object: [simulate.varBank, AgentObject], params: [{ name: "Location 1" }, { name: "Location 2" }] }, (x2) => {
      let loc1 = locationValue(x2[0]);
      let loc2 = locationValue(x2[1]);
      return distance2(loc1, loc2, simulate);
    });
    defineFunction(simulate, "Location", { object: [simulate.varBank, AgentObject], params: [{ needAgent: true, name: "[Agent]" }] }, (x2) => {
      if (!x2[0].location) {
        throw new ModelError("The location is not defined.", {
          code: 1046
        });
      } else {
        return x2[0].location.fullClone();
      }
    });
    function checkLocationVector(x2) {
      if (x2.items.length !== 2 || !(x2.items[0] instanceof Material) || !(x2.items[1] instanceof Material)) {
        throw new ModelError("Location vector does not contain exactly two numbers.", {
          code: 1067
        });
      }
      if (x2.names && (!x2.names.length || x2.names.length !== 2 || x2.namesLC[0] !== "x" || x2.namesLC[1] !== "y")) {
        throw new ModelError("Location vector must have names 'x' and 'y'.", {
          code: 1067
        });
      }
    }
    defineFunction(
      simulate,
      "SetLocation",
      { object: [simulate.varBank, AgentObject], params: [{ needAgent: true, name: "[Agent]" }, { needVector: true, name: "Direction" }] },
      /**
       * @param {[SAgent, Vector<Material>]} x
       * @returns
       */
      (x2) => {
        let v2 = toNum(x2[1]);
        checkLocationVector(v2);
        let agent2 = x2[0];
        agent2.location = v2.fullClone();
        if (!agent2.location.names) {
          agent2.location.names = ["x", "y"];
          agent2.location.namesLC = ["x", "y"];
        }
        return new Material(0);
      }
    );
    defineFunction(
      simulate,
      "Move",
      { object: [simulate.varBank, AgentObject], params: [{ needAgent: true, name: "[Mover]" }, { needVector: true, name: "Direction" }] },
      /**
       * @param {[SAgent, Vector<Material>]} x
       * @returns
       */
      (x2) => {
        let v2 = toNum(x2[1]);
        checkLocationVector(v2);
        shiftLocation(x2[0], plus(x2[0].location, v2));
        return new Material(0);
      }
    );
    function locationValue(x2) {
      const NOT_INIT = "Location not initialized yet for agents. Location initialization happens after agent primitive value initialization.";
      if (x2 instanceof Vector) {
        if (x2.items.length !== 2 || !(x2.items[0] instanceof Material) || !(x2.items[1] instanceof Material)) {
          throw new ModelError("Location vector does not contain exactly two numbers.", {
            code: 1047
          });
        } else {
          return {
            location: x2,
            agent: null
          };
        }
      } else {
        try {
          let a2 = agent(x2, simulate);
          let loc = a2.location;
          if (loc === null) {
            throw new ModelError(NOT_INIT, {
              code: 1048
            });
          }
          return {
            location: loc,
            agent: a2
          };
        } catch (err) {
          if (err.message === NOT_INIT) {
            throw err;
          }
          throw new ModelError("Location must be a vector or an agent.", {
            code: 1049
          });
        }
      }
    }
    defineFunction(
      simulate,
      "MoveTowards",
      { object: [simulate.varBank, AgentObject], params: [{ needAgent: true, name: "[Mover]" }, { name: "[Target]" }, { name: "Distance", noVector: true, needNum: true }] },
      /**
       * @param {[SAgent, Vector<Material>, Material]} x
       * @returns
       */
      (x2) => {
        let loc1 = locationValue(x2[0]);
        let loc2 = locationValue(x2[1]);
        let l1 = loc1.location;
        let l2 = loc2.location;
        let distX = minus(l2.items[0], l1.items[0]);
        let distY = minus(l2.items[1], l1.items[1]);
        if (distX.value === 0 && distY.value === 0) {
          return new Material(1);
        }
        let a2 = loc1.agent;
        if (a2.container.geoWrap) {
          if (greaterThan(distX, a2.container.halfWidth)) {
            distX = minus(distX, a2.container.geoWidth);
          } else if (lessThan(distX, negate(a2.container.halfWidth))) {
            distX = plus(distX, a2.container.geoWidth);
          }
          if (greaterThan(distY, a2.container.halfHeight)) {
            distY = minus(distY, a2.container.geoHeight);
          } else if (lessThan(distY, negate(a2.container.halfHeight))) {
            distY = plus(distY, a2.container.geoHeight);
          }
        }
        let dir = new Vector([distX, distY], simulate, ["x", "y"]);
        shiftLocation(a2, plus(a2.location, mult(dir, div(x2[2], distance2(loc1, loc2, simulate)))));
        return new Material(1);
      }
    );
    simulate.coreBank.set("primitivebase", makeObjectBase(PrimitiveObject, simulate));
    simulate.coreBank.set("agentbase", makeObjectBase(AgentObject, simulate));
    simulate.varBank.set("agentbase", simulate.coreBank.get("agentbase"));
    simulate.coreBank.get("primitivebase").parent = simulate.coreBank.get("agentbase");
    simulate.coreBank.set("vectorbase", makeObjectBase(VectorObject, simulate));
    simulate.varBank.set("vectorbase", simulate.coreBank.get("vectorbase"));
  }
  var MAX_DISTANCE_CACHES = 1e6;
  function distance2(a2, b2, simulate) {
    let l1 = a2.location;
    let l2 = b2.location;
    simulate.distanceCacheCount++;
    let agents2 = a2.agent ? a2.agent.container : b2.agent ? b2.agent.container : null;
    let cacheKey;
    if (simulate.distanceCacheCount < MAX_DISTANCE_CACHES) {
      let s1 = l1.items[0].toString() + "," + l1.items[1].toString();
      let s2 = l2.items[0].toString() + "," + l2.items[1].toString();
      if (s2 < s1) {
        [s1, s2] = [s2, s1];
      }
      cacheKey = s1 + ":" + s2;
      if (agents2) {
        cacheKey += "/" + agents2.id;
      }
      if (cacheKey in simulate.distanceCache) {
        return simulate.distanceCache[cacheKey];
      }
    }
    let distx = (
      /** @type {Material} */
      minus(l1.items[0], l2.items[0])
    );
    let disty = (
      /** @type {Material} */
      minus(l1.items[1], l2.items[1])
    );
    if (agents2 && agents2.geoWrap) {
      if (greaterThan(distx, agents2.halfWidth)) {
        distx = minus(agents2.geoWidth, distx);
      } else if (lessThan(distx, negate(agents2.halfWidth))) {
        distx = minus(distx, negate(agents2.geoWidth));
      }
      if (greaterThan(disty, agents2.halfHeight)) {
        disty = minus(agents2.geoHeight, disty);
      } else if (lessThan(disty, negate(agents2.halfHeight))) {
        disty = minus(disty, negate(agents2.geoHeight));
      }
    }
    let v1 = distx.value;
    let v2 = disty.value;
    if (distx.units !== disty.units) {
      v2 = fn["*"](v2, convertUnits(disty.units, distx.units));
    }
    let distN = fn["sqrt"](fn["+"](fn["*"](v1, v1), fn["*"](v2, v2)));
    let dist = new Material(distN, distx.units);
    if (simulate.distanceCacheCount < MAX_DISTANCE_CACHES) {
      simulate.distanceCache[cacheKey] = dist;
    }
    return dist;
  }
  function agent(obj, simulate) {
    if (obj instanceof SVariable || obj instanceof SStock) {
      obj = toNum(obj);
    }
    if (obj instanceof SAgent) {
      return obj;
    } else if (obj instanceof SPrimitive) {
      return agent(obj.container, simulate);
    } else {
      throw new ModelError("An agent is required here.", {
        code: 1050
      });
    }
  }
  function agents(obj) {
    if (obj instanceof SPopulation) {
      return obj;
    } else if (obj instanceof SPrimitive || obj instanceof SAgent) {
      return agents(obj.container);
    } else {
      throw new ModelError("An agent population is required here.", {
        code: 1051
      });
    }
  }
  function getPopulation(item, simulate) {
    if (item.items) {
      return item;
    }
    if (item instanceof SPopulation) {
      return new Vector(item.agents.slice(), simulate);
    } else if (toNum(item) instanceof Vector) {
      return toNum(item);
    } else {
      return new Vector([agent(item, simulate)], simulate);
    }
  }
  function shiftLocation(agent2, newLocation) {
    if (agent2.container.geoWrap) {
      while (lessThan(newLocation.items[0], new Material(0))) {
        newLocation.items[0] = plus(newLocation.items[0], agent2.container.geoWidth);
      }
      while (greaterThan(newLocation.items[0], agent2.container.geoWidth)) {
        newLocation.items[0] = minus(newLocation.items[0], agent2.container.geoWidth);
      }
      while (lessThan(newLocation.items[1], new Material(0))) {
        newLocation.items[1] = plus(newLocation.items[1], agent2.container.geoHeight);
      }
      while (greaterThan(newLocation.items[1], agent2.container.geoHeight)) {
        newLocation.items[1] = minus(newLocation.items[1], agent2.container.geoHeight);
      }
    }
    agent2.location = newLocation;
    if (!agent2.location.names) {
      agent2.location.names = ["x", "y"];
      agent2.location.namesLC = ["x", "y"];
    }
  }

  // ../insight-maker-simulation/vendor/random.js
  var SeedRandom = {};
  (function(global, pool, math) {
    var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
    function seedrandom(seed, options, callback) {
      var key = [];
      options = options == true ? { entropy: true } : options || {};
      var shortseed = mixkey(flatten(
        options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
        3
      ), key);
      var arc4 = new ARC4(key);
      var prng = function() {
        var n2 = arc4.g(chunks), d2 = startdenom, x2 = 0;
        while (n2 < significance) {
          n2 = (n2 + x2) * width;
          d2 *= width;
          x2 = arc4.g(1);
        }
        while (n2 >= overflow) {
          n2 /= 2;
          d2 /= 2;
          x2 >>>= 1;
        }
        return (n2 + x2) / d2;
      };
      prng.int32 = function() {
        return arc4.g(4) | 0;
      };
      prng.quick = function() {
        return arc4.g(4) / 4294967296;
      };
      prng.double = prng;
      mixkey(tostring(arc4.S), pool);
      return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
        if (state) {
          if (state.S) {
            copy2(state, arc4);
          }
          prng2.state = function() {
            return copy2(arc4, {});
          };
        }
        if (is_math_call) {
          math[rngname] = prng2;
          return seed2;
        } else return prng2;
      })(
        prng,
        shortseed,
        "global" in options ? options.global : this == math,
        options.state
      );
    }
    function ARC4(key) {
      var t2, keylen = key.length, me = this, i2 = 0, j = me.i = me.j = 0, s2 = me.S = [];
      if (!keylen) {
        key = [keylen++];
      }
      while (i2 < width) {
        s2[i2] = i2++;
      }
      for (i2 = 0; i2 < width; i2++) {
        s2[i2] = s2[j = mask & j + key[i2 % keylen] + (t2 = s2[i2])];
        s2[j] = t2;
      }
      (me.g = function(count) {
        var t3, r2 = 0, i3 = me.i, j2 = me.j, s3 = me.S;
        while (count--) {
          t3 = s3[i3 = mask & i3 + 1];
          r2 = r2 * width + s3[mask & (s3[i3] = s3[j2 = mask & j2 + t3]) + (s3[j2] = t3)];
        }
        me.i = i3;
        me.j = j2;
        return r2;
      })(width);
    }
    function copy2(f2, t2) {
      t2.i = f2.i;
      t2.j = f2.j;
      t2.S = f2.S.slice();
      return t2;
    }
    ;
    function flatten(obj, depth) {
      var result = [], typ = typeof obj, prop;
      if (depth && typ == "object") {
        for (prop in obj) {
          try {
            result.push(flatten(obj[prop], depth - 1));
          } catch (e2) {
          }
        }
      }
      return result.length ? result : typ == "string" ? obj : obj + "\0";
    }
    function mixkey(seed, key) {
      var stringseed = seed + "", smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
      }
      return tostring(key);
    }
    function autoseed() {
      try {
        var out;
        if (nodecrypto && (out = nodecrypto.randomBytes)) {
          out = out(width);
        } else {
          out = new Uint8Array(width);
          (global.crypto || global.msCrypto).getRandomValues(out);
        }
        return tostring(out);
      } catch (e2) {
        var browser = global.navigator, plugins = browser && browser.plugins;
        return [+/* @__PURE__ */ new Date(), global, plugins, global.screen, tostring(pool)];
      }
    }
    function tostring(a2) {
      return String.fromCharCode.apply(0, a2);
    }
    mixkey(math.random(), pool);
    SeedRandom.seedrandom = seedrandom;
  })(
    // global: `self` in browsers (including strict mode and web workers),
    // otherwise `this` in Node and other environments
    typeof self !== "undefined" ? self : void 0,
    [],
    // pool: entropy pool starts empty
    Math
    // math: package containing random, pow, and seedrandom
  );

  // ../insight-maker-simulation/src/formula/CalcFunctions.js
  function createFunctions2(simulate) {
    defineFunction(simulate, "RandBeta", { params: [{ name: "Alpha", noUnits: true, noVector: true }, { name: "Beta", noUnits: true, noVector: true }] }, (x2) => {
      return new Material(RandBeta(simulate, x2[0].value, x2[1].value));
    });
    defineFunction(simulate, "RandDist", { params: [{ name: "Distribution", noUnits: true, needVector: true }, { name: "Y (in which case Distribution is X)", noUnits: true, needVector: true, defaultVal: false }] }, (x2) => {
      let xVals, yVals;
      if (x2.length === 1 || x2[1] === false) {
        let vec = x2[0];
        xVals = [];
        yVals = [];
        for (let i2 = 0; i2 < vec.items.length; i2++) {
          if (!(vec.items[i2] instanceof Vector) || vec.items[i2].items.length !== 2) {
            throw new ModelError("Invalid vector provided to RandDist.", {
              code: 6e3
            });
          }
          xVals.push(toNum(vec.items[i2].items[0]).value);
          yVals.push(toNum(vec.items[i2].items[1]).value);
        }
      } else {
        xVals = toNum(x2[0]).items.map((x3) => x3.value);
        yVals = toNum(x2[1]).items.map((x3) => x3.value);
      }
      return new Material(RandDist(simulate, xVals, yVals));
    });
    defineFunction(simulate, "RandBoolean", { params: [{ name: "Probability", defaultVal: 0.5, noUnits: true, vectorize: true }] }, (x2) => {
      let p2;
      if (x2.length !== 0) {
        p2 = toNum(x2[0]).value;
      } else {
        p2 = 0.5;
      }
      if (Rand(simulate) < p2) {
        return true;
      } else {
        return false;
      }
    });
    defineFunction(simulate, "Rand", { params: [{ name: "Lower Bound", defaultVal: 0, noUnits: true, vectorize: true }, { name: "Upper Bound", defaultVal: 1, noUnits: true, vectorize: true }] }, (x2) => {
      if (x2.length === 0) {
        return new Material(Rand(simulate));
      } else if (x2.length === 2) {
        return new Material(Rand(simulate, toNum(x2[0]).value, toNum(x2[1]).value));
      } else {
        throw new ModelError("Rand() must either have no parameters or two: Min and Max bounds.", {
          code: 6001
        });
      }
    });
    defineFunction(simulate, "RandNormal", { params: [{ name: "Mean", defaultVal: 0, noUnits: true, vectorize: true }, { name: "Standard Deviation", defaultVal: 1, noUnits: true, vectorize: true }] }, (x2) => {
      if (x2.length === 0) {
        return new Material(RandNormal(simulate));
      } else if (x2.length === 2) {
        return new Material(RandNormal(simulate, toNum(x2[0]).value, toNum(x2[1]).value));
      } else {
        throw new ModelError("RandNormal() must either have no parameters or two: Mean and Standard Deviation.", {
          code: 6002
        });
      }
    });
    defineFunction(simulate, "RandExp", { params: [{ name: "Rate", defaultVal: 1, noUnits: true, vectorize: true }] }, (x2) => {
      if (x2.length !== 0) {
        return new Material(RandExp(simulate, toNum(x2[0]).value));
      } else {
        return new Material(RandExp(simulate));
      }
    });
    defineFunction(simulate, "RandLognormal", { params: [{ name: "Mean", noUnits: true, vectorize: true }, { name: "Standard Deviation", noUnits: true, vectorize: true }] }, (x2) => {
      return new Material(RandLognormal(simulate, toNum(x2[0]).value, toNum(x2[1]).value));
    });
    defineFunction(simulate, "RandBinomial", { params: [{ name: "Count", noUnits: true, vectorize: true }, { name: "Probability", noUnits: true, vectorize: true }] }, (x2) => {
      return new Material(RandBinomial(simulate, toNum(x2[0]).value, toNum(x2[1]).value));
    });
    defineFunction(simulate, "RandNegativeBinomial", { params: [{ name: "Successes", noUnits: true, vectorize: true }, { name: "Probability", noUnits: true, vectorize: true }] }, (x2) => {
      return new Material(RandNegativeBinomial(simulate, toNum(x2[0]).value, toNum(x2[1]).value));
    });
    defineFunction(simulate, "RandGamma", { params: [{ name: "Alpha", noUnits: true, vectorize: true }, { name: "Beta", noUnits: true, vectorize: true }] }, (x2) => {
      return new Material(RandGamma(simulate, toNum(x2[0]).value, toNum(x2[1]).value));
    });
    defineFunction(simulate, "RandPoisson", { params: [{ name: "Rate", noUnits: true, vectorize: true }] }, (x2) => {
      return new Material(RandPoisson(simulate, toNum(x2[0]).value));
    });
    defineFunction(simulate, "RandTriangular", { params: [{ name: "Minimum", noUnits: true, vectorize: true }, { name: "Maximum", noUnits: true, vectorize: true }, { name: "Peak", noUnits: true, vectorize: true }] }, (x2) => {
      return new Material(RandTriangular(simulate, toNum(x2[0]).value, toNum(x2[1]).value, toNum(x2[2]).value));
    });
    defineFunction(simulate, "Magnitude", { params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return simulate.coreBank.get("sqrt")([simulate.coreBank.get("sum")([mult(x2[0], x2[0])])]);
    });
    defineFunction(simulate, "Abs", { params: [{ name: "Number", leafNeedNum: true }], recurse: true }, (x2) => {
      let r2 = toNum(x2[0]);
      r2.value = fn.abs(r2.value);
      return r2;
    });
    defineFunction(simulate, "sin", { params: [{ name: "Number", leafNeedNum: true }], recurse: true }, (x2) => {
      let z = toNum(x2[0]);
      if (z.units && !z.units.isUnitless()) {
        z = mult(z, new Material(1, simulate.unitManager.getUnitStore(["radians"], [-1])));
      }
      if (!z.units) {
        return new Material(fn.sin(z.value));
      } else {
        throw new ModelError("Non-angular units cannot be used in Sin().", {
          code: 6003
        });
      }
    });
    defineFunction(simulate, "cos", { params: [{ name: "Number", leafNeedNum: true }], recurse: true }, (x2) => {
      let z = toNum(x2[0]);
      if (z.units && !z.units.isUnitless()) {
        z = mult(z, new Material(1, simulate.unitManager.getUnitStore(["radians"], [-1])));
      }
      if (!z.units) {
        return new Material(fn.cos(z.value));
      } else {
        throw new ModelError("Non-angular units cannot be used in Cos().", {
          code: 6004
        });
      }
    });
    defineFunction(simulate, "tan", { params: [{ name: "Number", leafNeedNum: true }], recurse: true }, (x2) => {
      let z = toNum(x2[0]);
      if (z.units && !z.units.isUnitless()) {
        z = mult(z, new Material(1, simulate.unitManager.getUnitStore(["radians"], [-1])));
      }
      if (!z.units) {
        return new Material(fn.tan(z.value));
      } else {
        throw new ModelError("Non-angular units cannot be used in Tan().", {
          code: 6005
        });
      }
    });
    defineFunction(simulate, "asin", { params: [{ name: "Number", noUnits: true, leafNeedNum: true }], recurse: true }, (x2) => {
      let val = toNum(x2[0]).value;
      if (val < -1 || val > 1) {
        throw new ModelError("asin() input must be between -1 and 1.", {
          code: 6077
        });
      }
      return new Material(fn.asin(val));
    });
    defineFunction(simulate, "acos", { params: [{ name: "Number", noUnits: true, leafNeedNum: true }], recurse: true }, (x2) => {
      let val = toNum(x2[0]).value;
      if (val < -1 || val > 1) {
        throw new ModelError("acos() input must be between -1 and 1.", {
          code: 6078
        });
      }
      return new Material(fn.acos(val));
    });
    defineFunction(simulate, "atan", { params: [{ name: "Number", noUnits: true, leafNeedNum: true }], recurse: true }, (x2) => {
      return new Material(fn.atan(toNum(x2[0]).value));
    });
    defineFunction(simulate, "arcsin", { params: [{ name: "Number", noUnits: true, leafNeedNum: true }], recurse: true }, (x2) => {
      let val = toNum(x2[0]).value;
      if (val < -1 || val > 1) {
        throw new ModelError("arcsin() input must be between -1 and 1.", {
          code: 6077
        });
      }
      return new Material(fn.asin(val), simulate.unitManager.getUnitStore(["radians"], [1]), false);
    });
    defineFunction(simulate, "arccos", { params: [{ name: "Number", noUnits: true, leafNeedNum: true }], recurse: true }, (x2) => {
      let val = toNum(x2[0]).value;
      if (val < -1 || val > 1) {
        throw new ModelError("arccos() input must be between -1 and 1.", {
          code: 6078
        });
      }
      return new Material(fn.acos(val), simulate.unitManager.getUnitStore(["radians"], [1]), false);
    });
    defineFunction(simulate, "arctan", { params: [{ name: "Number", noUnits: true, leafNeedNum: true }], recurse: true }, (x2) => {
      return new Material(fn.atan(toNum(x2[0]).value), simulate.unitManager.getUnitStore(["radians"], [1]), false);
    });
    defineFunction(simulate, "Sign", { params: [{ name: "Number", leafNeedNum: true }], recurse: true }, (x2) => {
      let r2 = toNum(x2[0]);
      if (r2.value < 0) {
        return new Material(-1);
      } else if (r2.value > 0) {
        return new Material(1);
      } else if (r2.value === 0) {
        return new Material(0);
      }
      throw new ModelError("Invalid value for <i>Sign</i>.", {
        code: 6006
      });
    });
    defineFunction(simulate, "Sqrt", { params: [{ name: "Number", leafNeedNum: true }], recurse: true }, (x2) => {
      let r2 = toNum(x2[0]).fullClone();
      if (r2.value < 0) {
        throw new ModelError("Sqrt() requires a number greater than or equal to 0.", {
          code: 6007
        });
      }
      r2.value = fn.sqrt(r2.value);
      if (r2.units && !r2.units.isUnitless()) {
        r2.units = r2.units.power(0.5);
      }
      return r2;
    });
    defineFunction(simulate, "Ln", { params: [{ name: "Number", noUnits: true, leafNeedNum: true }], recurse: true }, (x2) => {
      let val = toNum(x2[0]).value;
      if (val < 0) {
        throw new ModelError("Ln() requires a number greater than or equal to 0. Got, <i>" + val + "</i>.", {
          code: 6008
        });
      }
      return new Material(fn.log(val));
    });
    defineFunction(simulate, "Log", { params: [{ name: "Number", noUnits: true, leafNeedNum: true }], recurse: true }, (x2) => {
      let val = toNum(x2[0]).value;
      if (val < 0) {
        throw new ModelError("Log() requires a number greater than or equal to 0. Got, <i>" + val + "</i>.", {
          code: 6009
        });
      }
      return new Material(fn.log(val, 10));
    });
    defineFunction(simulate, "Logit", { params: [{ name: "Number", noUnits: true, leafNeedNum: true }], recurse: true }, (x2) => {
      let r2 = toNum(x2[0]);
      if (r2.value < 0 || r2.value > 1) {
        throw new ModelError("Logit() requires an input between 0 and 1 (inclusive).", {
          code: 6079
        });
      }
      r2.value = fn["-"](fn.log(r2.value), fn.log(fn["-"](1, r2.value)));
      return r2;
    });
    defineFunction(simulate, "Expit", { params: [{ name: "Number", noUnits: true, leafNeedNum: true }], recurse: true }, (x2) => {
      let r2 = toNum(x2[0]);
      r2.value = fn["/"](1, fn["+"](1, fn.exp(fn["-"](r2.value))));
      return r2;
    });
    defineFunction(simulate, "Round", { params: [
      { name: "Number", noUnits: false, leafNeedNum: true },
      { name: "Units", needString: true, defaultVal: "<DETECTED>" }
    ], recurse: true }, (x2) => {
      let r2 = toNum(x2[0]);
      if (!x2[1]) {
        if (r2.units && !r2.explicitUnits && !r2.units.isDeepUnitless()) {
          throw new ModelError("Round() requires either no units or units that have been explicitly set. Got: " + r2.units.toString() + '. If those units are correct, try <b>round(number, "' + r2.units.toStringShort() + '")', {
            code: 6463
          });
        }
      } else {
        r2 = r2.forceUnits(createUnitStore(x2[1], simulate));
      }
      r2.value = fn.round(r2.value);
      return r2;
    });
    defineFunction(simulate, "Ceiling", { params: [
      { name: "Number", noUnits: false, leafNeedNum: true },
      { name: "Units", needString: true, defaultVal: "<DETECTED>" }
    ], recurse: true }, (x2) => {
      let r2 = toNum(x2[0]);
      if (!x2[1]) {
        if (r2.units && !r2.explicitUnits && !r2.units.isDeepUnitless()) {
          throw new ModelError("Ceiling() requires either no units or units that have been explicitly set. Current units are " + r2.units.toString() + '. If those units are correct, try <b>ceiling(number, "' + r2.units.toStringShort() + '")', {
            code: 6464
          });
        }
      } else {
        r2 = r2.forceUnits(createUnitStore(x2[1], simulate));
      }
      r2.value = fn.ceiling(r2.value);
      return r2;
    });
    defineFunction(simulate, "Floor", { params: [
      { name: "Number", noUnits: false, leafNeedNum: true },
      { name: "Units", needString: true, defaultVal: "<DETECTED>" }
    ], recurse: true }, (x2) => {
      let r2 = toNum(x2[0]);
      if (!x2[1]) {
        if (r2.units && !r2.explicitUnits && !r2.units.isDeepUnitless()) {
          throw new ModelError("Floor() requires either no units or units that have been explicitly set. Got: " + r2.units.toString() + '. If those units are correct, try <b>floor(number, "' + r2.units.toStringShort() + '")', {
            code: 6462
          });
        }
      } else {
        r2 = r2.forceUnits(createUnitStore(x2[1], simulate));
      }
      r2.value = fn.floor(r2.value);
      return r2;
    });
    defineFunction(simulate, "Exp", { params: [{ name: "Number", noUnits: true, leafNeedNum: true }], recurse: true }, (x2) => {
      return new Material(fn.exp(toNum(x2[0]).value));
    });
    simulate.varBank.set("ifthenelse", function(x2) {
      testArgumentsSize(x2, "IfThenElse", 3, 3);
      let v2 = toNum(evaluateNode(x2[0].node, x2[0].scope, simulate));
      if (v2 instanceof Vector) {
        return vecIfThenElse(v2, evaluateNode(x2[1].node, x2[1].scope, simulate), evaluateNode(x2[2].node, x2[2].scope, simulate));
      }
      if (trueValue(v2)) {
        return evaluateNode(x2[1].node, x2[1].scope, simulate);
      } else {
        return evaluateNode(x2[2].node, x2[2].scope, simulate);
      }
    });
    simulate.varBank.get("ifthenelse").delayEvalParams = true;
    simulate.coreBank.set("ifthenelse", simulate.varBank.get("ifthenelse"));
    simulate.varBank.set("assert", function(x2) {
      testArgumentsSize(x2, "Assert", 1, 2);
      let v2 = evaluateNode(x2[0].node, x2[0].scope, simulate);
      if (!trueValue(v2)) {
        throw new ModelError(x2[1] ? evaluateNode(x2[1].node, x2[1].scope, simulate) : "Assert() failed", {
          code: 2e4
        });
      } else {
        return new Material(1);
      }
    });
    simulate.varBank.get("assert").delayEvalParams = true;
    simulate.coreBank.set("assert", simulate.varBank.get("assert"));
    function vecIfThenElse(test, tVal, fVal) {
      let choiceFn = function(t2, f2) {
        if (t2 instanceof Vector) {
          return t2.combine(f2, choiceFn);
        } else {
          return [t2, f2];
        }
      };
      tVal = toNum(tVal);
      fVal = toNum(fVal);
      let choices;
      if (tVal instanceof Vector) {
        choices = tVal.cloneCombine(fVal, choiceFn);
      } else if (fVal instanceof Vector) {
        choices = fVal.cloneCombine(tVal, (a2, b2) => {
          return choiceFn(b2, a2);
        });
      } else {
        choices = choiceFn(tVal, fVal);
      }
      let testFn = function(test2, val) {
        if (test2 instanceof Vector) {
          return test2.combine(val, testFn);
        }
        if (!Array.isArray(val)) {
          throw new ModelError("Keys do not match for vectorized IfThenElse().", {
            code: 6093
          });
        }
        if (trueValue(test2)) {
          return val[0];
        } else {
          return val[1];
        }
      };
      return test.cloneCombine(choices, testFn);
    }
    simulate.varBank.set("map", function(x2) {
      testArgumentsSize(x2, "Map", 2, 2);
      let v2;
      if (x2[0].node instanceof Vector) {
        v2 = x2[0].node;
      } else if (x2[0] instanceof Vector) {
        v2 = x2[0];
      } else {
        v2 = evaluateNode(x2[0].node, x2[1].scope, simulate);
      }
      if (v2 instanceof SPrimitive) {
        v2 = toNum(v2);
      }
      if (!(v2 instanceof Vector)) {
        throw new ModelError("Map() requires a vector as its first argument.", {
          code: 6010
        });
      }
      v2 = v2.fullClone();
      let fn2;
      let items = [
        [PARENT_SYMBOL, x2[1].scope],
        ["x", null]
      ];
      let scope = new Map(items);
      let node = x2[1].node;
      try {
        fn2 = evaluateNode(node, scope, simulate);
      } catch (err) {
      }
      let f2;
      if (fn2 instanceof Function || fn2 instanceof UserFunction) {
        if (fn2.fn) {
          fn2 = fn2.fn;
        }
        f2 = function(x3) {
          return fn2([x3]);
        };
      } else {
        f2 = function(input, key) {
          scope.set("x", input);
          scope.set("key", key || "");
          return evaluateNode(node, scope, simulate);
        };
      }
      return v2.apply(f2);
    });
    simulate.varBank.get("map").delayEvalParams = true;
    VectorObject["map"] = simulate.varBank.get("map");
    simulate.coreBank.set("map", simulate.varBank.get("map"));
    defineFunction(simulate, "Sample", { object: [simulate.varBank, VectorObject], params: [{ name: "Vector", needVector: true }, { name: "Sample Size" }, { name: "Repeat", noVector: true, allowBoolean: true, defaultVal: false }] }, (x2) => {
      let v2 = toNum(x2[0]);
      let count = toNum(x2[1]).value;
      if (count === 0) {
        return new Vector([], simulate);
      }
      let length = v2.length();
      let repeat = x2[2] && trueValue(toNum(x2[2]));
      if (length === 0) {
        throw new ModelError("Sample() requires a non-empty vector.", {
          code: 6011
        });
      }
      let res = [];
      if (repeat) {
        for (let i2 = 0; i2 < count; i2++) {
          res.push(v2.items[Math.floor(Rand(simulate) * length)]);
        }
      } else {
        if (length < count) {
          throw new ModelError("Vector for Sample() is too small for the given sample size.", {
            code: 6012
          });
        }
        let shuffled = v2.items.slice();
        for (let i2 = 0; i2 < count; i2++) {
          res.push(shuffled.splice(Math.floor(Rand(simulate) * shuffled.length), 1)[0]);
        }
      }
      return new Vector(res, simulate);
    });
    defineFunction(simulate, "IndexOf", { object: [simulate.varBank, VectorObject], params: [{ name: "Haystack", needVector: true, noUnits: true }, { name: "Needle", allowBoolean: true, allowString: true }] }, (x2) => {
      let v2 = x2[1];
      if (v2 instanceof Vector) {
        let res = [];
        for (let i2 = 0; i2 < v2.items.length; i2++) {
          res.push(findElement(v2.items[i2], x2[0]));
        }
        return new Vector(res, simulate);
      } else {
        return findElement(v2, x2[0]);
      }
    });
    defineFunction(simulate, "Contains", { object: [simulate.varBank, VectorObject], params: [
      { name: "Haystack", needVector: true, noUnits: true },
      { name: "Needle", allowBoolean: true, noVector: true, allowString: true }
    ] }, (x2) => {
      if (eq(
        new Material(0),
        simulate.coreBank.get("indexof")([new Vector(flatten(x2[0]).items, simulate), x2[1]])
      )) {
        return false;
      } else {
        return true;
      }
    });
    defineFunction(simulate, "Collapse", { params: [{ name: "Source", needVector: true, noUnits: false }, { name: "Target", noVector: false }] }, (x2) => {
      return toNum(x2[0]).collapseDimensions(toNum(x2[1]));
    });
    function findElement(needle, haystack) {
      for (let i2 = 0; i2 < haystack.length(); i2++) {
        if (eq(needle, haystack.items[i2])) {
          return new Material(i2 + 1);
        }
      }
      return new Material(0);
    }
    simulate.varBank.set("filter", function(x2) {
      testArgumentsSize(x2, "Filter", 2, 2);
      let v2;
      if (x2[0].node instanceof Vector) {
        v2 = x2[0].node;
      } else if (x2[0] instanceof Vector) {
        v2 = x2[0];
      } else {
        v2 = evaluateNode(x2[0].node, x2[0].scope, simulate);
      }
      if (v2 instanceof SPrimitive) {
        v2 = toNum(v2);
      }
      if (!(v2 instanceof Vector)) {
        throw new ModelError("Filter() requires a vector as its first argument.", {
          code: 6013
        });
      }
      v2 = v2.fullClone();
      let t2 = simulate.coreBank.get("map")(x2);
      return simulate.coreBank.get("select")([v2, t2]);
    });
    simulate.varBank.get("filter").delayEvalParams = true;
    VectorObject["filter"] = simulate.varBank.get("filter");
    simulate.coreBank.set("filter", simulate.varBank.get("filter"));
    simulate.varBank.set("join", function(x2) {
      let res = [];
      let names = [];
      let hasNames = false;
      for (let i2 = 0; i2 < x2.length; i2++) {
        let y2 = x2[i2];
        if (y2 instanceof SPrimitive) {
          y2 = toNum(y2);
        }
        if (y2 instanceof Vector) {
          res = res.concat(y2.items);
          if (y2.names) {
            names = names.concat(y2.names);
            hasNames = true;
          } else {
            for (let j = 0; j < y2.items.length; j++) {
              names.push(void 0);
            }
          }
        } else {
          res.push(y2);
          names.push(void 0);
        }
      }
      return new Vector(res, simulate, hasNames ? names : void 0);
    });
    simulate.coreBank.set("join", simulate.varBank.get("join"));
    simulate.varBank.set("repeat", function(x2) {
      testArgumentsSize(x2, "Repeat", 2, 2);
      let items = toNum(evaluateNode(x2[1].node, x2[1].scope, simulate));
      let count = items;
      if (items instanceof Vector) {
        if (items.names && items.names.length) {
          throw new ModelError(`If a repeat count is a vector, it can't have names. Got, <i>${items}</i>.`, {
            code: 6070
          });
        }
        let innerItems = items.items;
        if (innerItems.find((x3) => !(typeof x3 === "string" || x3 instanceof String))) {
          throw new ModelError(`If a repeat count is a vector, it must consist of all strings. Got, <i>${items}</i>.`, {
            code: 6071
          });
        }
        if (new Set(innerItems).size !== innerItems.length) {
          throw new ModelError(`If a repeat count is a vector, it must contain unique strings. Got, <i>${items}</i>.`, {
            code: 6072
          });
        }
        count = items.items.length;
      } else if (items instanceof Material) {
        if (items.units && !items.units.isUnitless()) {
          throw new ModelError(`Repeat count must be unitless. Got, <i>${items}</i>.`, {
            code: 6073
          });
        }
        if (items.value < 0) {
          throw new ModelError(`Repeat count must be a non-negative. Got, <i>${items.value}</i>.`, {
            code: 6075
          });
        }
      } else {
        throw new ModelError(`Repeat count must be a Number or Vector. Got, <i>${items}</i>.`, {
          code: 6074
        });
      }
      let res = [];
      let scopeItems = [
        ["x", null],
        [PARENT_SYMBOL, x2[1].scope],
        ["key", null]
      ];
      let scope = new Map(scopeItems);
      for (let i2 = 0; i2 < count; i2++) {
        if (items instanceof Vector) {
          scope.set("key", items.items[i2]);
        }
        scope.set("x", new Material(i2 + 1));
        res.push(evaluateNode(x2[0].node, scope, simulate));
      }
      return new Vector(res, simulate, items instanceof Vector ? items.items.slice() : void 0);
    });
    simulate.varBank.get("repeat").delayEvalParams = true;
    simulate.coreBank.set("repeat", simulate.varBank.get("repeat"));
    defineFunction(simulate, "Select", { params: [{ name: "Haystack", needVector: true, noUnits: true }, { name: "Indexes", noUnits: true }] }, (x2) => {
      if (x2[1] instanceof Vector) {
        let v2 = toNum(x2[1]);
        let isBoolean = true;
        for (let i2 = 0; i2 < v2.length(); i2++) {
          if (v2.items[i2] instanceof Material) {
            isBoolean = false;
            break;
          }
        }
        if (isBoolean === true) {
          let res = [];
          let names = x2[0].names ? (
            /** @type {string[]} */
            []
          ) : void 0;
          if (v2.length() !== x2[0].length()) {
            throw new ModelError("Length of vector must be equal for boolean selection.", {
              code: 6014
            });
          }
          for (let i2 = 0; i2 < v2.length(); i2++) {
            if (trueValue(v2.items[i2])) {
              res.push(x2[0].items[i2]);
              if (names) {
                names.push(x2[0].names[i2]);
              }
            }
          }
          return new Vector(res, simulate, names);
        } else {
          let res = [];
          let names = x2[0].names ? (
            /** @type {string[]} */
            []
          ) : void 0;
          for (let i2 = 0; i2 < v2.length(); i2++) {
            let q = v2.items[i2].value;
            if (q <= 0 || q > x2[0].length()) {
              throw new ModelError("Selected element out of range.", {
                code: 6015
              });
            }
            res.push(x2[0].items[q - 1]);
            if (names) {
              names.push(x2[0].names[q - 1]);
            }
          }
          return new Vector(res, simulate, names);
        }
      } else {
        if (x2[1].value > 0 && x2[1].value <= x2[0].length()) {
          return x2[0].items[x2[1].value - 1];
        } else {
          throw new ModelError("Selected element out of range.", {
            code: 6016
          });
        }
      }
    });
    defineFunction(simulate, "Reverse", {
      allowEmpty: true,
      param: { name: "Items..." },
      prep: function(x2) {
        return simulate.coreBank.get("join")(x2);
      }
    }, (x2) => {
      return new Vector(x2.items.slice().reverse(), simulate, x2.names ? x2.names.slice().reverse() : void 0);
    });
    defineFunction(simulate, "Reverse", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return simulate.coreBank.get("reverse")(x2);
    });
    defineFunction(
      simulate,
      "Sort",
      {
        allowEmpty: true,
        param: { name: "Items..." },
        prep: function(x2) {
          return toNum(simulate.coreBank.get("join")(x2));
        }
      },
      /**
         * @param {Vector} x
         * @returns
         */
      (x2) => {
        let res = x2.stackApply((x3) => {
          let items = [];
          for (let i2 = 0; i2 < x3.items.length; i2++) {
            items.push({ item: x3.items[i2], name: x3.names ? x3.names[i2] : void 0 });
          }
          let res2 = items.sort((a2, b2) => {
            if (lessThan(a2.item, b2.item)) {
              return -1;
            }
            if (greaterThan(a2.item, b2.item)) {
              return 1;
            }
            return 0;
          });
          let names = x3.names ? (
            /** @type {string[]} */
            []
          ) : void 0;
          items = [];
          for (let i2 = 0; i2 < res2.length; i2++) {
            items.push(res2[i2].item);
            if (names) {
              names.push(
                /** @type {string} */
                res2[i2].name
              );
            }
          }
          return new Vector(items, simulate, names);
        });
        return res;
      }
    );
    defineFunction(simulate, "Sort", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return simulate.coreBank.get("sort")(x2);
    });
    defineFunction(simulate, "Unique", {
      allowEmpty: true,
      param: { name: "Items...", allowBoolean: true },
      prep: function(x2) {
        return toNum(simulate.coreBank.get("join")(x2));
      }
    }, (x2) => {
      if (!x2.items.length) {
        return new Vector([], simulate);
      }
      let res = [];
      let names = x2.names ? (
        /** @type {string[]} */
        []
      ) : void 0;
      for (let i2 = 0; i2 < x2.items.length; i2++) {
        let found = false;
        for (let j = 0; j < res.length; j++) {
          if (strictEquals(x2.items[i2], res[j])) {
            found = true;
            break;
          }
        }
        if (!found) {
          res.push(x2.items[i2]);
          if (names) {
            names.push(x2.names[i2]);
          }
        }
      }
      return new Vector(res, simulate, names);
    });
    defineFunction(simulate, "Unique", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return simulate.coreBank.get("unique")(x2);
    });
    defineFunction(simulate, "Union", { object: [simulate.varBank, VectorObject], params: [{ name: "Vector 1", needVector: true }, { name: "Vector 2", needVector: true }] }, (x2) => {
      return simulate.coreBank.get("unique")(simulate.coreBank.get("join")(x2).items);
    });
    defineFunction(simulate, "Intersection", { object: [simulate.varBank, VectorObject], params: [{ name: "Vector 1", needVector: true }, { name: "Vector 2", needVector: true }] }, (x2) => {
      let v1 = x2[0];
      let v2 = x2[1];
      let res = [];
      for (let i2 = 0; i2 < v1.items.length; i2++) {
        for (let j = 0; j < v2.items.length; j++) {
          if (strictEquals(v1.items[i2], v2.items[j])) {
            res.push(v1.items[i2]);
            break;
          }
        }
      }
      return simulate.coreBank.get("unique")(res);
    });
    defineFunction(simulate, "Difference", { object: [simulate.varBank, VectorObject], params: [{ name: "Vector 1", needVector: true }, { name: "Vector 2", needVector: true }] }, (x2) => {
      let v1 = x2[0];
      let v2 = x2[1];
      let res = [];
      for (let i2 = 0; i2 < v1.items.length; i2++) {
        let found = false;
        for (let j = 0; j < v2.items.length; j++) {
          if (strictEquals(v1.items[i2], v2.items[j])) {
            found = true;
            break;
          }
        }
        if (!found) {
          res.push(v1.items[i2]);
        }
      }
      for (let i2 = 0; i2 < v2.items.length; i2++) {
        let found = false;
        for (let j = 0; j < v1.items.length; j++) {
          if (strictEquals(v2.items[i2], v1.items[j])) {
            found = true;
            break;
          }
        }
        if (!found) {
          res.push(v2.items[i2]);
        }
      }
      return simulate.coreBank.get("unique")(res);
    });
    defineFunction(simulate, "Factorial", { params: [{ name: "Number", noUnits: true, leafNeedNum: true }], recurse: true }, (x2) => {
      return new Material(factorial(toNum(x2[0]).value));
    });
    defineFunction(simulate, "Max", { param: { name: "Items..." }, prep: joinVector }, (x2) => {
      let res = x2.stackApply((v2) => {
        let x3 = v2.items;
        if (x3.length > 0) {
          let max = x3[0];
          for (let i2 = 1; i2 < x3.length; i2++) {
            if (greaterThan(x3[i2], max)) {
              max = x3[i2];
            }
          }
          return max;
        } else {
          throw new ModelError("You must have at least one element to calculate a max.", {
            code: 6017
          });
        }
      });
      return res;
    });
    defineFunction(simulate, "Max", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return simulate.coreBank.get("max")(x2);
    });
    function joinVector(x2, notToNum, skip) {
      if (!notToNum) {
        for (let i2 = 0; i2 < x2.length; i2++) {
          x2[i2] = toNum(x2[i2]);
        }
      }
      if (x2.length === 1 && x2[0] instanceof Vector) {
        if (skip) {
          return x2[0];
        } else {
          return simulate.coreBank.get("flatten")([x2[0]]);
        }
      } else {
        return new Vector(scalarsToVectors(x2), simulate);
      }
    }
    function joinArray(x2) {
      for (let i2 = 0; i2 < x2.length; i2++) {
        if (x2[i2].toNum) {
          x2[i2] = toNum(x2[i2]);
        }
      }
      if (x2.length === 1 && x2[0] instanceof Vector) {
        return simulate.coreBank.get("flatten")([toNum(x2[0])]).items;
      }
      return joinVector(x2, void 0, true).items;
    }
    function scalarsToVectors(x2) {
      let needVector = false;
      let vec;
      for (let i2 = 0; i2 < x2.length; i2++) {
        if (x2[i2] instanceof Vector) {
          vec = x2[i2];
          needVector = true;
          break;
        }
      }
      if (needVector) {
        for (let i2 = 0; i2 < x2.length; i2++) {
          if (!(x2[i2] instanceof Vector)) {
            x2[i2] = replicateVectorStructure(vec, x2[i2]);
          }
        }
      }
      return x2;
    }
    function replicateVectorStructure(vec, val) {
      let v2 = vec.fullClone();
      for (let i2 = 0; i2 < v2.items.length; i2++) {
        if (v2.items[i2] instanceof Vector) {
          v2.items[i2] = replicateVectorStructure(v2.items[i2], val);
        } else {
          v2.items[i2] = val;
        }
      }
      return v2;
    }
    defineFunction(simulate, "Lookup", { params: [{ name: "Value", noVector: true }, { name: "Value Vector", needVector: true }, { name: "Results Vector", needVector: true }] }, (x2) => {
      let v2 = toNum(x2[0]);
      let xVec = toNum(x2[1]);
      let yVec = toNum(x2[2]);
      if (xVec.items.length !== yVec.items.length) {
        throw new ModelError("The <i>value</i> and <i>results</i> vectors must be the same length", {
          code: 6018
        });
      }
      if (xVec.items.length < 1) {
        throw new ModelError("You must have at least one element in your vectors", {
          code: 6019
        });
      }
      let vec = [];
      for (let i2 = 0; i2 < xVec.items.length; i2++) {
        vec.push({ x: xVec.items[i2], y: yVec.items[i2] });
      }
      vec.sort((a2, b2) => {
        if (greaterThan(a2.x, b2.x)) {
          return 1;
        } else if (lessThan(a2.x, b2.x)) {
          return -1;
        } else {
          return 0;
        }
      });
      for (let i2 = 0; i2 < vec.length; i2++) {
        if (eq(vec[i2].x, v2)) {
          return vec[i2].y.fullClone();
        } else if (greaterThan(vec[i2].x, v2)) {
          if (i2 === 0) {
            return vec[i2].y.fullClone();
          }
          let dist = minus(vec[i2].x, vec[i2 - 1].x);
          let distLower = minus(v2, vec[i2 - 1].x);
          let distUpper = minus(vec[i2].x, v2);
          let fLower = div(distUpper, dist);
          let fUpper = div(distLower, dist);
          return plus(mult(vec[i2 - 1].y, fLower), mult(vec[i2].y, fUpper));
        }
      }
      return vec[vec.length - 1].y.fullClone();
    });
    defineFunction(simulate, "Fill", { object: [simulate.varBank, VectorObject], params: [{ name: "Vector", needVector: true }, { name: "Value", allowBoolean: true }] }, (x2) => {
      return replicateVectorStructure(x2[0], x2[1]);
    });
    defineFunction(
      simulate,
      "Min",
      { param: { name: "Items..." }, prep: joinVector },
      /**
       * @param {Vector} x
       * @returns
       */
      (x2) => {
        let res = x2.stackApply((v2) => {
          let x3 = v2.items;
          if (x3.length > 0) {
            let min = x3[0];
            for (let i2 = 1; i2 < x3.length; i2++) {
              if (lessThan(x3[i2], min)) {
                min = x3[i2];
              }
            }
            return min;
          } else {
            throw new ModelError("You must have at least one element to calculate a min.", {
              code: 6020
            });
          }
        });
        return res;
      }
    );
    defineFunction(simulate, "Min", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return simulate.coreBank.get("min")(x2);
    });
    defineFunction(
      simulate,
      "Mean",
      { param: { name: "Items..." }, prep: joinArray },
      /**
       * @param {any[]} x
       * @returns
       */
      (x2) => {
        let sum = x2[0];
        for (let i2 = 1; i2 < x2.length; i2++) {
          sum = plus(sum, x2[i2]);
        }
        return div(sum, new Material(x2.length));
      }
    );
    defineFunction(simulate, "Mean", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return simulate.coreBank.get("mean")(x2);
    });
    defineFunction(
      simulate,
      "Sum",
      { param: { name: "Items..." }, prep: joinArray },
      /**
       * @param {any[]} x
       * @returns
       */
      (x2) => {
        let sum = x2[0];
        for (let i2 = 1; i2 < x2.length; i2++) {
          sum = plus(sum, x2[i2]);
        }
        return sum;
      }
    );
    defineFunction(simulate, "Sum", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return simulate.coreBank.get("sum")(x2);
    });
    defineFunction(simulate, "Product", { param: { name: "Items..." }, prep: joinArray }, (x2) => {
      let total = x2[0];
      for (let i2 = 1; i2 < x2.length; i2++) {
        total = mult(total, x2[i2]);
      }
      return total;
    });
    defineFunction(simulate, "Product", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return simulate.coreBank.get("product")(x2);
    });
    defineFunction(simulate, "Median", { param: { name: "Items..." }, prep: joinVector }, (x2) => {
      let res = x2.stackApply((v2) => {
        let x3 = simulate.coreBank.get("sort")([v2]).items;
        if (x3.length > 0) {
          if (Math.floor((x3.length - 1) / 2) === (x3.length - 1) / 2) {
            return x3[(x3.length - 1) / 2];
          } else {
            return div(plus(x3[Math.floor((x3.length - 1) / 2)], x3[Math.ceil((x3.length - 1) / 2)]), new Material(2));
          }
        } else {
          throw new ModelError("You must have at least one element to calculate a median.", {
            code: 6021
          });
        }
      });
      return res;
    });
    defineFunction(simulate, "Median", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return simulate.coreBank.get("median")(x2);
    });
    defineFunction(simulate, "StdDev", { param: { name: "Items..." }, prep: joinVector }, (x2) => {
      let res = x2.stackApply((v2) => {
        let x3 = v2.items;
        if (x3.length > 1) {
          let mean = simulate.coreBank.get("mean")(x3);
          let sum = power(minus(x3[0], mean), new Material(2));
          for (let i2 = 1; i2 < x3.length; i2++) {
            sum = plus(sum, power(minus(x3[i2], mean), new Material(2)));
          }
          let r2 = power(div(sum, new Material(x3.length - 1)), new Material(0.5));
          return r2;
        } else {
          throw new ModelError("You must have at least two elements to calculate the standard deviation.", {
            code: 6022
          });
        }
      });
      return res;
    });
    defineFunction(simulate, "StdDev", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return simulate.coreBank.get("stddev")(x2);
    });
    defineFunction(simulate, "Correlation", { params: [{ name: "Vector 1", needVector: true }, { name: "Vector 2", needVector: true }] }, (x2) => {
      let v1 = toNum(x2[0]);
      let v2 = toNum(x2[1]);
      if (v1.length() <= 1) {
        throw new ModelError("You must have at least two elements in your vectors to calculate their correlation.", {
          code: 6023
        });
      }
      if (v1.length() !== v2.length()) {
        throw new ModelError("The vectors for Correlation() must be of the same size.", {
          code: 6024
        });
      }
      let v1Mean = simulate.coreBank.get("mean")([v1]);
      let v2Mean = simulate.coreBank.get("mean")([v2]);
      let v1StdDev = simulate.coreBank.get("stddev")([v1]);
      let v2StdDev = simulate.coreBank.get("stddev")([v2]);
      if (v1StdDev.value === 0 || v2StdDev.value === 0) {
        return new Material(0);
      }
      return div(simulate.coreBank.get("sum")([mult(minus(v1.clone(), v1Mean), minus(v2.clone(), v2Mean))]), mult(minus(simulate.coreBank.get("count")([v1]), new Material(1)), mult(v1StdDev, v2StdDev)));
    });
    simulate.varBank.set("count", function(x2) {
      x2 = simulate.coreBank.get("join")(x2).items;
      return new Material(x2.length);
    });
    simulate.coreBank.set("count", simulate.varBank.get("count"));
    simulate.varBank.set("flatten", function(x2) {
      let res = flatten(simulate.coreBank.get("join")(x2));
      return new Vector(res.items, simulate, res.hasName ? res.names : void 0);
    });
    simulate.coreBank.set("flatten", simulate.varBank.get("flatten"));
    defineFunction(simulate, "Keys", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      if (!x2[0].names) {
        return new Vector([], simulate);
      }
      return new Vector(x2[0].names.filter((x3) => x3 !== void 0).map((x3) => stringify(x3, simulate)), simulate);
    });
    defineFunction(simulate, "Values", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return new Vector(x2[0].items, simulate);
    });
    defineFunction(simulate, "Length", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return new Material(x2[0].items.length);
    });
    defineFunction(simulate, "Count", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return new Material(x2[0].items.length);
    });
    defineFunction(simulate, "Flatten", { object: VectorObject, params: [{ name: "Vector", needVector: true }] }, (x2) => {
      return simulate.coreBank.get("flatten")(x2);
    });
    function flatten(x2) {
      let res = [];
      let names = [];
      let hasName = void 0;
      for (let i2 = 0; i2 < x2.length(); i2++) {
        if (x2.items[i2] instanceof Vector) {
          let z = flatten(x2.items[i2]);
          res = res.concat(z.items);
          names = names.concat(z.names);
          hasName = hasName || z.hasName;
        } else {
          res.push(x2.items[i2]);
          if (x2.names) {
            names.push(x2.names[i2]);
            hasName = true;
          } else {
            names.push(void 0);
          }
        }
      }
      return { items: res, names, hasName };
    }
    defineFunction(simulate, "CDFNormal", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Mean", defaultVal: 0, noUnits: true, noVector: true }, { name: "Standard Deviation", defaultVal: 1, noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      let mu = x2[1] ? toNum(x2[1]).value : 0;
      let sd = x2[2] ? toNum(x2[2]).value : 1;
      if (sd < 0) {
        throw new ModelError("Standard Deviation must not be negative.", {
          code: 6076
        });
      }
      return new Material(jStat.normal.cdf(val, mu, sd));
    });
    defineFunction(simulate, "PDFNormal", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Mean", defaultVal: 0, noUnits: true, noVector: true }, { name: "Standard Deviation", defaultVal: 1, noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      let mu = x2[1] ? toNum(x2[1]).value : 0;
      let sd = x2[2] ? toNum(x2[2]).value : 1;
      if (sd < 0) {
        throw new ModelError("Standard Deviation must not be negative.", {
          code: 6076
        });
      }
      return new Material(jStat.normal.pdf(val, mu, sd));
    });
    defineFunction(simulate, "InvNormal", { params: [{ name: "p", noUnits: true, noVector: true }, { name: "Mean", defaultVal: 0, noUnits: true, noVector: true }, { name: "Standard Deviation", defaultVal: 1, noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      if (val < 0 || val > 1) {
        throw new ModelError("<i>p</i> is a probability and must be between 0 and 1 inclusive.", {
          code: 6025
        });
      }
      let mu = x2[1] ? toNum(x2[1]).value : 0;
      let sd = x2[2] ? toNum(x2[2]).value : 1;
      if (sd < 0) {
        throw new ModelError("Standard Deviation must not be negative.", {
          code: 6076
        });
      }
      return new Material(jStat.normal.inv(val, mu, sd));
    });
    defineFunction(simulate, "CDFLogNormal", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Mean", defaultVal: 0, noUnits: true, noVector: true }, { name: "Standard Deviation", defaultVal: 1, noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      let mu = x2[1] ? toNum(x2[1]).value : 0;
      let sd = x2[2] ? toNum(x2[2]).value : 1;
      if (sd < 0) {
        throw new ModelError("Standard Deviation must not be negative.", {
          code: 6076
        });
      }
      return new Material(jStat.lognormal.cdf(val, mu, sd));
    });
    defineFunction(simulate, "PDFLogNormal", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Mean", defaultVal: 0, noUnits: true, noVector: true }, { name: "Standard Deviation", defaultVal: 1, noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      let mu = x2[1] ? toNum(x2[1]).value : 0;
      let sd = x2[2] ? toNum(x2[2]).value : 1;
      if (sd < 0) {
        throw new ModelError("Standard Deviation must not be negative.", {
          code: 6076
        });
      }
      return new Material(jStat.lognormal.pdf(val, mu, sd));
    });
    defineFunction(simulate, "InvLogNormal", { params: [{ name: "p", noUnits: true, noVector: true }, { name: "Mean", defaultVal: 0, noUnits: true, noVector: true }, { name: "Standard Deviation", defaultVal: 1, noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      if (val < 0 || val > 1) {
        throw new ModelError("<i>p</i> is a probability and must be between 0 and 1 inclusive.", {
          code: 6026
        });
      }
      let mu = x2[1] ? toNum(x2[1]).value : 0;
      let sd = x2[2] ? toNum(x2[2]).value : 1;
      if (sd < 0) {
        throw new ModelError("Standard Deviation must not be negative.", {
          code: 6076
        });
      }
      return new Material(jStat.lognormal.inv(val, mu, sd));
    });
    defineFunction(simulate, "CDFt", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Degrees of Freedom", noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      let dof = toNum(x2[1]).value;
      if (dof <= 0) {
        throw new ModelError("<i>Degrees of Freedom</i> must be greater than 0.", {
          code: 6027
        });
      }
      return new Material(jStat.studentt.cdf(val, dof));
    });
    defineFunction(simulate, "PDFt", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Degrees of Freedom", noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      let dof = toNum(x2[1]).value;
      if (dof <= 0) {
        throw new ModelError("<i>Degrees of Freedom</i> must be greater than 0.", {
          code: 6028
        });
      }
      return new Material(jStat.studentt.pdf(val, dof));
    });
    defineFunction(simulate, "Invt", { params: [{ name: "p", noUnits: true, noVector: true }, { name: "Degrees of Freedom", noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      if (val < 0 || val > 1) {
        throw new ModelError("<i>p</i> is a probability and must be between 0 and 1 inclusive.", {
          code: 6029
        });
      }
      let dof = toNum(x2[1]).value;
      if (dof <= 0) {
        throw new ModelError("<i>Degrees of Freedom</i> must be greater than 0.", {
          code: 6030
        });
      }
      return new Material(jStat.studentt.inv(val, dof));
    });
    defineFunction(simulate, "CDFF", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Degrees of Freedom 1", noUnits: true, noVector: true }, { name: "Degrees of Freedom 2", noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      let dof1 = toNum(x2[1]).value;
      if (dof1 <= 0) {
        throw new ModelError("<i>Degrees of Freedom</i> must be greater than 0.", {
          code: 6031
        });
      }
      let dof2 = toNum(x2[2]).value;
      if (dof2 <= 0) {
        throw new ModelError("<i>Degrees of Freedom</i> must be greater than 0.", {
          code: 6032
        });
      }
      return new Material(jStat.centralF.cdf(val, dof1, dof2));
    });
    defineFunction(simulate, "PDFF", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Degrees of Freedom 1", noUnits: true, noVector: true }, { name: "Degrees of Freedom 2", noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      let dof1 = toNum(x2[1]).value;
      if (dof1 <= 0) {
        throw new ModelError("<i>Degrees of Freedom 1</i> must be greater than 0.", {
          code: 6033
        });
      }
      let dof2 = toNum(x2[2]).value;
      if (dof2 <= 0) {
        throw new ModelError("<i>Degrees of Freedom 2</i> must be greater than 0.", {
          code: 6034
        });
      }
      return new Material(jStat.centralF.pdf(val, dof1, dof2));
    });
    defineFunction(simulate, "InvF", { params: [{ name: "p", noUnits: true, noVector: true }, { name: "Degrees of Freedom 1", noUnits: true, noVector: true }, { name: "Degrees of Freedom 2", noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      if (val < 0 || val > 1) {
        throw new ModelError("<i>p</i> is a probability and must be between 0 and 1 inclusive.", {
          code: 6035
        });
      }
      let dof1 = toNum(x2[1]).value;
      if (dof1 <= 0) {
        throw new ModelError("<i>Degrees of Freedom 1</i> must be greater than 0.", {
          code: 6036
        });
      }
      let dof2 = toNum(x2[2]).value;
      if (dof2 <= 0) {
        throw new ModelError("<i>Degrees of Freedom</i> must be greater than 0.", {
          code: 6037
        });
      }
      return new Material(jStat.centralF.inv(val, dof1, dof2));
    });
    defineFunction(simulate, "CDFChiSquared", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Degrees of Freedom", noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      let dof = toNum(x2[1]).value;
      if (dof <= 0) {
        throw new ModelError("<i>Degrees of Freedom</i> must be greater than 0.", {
          code: 6038
        });
      }
      return new Material(jStat.chisquare.cdf(val, dof));
    });
    defineFunction(simulate, "PDFChiSquared", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Degrees of Freedom", noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      let dof = toNum(x2[1]).value;
      if (dof <= 0) {
        throw new ModelError("<i>Degrees of Freedom</i> must be greater than 0.", {
          code: 6039
        });
      }
      return new Material(jStat.chisquare.pdf(val, dof));
    });
    defineFunction(simulate, "InvChiSquared", { params: [{ name: "p", noUnits: true, noVector: true }, { name: "Degrees of Freedom", noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      if (val < 0 || val > 1) {
        throw new ModelError("<i>p</i> is a probability and must be between 0 and 1 inclusive.", {
          code: 6040
        });
      }
      let dof = toNum(x2[1]).value;
      if (dof <= 0) {
        throw new ModelError("<i>Degrees of Freedom</i> must be greater than 0.", {
          code: 6041
        });
      }
      return new Material(jStat.chisquare.inv(val, dof));
    });
    defineFunction(simulate, "CDFExponential", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Rate", noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      let rate = toNum(x2[1]).value;
      if (rate <= 0) {
        throw new ModelError("<i>Rate</i> must be greater than 0.", {
          code: 6042
        });
      }
      return new Material(jStat.exponential.cdf(val, rate));
    });
    defineFunction(simulate, "PDFExponential", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Rate", noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      let rate = toNum(x2[1]).value;
      if (rate <= 0) {
        throw new ModelError("<i>Rate</i> must be greater than 0.", {
          code: 6043
        });
      }
      return new Material(jStat.exponential.pdf(val, rate));
    });
    defineFunction(simulate, "InvExponential", { params: [{ name: "p", noUnits: true, noVector: true }, { name: "Rate", noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      if (val < 0 || val > 1) {
        throw new ModelError("<i>p</i> is a probability and must be between 0 and 1 inclusive.", {
          code: 6044
        });
      }
      let rate = toNum(x2[1]).value;
      if (rate <= 0) {
        throw new ModelError("<i>Rate</i> must be greater than 0.", {
          code: 6045
        });
      }
      return new Material(jStat.exponential.inv(val, rate));
    });
    defineFunction(simulate, "CDFPoisson", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Lambda", noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      let Lambda = toNum(x2[1]).value;
      if (Lambda <= 0) {
        throw new ModelError("<i>Lambda</i> must be greater than 0.", {
          code: 6046
        });
      }
      return new Material(jStat.poisson.cdf(val, Lambda));
    });
    defineFunction(simulate, "PMFPoisson", { params: [{ name: "x", noUnits: true, noVector: true }, { name: "Lambda", noUnits: true, noVector: true }] }, (x2) => {
      let val = toNum(x2[0]).value;
      let Lambda = toNum(x2[1]).value;
      if (Lambda <= 0) {
        throw new ModelError("<i>Lambda</i> must be greater than 0.", {
          code: 6047
        });
      }
      return new Material(jStat.poisson.pdf(val, Lambda));
    });
    defineFunction(simulate, "SetRandSeed", { params: [{ name: "Seed Number", noUnits: true, noVector: true }] }, (x2) => {
      simulate.random = SeedRandom.seedrandom(toNum(x2[0]).value);
      return stringify("Random Seed Set", simulate);
    });
    defineFunction(simulate, "Alert", { params: [{ name: "Message", allowString: true, allowBoolean: true }] }, (x2) => {
      if (typeof alert === "undefined") {
        throw new ModelError("Alert() is not implemented on this platform.", {
          code: 6048
        });
      }
      alert(x2[0]);
      return new Material(1);
    });
    defineFunction(simulate, "Console", { params: [{ name: "Message", allowString: true, allowBoolean: true }] }, (x2) => {
      console.log(x2[0]);
      return new Material(1);
    });
    defineFunction(simulate, "Prompt", { params: [{ name: "Message", allowString: true, allowBoolean: true }, { name: "Default", defaultVal: "", allowString: true, allowBoolean: true }] }, (x2) => {
      if (typeof prompt === "undefined") {
        throw new ModelError("Prompt() is not implemented on this platform.", {
          code: 6049
        });
      }
      let y2 = x2[1];
      if (y2 instanceof Material && !y2.units) {
        y2 = y2.value;
      }
      let result = prompt(x2[0], y2);
      if (result === null) {
        return new Material(0);
      } else if (parseFloat(result).toString() === result) {
        return new Material(parseFloat(result));
      } else {
        return stringify(result, simulate);
      }
    });
    defineFunction(simulate, "Confirm", { params: [{ name: "Message", allowString: true, allowBoolean: true }] }, (x2) => {
      if (typeof confirm === "undefined") {
        throw new ModelError("Confirm() is not implemented on this platform.", {
          code: 6050
        });
      }
      return confirm(x2[0]);
    });
    defineFunction(simulate, "Parse", { object: StringObject, params: [{ name: "String", allowString: true }] }, (x2) => {
      return new Material(parseFloat(x2[0]));
    });
    defineFunction(simulate, "Split", { object: StringObject, params: [{ name: "String", needString: true }, { name: "Splitter", needString: true }] }, (x2) => {
      return stringify(new Vector(x2[0].split(x2[1]), simulate), simulate);
    });
    defineFunction(simulate, "Join", { object: VectorObject, params: [{ name: "String", needVector: true }, { name: "Joiner", needString: true }] }, (x2) => {
      return stringify(x2[0].items.join(x2[1]), simulate);
    });
    defineFunction(simulate, "Trim", { object: StringObject, params: [{ name: "String", needString: true }], recurse: true }, (x2) => {
      return stringify(x2[0].trim(), simulate);
    });
    defineFunction(simulate, "Range", { object: StringObject, params: [{ name: "String", needString: true }, { name: "Indexes", noUnits: true }] }, (x2) => {
      if (x2[1] instanceof Vector) {
        let res = "";
        for (let i2 = 0; i2 < x2[1].items.length; i2++) {
          res += x2[0].charAt(toNum(x2[1].items[i2]).value - 1);
        }
        return stringify(res, simulate);
      } else {
        return stringify(x2[0].charAt(toNum(x2[1]).value - 1), simulate);
      }
    });
    defineFunction(simulate, "Length", { object: StringObject, params: [{ name: "String", needString: true }] }, (x2) => {
      return new Material(x2[0].length);
    });
    defineFunction(simulate, "IndexOf", { object: StringObject, params: [{ name: "Haystack", needString: true }, { name: "Needle", needString: true }] }, (x2) => {
      return new Material(x2[0].indexOf(x2[1]) + 1);
    });
    defineFunction(simulate, "Contains", { object: StringObject, params: [{ name: "Haystack", needString: true }, { name: "Needle", needString: true }] }, (x2) => {
      return !eq(StringObject["indexof"](x2), new Material(0));
    });
    defineFunction(simulate, "Lowercase", { object: StringObject, params: [{ name: "String", needString: true }] }, (x2) => {
      return stringify(x2[0].toLowerCase(), simulate);
    });
    defineFunction(simulate, "Uppercase", { object: StringObject, params: [{ name: "String", needString: true }] }, (x2) => {
      return stringify(x2[0].toUpperCase(), simulate);
    });
    simulate.coreBank.set("stringbase", makeObjectBase(StringObject, simulate));
    simulate.varBank.set("stringbase", simulate.coreBank.get("stringbase"));
    simulate.coreBank.set("vectorbase", makeObjectBase(VectorObject, simulate));
    simulate.varBank.set("vectorbase", simulate.coreBank.get("vectorbase"));
  }
  function makeObjectBase(x2, simulate) {
    let names = Object.keys(x2);
    let items = [];
    for (let name of names) {
      items.push(objectizeFunction(x2[name]));
    }
    let vec = new Vector(items, simulate, names);
    vec.parent = void 0;
    return vec;
  }
  function defineFunction(simulate, name, definition, fn2) {
    const arr = "params" in definition;
    let vectorized = [];
    let requiredLength = void 0;
    if (arr) {
      requiredLength = definition.params.length;
      for (let i2 = 0; i2 < definition.params.length; i2++) {
        if ("defaultVal" in definition.params[i2]) {
          requiredLength = i2;
          break;
        }
      }
      for (let i2 = 0; i2 < definition.params.length; i2++) {
        if (definition.params[i2].vectorize) {
          vectorized.push(i2);
          if (definition.params[i2].noVector) {
            throw new ModelError(`Cannot have a non-vector vectorized parameter. Function '${name}', parameter '${definition.params[i2].name}'.`, {
              code: 6051
            });
          }
        }
      }
    }
    let standardFnName;
    let objectFnName;
    if (arr) {
      standardFnName = name + "(" + definition.params.map((x2) => {
        return x2.name + ("defaultVal" in x2 ? "=" + x2.defaultVal.toString() : "");
      }).join(", ") + ")";
      objectFnName = name + "(" + definition.params.slice(1).map((x2) => {
        return x2.name + ("defaultVal" in x2 ? "=" + x2.defaultVal.toString() : "");
      }).join(", ") + ")";
    } else {
      standardFnName = name + "(items...)";
      objectFnName = name + "(items...)";
    }
    let f2 = function(x2, id2, _ls, config = {}) {
      let fnName;
      if (config.isObjectCaller) {
        fnName = objectFnName;
      } else {
        fnName = standardFnName;
      }
      if (definition.prep) {
        x2 = definition.prep(x2);
      }
      if (arr) {
        if (x2.length > definition.params.length || x2.length < requiredLength) {
          throw new ModelError(`Wrong number of parameters for ${fnName}.`, {
            code: 6052
          });
        }
      } else {
        if (!x2.length && !definition.allowEmpty) {
          throw new ModelError(`At least one parameter required for ${name}().`, {
            code: 6053
          });
        }
      }
      for (let i2 = 0; i2 < x2.length; i2++) {
        let simplify = function(param) {
          if (param instanceof UserFunction) {
            return simplify(param.fn([]));
          }
          if (!config2.needPrimitive && !config2.allowOptionalPrimitive && !config2.needAgent && !config2.needPopulation) {
            if (param instanceof SPrimitive && !(param instanceof SPopulation)) {
              return simplify(toNum(param));
            }
          }
          return param;
        };
        let config2 = arr ? definition.params[i2] : definition.param;
        x2[i2] = simplify(x2[i2]);
        if (config2.noUnits && toNum(x2[i2]) instanceof Material && toNum(x2[i2]).units && !toNum(x2[i2]).units.isUnitless()) {
          throw new ModelError(`${fnName} does not accept units for the parameter '${config2.name}'. Got units of <i>${toNum(x2[i2]).units.toString()}</i>`, {
            code: 6054
          });
        }
        if (config2.noVector && x2[i2] instanceof Vector) {
          throw new ModelError(`${fnName} does not accept vectors for the parameter '${config2.name}'.`, {
            code: 6055
          });
        }
        if (config2.vectorize && x2[i2] instanceof Vector && !x2[i2].names) {
          throw new ModelError(`${fnName} does not accepted non-named vectors for the parameter '${config2.name}'.`, {
            code: 6056
          });
        }
        if (config2.needVector) {
          if (x2[i2] instanceof SPrimitive) {
            x2[i2] = toNum(x2[i2]);
          }
          if (!(x2[i2] instanceof Vector)) {
            throw new ModelError(`${fnName} requires a vector for the parameter '${config2.name}'.`, {
              code: 6057
            });
          }
        }
        if (config2.needNum) {
          if (x2[i2] instanceof SPrimitive) {
            x2[i2] = toNum(x2[i2]);
          }
          if (!(x2[i2] instanceof Material)) {
            throw new ModelError(`${fnName} requires a number for the parameter '${config2.name}'.`, {
              code: 6058
            });
          }
        }
        if (config2.needPrimitive && !(x2[i2] instanceof SPrimitive)) {
          throw new ModelError(`${fnName} requires a primitive for the parameter '${config2.name}'.`, {
            code: 6059
          });
        }
        if (!config2.allowBoolean && typeof x2[i2] === "boolean") {
          throw new ModelError(`${fnName} does not accept boolean values for the parameter '${config2.name}'.`, {
            code: 6060
          });
        }
        if (config2.needAgent && !(x2[i2] instanceof SAgent)) {
          x2[i2] = agent(x2[i2], simulate);
        }
        if (config2.needString) {
          if (!(typeof x2[i2] === "string" || x2[i2] instanceof String)) {
            throw new ModelError(`${fnName} requires a string for the parameter '${config2.name}'.`, {
              code: 6061
            });
          }
        }
        if (!config2.allowString && !config2.needString && (typeof x2[i2] === "string" || x2[i2] instanceof String)) {
          throw new ModelError(`${fnName} does not accept string values for the parameter '${config2.name}'.`, {
            code: 6062
          });
        }
        if (config2.needAgents && !(x2[i2] instanceof SPopulation)) {
          x2[i2] = agents(x2[i2]);
        }
        if (config2.needPopulation && !(x2[i2] instanceof Vector)) {
          x2[i2] = getPopulation(x2[i2], simulate);
        }
      }
      let q;
      if (arr && definition.recurse) {
        q = toNum(x2[0]);
        if (definition.params[0] && definition.params[0].leafNeedNum) {
          if (!(q instanceof Vector)) {
            if (!(q instanceof Material)) {
              throw new ModelError(`${fnName} requires a number for the parameter '${definition.params[0].name}'.`, {
                code: 6058
              });
            }
          }
        }
      }
      if (arr && definition.recurse && q instanceof Vector) {
        return q.cloneApply((z) => {
          if (!(z instanceof Vector) && definition.params[0] && definition.params[0].leafNeedNum) {
            if (!(z instanceof Material)) {
              throw new ModelError(`${fnName} requires a number for the parameter '${definition.params[0].name}'.`, {
                code: 6058
              });
            }
          }
          return f2([z].concat(x2.slice(1)), id2);
        });
      } else if (arr && vectorized.length > 0) {
        let base = void 0, baseI = -1;
        for (let i2 = 0; i2 < vectorized.length; i2++) {
          if (x2[vectorized[i2]]) {
            let v2 = toNum(x2[vectorized[i2]]);
            if (v2 instanceof Vector && v2.namesLC) {
              if (!base) {
                base = v2;
                baseI = vectorized[i2];
              } else {
                if (!base.keysMatch(v2.namesLC)) {
                  throw new ModelError(`Vector keys do not match between parameters '${definition.params[baseI].name}' and '${definition.params[vectorized[i2]].name}' in ${fnName}.`, {
                    code: 6064
                  });
                }
              }
            }
          }
        }
        if (!base) {
          return fn2(x2, id2);
        } else {
          let keys = base.namesLC;
          let res = [];
          for (let i2 = 0; i2 < keys.length; i2++) {
            let newX = [];
            for (let j = 0; j < x2.length; j++) {
              if (vectorized.indexOf(j) === -1) {
                newX.push(x2[j]);
              } else {
                let v2 = toNum(x2[j]);
                if (v2 instanceof Vector && v2.namesLC) {
                  newX.push(v2.select([keys[i2]]));
                } else {
                  newX.push(v2);
                }
              }
            }
            let z = fn2(newX, id2);
            if (z instanceof Vector) {
              if (!base.keysMatch(z.namesLC)) {
                throw new ModelError(`Vector keys do not match between parameter '${definition.params[baseI].name}' and calculation result.`, {
                  code: 6065
                });
              }
              res.push(z.select([keys[i2]]));
            } else {
              res.push(z);
            }
          }
          return new Vector(res, simulate, keys);
        }
      } else {
        return fn2(x2, id2);
      }
    };
    if (!definition.object) {
      simulate.varBank.set(name.toLowerCase(), f2);
      simulate.coreBank.set(name.toLowerCase(), f2);
    } else {
      if (definition.object instanceof Array) {
        for (let i2 = 0; i2 < definition.object.length; i2++) {
          if (definition.object[i2] instanceof Map) {
            if (definition.object[i2] === simulate.varBank) {
              simulate.coreBank.set(name.toLowerCase(), f2);
            }
            definition.object[i2].set(name.toLowerCase(), f2);
          } else {
            definition.object[i2][name.toLowerCase()] = f2;
          }
        }
      } else {
        if (definition.object instanceof Map) {
          definition.object.set(name.toLowerCase(), f2);
        } else {
          definition.object[name.toLowerCase()] = f2;
        }
      }
    }
    if (arr && definition.recurse) {
      VectorObject[name.toLowerCase()] = f2;
    }
  }
  function objectizeFunction(fn2) {
    let f2 = function(x2, fingerprint, lastSelf) {
      if (!lastSelf) {
        throw new ModelError("Object function not used on object", {
          code: 6066
        });
      }
      return fn2([lastSelf].concat(x2), fingerprint, lastSelf, {
        isObjectCaller: true
      });
    };
    f2.delayEvalParams = fn2.delayEvalParams;
    return f2;
  }
  function factorial(x2) {
    if (Math.round(x2) !== x2) {
      throw new ModelError("The factorial() function only accepts integers.", {
        code: 6067
      });
    } else if (x2 < 0) {
      throw new ModelError("The factorial() function is only defined for integers 0 or larger.", {
        code: 6068
      });
    }
    if (x2 > 1) {
      return x2 * factorial(x2 - 1);
    } else {
      return 1;
    }
  }
  function testArgumentsSize(x2, name, min, max) {
    if (x2.length < min || x2.length > max) {
      throw new ModelError(`Wrong number of parameters for ${name}().`, {
        code: 6069
      });
    }
  }

  // ../insight-maker-simulation/vendor/antlr4-all.js
  var t = { 92: () => {
  } };
  var e = {};
  function n(s2) {
    var i2 = e[s2];
    if (void 0 !== i2) return i2.exports;
    var r2 = e[s2] = { exports: {} };
    return t[s2](r2, r2.exports, n), r2.exports;
  }
  n.d = (t2, e2) => {
    for (var s2 in e2) n.o(e2, s2) && !n.o(t2, s2) && Object.defineProperty(t2, s2, { enumerable: true, get: e2[s2] });
  }, n.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2);
  var s = {};
  (() => {
    n.d(s, { dx: () => $, q2: () => Lt, FO: () => Ce, xf: () => Ie, Gy: () => ve, s4: () => Pt, c7: () => be, _7: () => le, tx: () => Ae, gp: () => me, cK: () => Ot, zs: () => Te, AV: () => Ie, Xp: () => m2, VS: () => E2, ul: () => W, hW: () => Ut, x1: () => Xt, z5: () => ee, oN: () => de, TB: () => pe, u1: () => ge, _b: () => Fe, $F: () => se, _T: () => Be, db: () => ie, Zx: () => te, _x: () => Ft, r8: () => M2, JI: () => w2, TP: () => P3, WU: () => t2, Nj: () => c2, ZP: () => We });
    class t2 {
      constructor() {
        this.source = null, this.type = null, this.channel = null, this.start = null, this.stop = null, this.tokenIndex = null, this.line = null, this.column = null, this._text = null;
      }
      getTokenSource() {
        return this.source[0];
      }
      getInputStream() {
        return this.source[1];
      }
      get text() {
        return this._text;
      }
      set text(t3) {
        this._text = t3;
      }
    }
    function e2(t3, e3) {
      if (!Array.isArray(t3) || !Array.isArray(e3)) return false;
      if (t3 === e3) return true;
      if (t3.length !== e3.length) return false;
      for (let n2 = 0; n2 < t3.length; n2++) if (!(t3[n2] === e3[n2] || t3[n2].equals && t3[n2].equals(e3[n2]))) return false;
      return true;
    }
    t2.INVALID_TYPE = 0, t2.EPSILON = -2, t2.MIN_USER_TOKEN_TYPE = 1, t2.EOF = -1, t2.DEFAULT_CHANNEL = 0, t2.HIDDEN_CHANNEL = 1;
    const i2 = Math.round(Math.random() * Math.pow(2, 32));
    function r2(t3) {
      if (!t3) return 0;
      const e3 = typeof t3, n2 = "string" === e3 ? t3 : !("object" !== e3 || !t3.toString) && t3.toString();
      if (!n2) return 0;
      let s2, r3;
      const o3 = 3 & n2.length, a3 = n2.length - o3;
      let l3 = i2;
      const h3 = 3432918353, c3 = 461845907;
      let u3 = 0;
      for (; u3 < a3; ) r3 = 255 & n2.charCodeAt(u3) | (255 & n2.charCodeAt(++u3)) << 8 | (255 & n2.charCodeAt(++u3)) << 16 | (255 & n2.charCodeAt(++u3)) << 24, ++u3, r3 = (65535 & r3) * h3 + (((r3 >>> 16) * h3 & 65535) << 16) & 4294967295, r3 = r3 << 15 | r3 >>> 17, r3 = (65535 & r3) * c3 + (((r3 >>> 16) * c3 & 65535) << 16) & 4294967295, l3 ^= r3, l3 = l3 << 13 | l3 >>> 19, s2 = 5 * (65535 & l3) + ((5 * (l3 >>> 16) & 65535) << 16) & 4294967295, l3 = 27492 + (65535 & s2) + ((58964 + (s2 >>> 16) & 65535) << 16);
      switch (r3 = 0, o3) {
        case 3:
          r3 ^= (255 & n2.charCodeAt(u3 + 2)) << 16;
        case 2:
          r3 ^= (255 & n2.charCodeAt(u3 + 1)) << 8;
        case 1:
          r3 ^= 255 & n2.charCodeAt(u3), r3 = (65535 & r3) * h3 + (((r3 >>> 16) * h3 & 65535) << 16) & 4294967295, r3 = r3 << 15 | r3 >>> 17, r3 = (65535 & r3) * c3 + (((r3 >>> 16) * c3 & 65535) << 16) & 4294967295, l3 ^= r3;
      }
      return l3 ^= n2.length, l3 ^= l3 >>> 16, l3 = 2246822507 * (65535 & l3) + ((2246822507 * (l3 >>> 16) & 65535) << 16) & 4294967295, l3 ^= l3 >>> 13, l3 = 3266489909 * (65535 & l3) + ((3266489909 * (l3 >>> 16) & 65535) << 16) & 4294967295, l3 ^= l3 >>> 16, l3 >>> 0;
    }
    class o2 {
      constructor() {
        this.count = 0, this.hash = 0;
      }
      update() {
        for (let t3 = 0; t3 < arguments.length; t3++) {
          const e3 = arguments[t3];
          if (null != e3) if (Array.isArray(e3)) this.update.apply(this, e3);
          else {
            let t4 = 0;
            switch (typeof e3) {
              case "undefined":
              case "function":
                continue;
              case "number":
              case "boolean":
                t4 = e3;
                break;
              case "string":
                t4 = r2(e3);
                break;
              default:
                e3.updateHashCode ? e3.updateHashCode(this) : console.log("No updateHashCode for " + e3.toString());
                continue;
            }
            t4 *= 3432918353, t4 = t4 << 15 | t4 >>> 17, t4 *= 461845907, this.count = this.count + 1;
            let n2 = this.hash ^ t4;
            n2 = n2 << 13 | n2 >>> 19, n2 = 5 * n2 + 3864292196, this.hash = n2;
          }
        }
      }
      finish() {
        let t3 = this.hash ^ 4 * this.count;
        return t3 ^= t3 >>> 16, t3 *= 2246822507, t3 ^= t3 >>> 13, t3 *= 3266489909, t3 ^= t3 >>> 16, t3;
      }
      static hashStuff() {
        const t3 = new o2();
        return t3.update.apply(t3, arguments), t3.finish();
      }
    }
    function a2(t3) {
      return t3 ? "string" == typeof t3 ? r2(t3) : t3.hashCode() : -1;
    }
    function l2(t3, e3) {
      return t3 ? t3.equals(e3) : t3 === e3;
    }
    function h2(t3) {
      return null === t3 ? "null" : t3;
    }
    function c2(t3) {
      return Array.isArray(t3) ? "[" + t3.map(h2).join(", ") + "]" : "null";
    }
    const u2 = "h-";
    class d2 {
      constructor(t3, e3) {
        this.data = {}, this.hashFunction = t3 || a2, this.equalsFunction = e3 || l2;
      }
      add(t3) {
        const e3 = u2 + this.hashFunction(t3);
        if (e3 in this.data) {
          const n2 = this.data[e3];
          for (let e4 = 0; e4 < n2.length; e4++) if (this.equalsFunction(t3, n2[e4])) return n2[e4];
          return n2.push(t3), t3;
        }
        return this.data[e3] = [t3], t3;
      }
      has(t3) {
        return null != this.get(t3);
      }
      get(t3) {
        const e3 = u2 + this.hashFunction(t3);
        if (e3 in this.data) {
          const n2 = this.data[e3];
          for (let e4 = 0; e4 < n2.length; e4++) if (this.equalsFunction(t3, n2[e4])) return n2[e4];
        }
        return null;
      }
      values() {
        return Object.keys(this.data).filter(((t3) => t3.startsWith(u2))).flatMap(((t3) => this.data[t3]), this);
      }
      toString() {
        return c2(this.values());
      }
      get length() {
        return Object.keys(this.data).filter(((t3) => t3.startsWith(u2))).map(((t3) => this.data[t3].length), this).reduce(((t3, e3) => t3 + e3), 0);
      }
    }
    class p2 {
      hashCode() {
        const t3 = new o2();
        return this.updateHashCode(t3), t3.finish();
      }
      evaluate(t3, e3) {
      }
      evalPrecedence(t3, e3) {
        return this;
      }
      static andContext(t3, e3) {
        if (null === t3 || t3 === p2.NONE) return e3;
        if (null === e3 || e3 === p2.NONE) return t3;
        const n2 = new g2(t3, e3);
        return 1 === n2.opnds.length ? n2.opnds[0] : n2;
      }
      static orContext(t3, e3) {
        if (null === t3) return e3;
        if (null === e3) return t3;
        if (t3 === p2.NONE || e3 === p2.NONE) return p2.NONE;
        const n2 = new f2(t3, e3);
        return 1 === n2.opnds.length ? n2.opnds[0] : n2;
      }
    }
    class g2 extends p2 {
      constructor(t3, e3) {
        super();
        const n2 = new d2();
        t3 instanceof g2 ? t3.opnds.map((function(t4) {
          n2.add(t4);
        })) : n2.add(t3), e3 instanceof g2 ? e3.opnds.map((function(t4) {
          n2.add(t4);
        })) : n2.add(e3);
        const s2 = x2(n2);
        if (s2.length > 0) {
          let t4 = null;
          s2.map((function(e4) {
            (null === t4 || e4.precedence < t4.precedence) && (t4 = e4);
          })), n2.add(t4);
        }
        this.opnds = Array.from(n2.values());
      }
      equals(t3) {
        return this === t3 || t3 instanceof g2 && e2(this.opnds, t3.opnds);
      }
      updateHashCode(t3) {
        t3.update(this.opnds, "AND");
      }
      evaluate(t3, e3) {
        for (let n2 = 0; n2 < this.opnds.length; n2++) if (!this.opnds[n2].evaluate(t3, e3)) return false;
        return true;
      }
      evalPrecedence(t3, e3) {
        let n2 = false;
        const s2 = [];
        for (let i4 = 0; i4 < this.opnds.length; i4++) {
          const r3 = this.opnds[i4], o3 = r3.evalPrecedence(t3, e3);
          if (n2 |= o3 !== r3, null === o3) return null;
          o3 !== p2.NONE && s2.push(o3);
        }
        if (!n2) return this;
        if (0 === s2.length) return p2.NONE;
        let i3 = null;
        return s2.map((function(t4) {
          i3 = null === i3 ? t4 : p2.andContext(i3, t4);
        })), i3;
      }
      toString() {
        const t3 = this.opnds.map(((t4) => t4.toString()));
        return (t3.length > 3 ? t3.slice(3) : t3).join("&&");
      }
    }
    class f2 extends p2 {
      constructor(t3, e3) {
        super();
        const n2 = new d2();
        t3 instanceof f2 ? t3.opnds.map((function(t4) {
          n2.add(t4);
        })) : n2.add(t3), e3 instanceof f2 ? e3.opnds.map((function(t4) {
          n2.add(t4);
        })) : n2.add(e3);
        const s2 = x2(n2);
        if (s2.length > 0) {
          const t4 = s2.sort((function(t5, e5) {
            return t5.compareTo(e5);
          })), e4 = t4[t4.length - 1];
          n2.add(e4);
        }
        this.opnds = Array.from(n2.values());
      }
      equals(t3) {
        return this === t3 || t3 instanceof f2 && e2(this.opnds, t3.opnds);
      }
      updateHashCode(t3) {
        t3.update(this.opnds, "OR");
      }
      evaluate(t3, e3) {
        for (let n2 = 0; n2 < this.opnds.length; n2++) if (this.opnds[n2].evaluate(t3, e3)) return true;
        return false;
      }
      evalPrecedence(t3, e3) {
        let n2 = false;
        const s2 = [];
        for (let i3 = 0; i3 < this.opnds.length; i3++) {
          const r3 = this.opnds[i3], o3 = r3.evalPrecedence(t3, e3);
          if (n2 |= o3 !== r3, o3 === p2.NONE) return p2.NONE;
          null !== o3 && s2.push(o3);
        }
        if (!n2) return this;
        if (0 === s2.length) return null;
        return s2.map((function(t4) {
          return t4;
        })), null;
      }
      toString() {
        const t3 = this.opnds.map(((t4) => t4.toString()));
        return (t3.length > 3 ? t3.slice(3) : t3).join("||");
      }
    }
    function x2(t3) {
      const e3 = [];
      return t3.values().map((function(t4) {
        t4 instanceof p2.PrecedencePredicate && e3.push(t4);
      })), e3;
    }
    function T2(t3, e3) {
      if (null === t3) {
        const t4 = { state: null, alt: null, context: null, semanticContext: null };
        return e3 && (t4.reachesIntoOuterContext = 0), t4;
      }
      {
        const n2 = {};
        return n2.state = t3.state || null, n2.alt = void 0 === t3.alt ? null : t3.alt, n2.context = t3.context || null, n2.semanticContext = t3.semanticContext || null, e3 && (n2.reachesIntoOuterContext = t3.reachesIntoOuterContext || 0, n2.precedenceFilterSuppressed = t3.precedenceFilterSuppressed || false), n2;
      }
    }
    class S2 {
      constructor(t3, e3) {
        this.checkContext(t3, e3), t3 = T2(t3), e3 = T2(e3, true), this.state = null !== t3.state ? t3.state : e3.state, this.alt = null !== t3.alt ? t3.alt : e3.alt, this.context = null !== t3.context ? t3.context : e3.context, this.semanticContext = null !== t3.semanticContext ? t3.semanticContext : null !== e3.semanticContext ? e3.semanticContext : p2.NONE, this.reachesIntoOuterContext = e3.reachesIntoOuterContext, this.precedenceFilterSuppressed = e3.precedenceFilterSuppressed;
      }
      checkContext(t3, e3) {
        null !== t3.context && void 0 !== t3.context || null !== e3 && null !== e3.context && void 0 !== e3.context || (this.context = null);
      }
      hashCode() {
        const t3 = new o2();
        return this.updateHashCode(t3), t3.finish();
      }
      updateHashCode(t3) {
        t3.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
      }
      equals(t3) {
        return this === t3 || t3 instanceof S2 && this.state.stateNumber === t3.state.stateNumber && this.alt === t3.alt && (null === this.context ? null === t3.context : this.context.equals(t3.context)) && this.semanticContext.equals(t3.semanticContext) && this.precedenceFilterSuppressed === t3.precedenceFilterSuppressed;
      }
      hashCodeForConfigSet() {
        const t3 = new o2();
        return t3.update(this.state.stateNumber, this.alt, this.semanticContext), t3.finish();
      }
      equalsForConfigSet(t3) {
        return this === t3 || t3 instanceof S2 && this.state.stateNumber === t3.state.stateNumber && this.alt === t3.alt && this.semanticContext.equals(t3.semanticContext);
      }
      toString() {
        return "(" + this.state + "," + this.alt + (null !== this.context ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== p2.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext > 0 ? ",up=" + this.reachesIntoOuterContext : "") + ")";
      }
    }
    class m2 {
      constructor(t3, e3) {
        this.start = t3, this.stop = e3;
      }
      clone() {
        return new m2(this.start, this.stop);
      }
      contains(t3) {
        return t3 >= this.start && t3 < this.stop;
      }
      toString() {
        return this.start === this.stop - 1 ? this.start.toString() : this.start.toString() + ".." + (this.stop - 1).toString();
      }
      get length() {
        return this.stop - this.start;
      }
    }
    m2.INVALID_INTERVAL = new m2(-1, -2);
    class E2 {
      constructor() {
        this.intervals = null, this.readOnly = false;
      }
      first(e3) {
        return null === this.intervals || 0 === this.intervals.length ? t2.INVALID_TYPE : this.intervals[0].start;
      }
      addOne(t3) {
        this.addInterval(new m2(t3, t3 + 1));
      }
      addRange(t3, e3) {
        this.addInterval(new m2(t3, e3 + 1));
      }
      addInterval(t3) {
        if (null === this.intervals) this.intervals = [], this.intervals.push(t3.clone());
        else {
          for (let e3 = 0; e3 < this.intervals.length; e3++) {
            const n2 = this.intervals[e3];
            if (t3.stop < n2.start) return void this.intervals.splice(e3, 0, t3);
            if (t3.stop === n2.start) return void (this.intervals[e3] = new m2(t3.start, n2.stop));
            if (t3.start <= n2.stop) return this.intervals[e3] = new m2(Math.min(n2.start, t3.start), Math.max(n2.stop, t3.stop)), void this.reduce(e3);
          }
          this.intervals.push(t3.clone());
        }
      }
      addSet(t3) {
        return null !== t3.intervals && t3.intervals.forEach(((t4) => this.addInterval(t4)), this), this;
      }
      reduce(t3) {
        if (t3 < this.intervals.length - 1) {
          const e3 = this.intervals[t3], n2 = this.intervals[t3 + 1];
          e3.stop >= n2.stop ? (this.intervals.splice(t3 + 1, 1), this.reduce(t3)) : e3.stop >= n2.start && (this.intervals[t3] = new m2(e3.start, n2.stop), this.intervals.splice(t3 + 1, 1));
        }
      }
      complement(t3, e3) {
        const n2 = new E2();
        return n2.addInterval(new m2(t3, e3 + 1)), null !== this.intervals && this.intervals.forEach(((t4) => n2.removeRange(t4))), n2;
      }
      contains(t3) {
        if (null === this.intervals) return false;
        for (let e3 = 0; e3 < this.intervals.length; e3++) if (this.intervals[e3].contains(t3)) return true;
        return false;
      }
      removeRange(t3) {
        if (t3.start === t3.stop - 1) this.removeOne(t3.start);
        else if (null !== this.intervals) {
          let e3 = 0;
          for (let n2 = 0; n2 < this.intervals.length; n2++) {
            const n3 = this.intervals[e3];
            if (t3.stop <= n3.start) return;
            if (t3.start > n3.start && t3.stop < n3.stop) {
              this.intervals[e3] = new m2(n3.start, t3.start);
              const s2 = new m2(t3.stop, n3.stop);
              return void this.intervals.splice(e3, 0, s2);
            }
            t3.start <= n3.start && t3.stop >= n3.stop ? (this.intervals.splice(e3, 1), e3 -= 1) : t3.start < n3.stop ? this.intervals[e3] = new m2(n3.start, t3.start) : t3.stop < n3.stop && (this.intervals[e3] = new m2(t3.stop, n3.stop)), e3 += 1;
          }
        }
      }
      removeOne(t3) {
        if (null !== this.intervals) for (let e3 = 0; e3 < this.intervals.length; e3++) {
          const n2 = this.intervals[e3];
          if (t3 < n2.start) return;
          if (t3 === n2.start && t3 === n2.stop - 1) return void this.intervals.splice(e3, 1);
          if (t3 === n2.start) return void (this.intervals[e3] = new m2(n2.start + 1, n2.stop));
          if (t3 === n2.stop - 1) return void (this.intervals[e3] = new m2(n2.start, n2.stop - 1));
          if (t3 < n2.stop - 1) {
            const s2 = new m2(n2.start, t3);
            return n2.start = t3 + 1, void this.intervals.splice(e3, 0, s2);
          }
        }
      }
      toString(t3, e3, n2) {
        return t3 = t3 || null, e3 = e3 || null, n2 = n2 || false, null === this.intervals ? "{}" : null !== t3 || null !== e3 ? this.toTokenString(t3, e3) : n2 ? this.toCharString() : this.toIndexString();
      }
      toCharString() {
        const e3 = [];
        for (let n2 = 0; n2 < this.intervals.length; n2++) {
          const s2 = this.intervals[n2];
          s2.stop === s2.start + 1 ? s2.start === t2.EOF ? e3.push("<EOF>") : e3.push("'" + String.fromCharCode(s2.start) + "'") : e3.push("'" + String.fromCharCode(s2.start) + "'..'" + String.fromCharCode(s2.stop - 1) + "'");
        }
        return e3.length > 1 ? "{" + e3.join(", ") + "}" : e3[0];
      }
      toIndexString() {
        const e3 = [];
        for (let n2 = 0; n2 < this.intervals.length; n2++) {
          const s2 = this.intervals[n2];
          s2.stop === s2.start + 1 ? s2.start === t2.EOF ? e3.push("<EOF>") : e3.push(s2.start.toString()) : e3.push(s2.start.toString() + ".." + (s2.stop - 1).toString());
        }
        return e3.length > 1 ? "{" + e3.join(", ") + "}" : e3[0];
      }
      toTokenString(t3, e3) {
        const n2 = [];
        for (let s2 = 0; s2 < this.intervals.length; s2++) {
          const i3 = this.intervals[s2];
          for (let s3 = i3.start; s3 < i3.stop; s3++) n2.push(this.elementName(t3, e3, s3));
        }
        return n2.length > 1 ? "{" + n2.join(", ") + "}" : n2[0];
      }
      elementName(e3, n2, s2) {
        return s2 === t2.EOF ? "<EOF>" : s2 === t2.EPSILON ? "<EPSILON>" : e3[s2] || n2[s2];
      }
      get length() {
        return this.intervals.map(((t3) => t3.length)).reduce(((t3, e3) => t3 + e3));
      }
    }
    class _2 {
      constructor() {
        this.atn = null, this.stateNumber = _2.INVALID_STATE_NUMBER, this.stateType = null, this.ruleIndex = 0, this.epsilonOnlyTransitions = false, this.transitions = [], this.nextTokenWithinRule = null;
      }
      toString() {
        return this.stateNumber;
      }
      equals(t3) {
        return t3 instanceof _2 && this.stateNumber === t3.stateNumber;
      }
      isNonGreedyExitState() {
        return false;
      }
      addTransition(t3, e3) {
        void 0 === e3 && (e3 = -1), 0 === this.transitions.length ? this.epsilonOnlyTransitions = t3.isEpsilon : this.epsilonOnlyTransitions !== t3.isEpsilon && (this.epsilonOnlyTransitions = false), -1 === e3 ? this.transitions.push(t3) : this.transitions.splice(e3, 1, t3);
      }
    }
    _2.INVALID_TYPE = 0, _2.BASIC = 1, _2.RULE_START = 2, _2.BLOCK_START = 3, _2.PLUS_BLOCK_START = 4, _2.STAR_BLOCK_START = 5, _2.TOKEN_START = 6, _2.RULE_STOP = 7, _2.BLOCK_END = 8, _2.STAR_LOOP_BACK = 9, _2.STAR_LOOP_ENTRY = 10, _2.PLUS_LOOP_BACK = 11, _2.LOOP_END = 12, _2.serializationNames = ["INVALID", "BASIC", "RULE_START", "BLOCK_START", "PLUS_BLOCK_START", "STAR_BLOCK_START", "TOKEN_START", "RULE_STOP", "BLOCK_END", "STAR_LOOP_BACK", "STAR_LOOP_ENTRY", "PLUS_LOOP_BACK", "LOOP_END"], _2.INVALID_STATE_NUMBER = -1;
    class A2 extends _2 {
      constructor() {
        return super(), this.stateType = _2.RULE_STOP, this;
      }
    }
    class C2 {
      constructor(t3) {
        if (null == t3) throw "target cannot be null.";
        this.target = t3, this.isEpsilon = false, this.label = null;
      }
    }
    C2.EPSILON = 1, C2.RANGE = 2, C2.RULE = 3, C2.PREDICATE = 4, C2.ATOM = 5, C2.ACTION = 6, C2.SET = 7, C2.NOT_SET = 8, C2.WILDCARD = 9, C2.PRECEDENCE = 10, C2.serializationNames = ["INVALID", "EPSILON", "RANGE", "RULE", "PREDICATE", "ATOM", "ACTION", "SET", "NOT_SET", "WILDCARD", "PRECEDENCE"], C2.serializationTypes = { EpsilonTransition: C2.EPSILON, RangeTransition: C2.RANGE, RuleTransition: C2.RULE, PredicateTransition: C2.PREDICATE, AtomTransition: C2.ATOM, ActionTransition: C2.ACTION, SetTransition: C2.SET, NotSetTransition: C2.NOT_SET, WildcardTransition: C2.WILDCARD, PrecedencePredicateTransition: C2.PRECEDENCE };
    class N2 extends C2 {
      constructor(t3, e3, n2, s2) {
        super(t3), this.ruleIndex = e3, this.precedence = n2, this.followState = s2, this.serializationType = C2.RULE, this.isEpsilon = true;
      }
      matches(t3, e3, n2) {
        return false;
      }
    }
    class y2 extends C2 {
      constructor(e3, n2) {
        super(e3), this.serializationType = C2.SET, null != n2 ? this.label = n2 : (this.label = new E2(), this.label.addOne(t2.INVALID_TYPE));
      }
      matches(t3, e3, n2) {
        return this.label.contains(t3);
      }
      toString() {
        return this.label.toString();
      }
    }
    class I2 extends y2 {
      constructor(t3, e3) {
        super(t3, e3), this.serializationType = C2.NOT_SET;
      }
      matches(t3, e3, n2) {
        return t3 >= e3 && t3 <= n2 && !super.matches(t3, e3, n2);
      }
      toString() {
        return "~" + super.toString();
      }
    }
    class k2 extends C2 {
      constructor(t3) {
        super(t3), this.serializationType = C2.WILDCARD;
      }
      matches(t3, e3, n2) {
        return t3 >= e3 && t3 <= n2;
      }
      toString() {
        return ".";
      }
    }
    class L2 extends C2 {
      constructor(t3) {
        super(t3);
      }
    }
    class O2 {
    }
    class v2 extends O2 {
    }
    class R2 extends v2 {
    }
    class w2 extends R2 {
      get ruleContext() {
        throw new Error("missing interface implementation");
      }
    }
    class P3 extends R2 {
    }
    class b2 extends P3 {
    }
    const D2 = { toStringTree: function(t3, e3, n2) {
      e3 = e3 || null, null !== (n2 = n2 || null) && (e3 = n2.ruleNames);
      let s2 = D2.getNodeText(t3, e3);
      s2 = (function(t4, e4) {
        return t4 = t4.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r");
      })(s2);
      const i3 = t3.getChildCount();
      if (0 === i3) return s2;
      let r3 = "(" + s2 + " ";
      i3 > 0 && (s2 = D2.toStringTree(t3.getChild(0), e3), r3 = r3.concat(s2));
      for (let n3 = 1; n3 < i3; n3++) s2 = D2.toStringTree(t3.getChild(n3), e3), r3 = r3.concat(" " + s2);
      return r3 = r3.concat(")"), r3;
    }, getNodeText: function(e3, n2, s2) {
      if (n2 = n2 || null, null !== (s2 = s2 || null) && (n2 = s2.ruleNames), null !== n2) {
        if (e3 instanceof w2) {
          const t3 = e3.ruleContext.getAltNumber();
          return 0 != t3 ? n2[e3.ruleIndex] + ":" + t3 : n2[e3.ruleIndex];
        }
        if (e3 instanceof b2) return e3.toString();
        if (e3 instanceof P3 && null !== e3.symbol) return e3.symbol.text;
      }
      const i3 = e3.getPayload();
      return i3 instanceof t2 ? i3.text : e3.getPayload().toString();
    }, getChildren: function(t3) {
      const e3 = [];
      for (let n2 = 0; n2 < t3.getChildCount(); n2++) e3.push(t3.getChild(n2));
      return e3;
    }, getAncestors: function(t3) {
      let e3 = [];
      for (t3 = t3.getParent(); null !== t3; ) e3 = [t3].concat(e3), t3 = t3.getParent();
      return e3;
    }, findAllTokenNodes: function(t3, e3) {
      return D2.findAllNodes(t3, e3, true);
    }, findAllRuleNodes: function(t3, e3) {
      return D2.findAllNodes(t3, e3, false);
    }, findAllNodes: function(t3, e3, n2) {
      const s2 = [];
      return D2._findAllNodes(t3, e3, n2, s2), s2;
    }, _findAllNodes: function(t3, e3, n2, s2) {
      n2 && t3 instanceof P3 ? t3.symbol.type === e3 && s2.push(t3) : !n2 && t3 instanceof w2 && t3.ruleIndex === e3 && s2.push(t3);
      for (let i3 = 0; i3 < t3.getChildCount(); i3++) D2._findAllNodes(t3.getChild(i3), e3, n2, s2);
    }, descendants: function(t3) {
      let e3 = [t3];
      for (let n2 = 0; n2 < t3.getChildCount(); n2++) e3 = e3.concat(D2.descendants(t3.getChild(n2)));
      return e3;
    } }, F2 = D2;
    class M2 extends w2 {
      constructor(t3, e3) {
        super(), this.parentCtx = t3 || null, this.invokingState = e3 || -1;
      }
      depth() {
        let t3 = 0, e3 = this;
        for (; null !== e3; ) e3 = e3.parentCtx, t3 += 1;
        return t3;
      }
      isEmpty() {
        return -1 === this.invokingState;
      }
      getSourceInterval() {
        return m2.INVALID_INTERVAL;
      }
      get ruleContext() {
        return this;
      }
      getPayload() {
        return this;
      }
      getText() {
        return 0 === this.getChildCount() ? "" : this.children.map((function(t3) {
          return t3.getText();
        })).join("");
      }
      getAltNumber() {
        return 0;
      }
      setAltNumber(t3) {
      }
      getChild(t3) {
        return null;
      }
      getChildCount() {
        return 0;
      }
      accept(t3) {
        return t3.visitChildren(this);
      }
      toStringTree(t3, e3) {
        return F2.toStringTree(this, t3, e3);
      }
      toString(t3, e3) {
        t3 = t3 || null, e3 = e3 || null;
        let n2 = this, s2 = "[";
        for (; null !== n2 && n2 !== e3; ) {
          if (null === t3) n2.isEmpty() || (s2 += n2.invokingState);
          else {
            const e4 = n2.ruleIndex;
            s2 += e4 >= 0 && e4 < t3.length ? t3[e4] : "" + e4;
          }
          null === n2.parentCtx || null === t3 && n2.parentCtx.isEmpty() || (s2 += " "), n2 = n2.parentCtx;
        }
        return s2 += "]", s2;
      }
    }
    class U {
      constructor(t3) {
        this.cachedHashCode = t3;
      }
      isEmpty() {
        return this === U.EMPTY;
      }
      hasEmptyPath() {
        return this.getReturnState(this.length - 1) === U.EMPTY_RETURN_STATE;
      }
      hashCode() {
        return this.cachedHashCode;
      }
      updateHashCode(t3) {
        t3.update(this.cachedHashCode);
      }
    }
    U.EMPTY = null, U.EMPTY_RETURN_STATE = 2147483647, U.globalNodeCount = 1, U.id = U.globalNodeCount, U.trace_atn_sim = false;
    class B extends U {
      constructor(t3, e3) {
        const n2 = new o2();
        return n2.update(t3, e3), super(n2.finish()), this.parents = t3, this.returnStates = e3, this;
      }
      isEmpty() {
        return this.returnStates[0] === U.EMPTY_RETURN_STATE;
      }
      getParent(t3) {
        return this.parents[t3];
      }
      getReturnState(t3) {
        return this.returnStates[t3];
      }
      equals(t3) {
        return this === t3 || t3 instanceof B && this.hashCode() === t3.hashCode() && e2(this.returnStates, t3.returnStates) && e2(this.parents, t3.parents);
      }
      toString() {
        if (this.isEmpty()) return "[]";
        {
          let t3 = "[";
          for (let e3 = 0; e3 < this.returnStates.length; e3++) e3 > 0 && (t3 += ", "), this.returnStates[e3] !== U.EMPTY_RETURN_STATE ? (t3 += this.returnStates[e3], null !== this.parents[e3] ? t3 = t3 + " " + this.parents[e3] : t3 += "null") : t3 += "$";
          return t3 + "]";
        }
      }
      get length() {
        return this.returnStates.length;
      }
    }
    class V extends U {
      constructor(t3, e3) {
        let n2 = 0;
        const s2 = new o2();
        null !== t3 ? s2.update(t3, e3) : s2.update(1), n2 = s2.finish(), super(n2), this.parentCtx = t3, this.returnState = e3;
      }
      getParent(t3) {
        return this.parentCtx;
      }
      getReturnState(t3) {
        return this.returnState;
      }
      equals(t3) {
        return this === t3 || t3 instanceof V && this.hashCode() === t3.hashCode() && this.returnState === t3.returnState && (null == this.parentCtx ? null == t3.parentCtx : this.parentCtx.equals(t3.parentCtx));
      }
      toString() {
        const t3 = null === this.parentCtx ? "" : this.parentCtx.toString();
        return 0 === t3.length ? this.returnState === U.EMPTY_RETURN_STATE ? "$" : "" + this.returnState : this.returnState + " " + t3;
      }
      get length() {
        return 1;
      }
      static create(t3, e3) {
        return e3 === U.EMPTY_RETURN_STATE && null === t3 ? U.EMPTY : new V(t3, e3);
      }
    }
    class z extends V {
      constructor() {
        super(null, U.EMPTY_RETURN_STATE);
      }
      isEmpty() {
        return true;
      }
      getParent(t3) {
        return null;
      }
      getReturnState(t3) {
        return this.returnState;
      }
      equals(t3) {
        return this === t3;
      }
      toString() {
        return "$";
      }
    }
    U.EMPTY = new z();
    const q = "h-";
    class H {
      constructor(t3, e3) {
        this.data = {}, this.hashFunction = t3 || a2, this.equalsFunction = e3 || l2;
      }
      set(t3, e3) {
        const n2 = q + this.hashFunction(t3);
        if (n2 in this.data) {
          const s2 = this.data[n2];
          for (let n3 = 0; n3 < s2.length; n3++) {
            const i3 = s2[n3];
            if (this.equalsFunction(t3, i3.key)) {
              const t4 = i3.value;
              return i3.value = e3, t4;
            }
          }
          return s2.push({ key: t3, value: e3 }), e3;
        }
        return this.data[n2] = [{ key: t3, value: e3 }], e3;
      }
      containsKey(t3) {
        const e3 = q + this.hashFunction(t3);
        if (e3 in this.data) {
          const n2 = this.data[e3];
          for (let e4 = 0; e4 < n2.length; e4++) {
            const s2 = n2[e4];
            if (this.equalsFunction(t3, s2.key)) return true;
          }
        }
        return false;
      }
      get(t3) {
        const e3 = q + this.hashFunction(t3);
        if (e3 in this.data) {
          const n2 = this.data[e3];
          for (let e4 = 0; e4 < n2.length; e4++) {
            const s2 = n2[e4];
            if (this.equalsFunction(t3, s2.key)) return s2.value;
          }
        }
        return null;
      }
      entries() {
        return Object.keys(this.data).filter(((t3) => t3.startsWith(q))).flatMap(((t3) => this.data[t3]), this);
      }
      getKeys() {
        return this.entries().map(((t3) => t3.key));
      }
      getValues() {
        return this.entries().map(((t3) => t3.value));
      }
      toString() {
        return "[" + this.entries().map(((t3) => "{" + t3.key + ":" + t3.value + "}")).join(", ") + "]";
      }
      get length() {
        return Object.keys(this.data).filter(((t3) => t3.startsWith(q))).map(((t3) => this.data[t3].length), this).reduce(((t3, e3) => t3 + e3), 0);
      }
    }
    function K(t3, e3) {
      if (null == e3 && (e3 = M2.EMPTY), null === e3.parentCtx || e3 === M2.EMPTY) return U.EMPTY;
      const n2 = K(t3, e3.parentCtx), s2 = t3.states[e3.invokingState].transitions[0];
      return V.create(n2, s2.followState.stateNumber);
    }
    function Y(t3, e3, n2) {
      if (t3.isEmpty()) return t3;
      let s2 = n2.get(t3) || null;
      if (null !== s2) return s2;
      if (s2 = e3.get(t3), null !== s2) return n2.set(t3, s2), s2;
      let i3 = false, r3 = [];
      for (let s3 = 0; s3 < r3.length; s3++) {
        const o4 = Y(t3.getParent(s3), e3, n2);
        if (i3 || o4 !== t3.getParent(s3)) {
          if (!i3) {
            r3 = [];
            for (let e4 = 0; e4 < t3.length; e4++) r3[e4] = t3.getParent(e4);
            i3 = true;
          }
          r3[s3] = o4;
        }
      }
      if (!i3) return e3.add(t3), n2.set(t3, t3), t3;
      let o3 = null;
      return o3 = 0 === r3.length ? U.EMPTY : 1 === r3.length ? V.create(r3[0], t3.getReturnState(0)) : new B(r3, t3.returnStates), e3.add(o3), n2.set(o3, o3), n2.set(t3, o3), o3;
    }
    function G(t3, e3, n2, s2) {
      if (t3 === e3) return t3;
      if (t3 instanceof V && e3 instanceof V) return (function(t4, e4, n3, s3) {
        if (null !== s3) {
          let n4 = s3.get(t4, e4);
          if (null !== n4) return n4;
          if (n4 = s3.get(e4, t4), null !== n4) return n4;
        }
        const i3 = (function(t5, e5, n4) {
          if (n4) {
            if (t5 === U.EMPTY) return U.EMPTY;
            if (e5 === U.EMPTY) return U.EMPTY;
          } else {
            if (t5 === U.EMPTY && e5 === U.EMPTY) return U.EMPTY;
            if (t5 === U.EMPTY) {
              const t6 = [e5.returnState, U.EMPTY_RETURN_STATE], n5 = [e5.parentCtx, null];
              return new B(n5, t6);
            }
            if (e5 === U.EMPTY) {
              const e6 = [t5.returnState, U.EMPTY_RETURN_STATE], n5 = [t5.parentCtx, null];
              return new B(n5, e6);
            }
          }
          return null;
        })(t4, e4, n3);
        if (null !== i3) return null !== s3 && s3.set(t4, e4, i3), i3;
        if (t4.returnState === e4.returnState) {
          const i4 = G(t4.parentCtx, e4.parentCtx, n3, s3);
          if (i4 === t4.parentCtx) return t4;
          if (i4 === e4.parentCtx) return e4;
          const r3 = V.create(i4, t4.returnState);
          return null !== s3 && s3.set(t4, e4, r3), r3;
        }
        {
          let n4 = null;
          if ((t4 === e4 || null !== t4.parentCtx && t4.parentCtx === e4.parentCtx) && (n4 = t4.parentCtx), null !== n4) {
            const i5 = [t4.returnState, e4.returnState];
            t4.returnState > e4.returnState && (i5[0] = e4.returnState, i5[1] = t4.returnState);
            const r4 = new B([n4, n4], i5);
            return null !== s3 && s3.set(t4, e4, r4), r4;
          }
          const i4 = [t4.returnState, e4.returnState];
          let r3 = [t4.parentCtx, e4.parentCtx];
          t4.returnState > e4.returnState && (i4[0] = e4.returnState, i4[1] = t4.returnState, r3 = [e4.parentCtx, t4.parentCtx]);
          const o3 = new B(r3, i4);
          return null !== s3 && s3.set(t4, e4, o3), o3;
        }
      })(t3, e3, n2, s2);
      if (n2) {
        if (t3 instanceof z) return t3;
        if (e3 instanceof z) return e3;
      }
      return t3 instanceof V && (t3 = new B([t3.getParent()], [t3.returnState])), e3 instanceof V && (e3 = new B([e3.getParent()], [e3.returnState])), (function(t4, e4, n3, s3) {
        if (null !== s3) {
          let n4 = s3.get(t4, e4);
          if (null !== n4) return U.trace_atn_sim && console.log("mergeArrays a=" + t4 + ",b=" + e4 + " -> previous"), n4;
          if (n4 = s3.get(e4, t4), null !== n4) return U.trace_atn_sim && console.log("mergeArrays a=" + t4 + ",b=" + e4 + " -> previous"), n4;
        }
        let i3 = 0, r3 = 0, o3 = 0, a3 = new Array(t4.returnStates.length + e4.returnStates.length).fill(0), l3 = new Array(t4.returnStates.length + e4.returnStates.length).fill(null);
        for (; i3 < t4.returnStates.length && r3 < e4.returnStates.length; ) {
          const h4 = t4.parents[i3], c3 = e4.parents[r3];
          if (t4.returnStates[i3] === e4.returnStates[r3]) {
            const e5 = t4.returnStates[i3];
            e5 === U.EMPTY_RETURN_STATE && null === h4 && null === c3 || null !== h4 && null !== c3 && h4 === c3 ? (l3[o3] = h4, a3[o3] = e5) : (l3[o3] = G(h4, c3, n3, s3), a3[o3] = e5), i3 += 1, r3 += 1;
          } else t4.returnStates[i3] < e4.returnStates[r3] ? (l3[o3] = h4, a3[o3] = t4.returnStates[i3], i3 += 1) : (l3[o3] = c3, a3[o3] = e4.returnStates[r3], r3 += 1);
          o3 += 1;
        }
        if (i3 < t4.returnStates.length) for (let e5 = i3; e5 < t4.returnStates.length; e5++) l3[o3] = t4.parents[e5], a3[o3] = t4.returnStates[e5], o3 += 1;
        else for (let t5 = r3; t5 < e4.returnStates.length; t5++) l3[o3] = e4.parents[t5], a3[o3] = e4.returnStates[t5], o3 += 1;
        if (o3 < l3.length) {
          if (1 === o3) {
            const n4 = V.create(l3[0], a3[0]);
            return null !== s3 && s3.set(t4, e4, n4), n4;
          }
          l3 = l3.slice(0, o3), a3 = a3.slice(0, o3);
        }
        const h3 = new B(l3, a3);
        return h3.equals(t4) ? (null !== s3 && s3.set(t4, e4, t4), U.trace_atn_sim && console.log("mergeArrays a=" + t4 + ",b=" + e4 + " -> a"), t4) : h3.equals(e4) ? (null !== s3 && s3.set(t4, e4, e4), U.trace_atn_sim && console.log("mergeArrays a=" + t4 + ",b=" + e4 + " -> b"), e4) : ((function(t5) {
          const e5 = new H();
          for (let n4 = 0; n4 < t5.length; n4++) {
            const s4 = t5[n4];
            e5.containsKey(s4) || e5.set(s4, s4);
          }
          for (let n4 = 0; n4 < t5.length; n4++) t5[n4] = e5.get(t5[n4]);
        })(l3), null !== s3 && s3.set(t4, e4, h3), U.trace_atn_sim && console.log("mergeArrays a=" + t4 + ",b=" + e4 + " -> " + h3), h3);
      })(t3, e3, n2, s2);
    }
    class j {
      constructor() {
        this.data = [];
      }
      add(t3) {
        this.data[t3] = true;
      }
      or(t3) {
        Object.keys(t3.data).map(((t4) => this.add(t4)), this);
      }
      remove(t3) {
        delete this.data[t3];
      }
      has(t3) {
        return true === this.data[t3];
      }
      values() {
        return Object.keys(this.data);
      }
      minValue() {
        return Math.min.apply(null, this.values());
      }
      hashCode() {
        return o2.hashStuff(this.values());
      }
      equals(t3) {
        return t3 instanceof j && e2(this.data, t3.data);
      }
      toString() {
        return "{" + this.values().join(", ") + "}";
      }
      get length() {
        return this.values().length;
      }
    }
    class W {
      constructor(t3) {
        this.atn = t3;
      }
      getDecisionLookahead(t3) {
        if (null === t3) return null;
        const e3 = t3.transitions.length, n2 = [];
        for (let s2 = 0; s2 < e3; s2++) {
          n2[s2] = new E2();
          const e4 = new d2(), i3 = false;
          this._LOOK(t3.transition(s2).target, null, U.EMPTY, n2[s2], e4, new j(), i3, false), (0 === n2[s2].length || n2[s2].contains(W.HIT_PRED)) && (n2[s2] = null);
        }
        return n2;
      }
      LOOK(t3, e3, n2) {
        const s2 = new E2(), i3 = null !== (n2 = n2 || null) ? K(t3.atn, n2) : null;
        return this._LOOK(t3, e3, i3, s2, new d2(), new j(), true, true), s2;
      }
      _LOOK(e3, n2, s2, i3, r3, o3, a3, l3) {
        const h3 = new S2({ state: e3, alt: 0, context: s2 }, null);
        if (!r3.has(h3)) {
          if (r3.add(h3), e3 === n2) {
            if (null === s2) return void i3.addOne(t2.EPSILON);
            if (s2.isEmpty() && l3) return void i3.addOne(t2.EOF);
          }
          if (e3 instanceof A2) {
            if (null === s2) return void i3.addOne(t2.EPSILON);
            if (s2.isEmpty() && l3) return void i3.addOne(t2.EOF);
            if (s2 !== U.EMPTY) {
              const t3 = o3.has(e3.ruleIndex);
              try {
                o3.remove(e3.ruleIndex);
                for (let t4 = 0; t4 < s2.length; t4++) {
                  const e4 = this.atn.states[s2.getReturnState(t4)];
                  this._LOOK(e4, n2, s2.getParent(t4), i3, r3, o3, a3, l3);
                }
              } finally {
                t3 && o3.add(e3.ruleIndex);
              }
              return;
            }
          }
          for (let h4 = 0; h4 < e3.transitions.length; h4++) {
            const c3 = e3.transitions[h4];
            if (c3.constructor === N2) {
              if (o3.has(c3.target.ruleIndex)) continue;
              const t3 = V.create(s2, c3.followState.stateNumber);
              try {
                o3.add(c3.target.ruleIndex), this._LOOK(c3.target, n2, t3, i3, r3, o3, a3, l3);
              } finally {
                o3.remove(c3.target.ruleIndex);
              }
            } else if (c3 instanceof L2) a3 ? this._LOOK(c3.target, n2, s2, i3, r3, o3, a3, l3) : i3.addOne(W.HIT_PRED);
            else if (c3.isEpsilon) this._LOOK(c3.target, n2, s2, i3, r3, o3, a3, l3);
            else if (c3.constructor === k2) i3.addRange(t2.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
            else {
              let e4 = c3.label;
              null !== e4 && (c3 instanceof I2 && (e4 = e4.complement(t2.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType)), i3.addSet(e4));
            }
          }
        }
      }
    }
    W.HIT_PRED = t2.INVALID_TYPE;
    class $ {
      constructor(t3, e3) {
        this.grammarType = t3, this.maxTokenType = e3, this.states = [], this.decisionToState = [], this.ruleToStartState = [], this.ruleToStopState = null, this.modeNameToStartState = {}, this.ruleToTokenType = null, this.lexerActions = null, this.modeToStartState = [];
      }
      nextTokensInContext(t3, e3) {
        return new W(this).LOOK(t3, null, e3);
      }
      nextTokensNoContext(t3) {
        return null !== t3.nextTokenWithinRule || (t3.nextTokenWithinRule = this.nextTokensInContext(t3, null), t3.nextTokenWithinRule.readOnly = true), t3.nextTokenWithinRule;
      }
      nextTokens(t3, e3) {
        return void 0 === e3 ? this.nextTokensNoContext(t3) : this.nextTokensInContext(t3, e3);
      }
      addState(t3) {
        null !== t3 && (t3.atn = this, t3.stateNumber = this.states.length), this.states.push(t3);
      }
      removeState(t3) {
        this.states[t3.stateNumber] = null;
      }
      defineDecisionState(t3) {
        return this.decisionToState.push(t3), t3.decision = this.decisionToState.length - 1, t3.decision;
      }
      getDecisionState(t3) {
        return 0 === this.decisionToState.length ? null : this.decisionToState[t3];
      }
      getExpectedTokens(e3, n2) {
        if (e3 < 0 || e3 >= this.states.length) throw "Invalid state number.";
        const s2 = this.states[e3];
        let i3 = this.nextTokens(s2);
        if (!i3.contains(t2.EPSILON)) return i3;
        const r3 = new E2();
        for (r3.addSet(i3), r3.removeOne(t2.EPSILON); null !== n2 && n2.invokingState >= 0 && i3.contains(t2.EPSILON); ) {
          const e4 = this.states[n2.invokingState].transitions[0];
          i3 = this.nextTokens(e4.followState), r3.addSet(i3), r3.removeOne(t2.EPSILON), n2 = n2.parentCtx;
        }
        return i3.contains(t2.EPSILON) && r3.addOne(t2.EOF), r3;
      }
    }
    $.INVALID_ALT_NUMBER = 0;
    class X extends _2 {
      constructor() {
        super(), this.stateType = _2.BASIC;
      }
    }
    class J extends _2 {
      constructor() {
        return super(), this.decision = -1, this.nonGreedy = false, this;
      }
    }
    class Z extends J {
      constructor() {
        return super(), this.endState = null, this;
      }
    }
    class Q extends _2 {
      constructor() {
        return super(), this.stateType = _2.BLOCK_END, this.startState = null, this;
      }
    }
    class tt extends _2 {
      constructor() {
        return super(), this.stateType = _2.LOOP_END, this.loopBackState = null, this;
      }
    }
    class et extends _2 {
      constructor() {
        return super(), this.stateType = _2.RULE_START, this.stopState = null, this.isPrecedenceRule = false, this;
      }
    }
    class nt extends J {
      constructor() {
        return super(), this.stateType = _2.TOKEN_START, this;
      }
    }
    class st extends J {
      constructor() {
        return super(), this.stateType = _2.PLUS_LOOP_BACK, this;
      }
    }
    class it extends _2 {
      constructor() {
        return super(), this.stateType = _2.STAR_LOOP_BACK, this;
      }
    }
    class rt extends J {
      constructor() {
        return super(), this.stateType = _2.STAR_LOOP_ENTRY, this.loopBackState = null, this.isPrecedenceDecision = null, this;
      }
    }
    class ot extends Z {
      constructor() {
        return super(), this.stateType = _2.PLUS_BLOCK_START, this.loopBackState = null, this;
      }
    }
    class at extends Z {
      constructor() {
        return super(), this.stateType = _2.STAR_BLOCK_START, this;
      }
    }
    class lt extends Z {
      constructor() {
        return super(), this.stateType = _2.BLOCK_START, this;
      }
    }
    class ht extends C2 {
      constructor(t3, e3) {
        super(t3), this.label_ = e3, this.label = this.makeLabel(), this.serializationType = C2.ATOM;
      }
      makeLabel() {
        const t3 = new E2();
        return t3.addOne(this.label_), t3;
      }
      matches(t3, e3, n2) {
        return this.label_ === t3;
      }
      toString() {
        return this.label_;
      }
    }
    class ct extends C2 {
      constructor(t3, e3, n2) {
        super(t3), this.serializationType = C2.RANGE, this.start = e3, this.stop = n2, this.label = this.makeLabel();
      }
      makeLabel() {
        const t3 = new E2();
        return t3.addRange(this.start, this.stop), t3;
      }
      matches(t3, e3, n2) {
        return t3 >= this.start && t3 <= this.stop;
      }
      toString() {
        return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
      }
    }
    class ut extends C2 {
      constructor(t3, e3, n2, s2) {
        super(t3), this.serializationType = C2.ACTION, this.ruleIndex = e3, this.actionIndex = void 0 === n2 ? -1 : n2, this.isCtxDependent = void 0 !== s2 && s2, this.isEpsilon = true;
      }
      matches(t3, e3, n2) {
        return false;
      }
      toString() {
        return "action_" + this.ruleIndex + ":" + this.actionIndex;
      }
    }
    class dt extends C2 {
      constructor(t3, e3) {
        super(t3), this.serializationType = C2.EPSILON, this.isEpsilon = true, this.outermostPrecedenceReturn = e3;
      }
      matches(t3, e3, n2) {
        return false;
      }
      toString() {
        return "epsilon";
      }
    }
    class pt extends p2 {
      constructor(t3, e3, n2) {
        super(), this.ruleIndex = void 0 === t3 ? -1 : t3, this.predIndex = void 0 === e3 ? -1 : e3, this.isCtxDependent = void 0 !== n2 && n2;
      }
      evaluate(t3, e3) {
        const n2 = this.isCtxDependent ? e3 : null;
        return t3.sempred(n2, this.ruleIndex, this.predIndex);
      }
      updateHashCode(t3) {
        t3.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
      }
      equals(t3) {
        return this === t3 || t3 instanceof pt && this.ruleIndex === t3.ruleIndex && this.predIndex === t3.predIndex && this.isCtxDependent === t3.isCtxDependent;
      }
      toString() {
        return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
      }
    }
    p2.NONE = new pt();
    class gt extends L2 {
      constructor(t3, e3, n2, s2) {
        super(t3), this.serializationType = C2.PREDICATE, this.ruleIndex = e3, this.predIndex = n2, this.isCtxDependent = s2, this.isEpsilon = true;
      }
      matches(t3, e3, n2) {
        return false;
      }
      getPredicate() {
        return new pt(this.ruleIndex, this.predIndex, this.isCtxDependent);
      }
      toString() {
        return "pred_" + this.ruleIndex + ":" + this.predIndex;
      }
    }
    class ft extends p2 {
      constructor(t3) {
        super(), this.precedence = void 0 === t3 ? 0 : t3;
      }
      evaluate(t3, e3) {
        return t3.precpred(e3, this.precedence);
      }
      evalPrecedence(t3, e3) {
        return t3.precpred(e3, this.precedence) ? p2.NONE : null;
      }
      compareTo(t3) {
        return this.precedence - t3.precedence;
      }
      updateHashCode(t3) {
        t3.update(this.precedence);
      }
      equals(t3) {
        return this === t3 || t3 instanceof ft && this.precedence === t3.precedence;
      }
      toString() {
        return "{" + this.precedence + ">=prec}?";
      }
    }
    p2.PrecedencePredicate = ft;
    class xt extends L2 {
      constructor(t3, e3) {
        super(t3), this.serializationType = C2.PRECEDENCE, this.precedence = e3, this.isEpsilon = true;
      }
      matches(t3, e3, n2) {
        return false;
      }
      getPredicate() {
        return new ft(this.precedence);
      }
      toString() {
        return this.precedence + " >= _p";
      }
    }
    class Tt {
      constructor(t3) {
        void 0 === t3 && (t3 = null), this.readOnly = false, this.verifyATN = null === t3 || t3.verifyATN, this.generateRuleBypassTransitions = null !== t3 && t3.generateRuleBypassTransitions;
      }
    }
    Tt.defaultOptions = new Tt(), Tt.defaultOptions.readOnly = true;
    class St {
      constructor(t3) {
        this.actionType = t3, this.isPositionDependent = false;
      }
      hashCode() {
        const t3 = new o2();
        return this.updateHashCode(t3), t3.finish();
      }
      updateHashCode(t3) {
        t3.update(this.actionType);
      }
      equals(t3) {
        return this === t3;
      }
    }
    class mt extends St {
      constructor() {
        super(6);
      }
      execute(t3) {
        t3.skip();
      }
      toString() {
        return "skip";
      }
    }
    mt.INSTANCE = new mt();
    class Et extends St {
      constructor(t3) {
        super(0), this.channel = t3;
      }
      execute(t3) {
        t3._channel = this.channel;
      }
      updateHashCode(t3) {
        t3.update(this.actionType, this.channel);
      }
      equals(t3) {
        return this === t3 || t3 instanceof Et && this.channel === t3.channel;
      }
      toString() {
        return "channel(" + this.channel + ")";
      }
    }
    class _t extends St {
      constructor(t3, e3) {
        super(1), this.ruleIndex = t3, this.actionIndex = e3, this.isPositionDependent = true;
      }
      execute(t3) {
        t3.action(null, this.ruleIndex, this.actionIndex);
      }
      updateHashCode(t3) {
        t3.update(this.actionType, this.ruleIndex, this.actionIndex);
      }
      equals(t3) {
        return this === t3 || t3 instanceof _t && this.ruleIndex === t3.ruleIndex && this.actionIndex === t3.actionIndex;
      }
    }
    class At extends St {
      constructor() {
        super(3);
      }
      execute(t3) {
        t3.more();
      }
      toString() {
        return "more";
      }
    }
    At.INSTANCE = new At();
    class Ct extends St {
      constructor(t3) {
        super(7), this.type = t3;
      }
      execute(t3) {
        t3.type = this.type;
      }
      updateHashCode(t3) {
        t3.update(this.actionType, this.type);
      }
      equals(t3) {
        return this === t3 || t3 instanceof Ct && this.type === t3.type;
      }
      toString() {
        return "type(" + this.type + ")";
      }
    }
    class Nt extends St {
      constructor(t3) {
        super(5), this.mode = t3;
      }
      execute(t3) {
        t3.pushMode(this.mode);
      }
      updateHashCode(t3) {
        t3.update(this.actionType, this.mode);
      }
      equals(t3) {
        return this === t3 || t3 instanceof Nt && this.mode === t3.mode;
      }
      toString() {
        return "pushMode(" + this.mode + ")";
      }
    }
    class yt extends St {
      constructor() {
        super(4);
      }
      execute(t3) {
        t3.popMode();
      }
      toString() {
        return "popMode";
      }
    }
    yt.INSTANCE = new yt();
    class It extends St {
      constructor(t3) {
        super(2), this.mode = t3;
      }
      execute(t3) {
        t3.mode(this.mode);
      }
      updateHashCode(t3) {
        t3.update(this.actionType, this.mode);
      }
      equals(t3) {
        return this === t3 || t3 instanceof It && this.mode === t3.mode;
      }
      toString() {
        return "mode(" + this.mode + ")";
      }
    }
    function kt(t3, e3) {
      const n2 = [];
      return n2[t3 - 1] = e3, n2.map((function(t4) {
        return e3;
      }));
    }
    class Lt {
      constructor(t3) {
        null == t3 && (t3 = Tt.defaultOptions), this.deserializationOptions = t3, this.stateFactories = null, this.actionFactories = null;
      }
      deserialize(t3) {
        const e3 = this.reset(t3);
        this.checkVersion(e3), e3 && this.skipUUID();
        const n2 = this.readATN();
        this.readStates(n2, e3), this.readRules(n2, e3), this.readModes(n2);
        const s2 = [];
        return this.readSets(n2, s2, this.readInt.bind(this)), e3 && this.readSets(n2, s2, this.readInt32.bind(this)), this.readEdges(n2, s2), this.readDecisions(n2), this.readLexerActions(n2, e3), this.markPrecedenceDecisions(n2), this.verifyATN(n2), this.deserializationOptions.generateRuleBypassTransitions && 1 === n2.grammarType && (this.generateRuleBypassTransitions(n2), this.verifyATN(n2)), n2;
      }
      reset(t3) {
        if (3 === (t3.charCodeAt ? t3.charCodeAt(0) : t3[0])) {
          const e3 = function(t4) {
            const e4 = t4.charCodeAt(0);
            return e4 > 1 ? e4 - 2 : e4 + 65534;
          }, n2 = t3.split("").map(e3);
          return n2[0] = t3.charCodeAt(0), this.data = n2, this.pos = 0, true;
        }
        return this.data = t3, this.pos = 0, false;
      }
      skipUUID() {
        let t3 = 0;
        for (; t3++ < 8; ) this.readInt();
      }
      checkVersion(t3) {
        const e3 = this.readInt();
        if (!t3 && 4 !== e3) throw "Could not deserialize ATN with version " + e3 + " (expected 4).";
      }
      readATN() {
        const t3 = this.readInt(), e3 = this.readInt();
        return new $(t3, e3);
      }
      readStates(t3, e3) {
        let n2, s2, i3;
        const r3 = [], o3 = [], a3 = this.readInt();
        for (let n3 = 0; n3 < a3; n3++) {
          const n4 = this.readInt();
          if (n4 === _2.INVALID_TYPE) {
            t3.addState(null);
            continue;
          }
          let s3 = this.readInt();
          e3 && 65535 === s3 && (s3 = -1);
          const i4 = this.stateFactory(n4, s3);
          if (n4 === _2.LOOP_END) {
            const t4 = this.readInt();
            r3.push([i4, t4]);
          } else if (i4 instanceof Z) {
            const t4 = this.readInt();
            o3.push([i4, t4]);
          }
          t3.addState(i4);
        }
        for (n2 = 0; n2 < r3.length; n2++) s2 = r3[n2], s2[0].loopBackState = t3.states[s2[1]];
        for (n2 = 0; n2 < o3.length; n2++) s2 = o3[n2], s2[0].endState = t3.states[s2[1]];
        let l3 = this.readInt();
        for (n2 = 0; n2 < l3; n2++) i3 = this.readInt(), t3.states[i3].nonGreedy = true;
        let h3 = this.readInt();
        for (n2 = 0; n2 < h3; n2++) i3 = this.readInt(), t3.states[i3].isPrecedenceRule = true;
      }
      readRules(e3, n2) {
        let s2;
        const i3 = this.readInt();
        for (0 === e3.grammarType && (e3.ruleToTokenType = kt(i3, 0)), e3.ruleToStartState = kt(i3, 0), s2 = 0; s2 < i3; s2++) {
          const i4 = this.readInt();
          if (e3.ruleToStartState[s2] = e3.states[i4], 0 === e3.grammarType) {
            let i5 = this.readInt();
            n2 && 65535 === i5 && (i5 = t2.EOF), e3.ruleToTokenType[s2] = i5;
          }
        }
        for (e3.ruleToStopState = kt(i3, 0), s2 = 0; s2 < e3.states.length; s2++) {
          const t3 = e3.states[s2];
          t3 instanceof A2 && (e3.ruleToStopState[t3.ruleIndex] = t3, e3.ruleToStartState[t3.ruleIndex].stopState = t3);
        }
      }
      readModes(t3) {
        const e3 = this.readInt();
        for (let n2 = 0; n2 < e3; n2++) {
          let e4 = this.readInt();
          t3.modeToStartState.push(t3.states[e4]);
        }
      }
      readSets(t3, e3, n2) {
        const s2 = this.readInt();
        for (let t4 = 0; t4 < s2; t4++) {
          const t5 = new E2();
          e3.push(t5);
          const s3 = this.readInt();
          0 !== this.readInt() && t5.addOne(-1);
          for (let e4 = 0; e4 < s3; e4++) {
            const e5 = n2(), s4 = n2();
            t5.addRange(e5, s4);
          }
        }
      }
      readEdges(t3, e3) {
        let n2, s2, i3, r3, o3;
        const a3 = this.readInt();
        for (n2 = 0; n2 < a3; n2++) {
          const n3 = this.readInt(), s3 = this.readInt(), i4 = this.readInt(), o4 = this.readInt(), a4 = this.readInt(), l3 = this.readInt();
          r3 = this.edgeFactory(t3, i4, n3, s3, o4, a4, l3, e3), t3.states[n3].addTransition(r3);
        }
        for (n2 = 0; n2 < t3.states.length; n2++) for (i3 = t3.states[n2], s2 = 0; s2 < i3.transitions.length; s2++) {
          const e4 = i3.transitions[s2];
          if (!(e4 instanceof N2)) continue;
          let n3 = -1;
          t3.ruleToStartState[e4.target.ruleIndex].isPrecedenceRule && 0 === e4.precedence && (n3 = e4.target.ruleIndex), r3 = new dt(e4.followState, n3), t3.ruleToStopState[e4.target.ruleIndex].addTransition(r3);
        }
        for (n2 = 0; n2 < t3.states.length; n2++) {
          if (i3 = t3.states[n2], i3 instanceof Z) {
            if (null === i3.endState) throw "IllegalState";
            if (null !== i3.endState.startState) throw "IllegalState";
            i3.endState.startState = i3;
          }
          if (i3 instanceof st) for (s2 = 0; s2 < i3.transitions.length; s2++) o3 = i3.transitions[s2].target, o3 instanceof ot && (o3.loopBackState = i3);
          else if (i3 instanceof it) for (s2 = 0; s2 < i3.transitions.length; s2++) o3 = i3.transitions[s2].target, o3 instanceof rt && (o3.loopBackState = i3);
        }
      }
      readDecisions(t3) {
        const e3 = this.readInt();
        for (let n2 = 0; n2 < e3; n2++) {
          const e4 = this.readInt(), s2 = t3.states[e4];
          t3.decisionToState.push(s2), s2.decision = n2;
        }
      }
      readLexerActions(t3, e3) {
        if (0 === t3.grammarType) {
          const n2 = this.readInt();
          t3.lexerActions = kt(n2, null);
          for (let s2 = 0; s2 < n2; s2++) {
            const n3 = this.readInt();
            let i3 = this.readInt();
            e3 && 65535 === i3 && (i3 = -1);
            let r3 = this.readInt();
            e3 && 65535 === r3 && (r3 = -1), t3.lexerActions[s2] = this.lexerActionFactory(n3, i3, r3);
          }
        }
      }
      generateRuleBypassTransitions(t3) {
        let e3;
        const n2 = t3.ruleToStartState.length;
        for (e3 = 0; e3 < n2; e3++) t3.ruleToTokenType[e3] = t3.maxTokenType + e3 + 1;
        for (e3 = 0; e3 < n2; e3++) this.generateRuleBypassTransition(t3, e3);
      }
      generateRuleBypassTransition(t3, e3) {
        let n2, s2;
        const i3 = new lt();
        i3.ruleIndex = e3, t3.addState(i3);
        const r3 = new Q();
        r3.ruleIndex = e3, t3.addState(r3), i3.endState = r3, t3.defineDecisionState(i3), r3.startState = i3;
        let o3 = null, a3 = null;
        if (t3.ruleToStartState[e3].isPrecedenceRule) {
          for (a3 = null, n2 = 0; n2 < t3.states.length; n2++) if (s2 = t3.states[n2], this.stateIsEndStateFor(s2, e3)) {
            a3 = s2, o3 = s2.loopBackState.transitions[0];
            break;
          }
          if (null === o3) throw "Couldn't identify final state of the precedence rule prefix section.";
        } else a3 = t3.ruleToStopState[e3];
        for (n2 = 0; n2 < t3.states.length; n2++) {
          s2 = t3.states[n2];
          for (let t4 = 0; t4 < s2.transitions.length; t4++) {
            const e4 = s2.transitions[t4];
            e4 !== o3 && e4.target === a3 && (e4.target = r3);
          }
        }
        const l3 = t3.ruleToStartState[e3], h3 = l3.transitions.length;
        for (; h3 > 0; ) i3.addTransition(l3.transitions[h3 - 1]), l3.transitions = l3.transitions.slice(-1);
        t3.ruleToStartState[e3].addTransition(new dt(i3)), r3.addTransition(new dt(a3));
        const c3 = new X();
        t3.addState(c3), c3.addTransition(new ht(r3, t3.ruleToTokenType[e3])), i3.addTransition(new dt(c3));
      }
      stateIsEndStateFor(t3, e3) {
        if (t3.ruleIndex !== e3) return null;
        if (!(t3 instanceof rt)) return null;
        const n2 = t3.transitions[t3.transitions.length - 1].target;
        return n2 instanceof tt && n2.epsilonOnlyTransitions && n2.transitions[0].target instanceof A2 ? t3 : null;
      }
      markPrecedenceDecisions(t3) {
        for (let e3 = 0; e3 < t3.states.length; e3++) {
          const n2 = t3.states[e3];
          if (n2 instanceof rt && t3.ruleToStartState[n2.ruleIndex].isPrecedenceRule) {
            const t4 = n2.transitions[n2.transitions.length - 1].target;
            t4 instanceof tt && t4.epsilonOnlyTransitions && t4.transitions[0].target instanceof A2 && (n2.isPrecedenceDecision = true);
          }
        }
      }
      verifyATN(t3) {
        if (this.deserializationOptions.verifyATN) for (let e3 = 0; e3 < t3.states.length; e3++) {
          const n2 = t3.states[e3];
          if (null !== n2) if (this.checkCondition(n2.epsilonOnlyTransitions || n2.transitions.length <= 1), n2 instanceof ot) this.checkCondition(null !== n2.loopBackState);
          else if (n2 instanceof rt) if (this.checkCondition(null !== n2.loopBackState), this.checkCondition(2 === n2.transitions.length), n2.transitions[0].target instanceof at) this.checkCondition(n2.transitions[1].target instanceof tt), this.checkCondition(!n2.nonGreedy);
          else {
            if (!(n2.transitions[0].target instanceof tt)) throw "IllegalState";
            this.checkCondition(n2.transitions[1].target instanceof at), this.checkCondition(n2.nonGreedy);
          }
          else n2 instanceof it ? (this.checkCondition(1 === n2.transitions.length), this.checkCondition(n2.transitions[0].target instanceof rt)) : n2 instanceof tt ? this.checkCondition(null !== n2.loopBackState) : n2 instanceof et ? this.checkCondition(null !== n2.stopState) : n2 instanceof Z ? this.checkCondition(null !== n2.endState) : n2 instanceof Q ? this.checkCondition(null !== n2.startState) : n2 instanceof J ? this.checkCondition(n2.transitions.length <= 1 || n2.decision >= 0) : this.checkCondition(n2.transitions.length <= 1 || n2 instanceof A2);
        }
      }
      checkCondition(t3, e3) {
        if (!t3) throw null == e3 && (e3 = "IllegalState"), e3;
      }
      readInt() {
        return this.data[this.pos++];
      }
      readInt32() {
        return this.readInt() | this.readInt() << 16;
      }
      edgeFactory(e3, n2, s2, i3, r3, o3, a3, l3) {
        const h3 = e3.states[i3];
        switch (n2) {
          case C2.EPSILON:
            return new dt(h3);
          case C2.RANGE:
            return new ct(h3, 0 !== a3 ? t2.EOF : r3, o3);
          case C2.RULE:
            return new N2(e3.states[r3], o3, a3, h3);
          case C2.PREDICATE:
            return new gt(h3, r3, o3, 0 !== a3);
          case C2.PRECEDENCE:
            return new xt(h3, r3);
          case C2.ATOM:
            return new ht(h3, 0 !== a3 ? t2.EOF : r3);
          case C2.ACTION:
            return new ut(h3, r3, o3, 0 !== a3);
          case C2.SET:
            return new y2(h3, l3[r3]);
          case C2.NOT_SET:
            return new I2(h3, l3[r3]);
          case C2.WILDCARD:
            return new k2(h3);
          default:
            throw "The specified transition type: " + n2 + " is not valid.";
        }
      }
      stateFactory(t3, e3) {
        if (null === this.stateFactories) {
          const t4 = [];
          t4[_2.INVALID_TYPE] = null, t4[_2.BASIC] = () => new X(), t4[_2.RULE_START] = () => new et(), t4[_2.BLOCK_START] = () => new lt(), t4[_2.PLUS_BLOCK_START] = () => new ot(), t4[_2.STAR_BLOCK_START] = () => new at(), t4[_2.TOKEN_START] = () => new nt(), t4[_2.RULE_STOP] = () => new A2(), t4[_2.BLOCK_END] = () => new Q(), t4[_2.STAR_LOOP_BACK] = () => new it(), t4[_2.STAR_LOOP_ENTRY] = () => new rt(), t4[_2.PLUS_LOOP_BACK] = () => new st(), t4[_2.LOOP_END] = () => new tt(), this.stateFactories = t4;
        }
        if (t3 > this.stateFactories.length || null === this.stateFactories[t3]) throw "The specified state type " + t3 + " is not valid.";
        {
          const n2 = this.stateFactories[t3]();
          if (null !== n2) return n2.ruleIndex = e3, n2;
        }
      }
      lexerActionFactory(t3, e3, n2) {
        if (null === this.actionFactories) {
          const t4 = [];
          t4[0] = (t5, e4) => new Et(t5), t4[1] = (t5, e4) => new _t(t5, e4), t4[2] = (t5, e4) => new It(t5), t4[3] = (t5, e4) => At.INSTANCE, t4[4] = (t5, e4) => yt.INSTANCE, t4[5] = (t5, e4) => new Nt(t5), t4[6] = (t5, e4) => mt.INSTANCE, t4[7] = (t5, e4) => new Ct(t5), this.actionFactories = t4;
        }
        if (t3 > this.actionFactories.length || null === this.actionFactories[t3]) throw "The specified lexer action type " + t3 + " is not valid.";
        return this.actionFactories[t3](e3, n2);
      }
    }
    class Ot {
      syntaxError(t3, e3, n2, s2, i3, r3) {
      }
      reportAmbiguity(t3, e3, n2, s2, i3, r3, o3) {
      }
      reportAttemptingFullContext(t3, e3, n2, s2, i3, r3) {
      }
      reportContextSensitivity(t3, e3, n2, s2, i3, r3) {
      }
    }
    class vt extends Ot {
      constructor() {
        super();
      }
      syntaxError(t3, e3, n2, s2, i3, r3) {
        console.error("line " + n2 + ":" + s2 + " " + i3);
      }
    }
    vt.INSTANCE = new vt();
    class Rt extends Ot {
      constructor(t3) {
        if (super(), null === t3) throw "delegates";
        return this.delegates = t3, this;
      }
      syntaxError(t3, e3, n2, s2, i3, r3) {
        this.delegates.map(((o3) => o3.syntaxError(t3, e3, n2, s2, i3, r3)));
      }
      reportAmbiguity(t3, e3, n2, s2, i3, r3, o3) {
        this.delegates.map(((a3) => a3.reportAmbiguity(t3, e3, n2, s2, i3, r3, o3)));
      }
      reportAttemptingFullContext(t3, e3, n2, s2, i3, r3) {
        this.delegates.map(((o3) => o3.reportAttemptingFullContext(t3, e3, n2, s2, i3, r3)));
      }
      reportContextSensitivity(t3, e3, n2, s2, i3, r3) {
        this.delegates.map(((o3) => o3.reportContextSensitivity(t3, e3, n2, s2, i3, r3)));
      }
    }
    class wt {
      constructor() {
        this._listeners = [vt.INSTANCE], this._interp = null, this._stateNumber = -1;
      }
      checkVersion(t3) {
        const e3 = "4.13.1";
        e3 !== t3 && console.log("ANTLR runtime and generated code versions disagree: " + e3 + "!=" + t3);
      }
      addErrorListener(t3) {
        this._listeners.push(t3);
      }
      removeErrorListeners() {
        this._listeners = [];
      }
      getLiteralNames() {
        return Object.getPrototypeOf(this).constructor.literalNames || [];
      }
      getSymbolicNames() {
        return Object.getPrototypeOf(this).constructor.symbolicNames || [];
      }
      getTokenNames() {
        if (!this.tokenNames) {
          const t3 = this.getLiteralNames(), e3 = this.getSymbolicNames(), n2 = t3.length > e3.length ? t3.length : e3.length;
          this.tokenNames = [];
          for (let s2 = 0; s2 < n2; s2++) this.tokenNames[s2] = t3[s2] || e3[s2] || "<INVALID";
        }
        return this.tokenNames;
      }
      getTokenTypeMap() {
        const e3 = this.getTokenNames();
        if (null === e3) throw "The current recognizer does not provide a list of token names.";
        let n2 = this.tokenTypeMapCache[e3];
        return void 0 === n2 && (n2 = e3.reduce((function(t3, e4, n3) {
          t3[e4] = n3;
        })), n2.EOF = t2.EOF, this.tokenTypeMapCache[e3] = n2), n2;
      }
      getRuleIndexMap() {
        const t3 = this.ruleNames;
        if (null === t3) throw "The current recognizer does not provide a list of rule names.";
        let e3 = this.ruleIndexMapCache[t3];
        return void 0 === e3 && (e3 = t3.reduce((function(t4, e4, n2) {
          t4[e4] = n2;
        })), this.ruleIndexMapCache[t3] = e3), e3;
      }
      getTokenType(e3) {
        const n2 = this.getTokenTypeMap()[e3];
        return void 0 !== n2 ? n2 : t2.INVALID_TYPE;
      }
      getErrorHeader(t3) {
        return "line " + t3.getOffendingToken().line + ":" + t3.getOffendingToken().column;
      }
      getTokenErrorDisplay(e3) {
        if (null === e3) return "<no token>";
        let n2 = e3.text;
        return null === n2 && (n2 = e3.type === t2.EOF ? "<EOF>" : "<" + e3.type + ">"), n2 = n2.replace("\n", "\\n").replace("\r", "\\r").replace("	", "\\t"), "'" + n2 + "'";
      }
      getErrorListenerDispatch() {
        return new Rt(this._listeners);
      }
      sempred(t3, e3, n2) {
        return true;
      }
      precpred(t3, e3) {
        return true;
      }
      get atn() {
        return this._interp.atn;
      }
      get state() {
        return this._stateNumber;
      }
      set state(t3) {
        this._stateNumber = t3;
      }
    }
    wt.tokenTypeMapCache = {}, wt.ruleIndexMapCache = {};
    class Pt extends t2 {
      constructor(e3, n2, s2, i3, r3) {
        super(), this.source = void 0 !== e3 ? e3 : Pt.EMPTY_SOURCE, this.type = void 0 !== n2 ? n2 : null, this.channel = void 0 !== s2 ? s2 : t2.DEFAULT_CHANNEL, this.start = void 0 !== i3 ? i3 : -1, this.stop = void 0 !== r3 ? r3 : -1, this.tokenIndex = -1, null !== this.source[0] ? (this.line = e3[0].line, this.column = e3[0].column) : this.column = -1;
      }
      clone() {
        const t3 = new Pt(this.source, this.type, this.channel, this.start, this.stop);
        return t3.tokenIndex = this.tokenIndex, t3.line = this.line, t3.column = this.column, t3.text = this.text, t3;
      }
      cloneWithType(e3) {
        const n2 = new Pt(this.source, e3, this.channel, this.start, this.stop);
        return n2.tokenIndex = this.tokenIndex, n2.line = this.line, n2.column = this.column, e3 === t2.EOF && (n2.text = ""), n2;
      }
      toString() {
        let t3 = this.text;
        return t3 = null !== t3 ? t3.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t") : "<no text>", "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + t3 + "',<" + this.type + ">" + (this.channel > 0 ? ",channel=" + this.channel : "") + "," + this.line + ":" + this.column + "]";
      }
      get text() {
        if (null !== this._text) return this._text;
        const t3 = this.getInputStream();
        if (null === t3) return null;
        const e3 = t3.size;
        return this.start < e3 && this.stop < e3 ? t3.getText(this.start, this.stop) : "<EOF>";
      }
      set text(t3) {
        this._text = t3;
      }
    }
    Pt.EMPTY_SOURCE = [null, null];
    class bt {
    }
    class Dt extends bt {
      constructor(t3) {
        super(), this.copyText = void 0 !== t3 && t3;
      }
      create(t3, e3, n2, s2, i3, r3, o3, a3) {
        const l3 = new Pt(t3, e3, s2, i3, r3);
        return l3.line = o3, l3.column = a3, null !== n2 ? l3.text = n2 : this.copyText && null !== t3[1] && (l3.text = t3[1].getText(i3, r3)), l3;
      }
      createThin(t3, e3) {
        const n2 = new Pt(null, t3);
        return n2.text = e3, n2;
      }
    }
    Dt.DEFAULT = new Dt();
    class Ft extends Error {
      constructor(t3) {
        super(t3.message), Error.captureStackTrace && Error.captureStackTrace(this, Ft), this.message = t3.message, this.recognizer = t3.recognizer, this.input = t3.input, this.ctx = t3.ctx, this.offendingToken = null, this.offendingState = -1, null !== this.recognizer && (this.offendingState = this.recognizer.state);
      }
      getExpectedTokens() {
        return null !== this.recognizer ? this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx) : null;
      }
      toString() {
        return this.message;
      }
    }
    class Mt extends Ft {
      constructor(t3, e3, n2, s2) {
        super({ message: "", recognizer: t3, input: e3, ctx: null }), this.startIndex = n2, this.deadEndConfigs = s2;
      }
      toString() {
        let t3 = "";
        return this.startIndex >= 0 && this.startIndex < this.input.size && (t3 = this.input.getText(new m2(this.startIndex, this.startIndex))), "LexerNoViableAltException" + t3;
      }
    }
    class Ut extends wt {
      constructor(e3) {
        super(), this._input = e3, this._factory = Dt.DEFAULT, this._tokenFactorySourcePair = [this, e3], this._interp = null, this._token = null, this._tokenStartCharIndex = -1, this._tokenStartLine = -1, this._tokenStartColumn = -1, this._hitEOF = false, this._channel = t2.DEFAULT_CHANNEL, this._type = t2.INVALID_TYPE, this._modeStack = [], this._mode = Ut.DEFAULT_MODE, this._text = null;
      }
      reset() {
        null !== this._input && this._input.seek(0), this._token = null, this._type = t2.INVALID_TYPE, this._channel = t2.DEFAULT_CHANNEL, this._tokenStartCharIndex = -1, this._tokenStartColumn = -1, this._tokenStartLine = -1, this._text = null, this._hitEOF = false, this._mode = Ut.DEFAULT_MODE, this._modeStack = [], this._interp.reset();
      }
      nextToken() {
        if (null === this._input) throw "nextToken requires a non-null input stream.";
        const e3 = this._input.mark();
        try {
          for (; ; ) {
            if (this._hitEOF) return this.emitEOF(), this._token;
            this._token = null, this._channel = t2.DEFAULT_CHANNEL, this._tokenStartCharIndex = this._input.index, this._tokenStartColumn = this._interp.column, this._tokenStartLine = this._interp.line, this._text = null;
            let e4 = false;
            for (; ; ) {
              this._type = t2.INVALID_TYPE;
              let n2 = Ut.SKIP;
              try {
                n2 = this._interp.match(this._input, this._mode);
              } catch (t3) {
                if (!(t3 instanceof Ft)) throw console.log(t3.stack), t3;
                this.notifyListeners(t3), this.recover(t3);
              }
              if (this._input.LA(1) === t2.EOF && (this._hitEOF = true), this._type === t2.INVALID_TYPE && (this._type = n2), this._type === Ut.SKIP) {
                e4 = true;
                break;
              }
              if (this._type !== Ut.MORE) break;
            }
            if (!e4) return null === this._token && this.emit(), this._token;
          }
        } finally {
          this._input.release(e3);
        }
      }
      skip() {
        this._type = Ut.SKIP;
      }
      more() {
        this._type = Ut.MORE;
      }
      mode(t3) {
        this._mode = t3;
      }
      pushMode(t3) {
        this._interp.debug && console.log("pushMode " + t3), this._modeStack.push(this._mode), this.mode(t3);
      }
      popMode() {
        if (0 === this._modeStack.length) throw "Empty Stack";
        return this._interp.debug && console.log("popMode back to " + this._modeStack.slice(0, -1)), this.mode(this._modeStack.pop()), this._mode;
      }
      emitToken(t3) {
        this._token = t3;
      }
      emit() {
        const t3 = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.getCharIndex() - 1, this._tokenStartLine, this._tokenStartColumn);
        return this.emitToken(t3), t3;
      }
      emitEOF() {
        const e3 = this.column, n2 = this.line, s2 = this._factory.create(this._tokenFactorySourcePair, t2.EOF, null, t2.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, n2, e3);
        return this.emitToken(s2), s2;
      }
      getCharIndex() {
        return this._input.index;
      }
      getAllTokens() {
        const e3 = [];
        let n2 = this.nextToken();
        for (; n2.type !== t2.EOF; ) e3.push(n2), n2 = this.nextToken();
        return e3;
      }
      notifyListeners(t3) {
        const e3 = this._tokenStartCharIndex, n2 = this._input.index, s2 = this._input.getText(e3, n2), i3 = "token recognition error at: '" + this.getErrorDisplay(s2) + "'";
        this.getErrorListenerDispatch().syntaxError(this, null, this._tokenStartLine, this._tokenStartColumn, i3, t3);
      }
      getErrorDisplay(t3) {
        const e3 = [];
        for (let n2 = 0; n2 < t3.length; n2++) e3.push(t3[n2]);
        return e3.join("");
      }
      getErrorDisplayForChar(e3) {
        return e3.charCodeAt(0) === t2.EOF ? "<EOF>" : "\n" === e3 ? "\\n" : "	" === e3 ? "\\t" : "\r" === e3 ? "\\r" : e3;
      }
      getCharErrorDisplay(t3) {
        return "'" + this.getErrorDisplayForChar(t3) + "'";
      }
      recover(e3) {
        this._input.LA(1) !== t2.EOF && (e3 instanceof Mt ? this._interp.consume(this._input) : this._input.consume());
      }
      get inputStream() {
        return this._input;
      }
      set inputStream(t3) {
        this._input = null, this._tokenFactorySourcePair = [this, this._input], this.reset(), this._input = t3, this._tokenFactorySourcePair = [this, this._input];
      }
      get sourceName() {
        return this._input.sourceName;
      }
      get type() {
        return this._type;
      }
      set type(t3) {
        this._type = t3;
      }
      get line() {
        return this._interp.line;
      }
      set line(t3) {
        this._interp.line = t3;
      }
      get column() {
        return this._interp.column;
      }
      set column(t3) {
        this._interp.column = t3;
      }
      get text() {
        return null !== this._text ? this._text : this._interp.getText(this._input);
      }
      set text(t3) {
        this._text = t3;
      }
    }
    function Bt(t3) {
      return t3.hashCodeForConfigSet();
    }
    function Vt(t3, e3) {
      return t3 === e3 || null !== t3 && null !== e3 && t3.equalsForConfigSet(e3);
    }
    Ut.DEFAULT_MODE = 0, Ut.MORE = -2, Ut.SKIP = -3, Ut.DEFAULT_TOKEN_CHANNEL = t2.DEFAULT_CHANNEL, Ut.HIDDEN = t2.HIDDEN_CHANNEL, Ut.MIN_CHAR_VALUE = 0, Ut.MAX_CHAR_VALUE = 1114111;
    class zt {
      constructor(t3) {
        this.configLookup = new d2(Bt, Vt), this.fullCtx = void 0 === t3 || t3, this.readOnly = false, this.configs = [], this.uniqueAlt = 0, this.conflictingAlts = null, this.hasSemanticContext = false, this.dipsIntoOuterContext = false, this.cachedHashCode = -1;
      }
      add(t3, e3) {
        if (void 0 === e3 && (e3 = null), this.readOnly) throw "This set is readonly";
        t3.semanticContext !== p2.NONE && (this.hasSemanticContext = true), t3.reachesIntoOuterContext > 0 && (this.dipsIntoOuterContext = true);
        const n2 = this.configLookup.add(t3);
        if (n2 === t3) return this.cachedHashCode = -1, this.configs.push(t3), true;
        const s2 = !this.fullCtx, i3 = G(n2.context, t3.context, s2, e3);
        return n2.reachesIntoOuterContext = Math.max(n2.reachesIntoOuterContext, t3.reachesIntoOuterContext), t3.precedenceFilterSuppressed && (n2.precedenceFilterSuppressed = true), n2.context = i3, true;
      }
      getStates() {
        const t3 = new d2();
        for (let e3 = 0; e3 < this.configs.length; e3++) t3.add(this.configs[e3].state);
        return t3;
      }
      getPredicates() {
        const t3 = [];
        for (let e3 = 0; e3 < this.configs.length; e3++) {
          const n2 = this.configs[e3].semanticContext;
          n2 !== p2.NONE && t3.push(n2.semanticContext);
        }
        return t3;
      }
      optimizeConfigs(t3) {
        if (this.readOnly) throw "This set is readonly";
        if (0 !== this.configLookup.length) for (let e3 = 0; e3 < this.configs.length; e3++) {
          const n2 = this.configs[e3];
          n2.context = t3.getCachedContext(n2.context);
        }
      }
      addAll(t3) {
        for (let e3 = 0; e3 < t3.length; e3++) this.add(t3[e3]);
        return false;
      }
      equals(t3) {
        return this === t3 || t3 instanceof zt && e2(this.configs, t3.configs) && this.fullCtx === t3.fullCtx && this.uniqueAlt === t3.uniqueAlt && this.conflictingAlts === t3.conflictingAlts && this.hasSemanticContext === t3.hasSemanticContext && this.dipsIntoOuterContext === t3.dipsIntoOuterContext;
      }
      hashCode() {
        const t3 = new o2();
        return t3.update(this.configs), t3.finish();
      }
      updateHashCode(t3) {
        this.readOnly ? (-1 === this.cachedHashCode && (this.cachedHashCode = this.hashCode()), t3.update(this.cachedHashCode)) : t3.update(this.hashCode());
      }
      isEmpty() {
        return 0 === this.configs.length;
      }
      contains(t3) {
        if (null === this.configLookup) throw "This method is not implemented for readonly sets.";
        return this.configLookup.contains(t3);
      }
      containsFast(t3) {
        if (null === this.configLookup) throw "This method is not implemented for readonly sets.";
        return this.configLookup.containsFast(t3);
      }
      clear() {
        if (this.readOnly) throw "This set is readonly";
        this.configs = [], this.cachedHashCode = -1, this.configLookup = new d2();
      }
      setReadonly(t3) {
        this.readOnly = t3, t3 && (this.configLookup = null);
      }
      toString() {
        return c2(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== $.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (null !== this.conflictingAlts ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
      }
      get items() {
        return this.configs;
      }
      get length() {
        return this.configs.length;
      }
    }
    class qt {
      constructor(t3, e3) {
        return null === t3 && (t3 = -1), null === e3 && (e3 = new zt()), this.stateNumber = t3, this.configs = e3, this.edges = null, this.isAcceptState = false, this.prediction = 0, this.lexerActionExecutor = null, this.requiresFullContext = false, this.predicates = null, this;
      }
      getAltSet() {
        const t3 = new d2();
        if (null !== this.configs) for (let e3 = 0; e3 < this.configs.length; e3++) {
          const n2 = this.configs[e3];
          t3.add(n2.alt);
        }
        return 0 === t3.length ? null : t3;
      }
      equals(t3) {
        return this === t3 || t3 instanceof qt && this.configs.equals(t3.configs);
      }
      toString() {
        let t3 = this.stateNumber + ":" + this.configs;
        return this.isAcceptState && (t3 += "=>", null !== this.predicates ? t3 += this.predicates : t3 += this.prediction), t3;
      }
      hashCode() {
        const t3 = new o2();
        return t3.update(this.configs), t3.finish();
      }
    }
    class Ht {
      constructor(t3, e3) {
        return this.atn = t3, this.sharedContextCache = e3, this;
      }
      getCachedContext(t3) {
        if (null === this.sharedContextCache) return t3;
        const e3 = new H();
        return Y(t3, this.sharedContextCache, e3);
      }
    }
    Ht.ERROR = new qt(2147483647, new zt());
    class Kt extends zt {
      constructor() {
        super(), this.configLookup = new d2();
      }
    }
    class Yt extends S2 {
      constructor(t3, e3) {
        super(t3, e3);
        const n2 = t3.lexerActionExecutor || null;
        return this.lexerActionExecutor = n2 || (null !== e3 ? e3.lexerActionExecutor : null), this.passedThroughNonGreedyDecision = null !== e3 && this.checkNonGreedyDecision(e3, this.state), this.hashCodeForConfigSet = Yt.prototype.hashCode, this.equalsForConfigSet = Yt.prototype.equals, this;
      }
      updateHashCode(t3) {
        t3.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
      }
      equals(t3) {
        return this === t3 || t3 instanceof Yt && this.passedThroughNonGreedyDecision === t3.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(t3.lexerActionExecutor) : !t3.lexerActionExecutor) && super.equals(t3);
      }
      checkNonGreedyDecision(t3, e3) {
        return t3.passedThroughNonGreedyDecision || e3 instanceof J && e3.nonGreedy;
      }
    }
    class Gt extends St {
      constructor(t3, e3) {
        super(e3.actionType), this.offset = t3, this.action = e3, this.isPositionDependent = true;
      }
      execute(t3) {
        this.action.execute(t3);
      }
      updateHashCode(t3) {
        t3.update(this.actionType, this.offset, this.action);
      }
      equals(t3) {
        return this === t3 || t3 instanceof Gt && this.offset === t3.offset && this.action === t3.action;
      }
    }
    class jt {
      constructor(t3) {
        return this.lexerActions = null === t3 ? [] : t3, this.cachedHashCode = o2.hashStuff(t3), this;
      }
      fixOffsetBeforeMatch(t3) {
        let e3 = null;
        for (let n2 = 0; n2 < this.lexerActions.length; n2++) !this.lexerActions[n2].isPositionDependent || this.lexerActions[n2] instanceof Gt || (null === e3 && (e3 = this.lexerActions.concat([])), e3[n2] = new Gt(t3, this.lexerActions[n2]));
        return null === e3 ? this : new jt(e3);
      }
      execute(t3, e3, n2) {
        let s2 = false;
        const i3 = e3.index;
        try {
          for (let r3 = 0; r3 < this.lexerActions.length; r3++) {
            let o3 = this.lexerActions[r3];
            if (o3 instanceof Gt) {
              const t4 = o3.offset;
              e3.seek(n2 + t4), o3 = o3.action, s2 = n2 + t4 !== i3;
            } else o3.isPositionDependent && (e3.seek(i3), s2 = false);
            o3.execute(t3);
          }
        } finally {
          s2 && e3.seek(i3);
        }
      }
      hashCode() {
        return this.cachedHashCode;
      }
      updateHashCode(t3) {
        t3.update(this.cachedHashCode);
      }
      equals(t3) {
        if (this === t3) return true;
        if (t3 instanceof jt) {
          if (this.cachedHashCode != t3.cachedHashCode) return false;
          if (this.lexerActions.length != t3.lexerActions.length) return false;
          {
            const e3 = this.lexerActions.length;
            for (let n2 = 0; n2 < e3; ++n2) if (!this.lexerActions[n2].equals(t3.lexerActions[n2])) return false;
            return true;
          }
        }
        return false;
      }
      static append(t3, e3) {
        if (null === t3) return new jt([e3]);
        const n2 = t3.lexerActions.concat([e3]);
        return new jt(n2);
      }
    }
    function Wt(t3) {
      t3.index = -1, t3.line = 0, t3.column = -1, t3.dfaState = null;
    }
    class $t {
      constructor() {
        Wt(this);
      }
      reset() {
        Wt(this);
      }
    }
    class Xt extends Ht {
      constructor(t3, e3, n2, s2) {
        super(e3, s2), this.decisionToDFA = n2, this.recog = t3, this.startIndex = -1, this.line = 1, this.column = 0, this.mode = Ut.DEFAULT_MODE, this.prevAccept = new $t();
      }
      copyState(t3) {
        this.column = t3.column, this.line = t3.line, this.mode = t3.mode, this.startIndex = t3.startIndex;
      }
      match(t3, e3) {
        this.mode = e3;
        const n2 = t3.mark();
        try {
          this.startIndex = t3.index, this.prevAccept.reset();
          const n3 = this.decisionToDFA[e3];
          return null === n3.s0 ? this.matchATN(t3) : this.execATN(t3, n3.s0);
        } finally {
          t3.release(n2);
        }
      }
      reset() {
        this.prevAccept.reset(), this.startIndex = -1, this.line = 1, this.column = 0, this.mode = Ut.DEFAULT_MODE;
      }
      matchATN(t3) {
        const e3 = this.atn.modeToStartState[this.mode];
        Xt.debug && console.log("matchATN mode " + this.mode + " start: " + e3);
        const n2 = this.mode, s2 = this.computeStartState(t3, e3), i3 = s2.hasSemanticContext;
        s2.hasSemanticContext = false;
        const r3 = this.addDFAState(s2);
        i3 || (this.decisionToDFA[this.mode].s0 = r3);
        const o3 = this.execATN(t3, r3);
        return Xt.debug && console.log("DFA after matchATN: " + this.decisionToDFA[n2].toLexerString()), o3;
      }
      execATN(e3, n2) {
        Xt.debug && console.log("start state closure=" + n2.configs), n2.isAcceptState && this.captureSimState(this.prevAccept, e3, n2);
        let s2 = e3.LA(1), i3 = n2;
        for (; ; ) {
          Xt.debug && console.log("execATN loop starting closure: " + i3.configs);
          let n3 = this.getExistingTargetState(i3, s2);
          if (null === n3 && (n3 = this.computeTargetState(e3, i3, s2)), n3 === Ht.ERROR) break;
          if (s2 !== t2.EOF && this.consume(e3), n3.isAcceptState && (this.captureSimState(this.prevAccept, e3, n3), s2 === t2.EOF)) break;
          s2 = e3.LA(1), i3 = n3;
        }
        return this.failOrAccept(this.prevAccept, e3, i3.configs, s2);
      }
      getExistingTargetState(t3, e3) {
        if (null === t3.edges || e3 < Xt.MIN_DFA_EDGE || e3 > Xt.MAX_DFA_EDGE) return null;
        let n2 = t3.edges[e3 - Xt.MIN_DFA_EDGE];
        return void 0 === n2 && (n2 = null), Xt.debug && null !== n2 && console.log("reuse state " + t3.stateNumber + " edge to " + n2.stateNumber), n2;
      }
      computeTargetState(t3, e3, n2) {
        const s2 = new Kt();
        return this.getReachableConfigSet(t3, e3.configs, s2, n2), 0 === s2.items.length ? (s2.hasSemanticContext || this.addDFAEdge(e3, n2, Ht.ERROR), Ht.ERROR) : this.addDFAEdge(e3, n2, null, s2);
      }
      failOrAccept(e3, n2, s2, i3) {
        if (null !== this.prevAccept.dfaState) {
          const t3 = e3.dfaState.lexerActionExecutor;
          return this.accept(n2, t3, this.startIndex, e3.index, e3.line, e3.column), e3.dfaState.prediction;
        }
        if (i3 === t2.EOF && n2.index === this.startIndex) return t2.EOF;
        throw new Mt(this.recog, n2, this.startIndex, s2);
      }
      getReachableConfigSet(e3, n2, s2, i3) {
        let r3 = $.INVALID_ALT_NUMBER;
        for (let o3 = 0; o3 < n2.items.length; o3++) {
          const a3 = n2.items[o3], l3 = a3.alt === r3;
          if (!l3 || !a3.passedThroughNonGreedyDecision) {
            Xt.debug && console.log("testing %s at %s\n", this.getTokenName(i3), a3.toString(this.recog, true));
            for (let n3 = 0; n3 < a3.state.transitions.length; n3++) {
              const o4 = a3.state.transitions[n3], h3 = this.getReachableTarget(o4, i3);
              if (null !== h3) {
                let n4 = a3.lexerActionExecutor;
                null !== n4 && (n4 = n4.fixOffsetBeforeMatch(e3.index - this.startIndex));
                const o5 = i3 === t2.EOF, c3 = new Yt({ state: h3, lexerActionExecutor: n4 }, a3);
                this.closure(e3, c3, s2, l3, true, o5) && (r3 = a3.alt);
              }
            }
          }
        }
      }
      accept(t3, e3, n2, s2, i3, r3) {
        Xt.debug && console.log("ACTION %s\n", e3), t3.seek(s2), this.line = i3, this.column = r3, null !== e3 && null !== this.recog && e3.execute(this.recog, t3, n2);
      }
      getReachableTarget(t3, e3) {
        return t3.matches(e3, 0, Ut.MAX_CHAR_VALUE) ? t3.target : null;
      }
      computeStartState(t3, e3) {
        const n2 = U.EMPTY, s2 = new Kt();
        for (let i3 = 0; i3 < e3.transitions.length; i3++) {
          const r3 = e3.transitions[i3].target, o3 = new Yt({ state: r3, alt: i3 + 1, context: n2 }, null);
          this.closure(t3, o3, s2, false, false, false);
        }
        return s2;
      }
      closure(t3, e3, n2, s2, i3, r3) {
        let o3 = null;
        if (Xt.debug && console.log("closure(" + e3.toString(this.recog, true) + ")"), e3.state instanceof A2) {
          if (Xt.debug && (null !== this.recog ? console.log("closure at %s rule stop %s\n", this.recog.ruleNames[e3.state.ruleIndex], e3) : console.log("closure at rule stop %s\n", e3)), null === e3.context || e3.context.hasEmptyPath()) {
            if (null === e3.context || e3.context.isEmpty()) return n2.add(e3), true;
            n2.add(new Yt({ state: e3.state, context: U.EMPTY }, e3)), s2 = true;
          }
          if (null !== e3.context && !e3.context.isEmpty()) {
            for (let a3 = 0; a3 < e3.context.length; a3++) if (e3.context.getReturnState(a3) !== U.EMPTY_RETURN_STATE) {
              const l3 = e3.context.getParent(a3), h3 = this.atn.states[e3.context.getReturnState(a3)];
              o3 = new Yt({ state: h3, context: l3 }, e3), s2 = this.closure(t3, o3, n2, s2, i3, r3);
            }
          }
          return s2;
        }
        e3.state.epsilonOnlyTransitions || s2 && e3.passedThroughNonGreedyDecision || n2.add(e3);
        for (let a3 = 0; a3 < e3.state.transitions.length; a3++) {
          const l3 = e3.state.transitions[a3];
          o3 = this.getEpsilonTarget(t3, e3, l3, n2, i3, r3), null !== o3 && (s2 = this.closure(t3, o3, n2, s2, i3, r3));
        }
        return s2;
      }
      getEpsilonTarget(e3, n2, s2, i3, r3, o3) {
        let a3 = null;
        if (s2.serializationType === C2.RULE) {
          const t3 = V.create(n2.context, s2.followState.stateNumber);
          a3 = new Yt({ state: s2.target, context: t3 }, n2);
        } else {
          if (s2.serializationType === C2.PRECEDENCE) throw "Precedence predicates are not supported in lexers.";
          if (s2.serializationType === C2.PREDICATE) Xt.debug && console.log("EVAL rule " + s2.ruleIndex + ":" + s2.predIndex), i3.hasSemanticContext = true, this.evaluatePredicate(e3, s2.ruleIndex, s2.predIndex, r3) && (a3 = new Yt({ state: s2.target }, n2));
          else if (s2.serializationType === C2.ACTION) if (null === n2.context || n2.context.hasEmptyPath()) {
            const t3 = jt.append(n2.lexerActionExecutor, this.atn.lexerActions[s2.actionIndex]);
            a3 = new Yt({ state: s2.target, lexerActionExecutor: t3 }, n2);
          } else a3 = new Yt({ state: s2.target }, n2);
          else s2.serializationType === C2.EPSILON ? a3 = new Yt({ state: s2.target }, n2) : s2.serializationType !== C2.ATOM && s2.serializationType !== C2.RANGE && s2.serializationType !== C2.SET || o3 && s2.matches(t2.EOF, 0, Ut.MAX_CHAR_VALUE) && (a3 = new Yt({ state: s2.target }, n2));
        }
        return a3;
      }
      evaluatePredicate(t3, e3, n2, s2) {
        if (null === this.recog) return true;
        if (!s2) return this.recog.sempred(null, e3, n2);
        const i3 = this.column, r3 = this.line, o3 = t3.index, a3 = t3.mark();
        try {
          return this.consume(t3), this.recog.sempred(null, e3, n2);
        } finally {
          this.column = i3, this.line = r3, t3.seek(o3), t3.release(a3);
        }
      }
      captureSimState(t3, e3, n2) {
        t3.index = e3.index, t3.line = this.line, t3.column = this.column, t3.dfaState = n2;
      }
      addDFAEdge(t3, e3, n2, s2) {
        if (void 0 === n2 && (n2 = null), void 0 === s2 && (s2 = null), null === n2 && null !== s2) {
          const t4 = s2.hasSemanticContext;
          if (s2.hasSemanticContext = false, n2 = this.addDFAState(s2), t4) return n2;
        }
        return e3 < Xt.MIN_DFA_EDGE || e3 > Xt.MAX_DFA_EDGE || (Xt.debug && console.log("EDGE " + t3 + " -> " + n2 + " upon " + e3), null === t3.edges && (t3.edges = []), t3.edges[e3 - Xt.MIN_DFA_EDGE] = n2), n2;
      }
      addDFAState(t3) {
        const e3 = new qt(null, t3);
        let n2 = null;
        for (let e4 = 0; e4 < t3.items.length; e4++) {
          const s3 = t3.items[e4];
          if (s3.state instanceof A2) {
            n2 = s3;
            break;
          }
        }
        null !== n2 && (e3.isAcceptState = true, e3.lexerActionExecutor = n2.lexerActionExecutor, e3.prediction = this.atn.ruleToTokenType[n2.state.ruleIndex]);
        const s2 = this.decisionToDFA[this.mode], i3 = s2.states.get(e3);
        if (null !== i3) return i3;
        const r3 = e3;
        return r3.stateNumber = s2.states.length, t3.setReadonly(true), r3.configs = t3, s2.states.add(r3), r3;
      }
      getDFA(t3) {
        return this.decisionToDFA[t3];
      }
      getText(t3) {
        return t3.getText(this.startIndex, t3.index - 1);
      }
      consume(t3) {
        t3.LA(1) === "\n".charCodeAt(0) ? (this.line += 1, this.column = 0) : this.column += 1, t3.consume();
      }
      getTokenName(t3) {
        return -1 === t3 ? "EOF" : "'" + String.fromCharCode(t3) + "'";
      }
    }
    Xt.debug = false, Xt.dfa_debug = false, Xt.MIN_DFA_EDGE = 0, Xt.MAX_DFA_EDGE = 127;
    class Jt {
      constructor(t3, e3) {
        this.alt = e3, this.pred = t3;
      }
      toString() {
        return "(" + this.pred + ", " + this.alt + ")";
      }
    }
    class Zt {
      constructor() {
        this.data = {};
      }
      get(t3) {
        return this.data["k-" + t3] || null;
      }
      set(t3, e3) {
        this.data["k-" + t3] = e3;
      }
      values() {
        return Object.keys(this.data).filter(((t3) => t3.startsWith("k-"))).map(((t3) => this.data[t3]), this);
      }
    }
    const Qt = { SLL: 0, LL: 1, LL_EXACT_AMBIG_DETECTION: 2, hasSLLConflictTerminatingPrediction: function(t3, e3) {
      if (Qt.allConfigsInRuleStopStates(e3)) return true;
      if (t3 === Qt.SLL && e3.hasSemanticContext) {
        const t4 = new zt();
        for (let n3 = 0; n3 < e3.items.length; n3++) {
          let s2 = e3.items[n3];
          s2 = new S2({ semanticContext: p2.NONE }, s2), t4.add(s2);
        }
        e3 = t4;
      }
      const n2 = Qt.getConflictingAltSubsets(e3);
      return Qt.hasConflictingAltSet(n2) && !Qt.hasStateAssociatedWithOneAlt(e3);
    }, hasConfigInRuleStopState: function(t3) {
      for (let e3 = 0; e3 < t3.items.length; e3++) if (t3.items[e3].state instanceof A2) return true;
      return false;
    }, allConfigsInRuleStopStates: function(t3) {
      for (let e3 = 0; e3 < t3.items.length; e3++) if (!(t3.items[e3].state instanceof A2)) return false;
      return true;
    }, resolvesToJustOneViableAlt: function(t3) {
      return Qt.getSingleViableAlt(t3);
    }, allSubsetsConflict: function(t3) {
      return !Qt.hasNonConflictingAltSet(t3);
    }, hasNonConflictingAltSet: function(t3) {
      for (let e3 = 0; e3 < t3.length; e3++) if (1 === t3[e3].length) return true;
      return false;
    }, hasConflictingAltSet: function(t3) {
      for (let e3 = 0; e3 < t3.length; e3++) if (t3[e3].length > 1) return true;
      return false;
    }, allSubsetsEqual: function(t3) {
      let e3 = null;
      for (let n2 = 0; n2 < t3.length; n2++) {
        const s2 = t3[n2];
        if (null === e3) e3 = s2;
        else if (s2 !== e3) return false;
      }
      return true;
    }, getUniqueAlt: function(t3) {
      const e3 = Qt.getAlts(t3);
      return 1 === e3.length ? e3.minValue() : $.INVALID_ALT_NUMBER;
    }, getAlts: function(t3) {
      const e3 = new j();
      return t3.map((function(t4) {
        e3.or(t4);
      })), e3;
    }, getConflictingAltSubsets: function(t3) {
      const e3 = new H();
      return e3.hashFunction = function(t4) {
        o2.hashStuff(t4.state.stateNumber, t4.context);
      }, e3.equalsFunction = function(t4, e4) {
        return t4.state.stateNumber === e4.state.stateNumber && t4.context.equals(e4.context);
      }, t3.items.map((function(t4) {
        let n2 = e3.get(t4);
        null === n2 && (n2 = new j(), e3.set(t4, n2)), n2.add(t4.alt);
      })), e3.getValues();
    }, getStateToAltMap: function(t3) {
      const e3 = new Zt();
      return t3.items.map((function(t4) {
        let n2 = e3.get(t4.state);
        null === n2 && (n2 = new j(), e3.set(t4.state, n2)), n2.add(t4.alt);
      })), e3;
    }, hasStateAssociatedWithOneAlt: function(t3) {
      const e3 = Qt.getStateToAltMap(t3).values();
      for (let t4 = 0; t4 < e3.length; t4++) if (1 === e3[t4].length) return true;
      return false;
    }, getSingleViableAlt: function(t3) {
      let e3 = null;
      for (let n2 = 0; n2 < t3.length; n2++) {
        const s2 = t3[n2].minValue();
        if (null === e3) e3 = s2;
        else if (e3 !== s2) return $.INVALID_ALT_NUMBER;
      }
      return e3;
    } }, te = Qt;
    class ee extends Ft {
      constructor(t3, e3, n2, s2, i3, r3) {
        r3 = r3 || t3._ctx, s2 = s2 || t3.getCurrentToken(), n2 = n2 || t3.getCurrentToken(), e3 = e3 || t3.getInputStream(), super({ message: "", recognizer: t3, input: e3, ctx: r3 }), this.deadEndConfigs = i3, this.startToken = n2, this.offendingToken = s2;
      }
    }
    class ne {
      constructor(t3) {
        this.defaultMapCtor = t3 || H, this.cacheMap = new this.defaultMapCtor();
      }
      get(t3, e3) {
        const n2 = this.cacheMap.get(t3) || null;
        return null === n2 ? null : n2.get(e3) || null;
      }
      set(t3, e3, n2) {
        let s2 = this.cacheMap.get(t3) || null;
        null === s2 && (s2 = new this.defaultMapCtor(), this.cacheMap.set(t3, s2)), s2.set(e3, n2);
      }
    }
    class se extends Ht {
      constructor(t3, e3, n2, s2) {
        super(e3, s2), this.parser = t3, this.decisionToDFA = n2, this.predictionMode = te.LL, this._input = null, this._startIndex = 0, this._outerContext = null, this._dfa = null, this.mergeCache = null, this.debug = false, this.debug_closure = false, this.debug_add = false, this.trace_atn_sim = false, this.dfa_debug = false, this.retry_debug = false;
      }
      reset() {
      }
      adaptivePredict(t3, e3, n2) {
        (this.debug || this.trace_atn_sim) && console.log("adaptivePredict decision " + e3 + " exec LA(1)==" + this.getLookaheadName(t3) + " line " + t3.LT(1).line + ":" + t3.LT(1).column), this._input = t3, this._startIndex = t3.index, this._outerContext = n2;
        const s2 = this.decisionToDFA[e3];
        this._dfa = s2;
        const i3 = t3.mark(), r3 = t3.index;
        try {
          let e4;
          if (e4 = s2.precedenceDfa ? s2.getPrecedenceStartState(this.parser.getPrecedence()) : s2.s0, null === e4) {
            null === n2 && (n2 = M2.EMPTY), this.debug && console.log("predictATN decision " + s2.decision + " exec LA(1)==" + this.getLookaheadName(t3) + ", outerContext=" + n2.toString(this.parser.ruleNames));
            const i5 = false;
            let r4 = this.computeStartState(s2.atnStartState, M2.EMPTY, i5);
            s2.precedenceDfa ? (s2.s0.configs = r4, r4 = this.applyPrecedenceFilter(r4), e4 = this.addDFAState(s2, new qt(null, r4)), s2.setPrecedenceStartState(this.parser.getPrecedence(), e4)) : (e4 = this.addDFAState(s2, new qt(null, r4)), s2.s0 = e4);
          }
          const i4 = this.execATN(s2, e4, t3, r3, n2);
          return this.debug && console.log("DFA after predictATN: " + s2.toString(this.parser.literalNames, this.parser.symbolicNames)), i4;
        } finally {
          this._dfa = null, this.mergeCache = null, t3.seek(r3), t3.release(i3);
        }
      }
      execATN(e3, n2, s2, i3, r3) {
        let o3;
        (this.debug || this.trace_atn_sim) && console.log("execATN decision " + e3.decision + ", DFA state " + n2 + ", LA(1)==" + this.getLookaheadName(s2) + " line " + s2.LT(1).line + ":" + s2.LT(1).column);
        let a3 = n2;
        this.debug && console.log("s0 = " + n2);
        let l3 = s2.LA(1);
        for (; ; ) {
          let n3 = this.getExistingTargetState(a3, l3);
          if (null === n3 && (n3 = this.computeTargetState(e3, a3, l3)), n3 === Ht.ERROR) {
            const t3 = this.noViableAlt(s2, r3, a3.configs, i3);
            if (s2.seek(i3), o3 = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(a3.configs, r3), o3 !== $.INVALID_ALT_NUMBER) return o3;
            throw t3;
          }
          if (n3.requiresFullContext && this.predictionMode !== te.SLL) {
            let t3 = null;
            if (null !== n3.predicates) {
              this.debug && console.log("DFA state has preds in DFA sim LL failover");
              const e4 = s2.index;
              if (e4 !== i3 && s2.seek(i3), t3 = this.evalSemanticContext(n3.predicates, r3, true), 1 === t3.length) return this.debug && console.log("Full LL avoided"), t3.minValue();
              e4 !== i3 && s2.seek(e4);
            }
            this.dfa_debug && console.log("ctx sensitive state " + r3 + " in " + n3);
            const a4 = true, l4 = this.computeStartState(e3.atnStartState, r3, a4);
            return this.reportAttemptingFullContext(e3, t3, n3.configs, i3, s2.index), o3 = this.execATNWithFullContext(e3, n3, l4, s2, i3, r3), o3;
          }
          if (n3.isAcceptState) {
            if (null === n3.predicates) return n3.prediction;
            const t3 = s2.index;
            s2.seek(i3);
            const o4 = this.evalSemanticContext(n3.predicates, r3, true);
            if (0 === o4.length) throw this.noViableAlt(s2, r3, n3.configs, i3);
            return 1 === o4.length || this.reportAmbiguity(e3, n3, i3, t3, false, o4, n3.configs), o4.minValue();
          }
          a3 = n3, l3 !== t2.EOF && (s2.consume(), l3 = s2.LA(1));
        }
      }
      getExistingTargetState(t3, e3) {
        const n2 = t3.edges;
        return null === n2 ? null : n2[e3 + 1] || null;
      }
      computeTargetState(t3, e3, n2) {
        const s2 = this.computeReachSet(e3.configs, n2, false);
        if (null === s2) return this.addDFAEdge(t3, e3, n2, Ht.ERROR), Ht.ERROR;
        let i3 = new qt(null, s2);
        const r3 = this.getUniqueAlt(s2);
        if (this.debug) {
          const t4 = te.getConflictingAltSubsets(s2);
          console.log("SLL altSubSets=" + c2(t4) + ", configs=" + s2 + ", predict=" + r3 + ", allSubsetsConflict=" + te.allSubsetsConflict(t4) + ", conflictingAlts=" + this.getConflictingAlts(s2));
        }
        return r3 !== $.INVALID_ALT_NUMBER ? (i3.isAcceptState = true, i3.configs.uniqueAlt = r3, i3.prediction = r3) : te.hasSLLConflictTerminatingPrediction(this.predictionMode, s2) && (i3.configs.conflictingAlts = this.getConflictingAlts(s2), i3.requiresFullContext = true, i3.isAcceptState = true, i3.prediction = i3.configs.conflictingAlts.minValue()), i3.isAcceptState && i3.configs.hasSemanticContext && (this.predicateDFAState(i3, this.atn.getDecisionState(t3.decision)), null !== i3.predicates && (i3.prediction = $.INVALID_ALT_NUMBER)), i3 = this.addDFAEdge(t3, e3, n2, i3), i3;
      }
      predicateDFAState(t3, e3) {
        const n2 = e3.transitions.length, s2 = this.getConflictingAltsOrUniqueAlt(t3.configs), i3 = this.getPredsForAmbigAlts(s2, t3.configs, n2);
        null !== i3 ? (t3.predicates = this.getPredicatePredictions(s2, i3), t3.prediction = $.INVALID_ALT_NUMBER) : t3.prediction = s2.minValue();
      }
      execATNWithFullContext(e3, n2, s2, i3, r3, o3) {
        (this.debug || this.trace_atn_sim) && console.log("execATNWithFullContext " + s2);
        let a3, l3 = false, h3 = s2;
        i3.seek(r3);
        let c3 = i3.LA(1), u3 = -1;
        for (; ; ) {
          if (a3 = this.computeReachSet(h3, c3, true), null === a3) {
            const t3 = this.noViableAlt(i3, o3, h3, r3);
            i3.seek(r3);
            const e5 = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(h3, o3);
            if (e5 !== $.INVALID_ALT_NUMBER) return e5;
            throw t3;
          }
          const e4 = te.getConflictingAltSubsets(a3);
          if (this.debug && console.log("LL altSubSets=" + e4 + ", predict=" + te.getUniqueAlt(e4) + ", resolvesToJustOneViableAlt=" + te.resolvesToJustOneViableAlt(e4)), a3.uniqueAlt = this.getUniqueAlt(a3), a3.uniqueAlt !== $.INVALID_ALT_NUMBER) {
            u3 = a3.uniqueAlt;
            break;
          }
          if (this.predictionMode !== te.LL_EXACT_AMBIG_DETECTION) {
            if (u3 = te.resolvesToJustOneViableAlt(e4), u3 !== $.INVALID_ALT_NUMBER) break;
          } else if (te.allSubsetsConflict(e4) && te.allSubsetsEqual(e4)) {
            l3 = true, u3 = te.getSingleViableAlt(e4);
            break;
          }
          h3 = a3, c3 !== t2.EOF && (i3.consume(), c3 = i3.LA(1));
        }
        return a3.uniqueAlt !== $.INVALID_ALT_NUMBER ? (this.reportContextSensitivity(e3, u3, a3, r3, i3.index), u3) : (this.reportAmbiguity(e3, n2, r3, i3.index, l3, null, a3), u3);
      }
      computeReachSet(e3, n2, s2) {
        this.debug && console.log("in computeReachSet, starting closure: " + e3), null === this.mergeCache && (this.mergeCache = new ne());
        const i3 = new zt(s2);
        let r3 = null;
        for (let o4 = 0; o4 < e3.items.length; o4++) {
          const a3 = e3.items[o4];
          if (this.debug && console.log("testing " + this.getTokenName(n2) + " at " + a3), a3.state instanceof A2) (s2 || n2 === t2.EOF) && (null === r3 && (r3 = []), r3.push(a3), this.debug_add && console.log("added " + a3 + " to skippedStopStates"));
          else for (let t3 = 0; t3 < a3.state.transitions.length; t3++) {
            const e4 = a3.state.transitions[t3], s3 = this.getReachableTarget(e4, n2);
            if (null !== s3) {
              const t4 = new S2({ state: s3 }, a3);
              i3.add(t4, this.mergeCache), this.debug_add && console.log("added " + t4 + " to intermediate");
            }
          }
        }
        let o3 = null;
        if (null === r3 && n2 !== t2.EOF && (1 === i3.items.length || this.getUniqueAlt(i3) !== $.INVALID_ALT_NUMBER) && (o3 = i3), null === o3) {
          o3 = new zt(s2);
          const e4 = new d2(), r4 = n2 === t2.EOF;
          for (let t3 = 0; t3 < i3.items.length; t3++) this.closure(i3.items[t3], o3, e4, false, s2, r4);
        }
        if (n2 === t2.EOF && (o3 = this.removeAllConfigsNotInRuleStopState(o3, o3 === i3)), !(null === r3 || s2 && te.hasConfigInRuleStopState(o3))) for (let t3 = 0; t3 < r3.length; t3++) o3.add(r3[t3], this.mergeCache);
        return this.trace_atn_sim && console.log("computeReachSet " + e3 + " -> " + o3), 0 === o3.items.length ? null : o3;
      }
      removeAllConfigsNotInRuleStopState(e3, n2) {
        if (te.allConfigsInRuleStopStates(e3)) return e3;
        const s2 = new zt(e3.fullCtx);
        for (let i3 = 0; i3 < e3.items.length; i3++) {
          const r3 = e3.items[i3];
          if (r3.state instanceof A2) s2.add(r3, this.mergeCache);
          else if (n2 && r3.state.epsilonOnlyTransitions && this.atn.nextTokens(r3.state).contains(t2.EPSILON)) {
            const t3 = this.atn.ruleToStopState[r3.state.ruleIndex];
            s2.add(new S2({ state: t3 }, r3), this.mergeCache);
          }
        }
        return s2;
      }
      computeStartState(t3, e3, n2) {
        const s2 = K(this.atn, e3), i3 = new zt(n2);
        this.trace_atn_sim && console.log("computeStartState from ATN state " + t3 + " initialContext=" + s2.toString(this.parser));
        for (let e4 = 0; e4 < t3.transitions.length; e4++) {
          const r3 = t3.transitions[e4].target, o3 = new S2({ state: r3, alt: e4 + 1, context: s2 }, null), a3 = new d2();
          this.closure(o3, i3, a3, true, n2, false);
        }
        return i3;
      }
      applyPrecedenceFilter(t3) {
        let e3;
        const n2 = [], s2 = new zt(t3.fullCtx);
        for (let i3 = 0; i3 < t3.items.length; i3++) {
          if (e3 = t3.items[i3], 1 !== e3.alt) continue;
          const r3 = e3.semanticContext.evalPrecedence(this.parser, this._outerContext);
          null !== r3 && (n2[e3.state.stateNumber] = e3.context, r3 !== e3.semanticContext ? s2.add(new S2({ semanticContext: r3 }, e3), this.mergeCache) : s2.add(e3, this.mergeCache));
        }
        for (let i3 = 0; i3 < t3.items.length; i3++) if (e3 = t3.items[i3], 1 !== e3.alt) {
          if (!e3.precedenceFilterSuppressed) {
            const t4 = n2[e3.state.stateNumber] || null;
            if (null !== t4 && t4.equals(e3.context)) continue;
          }
          s2.add(e3, this.mergeCache);
        }
        return s2;
      }
      getReachableTarget(t3, e3) {
        return t3.matches(e3, 0, this.atn.maxTokenType) ? t3.target : null;
      }
      getPredsForAmbigAlts(t3, e3, n2) {
        let s2 = [];
        for (let n3 = 0; n3 < e3.items.length; n3++) {
          const i4 = e3.items[n3];
          t3.has(i4.alt) && (s2[i4.alt] = p2.orContext(s2[i4.alt] || null, i4.semanticContext));
        }
        let i3 = 0;
        for (let t4 = 1; t4 < n2 + 1; t4++) {
          const e4 = s2[t4] || null;
          null === e4 ? s2[t4] = p2.NONE : e4 !== p2.NONE && (i3 += 1);
        }
        return 0 === i3 && (s2 = null), this.debug && console.log("getPredsForAmbigAlts result " + c2(s2)), s2;
      }
      getPredicatePredictions(t3, e3) {
        const n2 = [];
        let s2 = false;
        for (let i3 = 1; i3 < e3.length; i3++) {
          const r3 = e3[i3];
          null !== t3 && t3.has(i3) && n2.push(new Jt(r3, i3)), r3 !== p2.NONE && (s2 = true);
        }
        return s2 ? n2 : null;
      }
      getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(t3, e3) {
        const n2 = this.splitAccordingToSemanticValidity(t3, e3), s2 = n2[0], i3 = n2[1];
        let r3 = this.getAltThatFinishedDecisionEntryRule(s2);
        return r3 !== $.INVALID_ALT_NUMBER || i3.items.length > 0 && (r3 = this.getAltThatFinishedDecisionEntryRule(i3), r3 !== $.INVALID_ALT_NUMBER) ? r3 : $.INVALID_ALT_NUMBER;
      }
      getAltThatFinishedDecisionEntryRule(t3) {
        const e3 = [];
        for (let n2 = 0; n2 < t3.items.length; n2++) {
          const s2 = t3.items[n2];
          (s2.reachesIntoOuterContext > 0 || s2.state instanceof A2 && s2.context.hasEmptyPath()) && e3.indexOf(s2.alt) < 0 && e3.push(s2.alt);
        }
        return 0 === e3.length ? $.INVALID_ALT_NUMBER : Math.min.apply(null, e3);
      }
      splitAccordingToSemanticValidity(t3, e3) {
        const n2 = new zt(t3.fullCtx), s2 = new zt(t3.fullCtx);
        for (let i3 = 0; i3 < t3.items.length; i3++) {
          const r3 = t3.items[i3];
          r3.semanticContext !== p2.NONE ? r3.semanticContext.evaluate(this.parser, e3) ? n2.add(r3) : s2.add(r3) : n2.add(r3);
        }
        return [n2, s2];
      }
      evalSemanticContext(t3, e3, n2) {
        const s2 = new j();
        for (let i3 = 0; i3 < t3.length; i3++) {
          const r3 = t3[i3];
          if (r3.pred === p2.NONE) {
            if (s2.add(r3.alt), !n2) break;
            continue;
          }
          const o3 = r3.pred.evaluate(this.parser, e3);
          if ((this.debug || this.dfa_debug) && console.log("eval pred " + r3 + "=" + o3), o3 && ((this.debug || this.dfa_debug) && console.log("PREDICT " + r3.alt), s2.add(r3.alt), !n2)) break;
        }
        return s2;
      }
      closure(t3, e3, n2, s2, i3, r3) {
        this.closureCheckingStopState(t3, e3, n2, s2, i3, 0, r3);
      }
      closureCheckingStopState(t3, e3, n2, s2, i3, r3, o3) {
        if ((this.trace_atn_sim || this.debug_closure) && console.log("closure(" + t3.toString(this.parser, true) + ")"), t3.state instanceof A2) {
          if (!t3.context.isEmpty()) {
            for (let a3 = 0; a3 < t3.context.length; a3++) {
              if (t3.context.getReturnState(a3) === U.EMPTY_RETURN_STATE) {
                if (i3) {
                  e3.add(new S2({ state: t3.state, context: U.EMPTY }, t3), this.mergeCache);
                  continue;
                }
                this.debug && console.log("FALLING off rule " + this.getRuleName(t3.state.ruleIndex)), this.closure_(t3, e3, n2, s2, i3, r3, o3);
                continue;
              }
              const l3 = this.atn.states[t3.context.getReturnState(a3)], h3 = t3.context.getParent(a3), c3 = { state: l3, alt: t3.alt, context: h3, semanticContext: t3.semanticContext }, u3 = new S2(c3, null);
              u3.reachesIntoOuterContext = t3.reachesIntoOuterContext, this.closureCheckingStopState(u3, e3, n2, s2, i3, r3 - 1, o3);
            }
            return;
          }
          if (i3) return void e3.add(t3, this.mergeCache);
          this.debug && console.log("FALLING off rule " + this.getRuleName(t3.state.ruleIndex));
        }
        this.closure_(t3, e3, n2, s2, i3, r3, o3);
      }
      closure_(t3, e3, n2, s2, i3, r3, o3) {
        const a3 = t3.state;
        a3.epsilonOnlyTransitions || e3.add(t3, this.mergeCache);
        for (let l3 = 0; l3 < a3.transitions.length; l3++) {
          if (0 === l3 && this.canDropLoopEntryEdgeInLeftRecursiveRule(t3)) continue;
          const h3 = a3.transitions[l3], c3 = s2 && !(h3 instanceof ut), u3 = this.getEpsilonTarget(t3, h3, c3, 0 === r3, i3, o3);
          if (null !== u3) {
            let s3 = r3;
            if (t3.state instanceof A2) {
              if (null !== this._dfa && this._dfa.precedenceDfa && h3.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex && (u3.precedenceFilterSuppressed = true), u3.reachesIntoOuterContext += 1, n2.add(u3) !== u3) continue;
              e3.dipsIntoOuterContext = true, s3 -= 1, this.debug && console.log("dips into outer ctx: " + u3);
            } else {
              if (!h3.isEpsilon && n2.add(u3) !== u3) continue;
              h3 instanceof N2 && s3 >= 0 && (s3 += 1);
            }
            this.closureCheckingStopState(u3, e3, n2, c3, i3, s3, o3);
          }
        }
      }
      canDropLoopEntryEdgeInLeftRecursiveRule(t3) {
        const e3 = t3.state;
        if (e3.stateType !== _2.STAR_LOOP_ENTRY) return false;
        if (e3.stateType !== _2.STAR_LOOP_ENTRY || !e3.isPrecedenceDecision || t3.context.isEmpty() || t3.context.hasEmptyPath()) return false;
        const n2 = t3.context.length;
        for (let s3 = 0; s3 < n2; s3++) if (this.atn.states[t3.context.getReturnState(s3)].ruleIndex !== e3.ruleIndex) return false;
        const s2 = e3.transitions[0].target.endState.stateNumber, i3 = this.atn.states[s2];
        for (let s3 = 0; s3 < n2; s3++) {
          const n3 = t3.context.getReturnState(s3), r3 = this.atn.states[n3];
          if (1 !== r3.transitions.length || !r3.transitions[0].isEpsilon) return false;
          const o3 = r3.transitions[0].target;
          if (!(r3.stateType === _2.BLOCK_END && o3 === e3 || r3 === i3 || o3 === i3 || o3.stateType === _2.BLOCK_END && 1 === o3.transitions.length && o3.transitions[0].isEpsilon && o3.transitions[0].target === e3)) return false;
        }
        return true;
      }
      getRuleName(t3) {
        return null !== this.parser && t3 >= 0 ? this.parser.ruleNames[t3] : "<rule " + t3 + ">";
      }
      getEpsilonTarget(e3, n2, s2, i3, r3, o3) {
        switch (n2.serializationType) {
          case C2.RULE:
            return this.ruleTransition(e3, n2);
          case C2.PRECEDENCE:
            return this.precedenceTransition(e3, n2, s2, i3, r3);
          case C2.PREDICATE:
            return this.predTransition(e3, n2, s2, i3, r3);
          case C2.ACTION:
            return this.actionTransition(e3, n2);
          case C2.EPSILON:
            return new S2({ state: n2.target }, e3);
          case C2.ATOM:
          case C2.RANGE:
          case C2.SET:
            return o3 && n2.matches(t2.EOF, 0, 1) ? new S2({ state: n2.target }, e3) : null;
          default:
            return null;
        }
      }
      actionTransition(t3, e3) {
        if (this.debug) {
          const t4 = -1 === e3.actionIndex ? 65535 : e3.actionIndex;
          console.log("ACTION edge " + e3.ruleIndex + ":" + t4);
        }
        return new S2({ state: e3.target }, t3);
      }
      precedenceTransition(t3, e3, n2, s2, i3) {
        this.debug && (console.log("PRED (collectPredicates=" + n2 + ") " + e3.precedence + ">=_p, ctx dependent=true"), null !== this.parser && console.log("context surrounding pred is " + c2(this.parser.getRuleInvocationStack())));
        let r3 = null;
        if (n2 && s2) if (i3) {
          const n3 = this._input.index;
          this._input.seek(this._startIndex);
          const s3 = e3.getPredicate().evaluate(this.parser, this._outerContext);
          this._input.seek(n3), s3 && (r3 = new S2({ state: e3.target }, t3));
        } else {
          const n3 = p2.andContext(t3.semanticContext, e3.getPredicate());
          r3 = new S2({ state: e3.target, semanticContext: n3 }, t3);
        }
        else r3 = new S2({ state: e3.target }, t3);
        return this.debug && console.log("config from pred transition=" + r3), r3;
      }
      predTransition(t3, e3, n2, s2, i3) {
        this.debug && (console.log("PRED (collectPredicates=" + n2 + ") " + e3.ruleIndex + ":" + e3.predIndex + ", ctx dependent=" + e3.isCtxDependent), null !== this.parser && console.log("context surrounding pred is " + c2(this.parser.getRuleInvocationStack())));
        let r3 = null;
        if (n2 && (e3.isCtxDependent && s2 || !e3.isCtxDependent)) if (i3) {
          const n3 = this._input.index;
          this._input.seek(this._startIndex);
          const s3 = e3.getPredicate().evaluate(this.parser, this._outerContext);
          this._input.seek(n3), s3 && (r3 = new S2({ state: e3.target }, t3));
        } else {
          const n3 = p2.andContext(t3.semanticContext, e3.getPredicate());
          r3 = new S2({ state: e3.target, semanticContext: n3 }, t3);
        }
        else r3 = new S2({ state: e3.target }, t3);
        return this.debug && console.log("config from pred transition=" + r3), r3;
      }
      ruleTransition(t3, e3) {
        this.debug && console.log("CALL rule " + this.getRuleName(e3.target.ruleIndex) + ", ctx=" + t3.context);
        const n2 = e3.followState, s2 = V.create(t3.context, n2.stateNumber);
        return new S2({ state: e3.target, context: s2 }, t3);
      }
      getConflictingAlts(t3) {
        const e3 = te.getConflictingAltSubsets(t3);
        return te.getAlts(e3);
      }
      getConflictingAltsOrUniqueAlt(t3) {
        let e3 = null;
        return t3.uniqueAlt !== $.INVALID_ALT_NUMBER ? (e3 = new j(), e3.add(t3.uniqueAlt)) : e3 = t3.conflictingAlts, e3;
      }
      getTokenName(e3) {
        if (e3 === t2.EOF) return "EOF";
        if (null !== this.parser && null !== this.parser.literalNames) {
          if (!(e3 >= this.parser.literalNames.length && e3 >= this.parser.symbolicNames.length)) return (this.parser.literalNames[e3] || this.parser.symbolicNames[e3]) + "<" + e3 + ">";
          console.log(e3 + " ttype out of range: " + this.parser.literalNames), console.log("" + this.parser.getInputStream().getTokens());
        }
        return "" + e3;
      }
      getLookaheadName(t3) {
        return this.getTokenName(t3.LA(1));
      }
      dumpDeadEndConfigs(t3) {
        console.log("dead end configs: ");
        const e3 = t3.getDeadEndConfigs();
        for (let t4 = 0; t4 < e3.length; t4++) {
          const n2 = e3[t4];
          let s2 = "no edges";
          if (n2.state.transitions.length > 0) {
            const t5 = n2.state.transitions[0];
            t5 instanceof ht ? s2 = "Atom " + this.getTokenName(t5.label) : t5 instanceof y2 && (s2 = (t5 instanceof I2 ? "~" : "") + "Set " + t5.set);
          }
          console.error(n2.toString(this.parser, true) + ":" + s2);
        }
      }
      noViableAlt(t3, e3, n2, s2) {
        return new ee(this.parser, t3, t3.get(s2), t3.LT(1), n2, e3);
      }
      getUniqueAlt(t3) {
        let e3 = $.INVALID_ALT_NUMBER;
        for (let n2 = 0; n2 < t3.items.length; n2++) {
          const s2 = t3.items[n2];
          if (e3 === $.INVALID_ALT_NUMBER) e3 = s2.alt;
          else if (s2.alt !== e3) return $.INVALID_ALT_NUMBER;
        }
        return e3;
      }
      addDFAEdge(t3, e3, n2, s2) {
        if (this.debug && console.log("EDGE " + e3 + " -> " + s2 + " upon " + this.getTokenName(n2)), null === s2) return null;
        if (s2 = this.addDFAState(t3, s2), null === e3 || n2 < -1 || n2 > this.atn.maxTokenType) return s2;
        if (null === e3.edges && (e3.edges = []), e3.edges[n2 + 1] = s2, this.debug) {
          const e4 = null === this.parser ? null : this.parser.literalNames, n3 = null === this.parser ? null : this.parser.symbolicNames;
          console.log("DFA=\n" + t3.toString(e4, n3));
        }
        return s2;
      }
      addDFAState(t3, e3) {
        if (e3 === Ht.ERROR) return e3;
        const n2 = t3.states.get(e3);
        return null !== n2 ? (this.trace_atn_sim && console.log("addDFAState " + e3 + " exists"), n2) : (e3.stateNumber = t3.states.length, e3.configs.readOnly || (e3.configs.optimizeConfigs(this), e3.configs.setReadonly(true)), this.trace_atn_sim && console.log("addDFAState new " + e3), t3.states.add(e3), this.debug && console.log("adding new DFA state: " + e3), e3);
      }
      reportAttemptingFullContext(t3, e3, n2, s2, i3) {
        if (this.debug || this.retry_debug) {
          const e4 = new m2(s2, i3 + 1);
          console.log("reportAttemptingFullContext decision=" + t3.decision + ":" + n2 + ", input=" + this.parser.getTokenStream().getText(e4));
        }
        null !== this.parser && this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, t3, s2, i3, e3, n2);
      }
      reportContextSensitivity(t3, e3, n2, s2, i3) {
        if (this.debug || this.retry_debug) {
          const e4 = new m2(s2, i3 + 1);
          console.log("reportContextSensitivity decision=" + t3.decision + ":" + n2 + ", input=" + this.parser.getTokenStream().getText(e4));
        }
        null !== this.parser && this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, t3, s2, i3, e3, n2);
      }
      reportAmbiguity(t3, e3, n2, s2, i3, r3, o3) {
        if (this.debug || this.retry_debug) {
          const t4 = new m2(n2, s2 + 1);
          console.log("reportAmbiguity " + r3 + ":" + o3 + ", input=" + this.parser.getTokenStream().getText(t4));
        }
        null !== this.parser && this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, t3, n2, s2, i3, r3, o3);
      }
    }
    class ie {
      constructor() {
        this.cache = new H();
      }
      add(t3) {
        if (t3 === U.EMPTY) return U.EMPTY;
        const e3 = this.cache.get(t3) || null;
        return null !== e3 ? e3 : (this.cache.set(t3, t3), t3);
      }
      get(t3) {
        return this.cache.get(t3) || null;
      }
      get length() {
        return this.cache.length;
      }
    }
    const re = { ATN: $, ATNDeserializer: Lt, LexerATNSimulator: Xt, ParserATNSimulator: se, PredictionMode: te, PredictionContextCache: ie };
    class oe {
      constructor(t3, e3, n2) {
        this.dfa = t3, this.literalNames = e3 || [], this.symbolicNames = n2 || [];
      }
      toString() {
        if (null === this.dfa.s0) return null;
        let t3 = "";
        const e3 = this.dfa.sortedStates();
        for (let n2 = 0; n2 < e3.length; n2++) {
          const s2 = e3[n2];
          if (null !== s2.edges) {
            const e4 = s2.edges.length;
            for (let n3 = 0; n3 < e4; n3++) {
              const e5 = s2.edges[n3] || null;
              null !== e5 && 2147483647 !== e5.stateNumber && (t3 = t3.concat(this.getStateString(s2)), t3 = t3.concat("-"), t3 = t3.concat(this.getEdgeLabel(n3)), t3 = t3.concat("->"), t3 = t3.concat(this.getStateString(e5)), t3 = t3.concat("\n"));
            }
          }
        }
        return 0 === t3.length ? null : t3;
      }
      getEdgeLabel(t3) {
        return 0 === t3 ? "EOF" : null !== this.literalNames || null !== this.symbolicNames ? this.literalNames[t3 - 1] || this.symbolicNames[t3 - 1] : String.fromCharCode(t3 - 1);
      }
      getStateString(t3) {
        const e3 = (t3.isAcceptState ? ":" : "") + "s" + t3.stateNumber + (t3.requiresFullContext ? "^" : "");
        return t3.isAcceptState ? null !== t3.predicates ? e3 + "=>" + c2(t3.predicates) : e3 + "=>" + t3.prediction.toString() : e3;
      }
    }
    class ae extends oe {
      constructor(t3) {
        super(t3, null);
      }
      getEdgeLabel(t3) {
        return "'" + String.fromCharCode(t3) + "'";
      }
    }
    class le {
      constructor(t3, e3) {
        if (void 0 === e3 && (e3 = 0), this.atnStartState = t3, this.decision = e3, this._states = new d2(), this.s0 = null, this.precedenceDfa = false, t3 instanceof rt && t3.isPrecedenceDecision) {
          this.precedenceDfa = true;
          const t4 = new qt(null, new zt());
          t4.edges = [], t4.isAcceptState = false, t4.requiresFullContext = false, this.s0 = t4;
        }
      }
      getPrecedenceStartState(t3) {
        if (!this.precedenceDfa) throw "Only precedence DFAs may contain a precedence start state.";
        return t3 < 0 || t3 >= this.s0.edges.length ? null : this.s0.edges[t3] || null;
      }
      setPrecedenceStartState(t3, e3) {
        if (!this.precedenceDfa) throw "Only precedence DFAs may contain a precedence start state.";
        t3 < 0 || (this.s0.edges[t3] = e3);
      }
      setPrecedenceDfa(t3) {
        if (this.precedenceDfa !== t3) {
          if (this._states = new d2(), t3) {
            const t4 = new qt(null, new zt());
            t4.edges = [], t4.isAcceptState = false, t4.requiresFullContext = false, this.s0 = t4;
          } else this.s0 = null;
          this.precedenceDfa = t3;
        }
      }
      sortedStates() {
        return this._states.values().sort((function(t3, e3) {
          return t3.stateNumber - e3.stateNumber;
        }));
      }
      toString(t3, e3) {
        return t3 = t3 || null, e3 = e3 || null, null === this.s0 ? "" : new oe(this, t3, e3).toString();
      }
      toLexerString() {
        return null === this.s0 ? "" : new ae(this).toString();
      }
      get states() {
        return this._states;
      }
    }
    const he = { DFA: le, DFASerializer: oe, LexerDFASerializer: ae, PredPrediction: Jt }, ce = { PredictionContext: U }, ue = { Interval: m2, IntervalSet: E2 };
    class de {
      visitTerminal(t3) {
      }
      visitErrorNode(t3) {
      }
      enterEveryRule(t3) {
      }
      exitEveryRule(t3) {
      }
    }
    class pe {
      visit(t3) {
        return Array.isArray(t3) ? t3.map((function(t4) {
          return t4.accept(this);
        }), this) : t3.accept(this);
      }
      visitChildren(t3) {
        return t3.children ? this.visit(t3.children) : null;
      }
      visitTerminal(t3) {
      }
      visitErrorNode(t3) {
      }
    }
    class ge {
      walk(t3, e3) {
        if (e3 instanceof b2 || void 0 !== e3.isErrorNode && e3.isErrorNode()) t3.visitErrorNode(e3);
        else if (e3 instanceof P3) t3.visitTerminal(e3);
        else {
          this.enterRule(t3, e3);
          for (let n2 = 0; n2 < e3.getChildCount(); n2++) {
            const s2 = e3.getChild(n2);
            this.walk(t3, s2);
          }
          this.exitRule(t3, e3);
        }
      }
      enterRule(t3, e3) {
        const n2 = e3.ruleContext;
        t3.enterEveryRule(n2), n2.enterRule(t3);
      }
      exitRule(t3, e3) {
        const n2 = e3.ruleContext;
        n2.exitRule(t3), t3.exitEveryRule(n2);
      }
    }
    ge.DEFAULT = new ge();
    const fe = { Trees: F2, RuleNode: w2, ErrorNode: b2, TerminalNode: P3, ParseTreeListener: de, ParseTreeVisitor: pe, ParseTreeWalker: ge };
    class xe extends Ft {
      constructor(t3) {
        super({ message: "", recognizer: t3, input: t3.getInputStream(), ctx: t3._ctx }), this.offendingToken = t3.getCurrentToken();
      }
    }
    class Te extends Ft {
      constructor(t3, e3, n2) {
        super({ message: Se(e3, n2 || null), recognizer: t3, input: t3.getInputStream(), ctx: t3._ctx });
        const s2 = t3._interp.atn.states[t3.state].transitions[0];
        s2 instanceof gt ? (this.ruleIndex = s2.ruleIndex, this.predicateIndex = s2.predIndex) : (this.ruleIndex = 0, this.predicateIndex = 0), this.predicate = e3, this.offendingToken = t3.getCurrentToken();
      }
    }
    function Se(t3, e3) {
      return null !== e3 ? e3 : "failed predicate: {" + t3 + "}?";
    }
    class me extends Ot {
      constructor(t3) {
        super(), t3 = t3 || true, this.exactOnly = t3;
      }
      reportAmbiguity(t3, e3, n2, s2, i3, r3, o3) {
        if (this.exactOnly && !i3) return;
        const a3 = "reportAmbiguity d=" + this.getDecisionDescription(t3, e3) + ": ambigAlts=" + this.getConflictingAlts(r3, o3) + ", input='" + t3.getTokenStream().getText(new m2(n2, s2)) + "'";
        t3.notifyErrorListeners(a3);
      }
      reportAttemptingFullContext(t3, e3, n2, s2, i3, r3) {
        const o3 = "reportAttemptingFullContext d=" + this.getDecisionDescription(t3, e3) + ", input='" + t3.getTokenStream().getText(new m2(n2, s2)) + "'";
        t3.notifyErrorListeners(o3);
      }
      reportContextSensitivity(t3, e3, n2, s2, i3, r3) {
        const o3 = "reportContextSensitivity d=" + this.getDecisionDescription(t3, e3) + ", input='" + t3.getTokenStream().getText(new m2(n2, s2)) + "'";
        t3.notifyErrorListeners(o3);
      }
      getDecisionDescription(t3, e3) {
        const n2 = e3.decision, s2 = e3.atnStartState.ruleIndex, i3 = t3.ruleNames;
        if (s2 < 0 || s2 >= i3.length) return "" + n2;
        const r3 = i3[s2] || null;
        return null === r3 || 0 === r3.length ? "" + n2 : `${n2} (${r3})`;
      }
      getConflictingAlts(t3, e3) {
        if (null !== t3) return t3;
        const n2 = new j();
        for (let t4 = 0; t4 < e3.items.length; t4++) n2.add(e3.items[t4].alt);
        return `{${n2.values().join(", ")}}`;
      }
    }
    class Ee extends Error {
      constructor() {
        super(), Error.captureStackTrace(this, Ee);
      }
    }
    class _e {
      reset(t3) {
      }
      recoverInline(t3) {
      }
      recover(t3, e3) {
      }
      sync(t3) {
      }
      inErrorRecoveryMode(t3) {
      }
      reportError(t3) {
      }
    }
    class Ae extends _e {
      constructor() {
        super(), this.errorRecoveryMode = false, this.lastErrorIndex = -1, this.lastErrorStates = null, this.nextTokensContext = null, this.nextTokenState = 0;
      }
      reset(t3) {
        this.endErrorCondition(t3);
      }
      beginErrorCondition(t3) {
        this.errorRecoveryMode = true;
      }
      inErrorRecoveryMode(t3) {
        return this.errorRecoveryMode;
      }
      endErrorCondition(t3) {
        this.errorRecoveryMode = false, this.lastErrorStates = null, this.lastErrorIndex = -1;
      }
      reportMatch(t3) {
        this.endErrorCondition(t3);
      }
      reportError(t3, e3) {
        this.inErrorRecoveryMode(t3) || (this.beginErrorCondition(t3), e3 instanceof ee ? this.reportNoViableAlternative(t3, e3) : e3 instanceof xe ? this.reportInputMismatch(t3, e3) : e3 instanceof Te ? this.reportFailedPredicate(t3, e3) : (console.log("unknown recognition error type: " + e3.constructor.name), console.log(e3.stack), t3.notifyErrorListeners(e3.getOffendingToken(), e3.getMessage(), e3)));
      }
      recover(t3, e3) {
        this.lastErrorIndex === t3.getInputStream().index && null !== this.lastErrorStates && this.lastErrorStates.indexOf(t3.state) >= 0 && t3.consume(), this.lastErrorIndex = t3._input.index, null === this.lastErrorStates && (this.lastErrorStates = []), this.lastErrorStates.push(t3.state);
        const n2 = this.getErrorRecoverySet(t3);
        this.consumeUntil(t3, n2);
      }
      sync(e3) {
        if (this.inErrorRecoveryMode(e3)) return;
        const n2 = e3._interp.atn.states[e3.state], s2 = e3.getTokenStream().LA(1), i3 = e3.atn.nextTokens(n2);
        if (i3.contains(s2)) return this.nextTokensContext = null, void (this.nextTokenState = _2.INVALID_STATE_NUMBER);
        if (i3.contains(t2.EPSILON)) null === this.nextTokensContext && (this.nextTokensContext = e3._ctx, this.nextTokensState = e3._stateNumber);
        else switch (n2.stateType) {
          case _2.BLOCK_START:
          case _2.STAR_BLOCK_START:
          case _2.PLUS_BLOCK_START:
          case _2.STAR_LOOP_ENTRY:
            if (null !== this.singleTokenDeletion(e3)) return;
            throw new xe(e3);
          case _2.PLUS_LOOP_BACK:
          case _2.STAR_LOOP_BACK: {
            this.reportUnwantedToken(e3);
            const t3 = new E2();
            t3.addSet(e3.getExpectedTokens());
            const n3 = t3.addSet(this.getErrorRecoverySet(e3));
            this.consumeUntil(e3, n3);
          }
        }
      }
      reportNoViableAlternative(e3, n2) {
        const s2 = e3.getTokenStream();
        let i3;
        i3 = null !== s2 ? n2.startToken.type === t2.EOF ? "<EOF>" : s2.getText(new m2(n2.startToken.tokenIndex, n2.offendingToken.tokenIndex)) : "<unknown input>";
        const r3 = "no viable alternative at input " + this.escapeWSAndQuote(i3);
        e3.notifyErrorListeners(r3, n2.offendingToken, n2);
      }
      reportInputMismatch(t3, e3) {
        const n2 = "mismatched input " + this.getTokenErrorDisplay(e3.offendingToken) + " expecting " + e3.getExpectedTokens().toString(t3.literalNames, t3.symbolicNames);
        t3.notifyErrorListeners(n2, e3.offendingToken, e3);
      }
      reportFailedPredicate(t3, e3) {
        const n2 = "rule " + t3.ruleNames[t3._ctx.ruleIndex] + " " + e3.message;
        t3.notifyErrorListeners(n2, e3.offendingToken, e3);
      }
      reportUnwantedToken(t3) {
        if (this.inErrorRecoveryMode(t3)) return;
        this.beginErrorCondition(t3);
        const e3 = t3.getCurrentToken(), n2 = "extraneous input " + this.getTokenErrorDisplay(e3) + " expecting " + this.getExpectedTokens(t3).toString(t3.literalNames, t3.symbolicNames);
        t3.notifyErrorListeners(n2, e3, null);
      }
      reportMissingToken(t3) {
        if (this.inErrorRecoveryMode(t3)) return;
        this.beginErrorCondition(t3);
        const e3 = t3.getCurrentToken(), n2 = "missing " + this.getExpectedTokens(t3).toString(t3.literalNames, t3.symbolicNames) + " at " + this.getTokenErrorDisplay(e3);
        t3.notifyErrorListeners(n2, e3, null);
      }
      recoverInline(t3) {
        const e3 = this.singleTokenDeletion(t3);
        if (null !== e3) return t3.consume(), e3;
        if (this.singleTokenInsertion(t3)) return this.getMissingSymbol(t3);
        throw new xe(t3);
      }
      singleTokenInsertion(t3) {
        const e3 = t3.getTokenStream().LA(1), n2 = t3._interp.atn, s2 = n2.states[t3.state].transitions[0].target;
        return !!n2.nextTokens(s2, t3._ctx).contains(e3) && (this.reportMissingToken(t3), true);
      }
      singleTokenDeletion(t3) {
        const e3 = t3.getTokenStream().LA(2);
        if (this.getExpectedTokens(t3).contains(e3)) {
          this.reportUnwantedToken(t3), t3.consume();
          const e4 = t3.getCurrentToken();
          return this.reportMatch(t3), e4;
        }
        return null;
      }
      getMissingSymbol(e3) {
        const n2 = e3.getCurrentToken(), s2 = this.getExpectedTokens(e3).first();
        let i3;
        i3 = s2 === t2.EOF ? "<missing EOF>" : "<missing " + e3.literalNames[s2] + ">";
        let r3 = n2;
        const o3 = e3.getTokenStream().LT(-1);
        return r3.type === t2.EOF && null !== o3 && (r3 = o3), e3.getTokenFactory().create(r3.source, s2, i3, t2.DEFAULT_CHANNEL, -1, -1, r3.line, r3.column);
      }
      getExpectedTokens(t3) {
        return t3.getExpectedTokens();
      }
      getTokenErrorDisplay(e3) {
        if (null === e3) return "<no token>";
        let n2 = e3.text;
        return null === n2 && (n2 = e3.type === t2.EOF ? "<EOF>" : "<" + e3.type + ">"), this.escapeWSAndQuote(n2);
      }
      escapeWSAndQuote(t3) {
        return "'" + (t3 = (t3 = (t3 = t3.replace(/\n/g, "\\n")).replace(/\r/g, "\\r")).replace(/\t/g, "\\t")) + "'";
      }
      getErrorRecoverySet(e3) {
        const n2 = e3._interp.atn;
        let s2 = e3._ctx;
        const i3 = new E2();
        for (; null !== s2 && s2.invokingState >= 0; ) {
          const t3 = n2.states[s2.invokingState].transitions[0], e4 = n2.nextTokens(t3.followState);
          i3.addSet(e4), s2 = s2.parentCtx;
        }
        return i3.removeOne(t2.EPSILON), i3;
      }
      consumeUntil(e3, n2) {
        let s2 = e3.getTokenStream().LA(1);
        for (; s2 !== t2.EOF && !n2.contains(s2); ) e3.consume(), s2 = e3.getTokenStream().LA(1);
      }
    }
    class Ce extends Ae {
      constructor() {
        super();
      }
      recover(t3, e3) {
        let n2 = t3._ctx;
        for (; null !== n2; ) n2.exception = e3, n2 = n2.parentCtx;
        throw new Ee(e3);
      }
      recoverInline(t3) {
        this.recover(t3, new xe(t3));
      }
      sync(t3) {
      }
    }
    const Ne = { RecognitionException: Ft, NoViableAltException: ee, LexerNoViableAltException: Mt, InputMismatchException: xe, FailedPredicateException: Te, DiagnosticErrorListener: me, BailErrorStrategy: Ce, DefaultErrorStrategy: Ae, ErrorListener: Ot };
    class ye {
      constructor(t3, e3) {
        if (this.name = "<empty>", this.strdata = t3, this.decodeToUnicodeCodePoints = e3 || false, this._index = 0, this.data = [], this.decodeToUnicodeCodePoints) for (let t4 = 0; t4 < this.strdata.length; ) {
          const e4 = this.strdata.codePointAt(t4);
          this.data.push(e4), t4 += e4 <= 65535 ? 1 : 2;
        }
        else {
          this.data = new Array(this.strdata.length);
          for (let t4 = 0; t4 < this.strdata.length; t4++) this.data[t4] = this.strdata.charCodeAt(t4);
        }
        this._size = this.data.length;
      }
      reset() {
        this._index = 0;
      }
      consume() {
        if (this._index >= this._size) throw "cannot consume EOF";
        this._index += 1;
      }
      LA(e3) {
        if (0 === e3) return 0;
        e3 < 0 && (e3 += 1);
        const n2 = this._index + e3 - 1;
        return n2 < 0 || n2 >= this._size ? t2.EOF : this.data[n2];
      }
      LT(t3) {
        return this.LA(t3);
      }
      mark() {
        return -1;
      }
      release(t3) {
      }
      seek(t3) {
        t3 <= this._index ? this._index = t3 : this._index = Math.min(t3, this._size);
      }
      getText(t3, e3) {
        if (e3 >= this._size && (e3 = this._size - 1), t3 >= this._size) return "";
        if (this.decodeToUnicodeCodePoints) {
          let n2 = "";
          for (let s2 = t3; s2 <= e3; s2++) n2 += String.fromCodePoint(this.data[s2]);
          return n2;
        }
        return this.strdata.slice(t3, e3 + 1);
      }
      toString() {
        return this.strdata;
      }
      get index() {
        return this._index;
      }
      get size() {
        return this._size;
      }
    }
    class Ie extends ye {
      constructor(t3, e3) {
        super(t3, e3);
      }
    }
    var ke = n(92);
    const Le = "undefined" != typeof process && null != process.versions && null != process.versions.node;
    class Oe extends Ie {
      static fromPath(t3, e3, n2) {
        if (!Le) throw new Error("FileStream is only available when running in Node!");
        ke.readFile(t3, e3, (function(t4, e4) {
          let s2 = null;
          null !== e4 && (s2 = new ye(e4, true)), n2(t4, s2);
        }));
      }
      constructor(t3, e3, n2) {
        if (!Le) throw new Error("FileStream is only available when running in Node!");
        super(ke.readFileSync(t3, e3 || "utf-8"), n2), this.fileName = t3;
      }
    }
    const ve = { fromString: function(t3) {
      return new ye(t3, true);
    }, fromBlob: function(t3, e3, n2, s2) {
      const i3 = new window.FileReader();
      i3.onload = function(t4) {
        const e4 = new ye(t4.target.result, true);
        n2(e4);
      }, i3.onerror = s2, i3.readAsText(t3, e3);
    }, fromBuffer: function(t3, e3) {
      return new ye(t3.toString(e3), true);
    }, fromPath: function(t3, e3, n2) {
      Oe.fromPath(t3, e3, n2);
    }, fromPathSync: function(t3, e3) {
      return new Oe(t3, e3);
    } }, Re = { arrayToString: c2, stringToCharArray: function(t3) {
      let e3 = new Uint16Array(t3.length);
      for (let n2 = 0; n2 < t3.length; n2++) e3[n2] = t3.charCodeAt(n2);
      return e3;
    } };
    class we {
    }
    class Pe extends we {
      constructor(t3) {
        super(), this.tokenSource = t3, this.tokens = [], this.index = -1, this.fetchedEOF = false;
      }
      mark() {
        return 0;
      }
      release(t3) {
      }
      reset() {
        this.seek(0);
      }
      seek(t3) {
        this.lazyInit(), this.index = this.adjustSeekIndex(t3);
      }
      get size() {
        return this.tokens.length;
      }
      get(t3) {
        return this.lazyInit(), this.tokens[t3];
      }
      consume() {
        let e3 = false;
        if (e3 = this.index >= 0 && (this.fetchedEOF ? this.index < this.tokens.length - 1 : this.index < this.tokens.length), !e3 && this.LA(1) === t2.EOF) throw "cannot consume EOF";
        this.sync(this.index + 1) && (this.index = this.adjustSeekIndex(this.index + 1));
      }
      sync(t3) {
        const e3 = t3 - this.tokens.length + 1;
        return !(e3 > 0) || this.fetch(e3) >= e3;
      }
      fetch(e3) {
        if (this.fetchedEOF) return 0;
        for (let n2 = 0; n2 < e3; n2++) {
          const e4 = this.tokenSource.nextToken();
          if (e4.tokenIndex = this.tokens.length, this.tokens.push(e4), e4.type === t2.EOF) return this.fetchedEOF = true, n2 + 1;
        }
        return e3;
      }
      getTokens(e3, n2, s2) {
        if (void 0 === s2 && (s2 = null), e3 < 0 || n2 < 0) return null;
        this.lazyInit();
        const i3 = [];
        n2 >= this.tokens.length && (n2 = this.tokens.length - 1);
        for (let r3 = e3; r3 < n2; r3++) {
          const e4 = this.tokens[r3];
          if (e4.type === t2.EOF) break;
          (null === s2 || s2.contains(e4.type)) && i3.push(e4);
        }
        return i3;
      }
      LA(t3) {
        return this.LT(t3).type;
      }
      LB(t3) {
        return this.index - t3 < 0 ? null : this.tokens[this.index - t3];
      }
      LT(t3) {
        if (this.lazyInit(), 0 === t3) return null;
        if (t3 < 0) return this.LB(-t3);
        const e3 = this.index + t3 - 1;
        return this.sync(e3), e3 >= this.tokens.length ? this.tokens[this.tokens.length - 1] : this.tokens[e3];
      }
      adjustSeekIndex(t3) {
        return t3;
      }
      lazyInit() {
        -1 === this.index && this.setup();
      }
      setup() {
        this.sync(0), this.index = this.adjustSeekIndex(0);
      }
      setTokenSource(t3) {
        this.tokenSource = t3, this.tokens = [], this.index = -1, this.fetchedEOF = false;
      }
      nextTokenOnChannel(e3, n2) {
        if (this.sync(e3), e3 >= this.tokens.length) return -1;
        let s2 = this.tokens[e3];
        for (; s2.channel !== this.channel; ) {
          if (s2.type === t2.EOF) return -1;
          e3 += 1, this.sync(e3), s2 = this.tokens[e3];
        }
        return e3;
      }
      previousTokenOnChannel(t3, e3) {
        for (; t3 >= 0 && this.tokens[t3].channel !== e3; ) t3 -= 1;
        return t3;
      }
      getHiddenTokensToRight(t3, e3) {
        if (void 0 === e3 && (e3 = -1), this.lazyInit(), t3 < 0 || t3 >= this.tokens.length) throw t3 + " not in 0.." + this.tokens.length - 1;
        const n2 = this.nextTokenOnChannel(t3 + 1, Ut.DEFAULT_TOKEN_CHANNEL), s2 = t3 + 1, i3 = -1 === n2 ? this.tokens.length - 1 : n2;
        return this.filterForChannel(s2, i3, e3);
      }
      getHiddenTokensToLeft(t3, e3) {
        if (void 0 === e3 && (e3 = -1), this.lazyInit(), t3 < 0 || t3 >= this.tokens.length) throw t3 + " not in 0.." + this.tokens.length - 1;
        const n2 = this.previousTokenOnChannel(t3 - 1, Ut.DEFAULT_TOKEN_CHANNEL);
        if (n2 === t3 - 1) return null;
        const s2 = n2 + 1, i3 = t3 - 1;
        return this.filterForChannel(s2, i3, e3);
      }
      filterForChannel(t3, e3, n2) {
        const s2 = [];
        for (let i3 = t3; i3 < e3 + 1; i3++) {
          const t4 = this.tokens[i3];
          -1 === n2 ? t4.channel !== Ut.DEFAULT_TOKEN_CHANNEL && s2.push(t4) : t4.channel === n2 && s2.push(t4);
        }
        return 0 === s2.length ? null : s2;
      }
      getSourceName() {
        return this.tokenSource.getSourceName();
      }
      getText(e3) {
        this.lazyInit(), this.fill(), e3 || (e3 = new m2(0, this.tokens.length - 1));
        let n2 = e3.start;
        n2 instanceof t2 && (n2 = n2.tokenIndex);
        let s2 = e3.stop;
        if (s2 instanceof t2 && (s2 = s2.tokenIndex), null === n2 || null === s2 || n2 < 0 || s2 < 0) return "";
        s2 >= this.tokens.length && (s2 = this.tokens.length - 1);
        let i3 = "";
        for (let e4 = n2; e4 < s2 + 1; e4++) {
          const n3 = this.tokens[e4];
          if (n3.type === t2.EOF) break;
          i3 += n3.text;
        }
        return i3;
      }
      fill() {
        for (this.lazyInit(); 1e3 === this.fetch(1e3); ) ;
      }
    }
    Object.defineProperty(Pe, "size", { get: function() {
      return this.tokens.length;
    } });
    class be extends Pe {
      constructor(e3, n2) {
        super(e3), this.channel = void 0 === n2 ? t2.DEFAULT_CHANNEL : n2;
      }
      adjustSeekIndex(t3) {
        return this.nextTokenOnChannel(t3, this.channel);
      }
      LB(t3) {
        if (0 === t3 || this.index - t3 < 0) return null;
        let e3 = this.index, n2 = 1;
        for (; n2 <= t3; ) e3 = this.previousTokenOnChannel(e3 - 1, this.channel), n2 += 1;
        return e3 < 0 ? null : this.tokens[e3];
      }
      LT(t3) {
        if (this.lazyInit(), 0 === t3) return null;
        if (t3 < 0) return this.LB(-t3);
        let e3 = this.index, n2 = 1;
        for (; n2 < t3; ) this.sync(e3 + 1) && (e3 = this.nextTokenOnChannel(e3 + 1, this.channel)), n2 += 1;
        return this.tokens[e3];
      }
      getNumberOfOnChannelTokens() {
        let e3 = 0;
        this.fill();
        for (let n2 = 0; n2 < this.tokens.length; n2++) {
          const s2 = this.tokens[n2];
          if (s2.channel === this.channel && (e3 += 1), s2.type === t2.EOF) break;
        }
        return e3;
      }
    }
    class De extends de {
      constructor(t3) {
        super(), this.parser = t3;
      }
      enterEveryRule(t3) {
        console.log("enter   " + this.parser.ruleNames[t3.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
      }
      visitTerminal(t3) {
        console.log("consume " + t3.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
      }
      exitEveryRule(t3) {
        console.log("exit    " + this.parser.ruleNames[t3.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
      }
    }
    class Fe extends wt {
      constructor(t3) {
        super(), this._input = null, this._errHandler = new Ae(), this._precedenceStack = [], this._precedenceStack.push(0), this._ctx = null, this.buildParseTrees = true, this._tracer = null, this._parseListeners = null, this._syntaxErrors = 0, this.setInputStream(t3);
      }
      reset() {
        null !== this._input && this._input.seek(0), this._errHandler.reset(this), this._ctx = null, this._syntaxErrors = 0, this.setTrace(false), this._precedenceStack = [], this._precedenceStack.push(0), null !== this._interp && this._interp.reset();
      }
      match(t3) {
        let e3 = this.getCurrentToken();
        return e3.type === t3 ? (this._errHandler.reportMatch(this), this.consume()) : (e3 = this._errHandler.recoverInline(this), this.buildParseTrees && -1 === e3.tokenIndex && this._ctx.addErrorNode(e3)), e3;
      }
      matchWildcard() {
        let t3 = this.getCurrentToken();
        return t3.type > 0 ? (this._errHandler.reportMatch(this), this.consume()) : (t3 = this._errHandler.recoverInline(this), this.buildParseTrees && -1 === t3.tokenIndex && this._ctx.addErrorNode(t3)), t3;
      }
      getParseListeners() {
        return this._parseListeners || [];
      }
      addParseListener(t3) {
        if (null === t3) throw "listener";
        null === this._parseListeners && (this._parseListeners = []), this._parseListeners.push(t3);
      }
      removeParseListener(t3) {
        if (null !== this._parseListeners) {
          const e3 = this._parseListeners.indexOf(t3);
          e3 >= 0 && this._parseListeners.splice(e3, 1), 0 === this._parseListeners.length && (this._parseListeners = null);
        }
      }
      removeParseListeners() {
        this._parseListeners = null;
      }
      triggerEnterRuleEvent() {
        if (null !== this._parseListeners) {
          const t3 = this._ctx;
          this._parseListeners.forEach((function(e3) {
            e3.enterEveryRule(t3), t3.enterRule(e3);
          }));
        }
      }
      triggerExitRuleEvent() {
        if (null !== this._parseListeners) {
          const t3 = this._ctx;
          this._parseListeners.slice(0).reverse().forEach((function(e3) {
            t3.exitRule(e3), e3.exitEveryRule(t3);
          }));
        }
      }
      getTokenFactory() {
        return this._input.tokenSource._factory;
      }
      setTokenFactory(t3) {
        this._input.tokenSource._factory = t3;
      }
      getATNWithBypassAlts() {
        const t3 = this.getSerializedATN();
        if (null === t3) throw "The current parser does not support an ATN with bypass alternatives.";
        let e3 = this.bypassAltsAtnCache[t3];
        if (null === e3) {
          const n2 = new Tt();
          n2.generateRuleBypassTransitions = true, e3 = new Lt(n2).deserialize(t3), this.bypassAltsAtnCache[t3] = e3;
        }
        return e3;
      }
      getInputStream() {
        return this.getTokenStream();
      }
      setInputStream(t3) {
        this.setTokenStream(t3);
      }
      getTokenStream() {
        return this._input;
      }
      setTokenStream(t3) {
        this._input = null, this.reset(), this._input = t3;
      }
      get syntaxErrorsCount() {
        return this._syntaxErrors;
      }
      getCurrentToken() {
        return this._input.LT(1);
      }
      notifyErrorListeners(t3, e3, n2) {
        n2 = n2 || null, null === (e3 = e3 || null) && (e3 = this.getCurrentToken()), this._syntaxErrors += 1;
        const s2 = e3.line, i3 = e3.column;
        this.getErrorListenerDispatch().syntaxError(this, e3, s2, i3, t3, n2);
      }
      consume() {
        const e3 = this.getCurrentToken();
        e3.type !== t2.EOF && this.getInputStream().consume();
        const n2 = null !== this._parseListeners && this._parseListeners.length > 0;
        if (this.buildParseTrees || n2) {
          let t3;
          t3 = this._errHandler.inErrorRecoveryMode(this) ? this._ctx.addErrorNode(e3) : this._ctx.addTokenNode(e3), t3.invokingState = this.state, n2 && this._parseListeners.forEach((function(e4) {
            t3 instanceof b2 || void 0 !== t3.isErrorNode && t3.isErrorNode() ? e4.visitErrorNode(t3) : t3 instanceof P3 && e4.visitTerminal(t3);
          }));
        }
        return e3;
      }
      addContextToParseTree() {
        null !== this._ctx.parentCtx && this._ctx.parentCtx.addChild(this._ctx);
      }
      enterRule(t3, e3, n2) {
        this.state = e3, this._ctx = t3, this._ctx.start = this._input.LT(1), this.buildParseTrees && this.addContextToParseTree(), this.triggerEnterRuleEvent();
      }
      exitRule() {
        this._ctx.stop = this._input.LT(-1), this.triggerExitRuleEvent(), this.state = this._ctx.invokingState, this._ctx = this._ctx.parentCtx;
      }
      enterOuterAlt(t3, e3) {
        t3.setAltNumber(e3), this.buildParseTrees && this._ctx !== t3 && null !== this._ctx.parentCtx && (this._ctx.parentCtx.removeLastChild(), this._ctx.parentCtx.addChild(t3)), this._ctx = t3;
      }
      getPrecedence() {
        return 0 === this._precedenceStack.length ? -1 : this._precedenceStack[this._precedenceStack.length - 1];
      }
      enterRecursionRule(t3, e3, n2, s2) {
        this.state = e3, this._precedenceStack.push(s2), this._ctx = t3, this._ctx.start = this._input.LT(1), this.triggerEnterRuleEvent();
      }
      pushNewRecursionContext(t3, e3, n2) {
        const s2 = this._ctx;
        s2.parentCtx = t3, s2.invokingState = e3, s2.stop = this._input.LT(-1), this._ctx = t3, this._ctx.start = s2.start, this.buildParseTrees && this._ctx.addChild(s2), this.triggerEnterRuleEvent();
      }
      unrollRecursionContexts(t3) {
        this._precedenceStack.pop(), this._ctx.stop = this._input.LT(-1);
        const e3 = this._ctx, n2 = this.getParseListeners();
        if (null !== n2 && n2.length > 0) for (; this._ctx !== t3; ) this.triggerExitRuleEvent(), this._ctx = this._ctx.parentCtx;
        else this._ctx = t3;
        e3.parentCtx = t3, this.buildParseTrees && null !== t3 && t3.addChild(e3);
      }
      getInvokingContext(t3) {
        let e3 = this._ctx;
        for (; null !== e3; ) {
          if (e3.ruleIndex === t3) return e3;
          e3 = e3.parentCtx;
        }
        return null;
      }
      precpred(t3, e3) {
        return e3 >= this._precedenceStack[this._precedenceStack.length - 1];
      }
      inContext(t3) {
        return false;
      }
      isExpectedToken(e3) {
        const n2 = this._interp.atn;
        let s2 = this._ctx;
        const i3 = n2.states[this.state];
        let r3 = n2.nextTokens(i3);
        if (r3.contains(e3)) return true;
        if (!r3.contains(t2.EPSILON)) return false;
        for (; null !== s2 && s2.invokingState >= 0 && r3.contains(t2.EPSILON); ) {
          const t3 = n2.states[s2.invokingState].transitions[0];
          if (r3 = n2.nextTokens(t3.followState), r3.contains(e3)) return true;
          s2 = s2.parentCtx;
        }
        return !(!r3.contains(t2.EPSILON) || e3 !== t2.EOF);
      }
      getExpectedTokens() {
        return this._interp.atn.getExpectedTokens(this.state, this._ctx);
      }
      getExpectedTokensWithinCurrentRule() {
        const t3 = this._interp.atn, e3 = t3.states[this.state];
        return t3.nextTokens(e3);
      }
      getRuleIndex(t3) {
        const e3 = this.getRuleIndexMap()[t3];
        return null !== e3 ? e3 : -1;
      }
      getRuleInvocationStack(t3) {
        null === (t3 = t3 || null) && (t3 = this._ctx);
        const e3 = [];
        for (; null !== t3; ) {
          const n2 = t3.ruleIndex;
          n2 < 0 ? e3.push("n/a") : e3.push(this.ruleNames[n2]), t3 = t3.parentCtx;
        }
        return e3;
      }
      getDFAStrings() {
        return this._interp.decisionToDFA.toString();
      }
      dumpDFA() {
        let t3 = false;
        for (let e3 = 0; e3 < this._interp.decisionToDFA.length; e3++) {
          const n2 = this._interp.decisionToDFA[e3];
          n2.states.length > 0 && (t3 && console.log(), this.printer.println("Decision " + n2.decision + ":"), this.printer.print(n2.toString(this.literalNames, this.symbolicNames)), t3 = true);
        }
      }
      getSourceName() {
        return this._input.sourceName;
      }
      setTrace(t3) {
        t3 ? (null !== this._tracer && this.removeParseListener(this._tracer), this._tracer = new De(this), this.addParseListener(this._tracer)) : (this.removeParseListener(this._tracer), this._tracer = null);
      }
    }
    Fe.bypassAltsAtnCache = {};
    class Me extends P3 {
      constructor(t3) {
        super(), this.parentCtx = null, this.symbol = t3;
      }
      getChild(t3) {
        return null;
      }
      getSymbol() {
        return this.symbol;
      }
      getParent() {
        return this.parentCtx;
      }
      getPayload() {
        return this.symbol;
      }
      getSourceInterval() {
        if (null === this.symbol) return m2.INVALID_INTERVAL;
        const t3 = this.symbol.tokenIndex;
        return new m2(t3, t3);
      }
      getChildCount() {
        return 0;
      }
      accept(t3) {
        return t3.visitTerminal(this);
      }
      getText() {
        return this.symbol.text;
      }
      toString() {
        return this.symbol.type === t2.EOF ? "<EOF>" : this.symbol.text;
      }
    }
    class Ue extends Me {
      constructor(t3) {
        super(t3);
      }
      isErrorNode() {
        return true;
      }
      accept(t3) {
        return t3.visitErrorNode(this);
      }
    }
    class Be extends M2 {
      constructor(t3, e3) {
        super(t3, e3), this.children = null, this.start = null, this.stop = null, this.exception = null;
      }
      copyFrom(t3) {
        this.parentCtx = t3.parentCtx, this.invokingState = t3.invokingState, this.children = null, this.start = t3.start, this.stop = t3.stop, t3.children && (this.children = [], t3.children.map((function(t4) {
          t4 instanceof Ue && (this.children.push(t4), t4.parentCtx = this);
        }), this));
      }
      enterRule(t3) {
      }
      exitRule(t3) {
      }
      addChild(t3) {
        return null === this.children && (this.children = []), this.children.push(t3), t3;
      }
      removeLastChild() {
        null !== this.children && this.children.pop();
      }
      addTokenNode(t3) {
        const e3 = new Me(t3);
        return this.addChild(e3), e3.parentCtx = this, e3;
      }
      addErrorNode(t3) {
        const e3 = new Ue(t3);
        return this.addChild(e3), e3.parentCtx = this, e3;
      }
      getChild(t3, e3) {
        if (e3 = e3 || null, null === this.children || t3 < 0 || t3 >= this.children.length) return null;
        if (null === e3) return this.children[t3];
        for (let n2 = 0; n2 < this.children.length; n2++) {
          const s2 = this.children[n2];
          if (s2 instanceof e3) {
            if (0 === t3) return s2;
            t3 -= 1;
          }
        }
        return null;
      }
      getToken(t3, e3) {
        if (null === this.children || e3 < 0 || e3 >= this.children.length) return null;
        for (let n2 = 0; n2 < this.children.length; n2++) {
          const s2 = this.children[n2];
          if (s2 instanceof P3 && s2.symbol.type === t3) {
            if (0 === e3) return s2;
            e3 -= 1;
          }
        }
        return null;
      }
      getTokens(t3) {
        if (null === this.children) return [];
        {
          const e3 = [];
          for (let n2 = 0; n2 < this.children.length; n2++) {
            const s2 = this.children[n2];
            s2 instanceof P3 && s2.symbol.type === t3 && e3.push(s2);
          }
          return e3;
        }
      }
      getTypedRuleContext(t3, e3) {
        return this.getChild(e3, t3);
      }
      getTypedRuleContexts(t3) {
        if (null === this.children) return [];
        {
          const e3 = [];
          for (let n2 = 0; n2 < this.children.length; n2++) {
            const s2 = this.children[n2];
            s2 instanceof t3 && e3.push(s2);
          }
          return e3;
        }
      }
      getChildCount() {
        return null === this.children ? 0 : this.children.length;
      }
      getSourceInterval() {
        return null === this.start || null === this.stop ? m2.INVALID_INTERVAL : new m2(this.start.tokenIndex, this.stop.tokenIndex);
      }
    }
    M2.EMPTY = new Be();
    class Ve {
      constructor(t3) {
        this.tokens = t3, this.programs = /* @__PURE__ */ new Map();
      }
      getTokenStream() {
        return this.tokens;
      }
      insertAfter(t3, e3) {
        let n2, s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ve.DEFAULT_PROGRAM_NAME;
        n2 = "number" == typeof t3 ? t3 : t3.tokenIndex;
        let i3 = this.getProgram(s2), r3 = new Ge(this.tokens, n2, i3.length, e3);
        i3.push(r3);
      }
      insertBefore(t3, e3) {
        let n2, s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ve.DEFAULT_PROGRAM_NAME;
        n2 = "number" == typeof t3 ? t3 : t3.tokenIndex;
        const i3 = this.getProgram(s2), r3 = new Ye(this.tokens, n2, i3.length, e3);
        i3.push(r3);
      }
      replaceSingle(t3, e3) {
        let n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ve.DEFAULT_PROGRAM_NAME;
        this.replace(t3, t3, e3, n2);
      }
      replace(t3, e3, n2) {
        let s2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ve.DEFAULT_PROGRAM_NAME;
        if ("number" != typeof t3 && (t3 = t3.tokenIndex), "number" != typeof e3 && (e3 = e3.tokenIndex), t3 > e3 || t3 < 0 || e3 < 0 || e3 >= this.tokens.size) throw new RangeError(`replace: range invalid: ${t3}..${e3}(size=${this.tokens.size})`);
        let i3 = this.getProgram(s2), r3 = new je(this.tokens, t3, e3, i3.length, n2);
        i3.push(r3);
      }
      delete(t3, e3) {
        let n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ve.DEFAULT_PROGRAM_NAME;
        void 0 === e3 && (e3 = t3), this.replace(t3, e3, null, n2);
      }
      getProgram(t3) {
        let e3 = this.programs.get(t3);
        return null == e3 && (e3 = this.initializeProgram(t3)), e3;
      }
      initializeProgram(t3) {
        const e3 = [];
        return this.programs.set(t3, e3), e3;
      }
      getText(e3) {
        let n2, s2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ve.DEFAULT_PROGRAM_NAME;
        n2 = e3 instanceof m2 ? e3 : new m2(0, this.tokens.size - 1), "string" == typeof e3 && (s2 = e3);
        const i3 = this.programs.get(s2);
        let r3 = n2.start, o3 = n2.stop;
        if (o3 > this.tokens.size - 1 && (o3 = this.tokens.size - 1), r3 < 0 && (r3 = 0), null == i3 || 0 === i3.length) return this.tokens.getText(new m2(r3, o3));
        let a3 = [], l3 = this.reduceToSingleOperationPerIndex(i3), h3 = r3;
        for (; h3 <= o3 && h3 < this.tokens.size; ) {
          let e4 = l3.get(h3);
          l3.delete(h3);
          let n3 = this.tokens.get(h3);
          null == e4 ? (n3.type !== t2.EOF && a3.push(String(n3.text)), h3++) : h3 = e4.execute(a3);
        }
        if (o3 === this.tokens.size - 1) for (const t3 of l3.values()) t3.index >= this.tokens.size - 1 && a3.push(t3.text.toString());
        return a3.join("");
      }
      reduceToSingleOperationPerIndex(t3) {
        for (let e4 = 0; e4 < t3.length; e4++) {
          let n2 = t3[e4];
          if (null == n2) continue;
          if (!(n2 instanceof je)) continue;
          let s2 = n2, i3 = this.getKindOfOps(t3, Ye, e4);
          for (let e5 of i3) e5.index === s2.index ? (t3[e5.instructionIndex] = void 0, s2.text = e5.text.toString() + (null != s2.text ? s2.text.toString() : "")) : e5.index > s2.index && e5.index <= s2.lastIndex && (t3[e5.instructionIndex] = void 0);
          let r3 = this.getKindOfOps(t3, je, e4);
          for (let e5 of r3) {
            if (e5.index >= s2.index && e5.lastIndex <= s2.lastIndex) {
              t3[e5.instructionIndex] = void 0;
              continue;
            }
            let n3 = e5.lastIndex < s2.index || e5.index > s2.lastIndex;
            if (null != e5.text || null != s2.text || n3) {
              if (!n3) throw new Error(`replace op boundaries of ${s2} overlap with previous ${e5}`);
            } else t3[e5.instructionIndex] = void 0, s2.index = Math.min(e5.index, s2.index), s2.lastIndex = Math.max(e5.lastIndex, s2.lastIndex);
          }
        }
        for (let e4 = 0; e4 < t3.length; e4++) {
          let n2 = t3[e4];
          if (null == n2) continue;
          if (!(n2 instanceof Ye)) continue;
          let s2 = n2, i3 = this.getKindOfOps(t3, Ye, e4);
          for (let e5 of i3) e5.index === s2.index && (e5 instanceof Ge ? (s2.text = this.catOpText(e5.text, s2.text), t3[e5.instructionIndex] = void 0) : e5 instanceof Ye && (s2.text = this.catOpText(s2.text, e5.text), t3[e5.instructionIndex] = void 0));
          let r3 = this.getKindOfOps(t3, je, e4);
          for (let n3 of r3) if (s2.index !== n3.index) {
            if (s2.index >= n3.index && s2.index <= n3.lastIndex) throw new Error(`insert op ${s2} within boundaries of previous ${n3}`);
          } else n3.text = this.catOpText(s2.text, n3.text), t3[e4] = void 0;
        }
        let e3 = /* @__PURE__ */ new Map();
        for (let n2 of t3) if (null != n2) {
          if (null != e3.get(n2.index)) throw new Error("should only be one op per index");
          e3.set(n2.index, n2);
        }
        return e3;
      }
      catOpText(t3, e3) {
        let n2 = "", s2 = "";
        return null != t3 && (n2 = t3.toString()), null != e3 && (s2 = e3.toString()), n2 + s2;
      }
      getKindOfOps(t3, e3, n2) {
        return t3.slice(0, n2).filter(((t4) => t4 && t4 instanceof e3));
      }
    }
    var ze, qe, He;
    ze = Ve, He = "default", (qe = (function(t3) {
      var e3 = (function(t4, e4) {
        if ("object" != typeof t4 || null === t4) return t4;
        var n2 = t4[Symbol.toPrimitive];
        if (void 0 !== n2) {
          var s2 = n2.call(t4, "string");
          if ("object" != typeof s2) return s2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return String(t4);
      })(t3);
      return "symbol" == typeof e3 ? e3 : String(e3);
    })(qe = "DEFAULT_PROGRAM_NAME")) in ze ? Object.defineProperty(ze, qe, { value: He, enumerable: true, configurable: true, writable: true }) : ze[qe] = He;
    class Ke {
      constructor(t3, e3, n2, s2) {
        this.tokens = t3, this.instructionIndex = n2, this.index = e3, this.text = void 0 === s2 ? "" : s2;
      }
      toString() {
        let t3 = this.constructor.name;
        const e3 = t3.indexOf("$");
        return t3 = t3.substring(e3 + 1, t3.length), "<" + t3 + "@" + this.tokens.get(this.index) + ':"' + this.text + '">';
      }
    }
    class Ye extends Ke {
      constructor(t3, e3, n2, s2) {
        super(t3, e3, n2, s2);
      }
      execute(e3) {
        return this.text && e3.push(this.text.toString()), this.tokens.get(this.index).type !== t2.EOF && e3.push(String(this.tokens.get(this.index).text)), this.index + 1;
      }
    }
    class Ge extends Ye {
      constructor(t3, e3, n2, s2) {
        super(t3, e3 + 1, n2, s2);
      }
    }
    class je extends Ke {
      constructor(t3, e3, n2, s2, i3) {
        super(t3, e3, s2, i3), this.lastIndex = n2;
      }
      execute(t3) {
        return this.text && t3.push(this.text.toString()), this.lastIndex + 1;
      }
      toString() {
        return null == this.text ? "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">" : "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
      }
    }
    const We = { atn: re, dfa: he, context: ce, misc: ue, tree: fe, error: Ne, Token: t2, CommonToken: Pt, CharStreams: ve, CharStream: Ie, InputStream: Ie, CommonTokenStream: be, Lexer: Ut, Parser: Fe, ParserRuleContext: Be, Interval: m2, IntervalSet: E2, LL1Analyzer: W, Utils: Re, TokenStreamRewriter: Ve };
  })();
  var i = s.dx;
  var r = s.q2;
  var o = s.FO;
  var a = s.xf;
  var l = s.Gy;
  var h = s.s4;
  var c = s.c7;
  var u = s._7;
  var d = s.tx;
  var p = s.gp;
  var g = s.cK;
  var f = s.zs;
  var x = s.AV;
  var T = s.Xp;
  var S = s.VS;
  var m = s.ul;
  var E = s.hW;
  var _ = s.x1;
  var A = s.z5;
  var C = s.oN;
  var N = s.TB;
  var y = s.u1;
  var I = s._b;
  var k = s.$F;
  var L = s._T;
  var O = s.db;
  var v = s.Zx;
  var R = s._x;
  var w = s.r8;
  var P2 = s.JI;
  var b = s.TP;
  var D = s.WU;
  var F = s.Nj;
  var M = s.ZP;

  // ../insight-maker-simulation/src/formula/grammar/FormulaLexer.js
  var serializedATN = [
    4,
    0,
    61,
    486,
    6,
    -1,
    2,
    0,
    7,
    0,
    2,
    1,
    7,
    1,
    2,
    2,
    7,
    2,
    2,
    3,
    7,
    3,
    2,
    4,
    7,
    4,
    2,
    5,
    7,
    5,
    2,
    6,
    7,
    6,
    2,
    7,
    7,
    7,
    2,
    8,
    7,
    8,
    2,
    9,
    7,
    9,
    2,
    10,
    7,
    10,
    2,
    11,
    7,
    11,
    2,
    12,
    7,
    12,
    2,
    13,
    7,
    13,
    2,
    14,
    7,
    14,
    2,
    15,
    7,
    15,
    2,
    16,
    7,
    16,
    2,
    17,
    7,
    17,
    2,
    18,
    7,
    18,
    2,
    19,
    7,
    19,
    2,
    20,
    7,
    20,
    2,
    21,
    7,
    21,
    2,
    22,
    7,
    22,
    2,
    23,
    7,
    23,
    2,
    24,
    7,
    24,
    2,
    25,
    7,
    25,
    2,
    26,
    7,
    26,
    2,
    27,
    7,
    27,
    2,
    28,
    7,
    28,
    2,
    29,
    7,
    29,
    2,
    30,
    7,
    30,
    2,
    31,
    7,
    31,
    2,
    32,
    7,
    32,
    2,
    33,
    7,
    33,
    2,
    34,
    7,
    34,
    2,
    35,
    7,
    35,
    2,
    36,
    7,
    36,
    2,
    37,
    7,
    37,
    2,
    38,
    7,
    38,
    2,
    39,
    7,
    39,
    2,
    40,
    7,
    40,
    2,
    41,
    7,
    41,
    2,
    42,
    7,
    42,
    2,
    43,
    7,
    43,
    2,
    44,
    7,
    44,
    2,
    45,
    7,
    45,
    2,
    46,
    7,
    46,
    2,
    47,
    7,
    47,
    2,
    48,
    7,
    48,
    2,
    49,
    7,
    49,
    2,
    50,
    7,
    50,
    2,
    51,
    7,
    51,
    2,
    52,
    7,
    52,
    2,
    53,
    7,
    53,
    2,
    54,
    7,
    54,
    2,
    55,
    7,
    55,
    2,
    56,
    7,
    56,
    2,
    57,
    7,
    57,
    2,
    58,
    7,
    58,
    2,
    59,
    7,
    59,
    2,
    60,
    7,
    60,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    2,
    1,
    2,
    1,
    3,
    1,
    3,
    1,
    3,
    1,
    4,
    1,
    4,
    1,
    5,
    1,
    5,
    1,
    6,
    1,
    6,
    1,
    6,
    1,
    6,
    1,
    7,
    1,
    7,
    1,
    8,
    3,
    8,
    144,
    8,
    8,
    1,
    8,
    1,
    8,
    1,
    8,
    1,
    8,
    5,
    8,
    150,
    8,
    8,
    10,
    8,
    12,
    8,
    153,
    9,
    8,
    1,
    8,
    1,
    8,
    1,
    8,
    1,
    8,
    3,
    8,
    159,
    8,
    8,
    1,
    8,
    1,
    8,
    1,
    9,
    3,
    9,
    164,
    8,
    9,
    1,
    9,
    1,
    9,
    1,
    9,
    3,
    9,
    169,
    8,
    9,
    1,
    9,
    5,
    9,
    172,
    8,
    9,
    10,
    9,
    12,
    9,
    175,
    9,
    9,
    1,
    9,
    3,
    9,
    178,
    8,
    9,
    1,
    9,
    1,
    9,
    1,
    10,
    5,
    10,
    183,
    8,
    10,
    10,
    10,
    12,
    10,
    186,
    9,
    10,
    1,
    10,
    1,
    10,
    5,
    10,
    190,
    8,
    10,
    10,
    10,
    12,
    10,
    193,
    9,
    10,
    4,
    10,
    195,
    8,
    10,
    11,
    10,
    12,
    10,
    196,
    1,
    11,
    4,
    11,
    200,
    8,
    11,
    11,
    11,
    12,
    11,
    201,
    1,
    12,
    1,
    12,
    1,
    13,
    1,
    13,
    1,
    13,
    1,
    13,
    1,
    13,
    1,
    13,
    1,
    14,
    1,
    14,
    1,
    14,
    1,
    14,
    1,
    15,
    1,
    15,
    1,
    15,
    1,
    15,
    1,
    15,
    1,
    16,
    1,
    16,
    1,
    16,
    1,
    17,
    1,
    17,
    1,
    17,
    1,
    18,
    1,
    18,
    1,
    18,
    1,
    19,
    1,
    19,
    1,
    19,
    1,
    19,
    1,
    19,
    1,
    20,
    1,
    20,
    1,
    20,
    1,
    21,
    1,
    21,
    1,
    21,
    1,
    21,
    1,
    21,
    1,
    22,
    1,
    22,
    1,
    22,
    1,
    22,
    1,
    22,
    1,
    23,
    1,
    23,
    1,
    23,
    1,
    23,
    1,
    23,
    1,
    23,
    1,
    23,
    1,
    23,
    1,
    23,
    1,
    24,
    1,
    24,
    1,
    24,
    1,
    24,
    1,
    25,
    1,
    25,
    1,
    25,
    1,
    25,
    1,
    25,
    1,
    25,
    1,
    25,
    1,
    26,
    1,
    26,
    1,
    26,
    1,
    26,
    1,
    27,
    1,
    27,
    1,
    27,
    1,
    27,
    1,
    28,
    1,
    28,
    1,
    28,
    1,
    28,
    1,
    28,
    1,
    28,
    1,
    29,
    1,
    29,
    1,
    29,
    1,
    29,
    1,
    29,
    1,
    29,
    1,
    30,
    1,
    30,
    1,
    30,
    1,
    30,
    3,
    30,
    292,
    8,
    30,
    1,
    31,
    1,
    31,
    1,
    31,
    1,
    31,
    1,
    32,
    1,
    32,
    1,
    32,
    1,
    32,
    1,
    32,
    3,
    32,
    303,
    8,
    32,
    1,
    33,
    1,
    33,
    1,
    33,
    3,
    33,
    308,
    8,
    33,
    1,
    34,
    1,
    34,
    1,
    34,
    1,
    34,
    3,
    34,
    314,
    8,
    34,
    1,
    35,
    1,
    35,
    1,
    36,
    1,
    36,
    1,
    36,
    1,
    37,
    1,
    37,
    1,
    38,
    1,
    38,
    1,
    38,
    1,
    39,
    1,
    39,
    1,
    40,
    1,
    40,
    1,
    41,
    1,
    41,
    1,
    42,
    1,
    42,
    1,
    43,
    1,
    43,
    1,
    43,
    1,
    43,
    3,
    43,
    338,
    8,
    43,
    1,
    44,
    1,
    44,
    1,
    45,
    1,
    45,
    1,
    45,
    3,
    45,
    345,
    8,
    45,
    1,
    46,
    1,
    46,
    1,
    46,
    3,
    46,
    350,
    8,
    46,
    1,
    47,
    1,
    47,
    1,
    48,
    1,
    48,
    1,
    49,
    4,
    49,
    357,
    8,
    49,
    11,
    49,
    12,
    49,
    358,
    1,
    49,
    1,
    49,
    3,
    49,
    363,
    8,
    49,
    1,
    49,
    5,
    49,
    366,
    8,
    49,
    10,
    49,
    12,
    49,
    369,
    9,
    49,
    3,
    49,
    371,
    8,
    49,
    1,
    50,
    5,
    50,
    374,
    8,
    50,
    10,
    50,
    12,
    50,
    377,
    9,
    50,
    1,
    50,
    1,
    50,
    4,
    50,
    381,
    8,
    50,
    11,
    50,
    12,
    50,
    382,
    1,
    50,
    4,
    50,
    386,
    8,
    50,
    11,
    50,
    12,
    50,
    387,
    1,
    50,
    3,
    50,
    391,
    8,
    50,
    1,
    50,
    1,
    50,
    3,
    50,
    395,
    8,
    50,
    1,
    50,
    5,
    50,
    398,
    8,
    50,
    10,
    50,
    12,
    50,
    401,
    9,
    50,
    3,
    50,
    403,
    8,
    50,
    1,
    51,
    1,
    51,
    1,
    51,
    1,
    51,
    1,
    51,
    1,
    51,
    1,
    51,
    1,
    51,
    1,
    51,
    3,
    51,
    414,
    8,
    51,
    1,
    52,
    1,
    52,
    1,
    52,
    1,
    52,
    1,
    53,
    1,
    53,
    1,
    53,
    1,
    53,
    1,
    53,
    1,
    53,
    1,
    53,
    1,
    53,
    1,
    54,
    1,
    54,
    1,
    54,
    1,
    54,
    1,
    54,
    1,
    54,
    1,
    55,
    1,
    55,
    5,
    55,
    436,
    8,
    55,
    10,
    55,
    12,
    55,
    439,
    9,
    55,
    1,
    56,
    1,
    56,
    4,
    56,
    443,
    8,
    56,
    11,
    56,
    12,
    56,
    444,
    1,
    56,
    1,
    56,
    1,
    56,
    1,
    56,
    1,
    56,
    4,
    56,
    452,
    8,
    56,
    11,
    56,
    12,
    56,
    453,
    1,
    56,
    1,
    56,
    1,
    56,
    3,
    56,
    459,
    8,
    56,
    1,
    57,
    1,
    57,
    1,
    58,
    1,
    58,
    1,
    59,
    1,
    59,
    1,
    60,
    1,
    60,
    5,
    60,
    469,
    8,
    60,
    10,
    60,
    12,
    60,
    472,
    9,
    60,
    1,
    60,
    1,
    60,
    1,
    60,
    1,
    60,
    1,
    60,
    5,
    60,
    479,
    8,
    60,
    10,
    60,
    12,
    60,
    482,
    9,
    60,
    1,
    60,
    3,
    60,
    485,
    8,
    60,
    4,
    151,
    444,
    453,
    470,
    0,
    61,
    1,
    1,
    3,
    2,
    5,
    3,
    7,
    4,
    9,
    5,
    11,
    6,
    13,
    7,
    15,
    8,
    17,
    9,
    19,
    10,
    21,
    11,
    23,
    12,
    25,
    13,
    27,
    14,
    29,
    15,
    31,
    16,
    33,
    17,
    35,
    18,
    37,
    19,
    39,
    20,
    41,
    21,
    43,
    22,
    45,
    23,
    47,
    24,
    49,
    25,
    51,
    26,
    53,
    27,
    55,
    28,
    57,
    29,
    59,
    30,
    61,
    31,
    63,
    32,
    65,
    33,
    67,
    34,
    69,
    35,
    71,
    36,
    73,
    37,
    75,
    38,
    77,
    39,
    79,
    40,
    81,
    41,
    83,
    42,
    85,
    43,
    87,
    44,
    89,
    45,
    91,
    46,
    93,
    47,
    95,
    48,
    97,
    49,
    99,
    50,
    101,
    51,
    103,
    52,
    105,
    53,
    107,
    54,
    109,
    55,
    111,
    56,
    113,
    57,
    115,
    58,
    117,
    59,
    119,
    60,
    121,
    61,
    1,
    0,
    28,
    2,
    0,
    78,
    78,
    110,
    110,
    2,
    0,
    79,
    79,
    111,
    111,
    2,
    0,
    84,
    84,
    116,
    116,
    2,
    0,
    10,
    10,
    13,
    13,
    2,
    0,
    87,
    87,
    119,
    119,
    2,
    0,
    72,
    72,
    104,
    104,
    2,
    0,
    73,
    73,
    105,
    105,
    2,
    0,
    76,
    76,
    108,
    108,
    2,
    0,
    69,
    69,
    101,
    101,
    2,
    0,
    70,
    70,
    102,
    102,
    2,
    0,
    82,
    82,
    114,
    114,
    2,
    0,
    77,
    77,
    109,
    109,
    2,
    0,
    66,
    66,
    98,
    98,
    2,
    0,
    89,
    89,
    121,
    121,
    2,
    0,
    80,
    80,
    112,
    112,
    2,
    0,
    83,
    83,
    115,
    115,
    2,
    0,
    85,
    85,
    117,
    117,
    2,
    0,
    67,
    67,
    99,
    99,
    2,
    0,
    68,
    68,
    100,
    100,
    2,
    0,
    65,
    65,
    97,
    97,
    2,
    0,
    88,
    88,
    120,
    120,
    2,
    0,
    43,
    43,
    45,
    45,
    2,
    0,
    81,
    81,
    113,
    113,
    659,
    0,
    65,
    90,
    97,
    122,
    170,
    170,
    181,
    181,
    186,
    186,
    192,
    214,
    216,
    246,
    248,
    705,
    710,
    721,
    736,
    740,
    748,
    748,
    750,
    750,
    880,
    884,
    886,
    887,
    890,
    893,
    895,
    895,
    902,
    902,
    904,
    906,
    908,
    908,
    910,
    929,
    931,
    1013,
    1015,
    1153,
    1162,
    1327,
    1329,
    1366,
    1369,
    1369,
    1376,
    1416,
    1488,
    1514,
    1519,
    1522,
    1568,
    1610,
    1646,
    1647,
    1649,
    1747,
    1749,
    1749,
    1765,
    1766,
    1774,
    1775,
    1786,
    1788,
    1791,
    1791,
    1808,
    1808,
    1810,
    1839,
    1869,
    1957,
    1969,
    1969,
    1994,
    2026,
    2036,
    2037,
    2042,
    2042,
    2048,
    2069,
    2074,
    2074,
    2084,
    2084,
    2088,
    2088,
    2112,
    2136,
    2144,
    2154,
    2160,
    2183,
    2185,
    2190,
    2208,
    2249,
    2308,
    2361,
    2365,
    2365,
    2384,
    2384,
    2392,
    2401,
    2417,
    2432,
    2437,
    2444,
    2447,
    2448,
    2451,
    2472,
    2474,
    2480,
    2482,
    2482,
    2486,
    2489,
    2493,
    2493,
    2510,
    2510,
    2524,
    2525,
    2527,
    2529,
    2544,
    2545,
    2556,
    2556,
    2565,
    2570,
    2575,
    2576,
    2579,
    2600,
    2602,
    2608,
    2610,
    2611,
    2613,
    2614,
    2616,
    2617,
    2649,
    2652,
    2654,
    2654,
    2674,
    2676,
    2693,
    2701,
    2703,
    2705,
    2707,
    2728,
    2730,
    2736,
    2738,
    2739,
    2741,
    2745,
    2749,
    2749,
    2768,
    2768,
    2784,
    2785,
    2809,
    2809,
    2821,
    2828,
    2831,
    2832,
    2835,
    2856,
    2858,
    2864,
    2866,
    2867,
    2869,
    2873,
    2877,
    2877,
    2908,
    2909,
    2911,
    2913,
    2929,
    2929,
    2947,
    2947,
    2949,
    2954,
    2958,
    2960,
    2962,
    2965,
    2969,
    2970,
    2972,
    2972,
    2974,
    2975,
    2979,
    2980,
    2984,
    2986,
    2990,
    3001,
    3024,
    3024,
    3077,
    3084,
    3086,
    3088,
    3090,
    3112,
    3114,
    3129,
    3133,
    3133,
    3160,
    3162,
    3165,
    3165,
    3168,
    3169,
    3200,
    3200,
    3205,
    3212,
    3214,
    3216,
    3218,
    3240,
    3242,
    3251,
    3253,
    3257,
    3261,
    3261,
    3293,
    3294,
    3296,
    3297,
    3313,
    3314,
    3332,
    3340,
    3342,
    3344,
    3346,
    3386,
    3389,
    3389,
    3406,
    3406,
    3412,
    3414,
    3423,
    3425,
    3450,
    3455,
    3461,
    3478,
    3482,
    3505,
    3507,
    3515,
    3517,
    3517,
    3520,
    3526,
    3585,
    3632,
    3634,
    3635,
    3648,
    3654,
    3713,
    3714,
    3716,
    3716,
    3718,
    3722,
    3724,
    3747,
    3749,
    3749,
    3751,
    3760,
    3762,
    3763,
    3773,
    3773,
    3776,
    3780,
    3782,
    3782,
    3804,
    3807,
    3840,
    3840,
    3904,
    3911,
    3913,
    3948,
    3976,
    3980,
    4096,
    4138,
    4159,
    4159,
    4176,
    4181,
    4186,
    4189,
    4193,
    4193,
    4197,
    4198,
    4206,
    4208,
    4213,
    4225,
    4238,
    4238,
    4256,
    4293,
    4295,
    4295,
    4301,
    4301,
    4304,
    4346,
    4348,
    4680,
    4682,
    4685,
    4688,
    4694,
    4696,
    4696,
    4698,
    4701,
    4704,
    4744,
    4746,
    4749,
    4752,
    4784,
    4786,
    4789,
    4792,
    4798,
    4800,
    4800,
    4802,
    4805,
    4808,
    4822,
    4824,
    4880,
    4882,
    4885,
    4888,
    4954,
    4992,
    5007,
    5024,
    5109,
    5112,
    5117,
    5121,
    5740,
    5743,
    5759,
    5761,
    5786,
    5792,
    5866,
    5873,
    5880,
    5888,
    5905,
    5919,
    5937,
    5952,
    5969,
    5984,
    5996,
    5998,
    6e3,
    6016,
    6067,
    6103,
    6103,
    6108,
    6108,
    6176,
    6264,
    6272,
    6276,
    6279,
    6312,
    6314,
    6314,
    6320,
    6389,
    6400,
    6430,
    6480,
    6509,
    6512,
    6516,
    6528,
    6571,
    6576,
    6601,
    6656,
    6678,
    6688,
    6740,
    6823,
    6823,
    6917,
    6963,
    6981,
    6988,
    7043,
    7072,
    7086,
    7087,
    7098,
    7141,
    7168,
    7203,
    7245,
    7247,
    7258,
    7293,
    7296,
    7304,
    7312,
    7354,
    7357,
    7359,
    7401,
    7404,
    7406,
    7411,
    7413,
    7414,
    7418,
    7418,
    7424,
    7615,
    7680,
    7957,
    7960,
    7965,
    7968,
    8005,
    8008,
    8013,
    8016,
    8023,
    8025,
    8025,
    8027,
    8027,
    8029,
    8029,
    8031,
    8061,
    8064,
    8116,
    8118,
    8124,
    8126,
    8126,
    8130,
    8132,
    8134,
    8140,
    8144,
    8147,
    8150,
    8155,
    8160,
    8172,
    8178,
    8180,
    8182,
    8188,
    8305,
    8305,
    8319,
    8319,
    8336,
    8348,
    8450,
    8450,
    8455,
    8455,
    8458,
    8467,
    8469,
    8469,
    8473,
    8477,
    8484,
    8484,
    8486,
    8486,
    8488,
    8488,
    8490,
    8493,
    8495,
    8505,
    8508,
    8511,
    8517,
    8521,
    8526,
    8526,
    8579,
    8580,
    11264,
    11492,
    11499,
    11502,
    11506,
    11507,
    11520,
    11557,
    11559,
    11559,
    11565,
    11565,
    11568,
    11623,
    11631,
    11631,
    11648,
    11670,
    11680,
    11686,
    11688,
    11694,
    11696,
    11702,
    11704,
    11710,
    11712,
    11718,
    11720,
    11726,
    11728,
    11734,
    11736,
    11742,
    11823,
    11823,
    12293,
    12294,
    12337,
    12341,
    12347,
    12348,
    12353,
    12438,
    12445,
    12447,
    12449,
    12538,
    12540,
    12543,
    12549,
    12591,
    12593,
    12686,
    12704,
    12735,
    12784,
    12799,
    13312,
    19903,
    19968,
    42124,
    42192,
    42237,
    42240,
    42508,
    42512,
    42527,
    42538,
    42539,
    42560,
    42606,
    42623,
    42653,
    42656,
    42725,
    42775,
    42783,
    42786,
    42888,
    42891,
    42954,
    42960,
    42961,
    42963,
    42963,
    42965,
    42969,
    42994,
    43009,
    43011,
    43013,
    43015,
    43018,
    43020,
    43042,
    43072,
    43123,
    43138,
    43187,
    43250,
    43255,
    43259,
    43259,
    43261,
    43262,
    43274,
    43301,
    43312,
    43334,
    43360,
    43388,
    43396,
    43442,
    43471,
    43471,
    43488,
    43492,
    43494,
    43503,
    43514,
    43518,
    43520,
    43560,
    43584,
    43586,
    43588,
    43595,
    43616,
    43638,
    43642,
    43642,
    43646,
    43695,
    43697,
    43697,
    43701,
    43702,
    43705,
    43709,
    43712,
    43712,
    43714,
    43714,
    43739,
    43741,
    43744,
    43754,
    43762,
    43764,
    43777,
    43782,
    43785,
    43790,
    43793,
    43798,
    43808,
    43814,
    43816,
    43822,
    43824,
    43866,
    43868,
    43881,
    43888,
    44002,
    44032,
    55203,
    55216,
    55238,
    55243,
    55291,
    63744,
    64109,
    64112,
    64217,
    64256,
    64262,
    64275,
    64279,
    64285,
    64285,
    64287,
    64296,
    64298,
    64310,
    64312,
    64316,
    64318,
    64318,
    64320,
    64321,
    64323,
    64324,
    64326,
    64433,
    64467,
    64829,
    64848,
    64911,
    64914,
    64967,
    65008,
    65019,
    65136,
    65140,
    65142,
    65276,
    65313,
    65338,
    65345,
    65370,
    65382,
    65470,
    65474,
    65479,
    65482,
    65487,
    65490,
    65495,
    65498,
    65500,
    65536,
    65547,
    65549,
    65574,
    65576,
    65594,
    65596,
    65597,
    65599,
    65613,
    65616,
    65629,
    65664,
    65786,
    66176,
    66204,
    66208,
    66256,
    66304,
    66335,
    66349,
    66368,
    66370,
    66377,
    66384,
    66421,
    66432,
    66461,
    66464,
    66499,
    66504,
    66511,
    66560,
    66717,
    66736,
    66771,
    66776,
    66811,
    66816,
    66855,
    66864,
    66915,
    66928,
    66938,
    66940,
    66954,
    66956,
    66962,
    66964,
    66965,
    66967,
    66977,
    66979,
    66993,
    66995,
    67001,
    67003,
    67004,
    67072,
    67382,
    67392,
    67413,
    67424,
    67431,
    67456,
    67461,
    67463,
    67504,
    67506,
    67514,
    67584,
    67589,
    67592,
    67592,
    67594,
    67637,
    67639,
    67640,
    67644,
    67644,
    67647,
    67669,
    67680,
    67702,
    67712,
    67742,
    67808,
    67826,
    67828,
    67829,
    67840,
    67861,
    67872,
    67897,
    67968,
    68023,
    68030,
    68031,
    68096,
    68096,
    68112,
    68115,
    68117,
    68119,
    68121,
    68149,
    68192,
    68220,
    68224,
    68252,
    68288,
    68295,
    68297,
    68324,
    68352,
    68405,
    68416,
    68437,
    68448,
    68466,
    68480,
    68497,
    68608,
    68680,
    68736,
    68786,
    68800,
    68850,
    68864,
    68899,
    69248,
    69289,
    69296,
    69297,
    69376,
    69404,
    69415,
    69415,
    69424,
    69445,
    69488,
    69505,
    69552,
    69572,
    69600,
    69622,
    69635,
    69687,
    69745,
    69746,
    69749,
    69749,
    69763,
    69807,
    69840,
    69864,
    69891,
    69926,
    69956,
    69956,
    69959,
    69959,
    69968,
    70002,
    70006,
    70006,
    70019,
    70066,
    70081,
    70084,
    70106,
    70106,
    70108,
    70108,
    70144,
    70161,
    70163,
    70187,
    70207,
    70208,
    70272,
    70278,
    70280,
    70280,
    70282,
    70285,
    70287,
    70301,
    70303,
    70312,
    70320,
    70366,
    70405,
    70412,
    70415,
    70416,
    70419,
    70440,
    70442,
    70448,
    70450,
    70451,
    70453,
    70457,
    70461,
    70461,
    70480,
    70480,
    70493,
    70497,
    70656,
    70708,
    70727,
    70730,
    70751,
    70753,
    70784,
    70831,
    70852,
    70853,
    70855,
    70855,
    71040,
    71086,
    71128,
    71131,
    71168,
    71215,
    71236,
    71236,
    71296,
    71338,
    71352,
    71352,
    71424,
    71450,
    71488,
    71494,
    71680,
    71723,
    71840,
    71903,
    71935,
    71942,
    71945,
    71945,
    71948,
    71955,
    71957,
    71958,
    71960,
    71983,
    71999,
    71999,
    72001,
    72001,
    72096,
    72103,
    72106,
    72144,
    72161,
    72161,
    72163,
    72163,
    72192,
    72192,
    72203,
    72242,
    72250,
    72250,
    72272,
    72272,
    72284,
    72329,
    72349,
    72349,
    72368,
    72440,
    72704,
    72712,
    72714,
    72750,
    72768,
    72768,
    72818,
    72847,
    72960,
    72966,
    72968,
    72969,
    72971,
    73008,
    73030,
    73030,
    73056,
    73061,
    73063,
    73064,
    73066,
    73097,
    73112,
    73112,
    73440,
    73458,
    73474,
    73474,
    73476,
    73488,
    73490,
    73523,
    73648,
    73648,
    73728,
    74649,
    74880,
    75075,
    77712,
    77808,
    77824,
    78895,
    78913,
    78918,
    82944,
    83526,
    92160,
    92728,
    92736,
    92766,
    92784,
    92862,
    92880,
    92909,
    92928,
    92975,
    92992,
    92995,
    93027,
    93047,
    93053,
    93071,
    93760,
    93823,
    93952,
    94026,
    94032,
    94032,
    94099,
    94111,
    94176,
    94177,
    94179,
    94179,
    94208,
    100343,
    100352,
    101589,
    101632,
    101640,
    110576,
    110579,
    110581,
    110587,
    110589,
    110590,
    110592,
    110882,
    110898,
    110898,
    110928,
    110930,
    110933,
    110933,
    110948,
    110951,
    110960,
    111355,
    113664,
    113770,
    113776,
    113788,
    113792,
    113800,
    113808,
    113817,
    119808,
    119892,
    119894,
    119964,
    119966,
    119967,
    119970,
    119970,
    119973,
    119974,
    119977,
    119980,
    119982,
    119993,
    119995,
    119995,
    119997,
    120003,
    120005,
    120069,
    120071,
    120074,
    120077,
    120084,
    120086,
    120092,
    120094,
    120121,
    120123,
    120126,
    120128,
    120132,
    120134,
    120134,
    120138,
    120144,
    120146,
    120485,
    120488,
    120512,
    120514,
    120538,
    120540,
    120570,
    120572,
    120596,
    120598,
    120628,
    120630,
    120654,
    120656,
    120686,
    120688,
    120712,
    120714,
    120744,
    120746,
    120770,
    120772,
    120779,
    122624,
    122654,
    122661,
    122666,
    122928,
    122989,
    123136,
    123180,
    123191,
    123197,
    123214,
    123214,
    123536,
    123565,
    123584,
    123627,
    124112,
    124139,
    124896,
    124902,
    124904,
    124907,
    124909,
    124910,
    124912,
    124926,
    124928,
    125124,
    125184,
    125251,
    125259,
    125259,
    126464,
    126467,
    126469,
    126495,
    126497,
    126498,
    126500,
    126500,
    126503,
    126503,
    126505,
    126514,
    126516,
    126519,
    126521,
    126521,
    126523,
    126523,
    126530,
    126530,
    126535,
    126535,
    126537,
    126537,
    126539,
    126539,
    126541,
    126543,
    126545,
    126546,
    126548,
    126548,
    126551,
    126551,
    126553,
    126553,
    126555,
    126555,
    126557,
    126557,
    126559,
    126559,
    126561,
    126562,
    126564,
    126564,
    126567,
    126570,
    126572,
    126578,
    126580,
    126583,
    126585,
    126588,
    126590,
    126590,
    126592,
    126601,
    126603,
    126619,
    126625,
    126627,
    126629,
    126633,
    126635,
    126651,
    131072,
    173791,
    173824,
    177977,
    177984,
    178205,
    178208,
    183969,
    183984,
    191456,
    194560,
    195101,
    196608,
    201546,
    201552,
    205743,
    748,
    0,
    48,
    57,
    65,
    90,
    95,
    95,
    97,
    122,
    170,
    170,
    178,
    179,
    181,
    181,
    185,
    186,
    188,
    190,
    192,
    214,
    216,
    246,
    248,
    705,
    710,
    721,
    736,
    740,
    748,
    748,
    750,
    750,
    880,
    884,
    886,
    887,
    890,
    893,
    895,
    895,
    902,
    902,
    904,
    906,
    908,
    908,
    910,
    929,
    931,
    1013,
    1015,
    1153,
    1162,
    1327,
    1329,
    1366,
    1369,
    1369,
    1376,
    1416,
    1488,
    1514,
    1519,
    1522,
    1568,
    1610,
    1632,
    1641,
    1646,
    1647,
    1649,
    1747,
    1749,
    1749,
    1765,
    1766,
    1774,
    1788,
    1791,
    1791,
    1808,
    1808,
    1810,
    1839,
    1869,
    1957,
    1969,
    1969,
    1984,
    2026,
    2036,
    2037,
    2042,
    2042,
    2048,
    2069,
    2074,
    2074,
    2084,
    2084,
    2088,
    2088,
    2112,
    2136,
    2144,
    2154,
    2160,
    2183,
    2185,
    2190,
    2208,
    2249,
    2308,
    2361,
    2365,
    2365,
    2384,
    2384,
    2392,
    2401,
    2406,
    2415,
    2417,
    2432,
    2437,
    2444,
    2447,
    2448,
    2451,
    2472,
    2474,
    2480,
    2482,
    2482,
    2486,
    2489,
    2493,
    2493,
    2510,
    2510,
    2524,
    2525,
    2527,
    2529,
    2534,
    2545,
    2548,
    2553,
    2556,
    2556,
    2565,
    2570,
    2575,
    2576,
    2579,
    2600,
    2602,
    2608,
    2610,
    2611,
    2613,
    2614,
    2616,
    2617,
    2649,
    2652,
    2654,
    2654,
    2662,
    2671,
    2674,
    2676,
    2693,
    2701,
    2703,
    2705,
    2707,
    2728,
    2730,
    2736,
    2738,
    2739,
    2741,
    2745,
    2749,
    2749,
    2768,
    2768,
    2784,
    2785,
    2790,
    2799,
    2809,
    2809,
    2821,
    2828,
    2831,
    2832,
    2835,
    2856,
    2858,
    2864,
    2866,
    2867,
    2869,
    2873,
    2877,
    2877,
    2908,
    2909,
    2911,
    2913,
    2918,
    2927,
    2929,
    2935,
    2947,
    2947,
    2949,
    2954,
    2958,
    2960,
    2962,
    2965,
    2969,
    2970,
    2972,
    2972,
    2974,
    2975,
    2979,
    2980,
    2984,
    2986,
    2990,
    3001,
    3024,
    3024,
    3046,
    3058,
    3077,
    3084,
    3086,
    3088,
    3090,
    3112,
    3114,
    3129,
    3133,
    3133,
    3160,
    3162,
    3165,
    3165,
    3168,
    3169,
    3174,
    3183,
    3192,
    3198,
    3200,
    3200,
    3205,
    3212,
    3214,
    3216,
    3218,
    3240,
    3242,
    3251,
    3253,
    3257,
    3261,
    3261,
    3293,
    3294,
    3296,
    3297,
    3302,
    3311,
    3313,
    3314,
    3332,
    3340,
    3342,
    3344,
    3346,
    3386,
    3389,
    3389,
    3406,
    3406,
    3412,
    3414,
    3416,
    3425,
    3430,
    3448,
    3450,
    3455,
    3461,
    3478,
    3482,
    3505,
    3507,
    3515,
    3517,
    3517,
    3520,
    3526,
    3558,
    3567,
    3585,
    3632,
    3634,
    3635,
    3648,
    3654,
    3664,
    3673,
    3713,
    3714,
    3716,
    3716,
    3718,
    3722,
    3724,
    3747,
    3749,
    3749,
    3751,
    3760,
    3762,
    3763,
    3773,
    3773,
    3776,
    3780,
    3782,
    3782,
    3792,
    3801,
    3804,
    3807,
    3840,
    3840,
    3872,
    3891,
    3904,
    3911,
    3913,
    3948,
    3976,
    3980,
    4096,
    4138,
    4159,
    4169,
    4176,
    4181,
    4186,
    4189,
    4193,
    4193,
    4197,
    4198,
    4206,
    4208,
    4213,
    4225,
    4238,
    4238,
    4240,
    4249,
    4256,
    4293,
    4295,
    4295,
    4301,
    4301,
    4304,
    4346,
    4348,
    4680,
    4682,
    4685,
    4688,
    4694,
    4696,
    4696,
    4698,
    4701,
    4704,
    4744,
    4746,
    4749,
    4752,
    4784,
    4786,
    4789,
    4792,
    4798,
    4800,
    4800,
    4802,
    4805,
    4808,
    4822,
    4824,
    4880,
    4882,
    4885,
    4888,
    4954,
    4969,
    4988,
    4992,
    5007,
    5024,
    5109,
    5112,
    5117,
    5121,
    5740,
    5743,
    5759,
    5761,
    5786,
    5792,
    5866,
    5870,
    5880,
    5888,
    5905,
    5919,
    5937,
    5952,
    5969,
    5984,
    5996,
    5998,
    6e3,
    6016,
    6067,
    6103,
    6103,
    6108,
    6108,
    6112,
    6121,
    6128,
    6137,
    6160,
    6169,
    6176,
    6264,
    6272,
    6276,
    6279,
    6312,
    6314,
    6314,
    6320,
    6389,
    6400,
    6430,
    6470,
    6509,
    6512,
    6516,
    6528,
    6571,
    6576,
    6601,
    6608,
    6618,
    6656,
    6678,
    6688,
    6740,
    6784,
    6793,
    6800,
    6809,
    6823,
    6823,
    6917,
    6963,
    6981,
    6988,
    6992,
    7001,
    7043,
    7072,
    7086,
    7141,
    7168,
    7203,
    7232,
    7241,
    7245,
    7293,
    7296,
    7304,
    7312,
    7354,
    7357,
    7359,
    7401,
    7404,
    7406,
    7411,
    7413,
    7414,
    7418,
    7418,
    7424,
    7615,
    7680,
    7957,
    7960,
    7965,
    7968,
    8005,
    8008,
    8013,
    8016,
    8023,
    8025,
    8025,
    8027,
    8027,
    8029,
    8029,
    8031,
    8061,
    8064,
    8116,
    8118,
    8124,
    8126,
    8126,
    8130,
    8132,
    8134,
    8140,
    8144,
    8147,
    8150,
    8155,
    8160,
    8172,
    8178,
    8180,
    8182,
    8188,
    8304,
    8305,
    8308,
    8313,
    8319,
    8329,
    8336,
    8348,
    8450,
    8450,
    8455,
    8455,
    8458,
    8467,
    8469,
    8469,
    8473,
    8477,
    8484,
    8484,
    8486,
    8486,
    8488,
    8488,
    8490,
    8493,
    8495,
    8505,
    8508,
    8511,
    8517,
    8521,
    8526,
    8526,
    8528,
    8585,
    9312,
    9371,
    9450,
    9471,
    10102,
    10131,
    11264,
    11492,
    11499,
    11502,
    11506,
    11507,
    11517,
    11517,
    11520,
    11557,
    11559,
    11559,
    11565,
    11565,
    11568,
    11623,
    11631,
    11631,
    11648,
    11670,
    11680,
    11686,
    11688,
    11694,
    11696,
    11702,
    11704,
    11710,
    11712,
    11718,
    11720,
    11726,
    11728,
    11734,
    11736,
    11742,
    11823,
    11823,
    12293,
    12295,
    12321,
    12329,
    12337,
    12341,
    12344,
    12348,
    12353,
    12438,
    12445,
    12447,
    12449,
    12538,
    12540,
    12543,
    12549,
    12591,
    12593,
    12686,
    12690,
    12693,
    12704,
    12735,
    12784,
    12799,
    12832,
    12841,
    12872,
    12879,
    12881,
    12895,
    12928,
    12937,
    12977,
    12991,
    13312,
    19903,
    19968,
    42124,
    42192,
    42237,
    42240,
    42508,
    42512,
    42539,
    42560,
    42606,
    42623,
    42653,
    42656,
    42735,
    42775,
    42783,
    42786,
    42888,
    42891,
    42954,
    42960,
    42961,
    42963,
    42963,
    42965,
    42969,
    42994,
    43009,
    43011,
    43013,
    43015,
    43018,
    43020,
    43042,
    43056,
    43061,
    43072,
    43123,
    43138,
    43187,
    43216,
    43225,
    43250,
    43255,
    43259,
    43259,
    43261,
    43262,
    43264,
    43301,
    43312,
    43334,
    43360,
    43388,
    43396,
    43442,
    43471,
    43481,
    43488,
    43492,
    43494,
    43518,
    43520,
    43560,
    43584,
    43586,
    43588,
    43595,
    43600,
    43609,
    43616,
    43638,
    43642,
    43642,
    43646,
    43695,
    43697,
    43697,
    43701,
    43702,
    43705,
    43709,
    43712,
    43712,
    43714,
    43714,
    43739,
    43741,
    43744,
    43754,
    43762,
    43764,
    43777,
    43782,
    43785,
    43790,
    43793,
    43798,
    43808,
    43814,
    43816,
    43822,
    43824,
    43866,
    43868,
    43881,
    43888,
    44002,
    44016,
    44025,
    44032,
    55203,
    55216,
    55238,
    55243,
    55291,
    63744,
    64109,
    64112,
    64217,
    64256,
    64262,
    64275,
    64279,
    64285,
    64285,
    64287,
    64296,
    64298,
    64310,
    64312,
    64316,
    64318,
    64318,
    64320,
    64321,
    64323,
    64324,
    64326,
    64433,
    64467,
    64829,
    64848,
    64911,
    64914,
    64967,
    65008,
    65019,
    65136,
    65140,
    65142,
    65276,
    65296,
    65305,
    65313,
    65338,
    65345,
    65370,
    65382,
    65470,
    65474,
    65479,
    65482,
    65487,
    65490,
    65495,
    65498,
    65500,
    65536,
    65547,
    65549,
    65574,
    65576,
    65594,
    65596,
    65597,
    65599,
    65613,
    65616,
    65629,
    65664,
    65786,
    65799,
    65843,
    65856,
    65912,
    65930,
    65931,
    66176,
    66204,
    66208,
    66256,
    66273,
    66299,
    66304,
    66339,
    66349,
    66378,
    66384,
    66421,
    66432,
    66461,
    66464,
    66499,
    66504,
    66511,
    66513,
    66517,
    66560,
    66717,
    66720,
    66729,
    66736,
    66771,
    66776,
    66811,
    66816,
    66855,
    66864,
    66915,
    66928,
    66938,
    66940,
    66954,
    66956,
    66962,
    66964,
    66965,
    66967,
    66977,
    66979,
    66993,
    66995,
    67001,
    67003,
    67004,
    67072,
    67382,
    67392,
    67413,
    67424,
    67431,
    67456,
    67461,
    67463,
    67504,
    67506,
    67514,
    67584,
    67589,
    67592,
    67592,
    67594,
    67637,
    67639,
    67640,
    67644,
    67644,
    67647,
    67669,
    67672,
    67702,
    67705,
    67742,
    67751,
    67759,
    67808,
    67826,
    67828,
    67829,
    67835,
    67867,
    67872,
    67897,
    67968,
    68023,
    68028,
    68047,
    68050,
    68096,
    68112,
    68115,
    68117,
    68119,
    68121,
    68149,
    68160,
    68168,
    68192,
    68222,
    68224,
    68255,
    68288,
    68295,
    68297,
    68324,
    68331,
    68335,
    68352,
    68405,
    68416,
    68437,
    68440,
    68466,
    68472,
    68497,
    68521,
    68527,
    68608,
    68680,
    68736,
    68786,
    68800,
    68850,
    68858,
    68899,
    68912,
    68921,
    69216,
    69246,
    69248,
    69289,
    69296,
    69297,
    69376,
    69415,
    69424,
    69445,
    69457,
    69460,
    69488,
    69505,
    69552,
    69579,
    69600,
    69622,
    69635,
    69687,
    69714,
    69743,
    69745,
    69746,
    69749,
    69749,
    69763,
    69807,
    69840,
    69864,
    69872,
    69881,
    69891,
    69926,
    69942,
    69951,
    69956,
    69956,
    69959,
    69959,
    69968,
    70002,
    70006,
    70006,
    70019,
    70066,
    70081,
    70084,
    70096,
    70106,
    70108,
    70108,
    70113,
    70132,
    70144,
    70161,
    70163,
    70187,
    70207,
    70208,
    70272,
    70278,
    70280,
    70280,
    70282,
    70285,
    70287,
    70301,
    70303,
    70312,
    70320,
    70366,
    70384,
    70393,
    70405,
    70412,
    70415,
    70416,
    70419,
    70440,
    70442,
    70448,
    70450,
    70451,
    70453,
    70457,
    70461,
    70461,
    70480,
    70480,
    70493,
    70497,
    70656,
    70708,
    70727,
    70730,
    70736,
    70745,
    70751,
    70753,
    70784,
    70831,
    70852,
    70853,
    70855,
    70855,
    70864,
    70873,
    71040,
    71086,
    71128,
    71131,
    71168,
    71215,
    71236,
    71236,
    71248,
    71257,
    71296,
    71338,
    71352,
    71352,
    71360,
    71369,
    71424,
    71450,
    71472,
    71483,
    71488,
    71494,
    71680,
    71723,
    71840,
    71922,
    71935,
    71942,
    71945,
    71945,
    71948,
    71955,
    71957,
    71958,
    71960,
    71983,
    71999,
    71999,
    72001,
    72001,
    72016,
    72025,
    72096,
    72103,
    72106,
    72144,
    72161,
    72161,
    72163,
    72163,
    72192,
    72192,
    72203,
    72242,
    72250,
    72250,
    72272,
    72272,
    72284,
    72329,
    72349,
    72349,
    72368,
    72440,
    72704,
    72712,
    72714,
    72750,
    72768,
    72768,
    72784,
    72812,
    72818,
    72847,
    72960,
    72966,
    72968,
    72969,
    72971,
    73008,
    73030,
    73030,
    73040,
    73049,
    73056,
    73061,
    73063,
    73064,
    73066,
    73097,
    73112,
    73112,
    73120,
    73129,
    73440,
    73458,
    73474,
    73474,
    73476,
    73488,
    73490,
    73523,
    73552,
    73561,
    73648,
    73648,
    73664,
    73684,
    73728,
    74649,
    74752,
    74862,
    74880,
    75075,
    77712,
    77808,
    77824,
    78895,
    78913,
    78918,
    82944,
    83526,
    92160,
    92728,
    92736,
    92766,
    92768,
    92777,
    92784,
    92862,
    92864,
    92873,
    92880,
    92909,
    92928,
    92975,
    92992,
    92995,
    93008,
    93017,
    93019,
    93025,
    93027,
    93047,
    93053,
    93071,
    93760,
    93846,
    93952,
    94026,
    94032,
    94032,
    94099,
    94111,
    94176,
    94177,
    94179,
    94179,
    94208,
    100343,
    100352,
    101589,
    101632,
    101640,
    110576,
    110579,
    110581,
    110587,
    110589,
    110590,
    110592,
    110882,
    110898,
    110898,
    110928,
    110930,
    110933,
    110933,
    110948,
    110951,
    110960,
    111355,
    113664,
    113770,
    113776,
    113788,
    113792,
    113800,
    113808,
    113817,
    119488,
    119507,
    119520,
    119539,
    119648,
    119672,
    119808,
    119892,
    119894,
    119964,
    119966,
    119967,
    119970,
    119970,
    119973,
    119974,
    119977,
    119980,
    119982,
    119993,
    119995,
    119995,
    119997,
    120003,
    120005,
    120069,
    120071,
    120074,
    120077,
    120084,
    120086,
    120092,
    120094,
    120121,
    120123,
    120126,
    120128,
    120132,
    120134,
    120134,
    120138,
    120144,
    120146,
    120485,
    120488,
    120512,
    120514,
    120538,
    120540,
    120570,
    120572,
    120596,
    120598,
    120628,
    120630,
    120654,
    120656,
    120686,
    120688,
    120712,
    120714,
    120744,
    120746,
    120770,
    120772,
    120779,
    120782,
    120831,
    122624,
    122654,
    122661,
    122666,
    122928,
    122989,
    123136,
    123180,
    123191,
    123197,
    123200,
    123209,
    123214,
    123214,
    123536,
    123565,
    123584,
    123627,
    123632,
    123641,
    124112,
    124139,
    124144,
    124153,
    124896,
    124902,
    124904,
    124907,
    124909,
    124910,
    124912,
    124926,
    124928,
    125124,
    125127,
    125135,
    125184,
    125251,
    125259,
    125259,
    125264,
    125273,
    126065,
    126123,
    126125,
    126127,
    126129,
    126132,
    126209,
    126253,
    126255,
    126269,
    126464,
    126467,
    126469,
    126495,
    126497,
    126498,
    126500,
    126500,
    126503,
    126503,
    126505,
    126514,
    126516,
    126519,
    126521,
    126521,
    126523,
    126523,
    126530,
    126530,
    126535,
    126535,
    126537,
    126537,
    126539,
    126539,
    126541,
    126543,
    126545,
    126546,
    126548,
    126548,
    126551,
    126551,
    126553,
    126553,
    126555,
    126555,
    126557,
    126557,
    126559,
    126559,
    126561,
    126562,
    126564,
    126564,
    126567,
    126570,
    126572,
    126578,
    126580,
    126583,
    126585,
    126588,
    126590,
    126590,
    126592,
    126601,
    126603,
    126619,
    126625,
    126627,
    126629,
    126633,
    126635,
    126651,
    127232,
    127244,
    130032,
    130041,
    131072,
    173791,
    173824,
    177977,
    177984,
    178205,
    178208,
    183969,
    183984,
    191456,
    194560,
    195101,
    196608,
    201546,
    201552,
    205743,
    2,
    0,
    91,
    91,
    93,
    93,
    3,
    0,
    9,
    9,
    12,
    12,
    32,
    32,
    1,
    0,
    34,
    34,
    523,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    3,
    1,
    0,
    0,
    0,
    0,
    5,
    1,
    0,
    0,
    0,
    0,
    7,
    1,
    0,
    0,
    0,
    0,
    9,
    1,
    0,
    0,
    0,
    0,
    11,
    1,
    0,
    0,
    0,
    0,
    13,
    1,
    0,
    0,
    0,
    0,
    15,
    1,
    0,
    0,
    0,
    0,
    17,
    1,
    0,
    0,
    0,
    0,
    19,
    1,
    0,
    0,
    0,
    0,
    21,
    1,
    0,
    0,
    0,
    0,
    23,
    1,
    0,
    0,
    0,
    0,
    25,
    1,
    0,
    0,
    0,
    0,
    27,
    1,
    0,
    0,
    0,
    0,
    29,
    1,
    0,
    0,
    0,
    0,
    31,
    1,
    0,
    0,
    0,
    0,
    33,
    1,
    0,
    0,
    0,
    0,
    35,
    1,
    0,
    0,
    0,
    0,
    37,
    1,
    0,
    0,
    0,
    0,
    39,
    1,
    0,
    0,
    0,
    0,
    41,
    1,
    0,
    0,
    0,
    0,
    43,
    1,
    0,
    0,
    0,
    0,
    45,
    1,
    0,
    0,
    0,
    0,
    47,
    1,
    0,
    0,
    0,
    0,
    49,
    1,
    0,
    0,
    0,
    0,
    51,
    1,
    0,
    0,
    0,
    0,
    53,
    1,
    0,
    0,
    0,
    0,
    55,
    1,
    0,
    0,
    0,
    0,
    57,
    1,
    0,
    0,
    0,
    0,
    59,
    1,
    0,
    0,
    0,
    0,
    61,
    1,
    0,
    0,
    0,
    0,
    63,
    1,
    0,
    0,
    0,
    0,
    65,
    1,
    0,
    0,
    0,
    0,
    67,
    1,
    0,
    0,
    0,
    0,
    69,
    1,
    0,
    0,
    0,
    0,
    71,
    1,
    0,
    0,
    0,
    0,
    73,
    1,
    0,
    0,
    0,
    0,
    75,
    1,
    0,
    0,
    0,
    0,
    77,
    1,
    0,
    0,
    0,
    0,
    79,
    1,
    0,
    0,
    0,
    0,
    81,
    1,
    0,
    0,
    0,
    0,
    83,
    1,
    0,
    0,
    0,
    0,
    85,
    1,
    0,
    0,
    0,
    0,
    87,
    1,
    0,
    0,
    0,
    0,
    89,
    1,
    0,
    0,
    0,
    0,
    91,
    1,
    0,
    0,
    0,
    0,
    93,
    1,
    0,
    0,
    0,
    0,
    95,
    1,
    0,
    0,
    0,
    0,
    97,
    1,
    0,
    0,
    0,
    0,
    99,
    1,
    0,
    0,
    0,
    0,
    101,
    1,
    0,
    0,
    0,
    0,
    103,
    1,
    0,
    0,
    0,
    0,
    105,
    1,
    0,
    0,
    0,
    0,
    107,
    1,
    0,
    0,
    0,
    0,
    109,
    1,
    0,
    0,
    0,
    0,
    111,
    1,
    0,
    0,
    0,
    0,
    113,
    1,
    0,
    0,
    0,
    0,
    115,
    1,
    0,
    0,
    0,
    0,
    117,
    1,
    0,
    0,
    0,
    0,
    119,
    1,
    0,
    0,
    0,
    0,
    121,
    1,
    0,
    0,
    0,
    1,
    123,
    1,
    0,
    0,
    0,
    3,
    125,
    1,
    0,
    0,
    0,
    5,
    127,
    1,
    0,
    0,
    0,
    7,
    129,
    1,
    0,
    0,
    0,
    9,
    132,
    1,
    0,
    0,
    0,
    11,
    134,
    1,
    0,
    0,
    0,
    13,
    136,
    1,
    0,
    0,
    0,
    15,
    140,
    1,
    0,
    0,
    0,
    17,
    143,
    1,
    0,
    0,
    0,
    19,
    163,
    1,
    0,
    0,
    0,
    21,
    184,
    1,
    0,
    0,
    0,
    23,
    199,
    1,
    0,
    0,
    0,
    25,
    203,
    1,
    0,
    0,
    0,
    27,
    205,
    1,
    0,
    0,
    0,
    29,
    211,
    1,
    0,
    0,
    0,
    31,
    215,
    1,
    0,
    0,
    0,
    33,
    220,
    1,
    0,
    0,
    0,
    35,
    223,
    1,
    0,
    0,
    0,
    37,
    226,
    1,
    0,
    0,
    0,
    39,
    229,
    1,
    0,
    0,
    0,
    41,
    234,
    1,
    0,
    0,
    0,
    43,
    237,
    1,
    0,
    0,
    0,
    45,
    242,
    1,
    0,
    0,
    0,
    47,
    247,
    1,
    0,
    0,
    0,
    49,
    256,
    1,
    0,
    0,
    0,
    51,
    260,
    1,
    0,
    0,
    0,
    53,
    267,
    1,
    0,
    0,
    0,
    55,
    271,
    1,
    0,
    0,
    0,
    57,
    275,
    1,
    0,
    0,
    0,
    59,
    281,
    1,
    0,
    0,
    0,
    61,
    291,
    1,
    0,
    0,
    0,
    63,
    293,
    1,
    0,
    0,
    0,
    65,
    302,
    1,
    0,
    0,
    0,
    67,
    307,
    1,
    0,
    0,
    0,
    69,
    313,
    1,
    0,
    0,
    0,
    71,
    315,
    1,
    0,
    0,
    0,
    73,
    317,
    1,
    0,
    0,
    0,
    75,
    320,
    1,
    0,
    0,
    0,
    77,
    322,
    1,
    0,
    0,
    0,
    79,
    325,
    1,
    0,
    0,
    0,
    81,
    327,
    1,
    0,
    0,
    0,
    83,
    329,
    1,
    0,
    0,
    0,
    85,
    331,
    1,
    0,
    0,
    0,
    87,
    337,
    1,
    0,
    0,
    0,
    89,
    339,
    1,
    0,
    0,
    0,
    91,
    344,
    1,
    0,
    0,
    0,
    93,
    349,
    1,
    0,
    0,
    0,
    95,
    351,
    1,
    0,
    0,
    0,
    97,
    353,
    1,
    0,
    0,
    0,
    99,
    356,
    1,
    0,
    0,
    0,
    101,
    390,
    1,
    0,
    0,
    0,
    103,
    413,
    1,
    0,
    0,
    0,
    105,
    415,
    1,
    0,
    0,
    0,
    107,
    419,
    1,
    0,
    0,
    0,
    109,
    427,
    1,
    0,
    0,
    0,
    111,
    433,
    1,
    0,
    0,
    0,
    113,
    458,
    1,
    0,
    0,
    0,
    115,
    460,
    1,
    0,
    0,
    0,
    117,
    462,
    1,
    0,
    0,
    0,
    119,
    464,
    1,
    0,
    0,
    0,
    121,
    484,
    1,
    0,
    0,
    0,
    123,
    124,
    5,
    40,
    0,
    0,
    124,
    2,
    1,
    0,
    0,
    0,
    125,
    126,
    5,
    44,
    0,
    0,
    126,
    4,
    1,
    0,
    0,
    0,
    127,
    128,
    5,
    41,
    0,
    0,
    128,
    6,
    1,
    0,
    0,
    0,
    129,
    130,
    5,
    60,
    0,
    0,
    130,
    131,
    5,
    45,
    0,
    0,
    131,
    8,
    1,
    0,
    0,
    0,
    132,
    133,
    5,
    58,
    0,
    0,
    133,
    10,
    1,
    0,
    0,
    0,
    134,
    135,
    5,
    33,
    0,
    0,
    135,
    12,
    1,
    0,
    0,
    0,
    136,
    137,
    7,
    0,
    0,
    0,
    137,
    138,
    7,
    1,
    0,
    0,
    138,
    139,
    7,
    2,
    0,
    0,
    139,
    14,
    1,
    0,
    0,
    0,
    140,
    141,
    5,
    46,
    0,
    0,
    141,
    16,
    1,
    0,
    0,
    0,
    142,
    144,
    3,
    23,
    11,
    0,
    143,
    142,
    1,
    0,
    0,
    0,
    143,
    144,
    1,
    0,
    0,
    0,
    144,
    145,
    1,
    0,
    0,
    0,
    145,
    146,
    5,
    47,
    0,
    0,
    146,
    147,
    5,
    42,
    0,
    0,
    147,
    151,
    1,
    0,
    0,
    0,
    148,
    150,
    9,
    0,
    0,
    0,
    149,
    148,
    1,
    0,
    0,
    0,
    150,
    153,
    1,
    0,
    0,
    0,
    151,
    152,
    1,
    0,
    0,
    0,
    151,
    149,
    1,
    0,
    0,
    0,
    152,
    154,
    1,
    0,
    0,
    0,
    153,
    151,
    1,
    0,
    0,
    0,
    154,
    155,
    5,
    42,
    0,
    0,
    155,
    156,
    5,
    47,
    0,
    0,
    156,
    158,
    1,
    0,
    0,
    0,
    157,
    159,
    3,
    23,
    11,
    0,
    158,
    157,
    1,
    0,
    0,
    0,
    158,
    159,
    1,
    0,
    0,
    0,
    159,
    160,
    1,
    0,
    0,
    0,
    160,
    161,
    6,
    8,
    0,
    0,
    161,
    18,
    1,
    0,
    0,
    0,
    162,
    164,
    3,
    23,
    11,
    0,
    163,
    162,
    1,
    0,
    0,
    0,
    163,
    164,
    1,
    0,
    0,
    0,
    164,
    168,
    1,
    0,
    0,
    0,
    165,
    166,
    5,
    47,
    0,
    0,
    166,
    169,
    5,
    47,
    0,
    0,
    167,
    169,
    5,
    35,
    0,
    0,
    168,
    165,
    1,
    0,
    0,
    0,
    168,
    167,
    1,
    0,
    0,
    0,
    169,
    173,
    1,
    0,
    0,
    0,
    170,
    172,
    8,
    3,
    0,
    0,
    171,
    170,
    1,
    0,
    0,
    0,
    172,
    175,
    1,
    0,
    0,
    0,
    173,
    171,
    1,
    0,
    0,
    0,
    173,
    174,
    1,
    0,
    0,
    0,
    174,
    177,
    1,
    0,
    0,
    0,
    175,
    173,
    1,
    0,
    0,
    0,
    176,
    178,
    3,
    23,
    11,
    0,
    177,
    176,
    1,
    0,
    0,
    0,
    177,
    178,
    1,
    0,
    0,
    0,
    178,
    179,
    1,
    0,
    0,
    0,
    179,
    180,
    6,
    9,
    0,
    0,
    180,
    20,
    1,
    0,
    0,
    0,
    181,
    183,
    3,
    119,
    59,
    0,
    182,
    181,
    1,
    0,
    0,
    0,
    183,
    186,
    1,
    0,
    0,
    0,
    184,
    182,
    1,
    0,
    0,
    0,
    184,
    185,
    1,
    0,
    0,
    0,
    185,
    194,
    1,
    0,
    0,
    0,
    186,
    184,
    1,
    0,
    0,
    0,
    187,
    191,
    3,
    25,
    12,
    0,
    188,
    190,
    3,
    119,
    59,
    0,
    189,
    188,
    1,
    0,
    0,
    0,
    190,
    193,
    1,
    0,
    0,
    0,
    191,
    189,
    1,
    0,
    0,
    0,
    191,
    192,
    1,
    0,
    0,
    0,
    192,
    195,
    1,
    0,
    0,
    0,
    193,
    191,
    1,
    0,
    0,
    0,
    194,
    187,
    1,
    0,
    0,
    0,
    195,
    196,
    1,
    0,
    0,
    0,
    196,
    194,
    1,
    0,
    0,
    0,
    196,
    197,
    1,
    0,
    0,
    0,
    197,
    22,
    1,
    0,
    0,
    0,
    198,
    200,
    3,
    119,
    59,
    0,
    199,
    198,
    1,
    0,
    0,
    0,
    200,
    201,
    1,
    0,
    0,
    0,
    201,
    199,
    1,
    0,
    0,
    0,
    201,
    202,
    1,
    0,
    0,
    0,
    202,
    24,
    1,
    0,
    0,
    0,
    203,
    204,
    7,
    3,
    0,
    0,
    204,
    26,
    1,
    0,
    0,
    0,
    205,
    206,
    7,
    4,
    0,
    0,
    206,
    207,
    7,
    5,
    0,
    0,
    207,
    208,
    7,
    6,
    0,
    0,
    208,
    209,
    7,
    7,
    0,
    0,
    209,
    210,
    7,
    8,
    0,
    0,
    210,
    28,
    1,
    0,
    0,
    0,
    211,
    212,
    7,
    9,
    0,
    0,
    212,
    213,
    7,
    1,
    0,
    0,
    213,
    214,
    7,
    10,
    0,
    0,
    214,
    30,
    1,
    0,
    0,
    0,
    215,
    216,
    7,
    9,
    0,
    0,
    216,
    217,
    7,
    10,
    0,
    0,
    217,
    218,
    7,
    1,
    0,
    0,
    218,
    219,
    7,
    11,
    0,
    0,
    219,
    32,
    1,
    0,
    0,
    0,
    220,
    221,
    7,
    6,
    0,
    0,
    221,
    222,
    7,
    0,
    0,
    0,
    222,
    34,
    1,
    0,
    0,
    0,
    223,
    224,
    7,
    2,
    0,
    0,
    224,
    225,
    7,
    1,
    0,
    0,
    225,
    36,
    1,
    0,
    0,
    0,
    226,
    227,
    7,
    12,
    0,
    0,
    227,
    228,
    7,
    13,
    0,
    0,
    228,
    38,
    1,
    0,
    0,
    0,
    229,
    230,
    7,
    7,
    0,
    0,
    230,
    231,
    7,
    1,
    0,
    0,
    231,
    232,
    7,
    1,
    0,
    0,
    232,
    233,
    7,
    14,
    0,
    0,
    233,
    40,
    1,
    0,
    0,
    0,
    234,
    235,
    7,
    6,
    0,
    0,
    235,
    236,
    7,
    9,
    0,
    0,
    236,
    42,
    1,
    0,
    0,
    0,
    237,
    238,
    7,
    2,
    0,
    0,
    238,
    239,
    7,
    5,
    0,
    0,
    239,
    240,
    7,
    8,
    0,
    0,
    240,
    241,
    7,
    0,
    0,
    0,
    241,
    44,
    1,
    0,
    0,
    0,
    242,
    243,
    7,
    8,
    0,
    0,
    243,
    244,
    7,
    7,
    0,
    0,
    244,
    245,
    7,
    15,
    0,
    0,
    245,
    246,
    7,
    8,
    0,
    0,
    246,
    46,
    1,
    0,
    0,
    0,
    247,
    248,
    7,
    9,
    0,
    0,
    248,
    249,
    7,
    16,
    0,
    0,
    249,
    250,
    7,
    0,
    0,
    0,
    250,
    251,
    7,
    17,
    0,
    0,
    251,
    252,
    7,
    2,
    0,
    0,
    252,
    253,
    7,
    6,
    0,
    0,
    253,
    254,
    7,
    1,
    0,
    0,
    254,
    255,
    7,
    0,
    0,
    0,
    255,
    48,
    1,
    0,
    0,
    0,
    256,
    257,
    7,
    8,
    0,
    0,
    257,
    258,
    7,
    0,
    0,
    0,
    258,
    259,
    7,
    18,
    0,
    0,
    259,
    50,
    1,
    0,
    0,
    0,
    260,
    261,
    7,
    10,
    0,
    0,
    261,
    262,
    7,
    8,
    0,
    0,
    262,
    263,
    7,
    2,
    0,
    0,
    263,
    264,
    7,
    16,
    0,
    0,
    264,
    265,
    7,
    10,
    0,
    0,
    265,
    266,
    7,
    0,
    0,
    0,
    266,
    52,
    1,
    0,
    0,
    0,
    267,
    268,
    7,
    0,
    0,
    0,
    268,
    269,
    7,
    8,
    0,
    0,
    269,
    270,
    7,
    4,
    0,
    0,
    270,
    54,
    1,
    0,
    0,
    0,
    271,
    272,
    7,
    2,
    0,
    0,
    272,
    273,
    7,
    10,
    0,
    0,
    273,
    274,
    7,
    13,
    0,
    0,
    274,
    56,
    1,
    0,
    0,
    0,
    275,
    276,
    7,
    17,
    0,
    0,
    276,
    277,
    7,
    19,
    0,
    0,
    277,
    278,
    7,
    2,
    0,
    0,
    278,
    279,
    7,
    17,
    0,
    0,
    279,
    280,
    7,
    5,
    0,
    0,
    280,
    58,
    1,
    0,
    0,
    0,
    281,
    282,
    7,
    2,
    0,
    0,
    282,
    283,
    7,
    5,
    0,
    0,
    283,
    284,
    7,
    10,
    0,
    0,
    284,
    285,
    7,
    1,
    0,
    0,
    285,
    286,
    7,
    4,
    0,
    0,
    286,
    60,
    1,
    0,
    0,
    0,
    287,
    288,
    5,
    124,
    0,
    0,
    288,
    292,
    5,
    124,
    0,
    0,
    289,
    290,
    7,
    1,
    0,
    0,
    290,
    292,
    7,
    10,
    0,
    0,
    291,
    287,
    1,
    0,
    0,
    0,
    291,
    289,
    1,
    0,
    0,
    0,
    292,
    62,
    1,
    0,
    0,
    0,
    293,
    294,
    7,
    20,
    0,
    0,
    294,
    295,
    7,
    1,
    0,
    0,
    295,
    296,
    7,
    10,
    0,
    0,
    296,
    64,
    1,
    0,
    0,
    0,
    297,
    298,
    5,
    38,
    0,
    0,
    298,
    303,
    5,
    38,
    0,
    0,
    299,
    300,
    7,
    19,
    0,
    0,
    300,
    301,
    7,
    0,
    0,
    0,
    301,
    303,
    7,
    18,
    0,
    0,
    302,
    297,
    1,
    0,
    0,
    0,
    302,
    299,
    1,
    0,
    0,
    0,
    303,
    66,
    1,
    0,
    0,
    0,
    304,
    308,
    5,
    61,
    0,
    0,
    305,
    306,
    5,
    61,
    0,
    0,
    306,
    308,
    5,
    61,
    0,
    0,
    307,
    304,
    1,
    0,
    0,
    0,
    307,
    305,
    1,
    0,
    0,
    0,
    308,
    68,
    1,
    0,
    0,
    0,
    309,
    310,
    5,
    33,
    0,
    0,
    310,
    314,
    5,
    61,
    0,
    0,
    311,
    312,
    5,
    60,
    0,
    0,
    312,
    314,
    5,
    62,
    0,
    0,
    313,
    309,
    1,
    0,
    0,
    0,
    313,
    311,
    1,
    0,
    0,
    0,
    314,
    70,
    1,
    0,
    0,
    0,
    315,
    316,
    5,
    60,
    0,
    0,
    316,
    72,
    1,
    0,
    0,
    0,
    317,
    318,
    5,
    60,
    0,
    0,
    318,
    319,
    5,
    61,
    0,
    0,
    319,
    74,
    1,
    0,
    0,
    0,
    320,
    321,
    5,
    62,
    0,
    0,
    321,
    76,
    1,
    0,
    0,
    0,
    322,
    323,
    5,
    62,
    0,
    0,
    323,
    324,
    5,
    61,
    0,
    0,
    324,
    78,
    1,
    0,
    0,
    0,
    325,
    326,
    5,
    43,
    0,
    0,
    326,
    80,
    1,
    0,
    0,
    0,
    327,
    328,
    5,
    45,
    0,
    0,
    328,
    82,
    1,
    0,
    0,
    0,
    329,
    330,
    5,
    42,
    0,
    0,
    330,
    84,
    1,
    0,
    0,
    0,
    331,
    332,
    5,
    47,
    0,
    0,
    332,
    86,
    1,
    0,
    0,
    0,
    333,
    338,
    5,
    37,
    0,
    0,
    334,
    335,
    7,
    11,
    0,
    0,
    335,
    336,
    7,
    1,
    0,
    0,
    336,
    338,
    7,
    18,
    0,
    0,
    337,
    333,
    1,
    0,
    0,
    0,
    337,
    334,
    1,
    0,
    0,
    0,
    338,
    88,
    1,
    0,
    0,
    0,
    339,
    340,
    5,
    94,
    0,
    0,
    340,
    90,
    1,
    0,
    0,
    0,
    341,
    345,
    5,
    171,
    0,
    0,
    342,
    343,
    5,
    60,
    0,
    0,
    343,
    345,
    5,
    60,
    0,
    0,
    344,
    341,
    1,
    0,
    0,
    0,
    344,
    342,
    1,
    0,
    0,
    0,
    345,
    92,
    1,
    0,
    0,
    0,
    346,
    350,
    5,
    187,
    0,
    0,
    347,
    348,
    5,
    62,
    0,
    0,
    348,
    350,
    5,
    62,
    0,
    0,
    349,
    346,
    1,
    0,
    0,
    0,
    349,
    347,
    1,
    0,
    0,
    0,
    350,
    94,
    1,
    0,
    0,
    0,
    351,
    352,
    5,
    123,
    0,
    0,
    352,
    96,
    1,
    0,
    0,
    0,
    353,
    354,
    5,
    125,
    0,
    0,
    354,
    98,
    1,
    0,
    0,
    0,
    355,
    357,
    2,
    48,
    57,
    0,
    356,
    355,
    1,
    0,
    0,
    0,
    357,
    358,
    1,
    0,
    0,
    0,
    358,
    356,
    1,
    0,
    0,
    0,
    358,
    359,
    1,
    0,
    0,
    0,
    359,
    370,
    1,
    0,
    0,
    0,
    360,
    362,
    7,
    8,
    0,
    0,
    361,
    363,
    7,
    21,
    0,
    0,
    362,
    361,
    1,
    0,
    0,
    0,
    362,
    363,
    1,
    0,
    0,
    0,
    363,
    367,
    1,
    0,
    0,
    0,
    364,
    366,
    2,
    48,
    57,
    0,
    365,
    364,
    1,
    0,
    0,
    0,
    366,
    369,
    1,
    0,
    0,
    0,
    367,
    365,
    1,
    0,
    0,
    0,
    367,
    368,
    1,
    0,
    0,
    0,
    368,
    371,
    1,
    0,
    0,
    0,
    369,
    367,
    1,
    0,
    0,
    0,
    370,
    360,
    1,
    0,
    0,
    0,
    370,
    371,
    1,
    0,
    0,
    0,
    371,
    100,
    1,
    0,
    0,
    0,
    372,
    374,
    2,
    48,
    57,
    0,
    373,
    372,
    1,
    0,
    0,
    0,
    374,
    377,
    1,
    0,
    0,
    0,
    375,
    373,
    1,
    0,
    0,
    0,
    375,
    376,
    1,
    0,
    0,
    0,
    376,
    378,
    1,
    0,
    0,
    0,
    377,
    375,
    1,
    0,
    0,
    0,
    378,
    380,
    5,
    46,
    0,
    0,
    379,
    381,
    2,
    48,
    57,
    0,
    380,
    379,
    1,
    0,
    0,
    0,
    381,
    382,
    1,
    0,
    0,
    0,
    382,
    380,
    1,
    0,
    0,
    0,
    382,
    383,
    1,
    0,
    0,
    0,
    383,
    391,
    1,
    0,
    0,
    0,
    384,
    386,
    2,
    48,
    57,
    0,
    385,
    384,
    1,
    0,
    0,
    0,
    386,
    387,
    1,
    0,
    0,
    0,
    387,
    385,
    1,
    0,
    0,
    0,
    387,
    388,
    1,
    0,
    0,
    0,
    388,
    389,
    1,
    0,
    0,
    0,
    389,
    391,
    5,
    46,
    0,
    0,
    390,
    375,
    1,
    0,
    0,
    0,
    390,
    385,
    1,
    0,
    0,
    0,
    391,
    402,
    1,
    0,
    0,
    0,
    392,
    394,
    7,
    8,
    0,
    0,
    393,
    395,
    7,
    21,
    0,
    0,
    394,
    393,
    1,
    0,
    0,
    0,
    394,
    395,
    1,
    0,
    0,
    0,
    395,
    399,
    1,
    0,
    0,
    0,
    396,
    398,
    2,
    48,
    57,
    0,
    397,
    396,
    1,
    0,
    0,
    0,
    398,
    401,
    1,
    0,
    0,
    0,
    399,
    397,
    1,
    0,
    0,
    0,
    399,
    400,
    1,
    0,
    0,
    0,
    400,
    403,
    1,
    0,
    0,
    0,
    401,
    399,
    1,
    0,
    0,
    0,
    402,
    392,
    1,
    0,
    0,
    0,
    402,
    403,
    1,
    0,
    0,
    0,
    403,
    102,
    1,
    0,
    0,
    0,
    404,
    405,
    7,
    2,
    0,
    0,
    405,
    406,
    7,
    10,
    0,
    0,
    406,
    407,
    7,
    16,
    0,
    0,
    407,
    414,
    7,
    8,
    0,
    0,
    408,
    409,
    7,
    9,
    0,
    0,
    409,
    410,
    7,
    19,
    0,
    0,
    410,
    411,
    7,
    7,
    0,
    0,
    411,
    412,
    7,
    15,
    0,
    0,
    412,
    414,
    7,
    8,
    0,
    0,
    413,
    404,
    1,
    0,
    0,
    0,
    413,
    408,
    1,
    0,
    0,
    0,
    414,
    104,
    1,
    0,
    0,
    0,
    415,
    416,
    7,
    14,
    0,
    0,
    416,
    417,
    7,
    8,
    0,
    0,
    417,
    418,
    7,
    10,
    0,
    0,
    418,
    106,
    1,
    0,
    0,
    0,
    419,
    420,
    7,
    15,
    0,
    0,
    420,
    421,
    7,
    22,
    0,
    0,
    421,
    422,
    7,
    16,
    0,
    0,
    422,
    423,
    7,
    19,
    0,
    0,
    423,
    424,
    7,
    10,
    0,
    0,
    424,
    425,
    7,
    8,
    0,
    0,
    425,
    426,
    7,
    18,
    0,
    0,
    426,
    108,
    1,
    0,
    0,
    0,
    427,
    428,
    7,
    17,
    0,
    0,
    428,
    429,
    7,
    16,
    0,
    0,
    429,
    430,
    7,
    12,
    0,
    0,
    430,
    431,
    7,
    8,
    0,
    0,
    431,
    432,
    7,
    18,
    0,
    0,
    432,
    110,
    1,
    0,
    0,
    0,
    433,
    437,
    7,
    23,
    0,
    0,
    434,
    436,
    7,
    24,
    0,
    0,
    435,
    434,
    1,
    0,
    0,
    0,
    436,
    439,
    1,
    0,
    0,
    0,
    437,
    435,
    1,
    0,
    0,
    0,
    437,
    438,
    1,
    0,
    0,
    0,
    438,
    112,
    1,
    0,
    0,
    0,
    439,
    437,
    1,
    0,
    0,
    0,
    440,
    442,
    3,
    115,
    57,
    0,
    441,
    443,
    8,
    25,
    0,
    0,
    442,
    441,
    1,
    0,
    0,
    0,
    443,
    444,
    1,
    0,
    0,
    0,
    444,
    445,
    1,
    0,
    0,
    0,
    444,
    442,
    1,
    0,
    0,
    0,
    445,
    446,
    1,
    0,
    0,
    0,
    446,
    447,
    3,
    117,
    58,
    0,
    447,
    459,
    1,
    0,
    0,
    0,
    448,
    449,
    3,
    115,
    57,
    0,
    449,
    451,
    3,
    115,
    57,
    0,
    450,
    452,
    8,
    25,
    0,
    0,
    451,
    450,
    1,
    0,
    0,
    0,
    452,
    453,
    1,
    0,
    0,
    0,
    453,
    454,
    1,
    0,
    0,
    0,
    453,
    451,
    1,
    0,
    0,
    0,
    454,
    455,
    1,
    0,
    0,
    0,
    455,
    456,
    3,
    117,
    58,
    0,
    456,
    457,
    3,
    117,
    58,
    0,
    457,
    459,
    1,
    0,
    0,
    0,
    458,
    440,
    1,
    0,
    0,
    0,
    458,
    448,
    1,
    0,
    0,
    0,
    459,
    114,
    1,
    0,
    0,
    0,
    460,
    461,
    5,
    91,
    0,
    0,
    461,
    116,
    1,
    0,
    0,
    0,
    462,
    463,
    5,
    93,
    0,
    0,
    463,
    118,
    1,
    0,
    0,
    0,
    464,
    465,
    7,
    26,
    0,
    0,
    465,
    120,
    1,
    0,
    0,
    0,
    466,
    470,
    5,
    39,
    0,
    0,
    467,
    469,
    9,
    0,
    0,
    0,
    468,
    467,
    1,
    0,
    0,
    0,
    469,
    472,
    1,
    0,
    0,
    0,
    470,
    471,
    1,
    0,
    0,
    0,
    470,
    468,
    1,
    0,
    0,
    0,
    471,
    473,
    1,
    0,
    0,
    0,
    472,
    470,
    1,
    0,
    0,
    0,
    473,
    485,
    5,
    39,
    0,
    0,
    474,
    480,
    5,
    34,
    0,
    0,
    475,
    476,
    5,
    92,
    0,
    0,
    476,
    479,
    5,
    34,
    0,
    0,
    477,
    479,
    8,
    27,
    0,
    0,
    478,
    475,
    1,
    0,
    0,
    0,
    478,
    477,
    1,
    0,
    0,
    0,
    479,
    482,
    1,
    0,
    0,
    0,
    480,
    478,
    1,
    0,
    0,
    0,
    480,
    481,
    1,
    0,
    0,
    0,
    481,
    483,
    1,
    0,
    0,
    0,
    482,
    480,
    1,
    0,
    0,
    0,
    483,
    485,
    5,
    34,
    0,
    0,
    484,
    466,
    1,
    0,
    0,
    0,
    484,
    474,
    1,
    0,
    0,
    0,
    485,
    122,
    1,
    0,
    0,
    0,
    39,
    0,
    143,
    151,
    158,
    163,
    168,
    173,
    177,
    184,
    191,
    196,
    201,
    291,
    302,
    307,
    313,
    337,
    344,
    349,
    358,
    362,
    367,
    370,
    375,
    382,
    387,
    390,
    394,
    399,
    402,
    413,
    437,
    444,
    453,
    458,
    470,
    478,
    480,
    484,
    1,
    6,
    0,
    0
  ];
  var atn = new M.atn.ATNDeserializer().deserialize(serializedATN);
  var decisionsToDFA = atn.decisionToState.map((ds, index) => new M.dfa.DFA(ds, index));
  var FormulaLexer = class extends M.Lexer {
    constructor(input) {
      super(input);
      this._interp = new M.atn.LexerATNSimulator(this, atn, decisionsToDFA, new M.atn.PredictionContextCache());
    }
  };
  __publicField(FormulaLexer, "grammarFileName", "Formula.g");
  __publicField(FormulaLexer, "channelNames", ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"]);
  __publicField(FormulaLexer, "modeNames", ["DEFAULT_MODE"]);
  __publicField(FormulaLexer, "literalNames", [
    null,
    "'('",
    "','",
    "')'",
    "'<-'",
    "':'",
    "'!'",
    "'not'",
    "'.'",
    null,
    null,
    null,
    null,
    null,
    "'while'",
    "'for'",
    "'from'",
    "'in'",
    "'to'",
    "'by'",
    "'loop'",
    "'if'",
    "'then'",
    "'else'",
    "'function'",
    "'end'",
    "'return'",
    "'new'",
    "'try'",
    "'catch'",
    "'throw'",
    null,
    "'xor'",
    null,
    null,
    null,
    "'<'",
    "'<='",
    "'>'",
    "'>='",
    "'+'",
    "'-'",
    "'*'",
    "'/'",
    null,
    "'^'",
    null,
    null,
    "'{'",
    "'}'",
    null,
    null,
    null,
    "'per'",
    "'squared'",
    "'cubed'",
    null,
    null,
    "'['",
    "']'"
  ]);
  __publicField(FormulaLexer, "symbolicNames", [
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "COMMENT",
    "LINE_COMMENT",
    "R__",
    "R_",
    "NEWLINES",
    "WHILESTATEMENT",
    "FORSTATEMENT",
    "FROMSTATEMENT",
    "INSTATEMENT",
    "TOSTATEMENT",
    "BYSTATEMENT",
    "LOOPSTATEMENT",
    "IFSTATEMENT",
    "THENSTATEMENT",
    "ELSESTATEMENT",
    "FUNCTIONSTATEMENT",
    "ENDBLOCK",
    "RETURNSTATEMENT",
    "NEWSTATEMENT",
    "TRYSTATEMENT",
    "CATCHSTATEMENT",
    "THROWSTATEMENT",
    "OR",
    "XOR",
    "AND",
    "EQUALS",
    "NOTEQUALS",
    "LT",
    "LTEQ",
    "GT",
    "GTEQ",
    "PLUS",
    "MINUS",
    "MULT",
    "DIV",
    "MOD",
    "POW",
    "LARR",
    "RARR",
    "LCURL",
    "RCURL",
    "INTEGER",
    "FLOAT",
    "BOOL",
    "PER",
    "SQUARED",
    "CUBED",
    "IDENT",
    "PRIMITIVE",
    "LBRACKET",
    "RBRACKET",
    "SPACE",
    "STRING"
  ]);
  __publicField(FormulaLexer, "ruleNames", [
    "T__0",
    "T__1",
    "T__2",
    "T__3",
    "T__4",
    "T__5",
    "T__6",
    "T__7",
    "COMMENT",
    "LINE_COMMENT",
    "R__",
    "R_",
    "NEWLINES",
    "WHILESTATEMENT",
    "FORSTATEMENT",
    "FROMSTATEMENT",
    "INSTATEMENT",
    "TOSTATEMENT",
    "BYSTATEMENT",
    "LOOPSTATEMENT",
    "IFSTATEMENT",
    "THENSTATEMENT",
    "ELSESTATEMENT",
    "FUNCTIONSTATEMENT",
    "ENDBLOCK",
    "RETURNSTATEMENT",
    "NEWSTATEMENT",
    "TRYSTATEMENT",
    "CATCHSTATEMENT",
    "THROWSTATEMENT",
    "OR",
    "XOR",
    "AND",
    "EQUALS",
    "NOTEQUALS",
    "LT",
    "LTEQ",
    "GT",
    "GTEQ",
    "PLUS",
    "MINUS",
    "MULT",
    "DIV",
    "MOD",
    "POW",
    "LARR",
    "RARR",
    "LCURL",
    "RCURL",
    "INTEGER",
    "FLOAT",
    "BOOL",
    "PER",
    "SQUARED",
    "CUBED",
    "IDENT",
    "PRIMITIVE",
    "LBRACKET",
    "RBRACKET",
    "SPACE",
    "STRING"
  ]);
  FormulaLexer.EOF = M.Token.EOF;
  FormulaLexer.T__0 = 1;
  FormulaLexer.T__1 = 2;
  FormulaLexer.T__2 = 3;
  FormulaLexer.T__3 = 4;
  FormulaLexer.T__4 = 5;
  FormulaLexer.T__5 = 6;
  FormulaLexer.T__6 = 7;
  FormulaLexer.T__7 = 8;
  FormulaLexer.COMMENT = 9;
  FormulaLexer.LINE_COMMENT = 10;
  FormulaLexer.R__ = 11;
  FormulaLexer.R_ = 12;
  FormulaLexer.NEWLINES = 13;
  FormulaLexer.WHILESTATEMENT = 14;
  FormulaLexer.FORSTATEMENT = 15;
  FormulaLexer.FROMSTATEMENT = 16;
  FormulaLexer.INSTATEMENT = 17;
  FormulaLexer.TOSTATEMENT = 18;
  FormulaLexer.BYSTATEMENT = 19;
  FormulaLexer.LOOPSTATEMENT = 20;
  FormulaLexer.IFSTATEMENT = 21;
  FormulaLexer.THENSTATEMENT = 22;
  FormulaLexer.ELSESTATEMENT = 23;
  FormulaLexer.FUNCTIONSTATEMENT = 24;
  FormulaLexer.ENDBLOCK = 25;
  FormulaLexer.RETURNSTATEMENT = 26;
  FormulaLexer.NEWSTATEMENT = 27;
  FormulaLexer.TRYSTATEMENT = 28;
  FormulaLexer.CATCHSTATEMENT = 29;
  FormulaLexer.THROWSTATEMENT = 30;
  FormulaLexer.OR = 31;
  FormulaLexer.XOR = 32;
  FormulaLexer.AND = 33;
  FormulaLexer.EQUALS = 34;
  FormulaLexer.NOTEQUALS = 35;
  FormulaLexer.LT = 36;
  FormulaLexer.LTEQ = 37;
  FormulaLexer.GT = 38;
  FormulaLexer.GTEQ = 39;
  FormulaLexer.PLUS = 40;
  FormulaLexer.MINUS = 41;
  FormulaLexer.MULT = 42;
  FormulaLexer.DIV = 43;
  FormulaLexer.MOD = 44;
  FormulaLexer.POW = 45;
  FormulaLexer.LARR = 46;
  FormulaLexer.RARR = 47;
  FormulaLexer.LCURL = 48;
  FormulaLexer.RCURL = 49;
  FormulaLexer.INTEGER = 50;
  FormulaLexer.FLOAT = 51;
  FormulaLexer.BOOL = 52;
  FormulaLexer.PER = 53;
  FormulaLexer.SQUARED = 54;
  FormulaLexer.CUBED = 55;
  FormulaLexer.IDENT = 56;
  FormulaLexer.PRIMITIVE = 57;
  FormulaLexer.LBRACKET = 58;
  FormulaLexer.RBRACKET = 59;
  FormulaLexer.SPACE = 60;
  FormulaLexer.STRING = 61;

  // ../insight-maker-simulation/src/formula/grammar/FormulaParser.js
  var serializedATN2 = [
    4,
    1,
    61,
    1396,
    2,
    0,
    7,
    0,
    2,
    1,
    7,
    1,
    2,
    2,
    7,
    2,
    2,
    3,
    7,
    3,
    2,
    4,
    7,
    4,
    2,
    5,
    7,
    5,
    2,
    6,
    7,
    6,
    2,
    7,
    7,
    7,
    2,
    8,
    7,
    8,
    2,
    9,
    7,
    9,
    2,
    10,
    7,
    10,
    2,
    11,
    7,
    11,
    2,
    12,
    7,
    12,
    2,
    13,
    7,
    13,
    2,
    14,
    7,
    14,
    2,
    15,
    7,
    15,
    2,
    16,
    7,
    16,
    2,
    17,
    7,
    17,
    2,
    18,
    7,
    18,
    2,
    19,
    7,
    19,
    2,
    20,
    7,
    20,
    2,
    21,
    7,
    21,
    2,
    22,
    7,
    22,
    2,
    23,
    7,
    23,
    2,
    24,
    7,
    24,
    2,
    25,
    7,
    25,
    2,
    26,
    7,
    26,
    2,
    27,
    7,
    27,
    2,
    28,
    7,
    28,
    2,
    29,
    7,
    29,
    2,
    30,
    7,
    30,
    2,
    31,
    7,
    31,
    2,
    32,
    7,
    32,
    2,
    33,
    7,
    33,
    2,
    34,
    7,
    34,
    2,
    35,
    7,
    35,
    2,
    36,
    7,
    36,
    2,
    37,
    7,
    37,
    2,
    38,
    7,
    38,
    2,
    39,
    7,
    39,
    2,
    40,
    7,
    40,
    2,
    41,
    7,
    41,
    2,
    42,
    7,
    42,
    2,
    43,
    7,
    43,
    2,
    44,
    7,
    44,
    2,
    45,
    7,
    45,
    2,
    46,
    7,
    46,
    2,
    47,
    7,
    47,
    1,
    0,
    5,
    0,
    98,
    8,
    0,
    10,
    0,
    12,
    0,
    101,
    9,
    0,
    1,
    0,
    1,
    0,
    4,
    0,
    105,
    8,
    0,
    11,
    0,
    12,
    0,
    106,
    1,
    0,
    5,
    0,
    110,
    8,
    0,
    10,
    0,
    12,
    0,
    113,
    9,
    0,
    1,
    0,
    5,
    0,
    116,
    8,
    0,
    10,
    0,
    12,
    0,
    119,
    9,
    0,
    3,
    0,
    121,
    8,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    3,
    1,
    135,
    8,
    1,
    1,
    2,
    1,
    2,
    5,
    2,
    139,
    8,
    2,
    10,
    2,
    12,
    2,
    142,
    9,
    2,
    1,
    2,
    1,
    2,
    1,
    3,
    5,
    3,
    147,
    8,
    3,
    10,
    3,
    12,
    3,
    150,
    9,
    3,
    1,
    3,
    1,
    3,
    4,
    3,
    154,
    8,
    3,
    11,
    3,
    12,
    3,
    155,
    1,
    3,
    5,
    3,
    159,
    8,
    3,
    10,
    3,
    12,
    3,
    162,
    9,
    3,
    1,
    3,
    5,
    3,
    165,
    8,
    3,
    10,
    3,
    12,
    3,
    168,
    9,
    3,
    3,
    3,
    170,
    8,
    3,
    1,
    4,
    1,
    4,
    5,
    4,
    174,
    8,
    4,
    10,
    4,
    12,
    4,
    177,
    9,
    4,
    1,
    4,
    1,
    4,
    1,
    4,
    1,
    4,
    1,
    4,
    1,
    4,
    1,
    4,
    1,
    4,
    1,
    4,
    1,
    5,
    1,
    5,
    1,
    5,
    1,
    5,
    1,
    5,
    1,
    5,
    5,
    5,
    194,
    8,
    5,
    10,
    5,
    12,
    5,
    197,
    9,
    5,
    1,
    5,
    1,
    5,
    5,
    5,
    201,
    8,
    5,
    10,
    5,
    12,
    5,
    204,
    9,
    5,
    1,
    5,
    1,
    5,
    5,
    5,
    208,
    8,
    5,
    10,
    5,
    12,
    5,
    211,
    9,
    5,
    1,
    5,
    1,
    5,
    5,
    5,
    215,
    8,
    5,
    10,
    5,
    12,
    5,
    218,
    9,
    5,
    1,
    5,
    1,
    5,
    5,
    5,
    222,
    8,
    5,
    10,
    5,
    12,
    5,
    225,
    9,
    5,
    1,
    5,
    3,
    5,
    228,
    8,
    5,
    1,
    5,
    1,
    5,
    3,
    5,
    232,
    8,
    5,
    1,
    5,
    1,
    5,
    1,
    5,
    1,
    5,
    1,
    5,
    1,
    6,
    1,
    6,
    1,
    6,
    1,
    6,
    1,
    6,
    1,
    6,
    5,
    6,
    245,
    8,
    6,
    10,
    6,
    12,
    6,
    248,
    9,
    6,
    1,
    6,
    1,
    6,
    1,
    6,
    3,
    6,
    253,
    8,
    6,
    1,
    6,
    1,
    6,
    1,
    6,
    1,
    6,
    1,
    6,
    1,
    7,
    1,
    7,
    5,
    7,
    262,
    8,
    7,
    10,
    7,
    12,
    7,
    265,
    9,
    7,
    1,
    7,
    1,
    7,
    5,
    7,
    269,
    8,
    7,
    10,
    7,
    12,
    7,
    272,
    9,
    7,
    1,
    7,
    3,
    7,
    275,
    8,
    7,
    1,
    7,
    1,
    7,
    3,
    7,
    279,
    8,
    7,
    1,
    7,
    1,
    7,
    1,
    7,
    1,
    7,
    1,
    7,
    5,
    7,
    286,
    8,
    7,
    10,
    7,
    12,
    7,
    289,
    9,
    7,
    1,
    7,
    1,
    7,
    5,
    7,
    293,
    8,
    7,
    10,
    7,
    12,
    7,
    296,
    9,
    7,
    1,
    7,
    3,
    7,
    299,
    8,
    7,
    1,
    7,
    1,
    7,
    3,
    7,
    303,
    8,
    7,
    5,
    7,
    305,
    8,
    7,
    10,
    7,
    12,
    7,
    308,
    9,
    7,
    1,
    7,
    1,
    7,
    1,
    7,
    1,
    7,
    3,
    7,
    314,
    8,
    7,
    3,
    7,
    316,
    8,
    7,
    1,
    7,
    1,
    7,
    1,
    7,
    1,
    7,
    1,
    7,
    1,
    8,
    1,
    8,
    1,
    8,
    1,
    8,
    5,
    8,
    327,
    8,
    8,
    10,
    8,
    12,
    8,
    330,
    9,
    8,
    1,
    8,
    1,
    8,
    5,
    8,
    334,
    8,
    8,
    10,
    8,
    12,
    8,
    337,
    9,
    8,
    1,
    8,
    1,
    8,
    5,
    8,
    341,
    8,
    8,
    10,
    8,
    12,
    8,
    344,
    9,
    8,
    1,
    8,
    1,
    8,
    5,
    8,
    348,
    8,
    8,
    10,
    8,
    12,
    8,
    351,
    9,
    8,
    1,
    8,
    1,
    8,
    5,
    8,
    355,
    8,
    8,
    10,
    8,
    12,
    8,
    358,
    9,
    8,
    1,
    8,
    1,
    8,
    5,
    8,
    362,
    8,
    8,
    10,
    8,
    12,
    8,
    365,
    9,
    8,
    1,
    8,
    5,
    8,
    368,
    8,
    8,
    10,
    8,
    12,
    8,
    371,
    9,
    8,
    3,
    8,
    373,
    8,
    8,
    1,
    8,
    5,
    8,
    376,
    8,
    8,
    10,
    8,
    12,
    8,
    379,
    9,
    8,
    1,
    8,
    1,
    8,
    5,
    8,
    383,
    8,
    8,
    10,
    8,
    12,
    8,
    386,
    9,
    8,
    1,
    8,
    1,
    8,
    5,
    8,
    390,
    8,
    8,
    10,
    8,
    12,
    8,
    393,
    9,
    8,
    1,
    8,
    1,
    8,
    5,
    8,
    397,
    8,
    8,
    10,
    8,
    12,
    8,
    400,
    9,
    8,
    1,
    8,
    5,
    8,
    403,
    8,
    8,
    10,
    8,
    12,
    8,
    406,
    9,
    8,
    3,
    8,
    408,
    8,
    8,
    1,
    8,
    5,
    8,
    411,
    8,
    8,
    10,
    8,
    12,
    8,
    414,
    9,
    8,
    1,
    8,
    1,
    8,
    1,
    8,
    3,
    8,
    419,
    8,
    8,
    1,
    8,
    1,
    8,
    1,
    8,
    1,
    8,
    1,
    8,
    1,
    9,
    1,
    9,
    1,
    9,
    3,
    9,
    429,
    8,
    9,
    1,
    9,
    1,
    9,
    1,
    9,
    1,
    9,
    1,
    9,
    1,
    9,
    3,
    9,
    437,
    8,
    9,
    1,
    9,
    1,
    9,
    1,
    9,
    1,
    9,
    1,
    9,
    1,
    10,
    1,
    10,
    1,
    10,
    1,
    10,
    1,
    11,
    1,
    11,
    5,
    11,
    450,
    8,
    11,
    10,
    11,
    12,
    11,
    453,
    9,
    11,
    1,
    11,
    1,
    11,
    5,
    11,
    457,
    8,
    11,
    10,
    11,
    12,
    11,
    460,
    9,
    11,
    1,
    11,
    1,
    11,
    5,
    11,
    464,
    8,
    11,
    10,
    11,
    12,
    11,
    467,
    9,
    11,
    1,
    11,
    1,
    11,
    5,
    11,
    471,
    8,
    11,
    10,
    11,
    12,
    11,
    474,
    9,
    11,
    1,
    11,
    1,
    11,
    5,
    11,
    478,
    8,
    11,
    10,
    11,
    12,
    11,
    481,
    9,
    11,
    1,
    11,
    1,
    11,
    5,
    11,
    485,
    8,
    11,
    10,
    11,
    12,
    11,
    488,
    9,
    11,
    1,
    11,
    5,
    11,
    491,
    8,
    11,
    10,
    11,
    12,
    11,
    494,
    9,
    11,
    3,
    11,
    496,
    8,
    11,
    1,
    11,
    5,
    11,
    499,
    8,
    11,
    10,
    11,
    12,
    11,
    502,
    9,
    11,
    1,
    11,
    1,
    11,
    5,
    11,
    506,
    8,
    11,
    10,
    11,
    12,
    11,
    509,
    9,
    11,
    1,
    11,
    1,
    11,
    5,
    11,
    513,
    8,
    11,
    10,
    11,
    12,
    11,
    516,
    9,
    11,
    1,
    11,
    1,
    11,
    5,
    11,
    520,
    8,
    11,
    10,
    11,
    12,
    11,
    523,
    9,
    11,
    1,
    11,
    5,
    11,
    526,
    8,
    11,
    10,
    11,
    12,
    11,
    529,
    9,
    11,
    3,
    11,
    531,
    8,
    11,
    1,
    11,
    5,
    11,
    534,
    8,
    11,
    10,
    11,
    12,
    11,
    537,
    9,
    11,
    1,
    11,
    1,
    11,
    1,
    11,
    3,
    11,
    542,
    8,
    11,
    1,
    11,
    1,
    11,
    1,
    11,
    1,
    11,
    1,
    11,
    5,
    11,
    549,
    8,
    11,
    10,
    11,
    12,
    11,
    552,
    9,
    11,
    1,
    11,
    3,
    11,
    555,
    8,
    11,
    1,
    12,
    1,
    12,
    5,
    12,
    559,
    8,
    12,
    10,
    12,
    12,
    12,
    562,
    9,
    12,
    1,
    12,
    1,
    12,
    5,
    12,
    566,
    8,
    12,
    10,
    12,
    12,
    12,
    569,
    9,
    12,
    1,
    12,
    1,
    12,
    5,
    12,
    573,
    8,
    12,
    10,
    12,
    12,
    12,
    576,
    9,
    12,
    1,
    12,
    1,
    12,
    5,
    12,
    580,
    8,
    12,
    10,
    12,
    12,
    12,
    583,
    9,
    12,
    1,
    12,
    1,
    12,
    5,
    12,
    587,
    8,
    12,
    10,
    12,
    12,
    12,
    590,
    9,
    12,
    1,
    12,
    1,
    12,
    5,
    12,
    594,
    8,
    12,
    10,
    12,
    12,
    12,
    597,
    9,
    12,
    1,
    12,
    5,
    12,
    600,
    8,
    12,
    10,
    12,
    12,
    12,
    603,
    9,
    12,
    3,
    12,
    605,
    8,
    12,
    1,
    12,
    1,
    12,
    5,
    12,
    609,
    8,
    12,
    10,
    12,
    12,
    12,
    612,
    9,
    12,
    1,
    12,
    1,
    12,
    5,
    12,
    616,
    8,
    12,
    10,
    12,
    12,
    12,
    619,
    9,
    12,
    1,
    12,
    1,
    12,
    5,
    12,
    623,
    8,
    12,
    10,
    12,
    12,
    12,
    626,
    9,
    12,
    1,
    12,
    5,
    12,
    629,
    8,
    12,
    10,
    12,
    12,
    12,
    632,
    9,
    12,
    3,
    12,
    634,
    8,
    12,
    1,
    12,
    5,
    12,
    637,
    8,
    12,
    10,
    12,
    12,
    12,
    640,
    9,
    12,
    1,
    12,
    1,
    12,
    5,
    12,
    644,
    8,
    12,
    10,
    12,
    12,
    12,
    647,
    9,
    12,
    1,
    12,
    1,
    12,
    5,
    12,
    651,
    8,
    12,
    10,
    12,
    12,
    12,
    654,
    9,
    12,
    1,
    12,
    1,
    12,
    1,
    12,
    3,
    12,
    659,
    8,
    12,
    1,
    12,
    5,
    12,
    662,
    8,
    12,
    10,
    12,
    12,
    12,
    665,
    9,
    12,
    1,
    12,
    1,
    12,
    5,
    12,
    669,
    8,
    12,
    10,
    12,
    12,
    12,
    672,
    9,
    12,
    1,
    12,
    1,
    12,
    3,
    12,
    676,
    8,
    12,
    5,
    12,
    678,
    8,
    12,
    10,
    12,
    12,
    12,
    681,
    9,
    12,
    1,
    12,
    5,
    12,
    684,
    8,
    12,
    10,
    12,
    12,
    12,
    687,
    9,
    12,
    1,
    12,
    1,
    12,
    5,
    12,
    691,
    8,
    12,
    10,
    12,
    12,
    12,
    694,
    9,
    12,
    1,
    12,
    3,
    12,
    697,
    8,
    12,
    1,
    13,
    1,
    13,
    3,
    13,
    701,
    8,
    13,
    1,
    14,
    1,
    14,
    5,
    14,
    705,
    8,
    14,
    10,
    14,
    12,
    14,
    708,
    9,
    14,
    1,
    14,
    1,
    14,
    5,
    14,
    712,
    8,
    14,
    10,
    14,
    12,
    14,
    715,
    9,
    14,
    1,
    14,
    5,
    14,
    718,
    8,
    14,
    10,
    14,
    12,
    14,
    721,
    9,
    14,
    1,
    15,
    1,
    15,
    5,
    15,
    725,
    8,
    15,
    10,
    15,
    12,
    15,
    728,
    9,
    15,
    1,
    15,
    1,
    15,
    5,
    15,
    732,
    8,
    15,
    10,
    15,
    12,
    15,
    735,
    9,
    15,
    1,
    15,
    5,
    15,
    738,
    8,
    15,
    10,
    15,
    12,
    15,
    741,
    9,
    15,
    1,
    16,
    1,
    16,
    5,
    16,
    745,
    8,
    16,
    10,
    16,
    12,
    16,
    748,
    9,
    16,
    1,
    16,
    1,
    16,
    5,
    16,
    752,
    8,
    16,
    10,
    16,
    12,
    16,
    755,
    9,
    16,
    1,
    16,
    5,
    16,
    758,
    8,
    16,
    10,
    16,
    12,
    16,
    761,
    9,
    16,
    1,
    17,
    1,
    17,
    5,
    17,
    765,
    8,
    17,
    10,
    17,
    12,
    17,
    768,
    9,
    17,
    1,
    17,
    1,
    17,
    5,
    17,
    772,
    8,
    17,
    10,
    17,
    12,
    17,
    775,
    9,
    17,
    1,
    17,
    5,
    17,
    778,
    8,
    17,
    10,
    17,
    12,
    17,
    781,
    9,
    17,
    1,
    18,
    1,
    18,
    5,
    18,
    785,
    8,
    18,
    10,
    18,
    12,
    18,
    788,
    9,
    18,
    1,
    18,
    1,
    18,
    5,
    18,
    792,
    8,
    18,
    10,
    18,
    12,
    18,
    795,
    9,
    18,
    1,
    18,
    5,
    18,
    798,
    8,
    18,
    10,
    18,
    12,
    18,
    801,
    9,
    18,
    1,
    19,
    1,
    19,
    5,
    19,
    805,
    8,
    19,
    10,
    19,
    12,
    19,
    808,
    9,
    19,
    1,
    19,
    1,
    19,
    5,
    19,
    812,
    8,
    19,
    10,
    19,
    12,
    19,
    815,
    9,
    19,
    1,
    19,
    5,
    19,
    818,
    8,
    19,
    10,
    19,
    12,
    19,
    821,
    9,
    19,
    1,
    20,
    1,
    20,
    5,
    20,
    825,
    8,
    20,
    10,
    20,
    12,
    20,
    828,
    9,
    20,
    1,
    20,
    1,
    20,
    5,
    20,
    832,
    8,
    20,
    10,
    20,
    12,
    20,
    835,
    9,
    20,
    1,
    20,
    5,
    20,
    838,
    8,
    20,
    10,
    20,
    12,
    20,
    841,
    9,
    20,
    1,
    21,
    1,
    21,
    1,
    21,
    3,
    21,
    846,
    8,
    21,
    1,
    21,
    1,
    21,
    3,
    21,
    850,
    8,
    21,
    1,
    22,
    1,
    22,
    5,
    22,
    854,
    8,
    22,
    10,
    22,
    12,
    22,
    857,
    9,
    22,
    1,
    22,
    1,
    22,
    3,
    22,
    861,
    8,
    22,
    1,
    23,
    1,
    23,
    5,
    23,
    865,
    8,
    23,
    10,
    23,
    12,
    23,
    868,
    9,
    23,
    1,
    23,
    1,
    23,
    5,
    23,
    872,
    8,
    23,
    10,
    23,
    12,
    23,
    875,
    9,
    23,
    1,
    23,
    5,
    23,
    878,
    8,
    23,
    10,
    23,
    12,
    23,
    881,
    9,
    23,
    1,
    24,
    1,
    24,
    5,
    24,
    885,
    8,
    24,
    10,
    24,
    12,
    24,
    888,
    9,
    24,
    1,
    24,
    1,
    24,
    3,
    24,
    892,
    8,
    24,
    1,
    25,
    1,
    25,
    5,
    25,
    896,
    8,
    25,
    10,
    25,
    12,
    25,
    899,
    9,
    25,
    1,
    25,
    1,
    25,
    3,
    25,
    903,
    8,
    25,
    1,
    26,
    1,
    26,
    1,
    27,
    1,
    27,
    1,
    27,
    5,
    27,
    910,
    8,
    27,
    10,
    27,
    12,
    27,
    913,
    9,
    27,
    1,
    28,
    1,
    28,
    5,
    28,
    917,
    8,
    28,
    10,
    28,
    12,
    28,
    920,
    9,
    28,
    1,
    28,
    1,
    28,
    5,
    28,
    924,
    8,
    28,
    10,
    28,
    12,
    28,
    927,
    9,
    28,
    1,
    28,
    1,
    28,
    5,
    28,
    931,
    8,
    28,
    10,
    28,
    12,
    28,
    934,
    9,
    28,
    1,
    28,
    5,
    28,
    937,
    8,
    28,
    10,
    28,
    12,
    28,
    940,
    9,
    28,
    3,
    28,
    942,
    8,
    28,
    1,
    28,
    5,
    28,
    945,
    8,
    28,
    10,
    28,
    12,
    28,
    948,
    9,
    28,
    1,
    28,
    1,
    28,
    1,
    29,
    1,
    29,
    5,
    29,
    954,
    8,
    29,
    10,
    29,
    12,
    29,
    957,
    9,
    29,
    1,
    29,
    1,
    29,
    5,
    29,
    961,
    8,
    29,
    10,
    29,
    12,
    29,
    964,
    9,
    29,
    1,
    29,
    1,
    29,
    1,
    29,
    3,
    29,
    969,
    8,
    29,
    1,
    30,
    1,
    30,
    1,
    30,
    1,
    30,
    1,
    30,
    1,
    30,
    1,
    30,
    1,
    30,
    1,
    30,
    3,
    30,
    980,
    8,
    30,
    1,
    31,
    1,
    31,
    5,
    31,
    984,
    8,
    31,
    10,
    31,
    12,
    31,
    987,
    9,
    31,
    1,
    31,
    1,
    31,
    1,
    31,
    1,
    31,
    5,
    31,
    993,
    8,
    31,
    10,
    31,
    12,
    31,
    996,
    9,
    31,
    1,
    31,
    1,
    31,
    1,
    32,
    1,
    32,
    5,
    32,
    1002,
    8,
    32,
    10,
    32,
    12,
    32,
    1005,
    9,
    32,
    1,
    32,
    1,
    32,
    5,
    32,
    1009,
    8,
    32,
    10,
    32,
    12,
    32,
    1012,
    9,
    32,
    1,
    32,
    1,
    32,
    5,
    32,
    1016,
    8,
    32,
    10,
    32,
    12,
    32,
    1019,
    9,
    32,
    1,
    32,
    5,
    32,
    1022,
    8,
    32,
    10,
    32,
    12,
    32,
    1025,
    9,
    32,
    3,
    32,
    1027,
    8,
    32,
    1,
    32,
    5,
    32,
    1030,
    8,
    32,
    10,
    32,
    12,
    32,
    1033,
    9,
    32,
    1,
    32,
    1,
    32,
    1,
    32,
    5,
    32,
    1038,
    8,
    32,
    10,
    32,
    12,
    32,
    1041,
    9,
    32,
    1,
    32,
    1,
    32,
    5,
    32,
    1045,
    8,
    32,
    10,
    32,
    12,
    32,
    1048,
    9,
    32,
    1,
    32,
    1,
    32,
    5,
    32,
    1052,
    8,
    32,
    10,
    32,
    12,
    32,
    1055,
    9,
    32,
    1,
    32,
    5,
    32,
    1058,
    8,
    32,
    10,
    32,
    12,
    32,
    1061,
    9,
    32,
    3,
    32,
    1063,
    8,
    32,
    1,
    32,
    5,
    32,
    1066,
    8,
    32,
    10,
    32,
    12,
    32,
    1069,
    9,
    32,
    1,
    32,
    1,
    32,
    1,
    32,
    5,
    32,
    1074,
    8,
    32,
    10,
    32,
    12,
    32,
    1077,
    9,
    32,
    1,
    32,
    1,
    32,
    5,
    32,
    1081,
    8,
    32,
    10,
    32,
    12,
    32,
    1084,
    9,
    32,
    1,
    32,
    1,
    32,
    5,
    32,
    1088,
    8,
    32,
    10,
    32,
    12,
    32,
    1091,
    9,
    32,
    1,
    32,
    5,
    32,
    1094,
    8,
    32,
    10,
    32,
    12,
    32,
    1097,
    9,
    32,
    3,
    32,
    1099,
    8,
    32,
    1,
    32,
    5,
    32,
    1102,
    8,
    32,
    10,
    32,
    12,
    32,
    1105,
    9,
    32,
    1,
    32,
    1,
    32,
    1,
    32,
    5,
    32,
    1110,
    8,
    32,
    10,
    32,
    12,
    32,
    1113,
    9,
    32,
    1,
    32,
    1,
    32,
    5,
    32,
    1117,
    8,
    32,
    10,
    32,
    12,
    32,
    1120,
    9,
    32,
    1,
    32,
    1,
    32,
    5,
    32,
    1124,
    8,
    32,
    10,
    32,
    12,
    32,
    1127,
    9,
    32,
    1,
    32,
    5,
    32,
    1130,
    8,
    32,
    10,
    32,
    12,
    32,
    1133,
    9,
    32,
    3,
    32,
    1135,
    8,
    32,
    1,
    32,
    5,
    32,
    1138,
    8,
    32,
    10,
    32,
    12,
    32,
    1141,
    9,
    32,
    1,
    32,
    3,
    32,
    1144,
    8,
    32,
    1,
    33,
    1,
    33,
    1,
    33,
    1,
    33,
    3,
    33,
    1150,
    8,
    33,
    1,
    34,
    1,
    34,
    1,
    34,
    1,
    34,
    1,
    34,
    3,
    34,
    1157,
    8,
    34,
    1,
    35,
    1,
    35,
    3,
    35,
    1161,
    8,
    35,
    1,
    36,
    1,
    36,
    5,
    36,
    1165,
    8,
    36,
    10,
    36,
    12,
    36,
    1168,
    9,
    36,
    1,
    36,
    1,
    36,
    3,
    36,
    1172,
    8,
    36,
    1,
    36,
    5,
    36,
    1175,
    8,
    36,
    10,
    36,
    12,
    36,
    1178,
    9,
    36,
    1,
    36,
    1,
    36,
    5,
    36,
    1182,
    8,
    36,
    10,
    36,
    12,
    36,
    1185,
    9,
    36,
    1,
    36,
    1,
    36,
    3,
    36,
    1189,
    8,
    36,
    5,
    36,
    1191,
    8,
    36,
    10,
    36,
    12,
    36,
    1194,
    9,
    36,
    1,
    36,
    5,
    36,
    1197,
    8,
    36,
    10,
    36,
    12,
    36,
    1200,
    9,
    36,
    1,
    36,
    1,
    36,
    1,
    36,
    5,
    36,
    1205,
    8,
    36,
    10,
    36,
    12,
    36,
    1208,
    9,
    36,
    1,
    36,
    1,
    36,
    3,
    36,
    1212,
    8,
    36,
    1,
    36,
    5,
    36,
    1215,
    8,
    36,
    10,
    36,
    12,
    36,
    1218,
    9,
    36,
    1,
    36,
    1,
    36,
    5,
    36,
    1222,
    8,
    36,
    10,
    36,
    12,
    36,
    1225,
    9,
    36,
    1,
    36,
    1,
    36,
    3,
    36,
    1229,
    8,
    36,
    5,
    36,
    1231,
    8,
    36,
    10,
    36,
    12,
    36,
    1234,
    9,
    36,
    1,
    36,
    5,
    36,
    1237,
    8,
    36,
    10,
    36,
    12,
    36,
    1240,
    9,
    36,
    1,
    36,
    3,
    36,
    1243,
    8,
    36,
    1,
    37,
    1,
    37,
    4,
    37,
    1247,
    8,
    37,
    11,
    37,
    12,
    37,
    1248,
    1,
    38,
    1,
    38,
    1,
    39,
    1,
    39,
    5,
    39,
    1255,
    8,
    39,
    10,
    39,
    12,
    39,
    1258,
    9,
    39,
    1,
    39,
    1,
    39,
    5,
    39,
    1262,
    8,
    39,
    10,
    39,
    12,
    39,
    1265,
    9,
    39,
    1,
    39,
    1,
    39,
    1,
    40,
    1,
    40,
    1,
    41,
    1,
    41,
    1,
    41,
    1,
    42,
    1,
    42,
    1,
    42,
    1,
    42,
    1,
    42,
    5,
    42,
    1279,
    8,
    42,
    10,
    42,
    12,
    42,
    1282,
    9,
    42,
    1,
    43,
    1,
    43,
    5,
    43,
    1286,
    8,
    43,
    10,
    43,
    12,
    43,
    1289,
    9,
    43,
    1,
    43,
    1,
    43,
    5,
    43,
    1293,
    8,
    43,
    10,
    43,
    12,
    43,
    1296,
    9,
    43,
    1,
    43,
    5,
    43,
    1299,
    8,
    43,
    10,
    43,
    12,
    43,
    1302,
    9,
    43,
    1,
    44,
    1,
    44,
    5,
    44,
    1306,
    8,
    44,
    10,
    44,
    12,
    44,
    1309,
    9,
    44,
    1,
    44,
    1,
    44,
    1,
    44,
    5,
    44,
    1314,
    8,
    44,
    10,
    44,
    12,
    44,
    1317,
    9,
    44,
    1,
    44,
    1,
    44,
    1,
    44,
    3,
    44,
    1322,
    8,
    44,
    1,
    44,
    1,
    44,
    3,
    44,
    1326,
    8,
    44,
    1,
    44,
    1,
    44,
    1,
    44,
    3,
    44,
    1331,
    8,
    44,
    1,
    44,
    1,
    44,
    3,
    44,
    1335,
    8,
    44,
    3,
    44,
    1337,
    8,
    44,
    1,
    45,
    1,
    45,
    5,
    45,
    1341,
    8,
    45,
    10,
    45,
    12,
    45,
    1344,
    9,
    45,
    1,
    45,
    1,
    45,
    5,
    45,
    1348,
    8,
    45,
    10,
    45,
    12,
    45,
    1351,
    9,
    45,
    1,
    45,
    3,
    45,
    1354,
    8,
    45,
    1,
    45,
    5,
    45,
    1357,
    8,
    45,
    10,
    45,
    12,
    45,
    1360,
    9,
    45,
    1,
    45,
    5,
    45,
    1363,
    8,
    45,
    10,
    45,
    12,
    45,
    1366,
    9,
    45,
    1,
    46,
    1,
    46,
    1,
    46,
    5,
    46,
    1371,
    8,
    46,
    10,
    46,
    12,
    46,
    1374,
    9,
    46,
    1,
    46,
    1,
    46,
    5,
    46,
    1378,
    8,
    46,
    10,
    46,
    12,
    46,
    1381,
    9,
    46,
    1,
    46,
    1,
    46,
    5,
    46,
    1385,
    8,
    46,
    10,
    46,
    12,
    46,
    1388,
    9,
    46,
    1,
    46,
    1,
    46,
    3,
    46,
    1392,
    8,
    46,
    1,
    47,
    1,
    47,
    1,
    47,
    0,
    0,
    48,
    0,
    2,
    4,
    6,
    8,
    10,
    12,
    14,
    16,
    18,
    20,
    22,
    24,
    26,
    28,
    30,
    32,
    34,
    36,
    38,
    40,
    42,
    44,
    46,
    48,
    50,
    52,
    54,
    56,
    58,
    60,
    62,
    64,
    66,
    68,
    70,
    72,
    74,
    76,
    78,
    80,
    82,
    84,
    86,
    88,
    90,
    92,
    94,
    0,
    9,
    1,
    0,
    11,
    12,
    1,
    0,
    34,
    35,
    1,
    0,
    36,
    39,
    1,
    0,
    40,
    41,
    1,
    0,
    42,
    44,
    1,
    0,
    6,
    7,
    3,
    0,
    42,
    42,
    56,
    56,
    61,
    61,
    1,
    0,
    50,
    51,
    1,
    0,
    42,
    43,
    1573,
    0,
    99,
    1,
    0,
    0,
    0,
    2,
    134,
    1,
    0,
    0,
    0,
    4,
    136,
    1,
    0,
    0,
    0,
    6,
    148,
    1,
    0,
    0,
    0,
    8,
    171,
    1,
    0,
    0,
    0,
    10,
    187,
    1,
    0,
    0,
    0,
    12,
    238,
    1,
    0,
    0,
    0,
    14,
    259,
    1,
    0,
    0,
    0,
    16,
    322,
    1,
    0,
    0,
    0,
    18,
    425,
    1,
    0,
    0,
    0,
    20,
    443,
    1,
    0,
    0,
    0,
    22,
    447,
    1,
    0,
    0,
    0,
    24,
    696,
    1,
    0,
    0,
    0,
    26,
    698,
    1,
    0,
    0,
    0,
    28,
    702,
    1,
    0,
    0,
    0,
    30,
    722,
    1,
    0,
    0,
    0,
    32,
    742,
    1,
    0,
    0,
    0,
    34,
    762,
    1,
    0,
    0,
    0,
    36,
    782,
    1,
    0,
    0,
    0,
    38,
    802,
    1,
    0,
    0,
    0,
    40,
    822,
    1,
    0,
    0,
    0,
    42,
    842,
    1,
    0,
    0,
    0,
    44,
    860,
    1,
    0,
    0,
    0,
    46,
    862,
    1,
    0,
    0,
    0,
    48,
    891,
    1,
    0,
    0,
    0,
    50,
    902,
    1,
    0,
    0,
    0,
    52,
    904,
    1,
    0,
    0,
    0,
    54,
    906,
    1,
    0,
    0,
    0,
    56,
    914,
    1,
    0,
    0,
    0,
    58,
    968,
    1,
    0,
    0,
    0,
    60,
    979,
    1,
    0,
    0,
    0,
    62,
    981,
    1,
    0,
    0,
    0,
    64,
    1143,
    1,
    0,
    0,
    0,
    66,
    1145,
    1,
    0,
    0,
    0,
    68,
    1156,
    1,
    0,
    0,
    0,
    70,
    1160,
    1,
    0,
    0,
    0,
    72,
    1242,
    1,
    0,
    0,
    0,
    74,
    1246,
    1,
    0,
    0,
    0,
    76,
    1250,
    1,
    0,
    0,
    0,
    78,
    1252,
    1,
    0,
    0,
    0,
    80,
    1268,
    1,
    0,
    0,
    0,
    82,
    1270,
    1,
    0,
    0,
    0,
    84,
    1273,
    1,
    0,
    0,
    0,
    86,
    1283,
    1,
    0,
    0,
    0,
    88,
    1336,
    1,
    0,
    0,
    0,
    90,
    1338,
    1,
    0,
    0,
    0,
    92,
    1391,
    1,
    0,
    0,
    0,
    94,
    1393,
    1,
    0,
    0,
    0,
    96,
    98,
    7,
    0,
    0,
    0,
    97,
    96,
    1,
    0,
    0,
    0,
    98,
    101,
    1,
    0,
    0,
    0,
    99,
    97,
    1,
    0,
    0,
    0,
    99,
    100,
    1,
    0,
    0,
    0,
    100,
    120,
    1,
    0,
    0,
    0,
    101,
    99,
    1,
    0,
    0,
    0,
    102,
    111,
    3,
    2,
    1,
    0,
    103,
    105,
    5,
    11,
    0,
    0,
    104,
    103,
    1,
    0,
    0,
    0,
    105,
    106,
    1,
    0,
    0,
    0,
    106,
    104,
    1,
    0,
    0,
    0,
    106,
    107,
    1,
    0,
    0,
    0,
    107,
    108,
    1,
    0,
    0,
    0,
    108,
    110,
    3,
    2,
    1,
    0,
    109,
    104,
    1,
    0,
    0,
    0,
    110,
    113,
    1,
    0,
    0,
    0,
    111,
    109,
    1,
    0,
    0,
    0,
    111,
    112,
    1,
    0,
    0,
    0,
    112,
    117,
    1,
    0,
    0,
    0,
    113,
    111,
    1,
    0,
    0,
    0,
    114,
    116,
    7,
    0,
    0,
    0,
    115,
    114,
    1,
    0,
    0,
    0,
    116,
    119,
    1,
    0,
    0,
    0,
    117,
    115,
    1,
    0,
    0,
    0,
    117,
    118,
    1,
    0,
    0,
    0,
    118,
    121,
    1,
    0,
    0,
    0,
    119,
    117,
    1,
    0,
    0,
    0,
    120,
    102,
    1,
    0,
    0,
    0,
    120,
    121,
    1,
    0,
    0,
    0,
    121,
    122,
    1,
    0,
    0,
    0,
    122,
    123,
    5,
    0,
    0,
    1,
    123,
    1,
    1,
    0,
    0,
    0,
    124,
    135,
    3,
    24,
    12,
    0,
    125,
    135,
    3,
    28,
    14,
    0,
    126,
    135,
    3,
    8,
    4,
    0,
    127,
    135,
    3,
    10,
    5,
    0,
    128,
    135,
    3,
    12,
    6,
    0,
    129,
    135,
    3,
    14,
    7,
    0,
    130,
    135,
    3,
    16,
    8,
    0,
    131,
    135,
    3,
    4,
    2,
    0,
    132,
    135,
    3,
    18,
    9,
    0,
    133,
    135,
    3,
    20,
    10,
    0,
    134,
    124,
    1,
    0,
    0,
    0,
    134,
    125,
    1,
    0,
    0,
    0,
    134,
    126,
    1,
    0,
    0,
    0,
    134,
    127,
    1,
    0,
    0,
    0,
    134,
    128,
    1,
    0,
    0,
    0,
    134,
    129,
    1,
    0,
    0,
    0,
    134,
    130,
    1,
    0,
    0,
    0,
    134,
    131,
    1,
    0,
    0,
    0,
    134,
    132,
    1,
    0,
    0,
    0,
    134,
    133,
    1,
    0,
    0,
    0,
    135,
    3,
    1,
    0,
    0,
    0,
    136,
    140,
    5,
    26,
    0,
    0,
    137,
    139,
    5,
    12,
    0,
    0,
    138,
    137,
    1,
    0,
    0,
    0,
    139,
    142,
    1,
    0,
    0,
    0,
    140,
    138,
    1,
    0,
    0,
    0,
    140,
    141,
    1,
    0,
    0,
    0,
    141,
    143,
    1,
    0,
    0,
    0,
    142,
    140,
    1,
    0,
    0,
    0,
    143,
    144,
    3,
    28,
    14,
    0,
    144,
    5,
    1,
    0,
    0,
    0,
    145,
    147,
    7,
    0,
    0,
    0,
    146,
    145,
    1,
    0,
    0,
    0,
    147,
    150,
    1,
    0,
    0,
    0,
    148,
    146,
    1,
    0,
    0,
    0,
    148,
    149,
    1,
    0,
    0,
    0,
    149,
    169,
    1,
    0,
    0,
    0,
    150,
    148,
    1,
    0,
    0,
    0,
    151,
    160,
    3,
    2,
    1,
    0,
    152,
    154,
    5,
    11,
    0,
    0,
    153,
    152,
    1,
    0,
    0,
    0,
    154,
    155,
    1,
    0,
    0,
    0,
    155,
    153,
    1,
    0,
    0,
    0,
    155,
    156,
    1,
    0,
    0,
    0,
    156,
    157,
    1,
    0,
    0,
    0,
    157,
    159,
    3,
    2,
    1,
    0,
    158,
    153,
    1,
    0,
    0,
    0,
    159,
    162,
    1,
    0,
    0,
    0,
    160,
    158,
    1,
    0,
    0,
    0,
    160,
    161,
    1,
    0,
    0,
    0,
    161,
    166,
    1,
    0,
    0,
    0,
    162,
    160,
    1,
    0,
    0,
    0,
    163,
    165,
    7,
    0,
    0,
    0,
    164,
    163,
    1,
    0,
    0,
    0,
    165,
    168,
    1,
    0,
    0,
    0,
    166,
    164,
    1,
    0,
    0,
    0,
    166,
    167,
    1,
    0,
    0,
    0,
    167,
    170,
    1,
    0,
    0,
    0,
    168,
    166,
    1,
    0,
    0,
    0,
    169,
    151,
    1,
    0,
    0,
    0,
    169,
    170,
    1,
    0,
    0,
    0,
    170,
    7,
    1,
    0,
    0,
    0,
    171,
    175,
    5,
    14,
    0,
    0,
    172,
    174,
    5,
    12,
    0,
    0,
    173,
    172,
    1,
    0,
    0,
    0,
    174,
    177,
    1,
    0,
    0,
    0,
    175,
    173,
    1,
    0,
    0,
    0,
    175,
    176,
    1,
    0,
    0,
    0,
    176,
    178,
    1,
    0,
    0,
    0,
    177,
    175,
    1,
    0,
    0,
    0,
    178,
    179,
    3,
    28,
    14,
    0,
    179,
    180,
    5,
    11,
    0,
    0,
    180,
    181,
    3,
    6,
    3,
    0,
    181,
    182,
    1,
    0,
    0,
    0,
    182,
    183,
    5,
    11,
    0,
    0,
    183,
    184,
    5,
    25,
    0,
    0,
    184,
    185,
    5,
    12,
    0,
    0,
    185,
    186,
    5,
    20,
    0,
    0,
    186,
    9,
    1,
    0,
    0,
    0,
    187,
    188,
    5,
    15,
    0,
    0,
    188,
    189,
    5,
    12,
    0,
    0,
    189,
    190,
    5,
    56,
    0,
    0,
    190,
    191,
    5,
    12,
    0,
    0,
    191,
    195,
    5,
    16,
    0,
    0,
    192,
    194,
    5,
    12,
    0,
    0,
    193,
    192,
    1,
    0,
    0,
    0,
    194,
    197,
    1,
    0,
    0,
    0,
    195,
    193,
    1,
    0,
    0,
    0,
    195,
    196,
    1,
    0,
    0,
    0,
    196,
    198,
    1,
    0,
    0,
    0,
    197,
    195,
    1,
    0,
    0,
    0,
    198,
    202,
    3,
    28,
    14,
    0,
    199,
    201,
    5,
    12,
    0,
    0,
    200,
    199,
    1,
    0,
    0,
    0,
    201,
    204,
    1,
    0,
    0,
    0,
    202,
    200,
    1,
    0,
    0,
    0,
    202,
    203,
    1,
    0,
    0,
    0,
    203,
    205,
    1,
    0,
    0,
    0,
    204,
    202,
    1,
    0,
    0,
    0,
    205,
    209,
    5,
    18,
    0,
    0,
    206,
    208,
    5,
    12,
    0,
    0,
    207,
    206,
    1,
    0,
    0,
    0,
    208,
    211,
    1,
    0,
    0,
    0,
    209,
    207,
    1,
    0,
    0,
    0,
    209,
    210,
    1,
    0,
    0,
    0,
    210,
    212,
    1,
    0,
    0,
    0,
    211,
    209,
    1,
    0,
    0,
    0,
    212,
    227,
    3,
    28,
    14,
    0,
    213,
    215,
    5,
    12,
    0,
    0,
    214,
    213,
    1,
    0,
    0,
    0,
    215,
    218,
    1,
    0,
    0,
    0,
    216,
    214,
    1,
    0,
    0,
    0,
    216,
    217,
    1,
    0,
    0,
    0,
    217,
    219,
    1,
    0,
    0,
    0,
    218,
    216,
    1,
    0,
    0,
    0,
    219,
    223,
    5,
    19,
    0,
    0,
    220,
    222,
    5,
    12,
    0,
    0,
    221,
    220,
    1,
    0,
    0,
    0,
    222,
    225,
    1,
    0,
    0,
    0,
    223,
    221,
    1,
    0,
    0,
    0,
    223,
    224,
    1,
    0,
    0,
    0,
    224,
    226,
    1,
    0,
    0,
    0,
    225,
    223,
    1,
    0,
    0,
    0,
    226,
    228,
    3,
    28,
    14,
    0,
    227,
    216,
    1,
    0,
    0,
    0,
    227,
    228,
    1,
    0,
    0,
    0,
    228,
    231,
    1,
    0,
    0,
    0,
    229,
    230,
    5,
    11,
    0,
    0,
    230,
    232,
    3,
    6,
    3,
    0,
    231,
    229,
    1,
    0,
    0,
    0,
    231,
    232,
    1,
    0,
    0,
    0,
    232,
    233,
    1,
    0,
    0,
    0,
    233,
    234,
    5,
    11,
    0,
    0,
    234,
    235,
    5,
    25,
    0,
    0,
    235,
    236,
    5,
    12,
    0,
    0,
    236,
    237,
    5,
    20,
    0,
    0,
    237,
    11,
    1,
    0,
    0,
    0,
    238,
    239,
    5,
    15,
    0,
    0,
    239,
    240,
    5,
    12,
    0,
    0,
    240,
    241,
    5,
    56,
    0,
    0,
    241,
    242,
    5,
    12,
    0,
    0,
    242,
    246,
    5,
    17,
    0,
    0,
    243,
    245,
    5,
    12,
    0,
    0,
    244,
    243,
    1,
    0,
    0,
    0,
    245,
    248,
    1,
    0,
    0,
    0,
    246,
    244,
    1,
    0,
    0,
    0,
    246,
    247,
    1,
    0,
    0,
    0,
    247,
    249,
    1,
    0,
    0,
    0,
    248,
    246,
    1,
    0,
    0,
    0,
    249,
    252,
    3,
    28,
    14,
    0,
    250,
    251,
    5,
    11,
    0,
    0,
    251,
    253,
    3,
    6,
    3,
    0,
    252,
    250,
    1,
    0,
    0,
    0,
    252,
    253,
    1,
    0,
    0,
    0,
    253,
    254,
    1,
    0,
    0,
    0,
    254,
    255,
    5,
    11,
    0,
    0,
    255,
    256,
    5,
    25,
    0,
    0,
    256,
    257,
    5,
    12,
    0,
    0,
    257,
    258,
    5,
    20,
    0,
    0,
    258,
    13,
    1,
    0,
    0,
    0,
    259,
    263,
    5,
    21,
    0,
    0,
    260,
    262,
    5,
    12,
    0,
    0,
    261,
    260,
    1,
    0,
    0,
    0,
    262,
    265,
    1,
    0,
    0,
    0,
    263,
    261,
    1,
    0,
    0,
    0,
    263,
    264,
    1,
    0,
    0,
    0,
    264,
    266,
    1,
    0,
    0,
    0,
    265,
    263,
    1,
    0,
    0,
    0,
    266,
    270,
    3,
    28,
    14,
    0,
    267,
    269,
    7,
    0,
    0,
    0,
    268,
    267,
    1,
    0,
    0,
    0,
    269,
    272,
    1,
    0,
    0,
    0,
    270,
    268,
    1,
    0,
    0,
    0,
    270,
    271,
    1,
    0,
    0,
    0,
    271,
    274,
    1,
    0,
    0,
    0,
    272,
    270,
    1,
    0,
    0,
    0,
    273,
    275,
    5,
    22,
    0,
    0,
    274,
    273,
    1,
    0,
    0,
    0,
    274,
    275,
    1,
    0,
    0,
    0,
    275,
    278,
    1,
    0,
    0,
    0,
    276,
    277,
    5,
    11,
    0,
    0,
    277,
    279,
    3,
    6,
    3,
    0,
    278,
    276,
    1,
    0,
    0,
    0,
    278,
    279,
    1,
    0,
    0,
    0,
    279,
    306,
    1,
    0,
    0,
    0,
    280,
    281,
    5,
    11,
    0,
    0,
    281,
    282,
    5,
    23,
    0,
    0,
    282,
    283,
    5,
    12,
    0,
    0,
    283,
    287,
    5,
    21,
    0,
    0,
    284,
    286,
    5,
    12,
    0,
    0,
    285,
    284,
    1,
    0,
    0,
    0,
    286,
    289,
    1,
    0,
    0,
    0,
    287,
    285,
    1,
    0,
    0,
    0,
    287,
    288,
    1,
    0,
    0,
    0,
    288,
    290,
    1,
    0,
    0,
    0,
    289,
    287,
    1,
    0,
    0,
    0,
    290,
    294,
    3,
    28,
    14,
    0,
    291,
    293,
    7,
    0,
    0,
    0,
    292,
    291,
    1,
    0,
    0,
    0,
    293,
    296,
    1,
    0,
    0,
    0,
    294,
    292,
    1,
    0,
    0,
    0,
    294,
    295,
    1,
    0,
    0,
    0,
    295,
    298,
    1,
    0,
    0,
    0,
    296,
    294,
    1,
    0,
    0,
    0,
    297,
    299,
    5,
    22,
    0,
    0,
    298,
    297,
    1,
    0,
    0,
    0,
    298,
    299,
    1,
    0,
    0,
    0,
    299,
    302,
    1,
    0,
    0,
    0,
    300,
    301,
    5,
    11,
    0,
    0,
    301,
    303,
    3,
    6,
    3,
    0,
    302,
    300,
    1,
    0,
    0,
    0,
    302,
    303,
    1,
    0,
    0,
    0,
    303,
    305,
    1,
    0,
    0,
    0,
    304,
    280,
    1,
    0,
    0,
    0,
    305,
    308,
    1,
    0,
    0,
    0,
    306,
    304,
    1,
    0,
    0,
    0,
    306,
    307,
    1,
    0,
    0,
    0,
    307,
    315,
    1,
    0,
    0,
    0,
    308,
    306,
    1,
    0,
    0,
    0,
    309,
    310,
    5,
    11,
    0,
    0,
    310,
    313,
    5,
    23,
    0,
    0,
    311,
    312,
    5,
    11,
    0,
    0,
    312,
    314,
    3,
    6,
    3,
    0,
    313,
    311,
    1,
    0,
    0,
    0,
    313,
    314,
    1,
    0,
    0,
    0,
    314,
    316,
    1,
    0,
    0,
    0,
    315,
    309,
    1,
    0,
    0,
    0,
    315,
    316,
    1,
    0,
    0,
    0,
    316,
    317,
    1,
    0,
    0,
    0,
    317,
    318,
    5,
    11,
    0,
    0,
    318,
    319,
    5,
    25,
    0,
    0,
    319,
    320,
    5,
    12,
    0,
    0,
    320,
    321,
    5,
    21,
    0,
    0,
    321,
    15,
    1,
    0,
    0,
    0,
    322,
    323,
    5,
    24,
    0,
    0,
    323,
    324,
    5,
    12,
    0,
    0,
    324,
    328,
    5,
    56,
    0,
    0,
    325,
    327,
    5,
    12,
    0,
    0,
    326,
    325,
    1,
    0,
    0,
    0,
    327,
    330,
    1,
    0,
    0,
    0,
    328,
    326,
    1,
    0,
    0,
    0,
    328,
    329,
    1,
    0,
    0,
    0,
    329,
    331,
    1,
    0,
    0,
    0,
    330,
    328,
    1,
    0,
    0,
    0,
    331,
    407,
    5,
    1,
    0,
    0,
    332,
    334,
    5,
    12,
    0,
    0,
    333,
    332,
    1,
    0,
    0,
    0,
    334,
    337,
    1,
    0,
    0,
    0,
    335,
    333,
    1,
    0,
    0,
    0,
    335,
    336,
    1,
    0,
    0,
    0,
    336,
    338,
    1,
    0,
    0,
    0,
    337,
    335,
    1,
    0,
    0,
    0,
    338,
    372,
    5,
    56,
    0,
    0,
    339,
    341,
    5,
    12,
    0,
    0,
    340,
    339,
    1,
    0,
    0,
    0,
    341,
    344,
    1,
    0,
    0,
    0,
    342,
    340,
    1,
    0,
    0,
    0,
    342,
    343,
    1,
    0,
    0,
    0,
    343,
    345,
    1,
    0,
    0,
    0,
    344,
    342,
    1,
    0,
    0,
    0,
    345,
    349,
    5,
    34,
    0,
    0,
    346,
    348,
    5,
    12,
    0,
    0,
    347,
    346,
    1,
    0,
    0,
    0,
    348,
    351,
    1,
    0,
    0,
    0,
    349,
    347,
    1,
    0,
    0,
    0,
    349,
    350,
    1,
    0,
    0,
    0,
    350,
    352,
    1,
    0,
    0,
    0,
    351,
    349,
    1,
    0,
    0,
    0,
    352,
    373,
    3,
    68,
    34,
    0,
    353,
    355,
    5,
    12,
    0,
    0,
    354,
    353,
    1,
    0,
    0,
    0,
    355,
    358,
    1,
    0,
    0,
    0,
    356,
    354,
    1,
    0,
    0,
    0,
    356,
    357,
    1,
    0,
    0,
    0,
    357,
    359,
    1,
    0,
    0,
    0,
    358,
    356,
    1,
    0,
    0,
    0,
    359,
    363,
    5,
    2,
    0,
    0,
    360,
    362,
    5,
    12,
    0,
    0,
    361,
    360,
    1,
    0,
    0,
    0,
    362,
    365,
    1,
    0,
    0,
    0,
    363,
    361,
    1,
    0,
    0,
    0,
    363,
    364,
    1,
    0,
    0,
    0,
    364,
    366,
    1,
    0,
    0,
    0,
    365,
    363,
    1,
    0,
    0,
    0,
    366,
    368,
    5,
    56,
    0,
    0,
    367,
    356,
    1,
    0,
    0,
    0,
    368,
    371,
    1,
    0,
    0,
    0,
    369,
    367,
    1,
    0,
    0,
    0,
    369,
    370,
    1,
    0,
    0,
    0,
    370,
    373,
    1,
    0,
    0,
    0,
    371,
    369,
    1,
    0,
    0,
    0,
    372,
    342,
    1,
    0,
    0,
    0,
    372,
    369,
    1,
    0,
    0,
    0,
    373,
    404,
    1,
    0,
    0,
    0,
    374,
    376,
    5,
    12,
    0,
    0,
    375,
    374,
    1,
    0,
    0,
    0,
    376,
    379,
    1,
    0,
    0,
    0,
    377,
    375,
    1,
    0,
    0,
    0,
    377,
    378,
    1,
    0,
    0,
    0,
    378,
    380,
    1,
    0,
    0,
    0,
    379,
    377,
    1,
    0,
    0,
    0,
    380,
    384,
    5,
    2,
    0,
    0,
    381,
    383,
    5,
    12,
    0,
    0,
    382,
    381,
    1,
    0,
    0,
    0,
    383,
    386,
    1,
    0,
    0,
    0,
    384,
    382,
    1,
    0,
    0,
    0,
    384,
    385,
    1,
    0,
    0,
    0,
    385,
    387,
    1,
    0,
    0,
    0,
    386,
    384,
    1,
    0,
    0,
    0,
    387,
    391,
    5,
    56,
    0,
    0,
    388,
    390,
    5,
    12,
    0,
    0,
    389,
    388,
    1,
    0,
    0,
    0,
    390,
    393,
    1,
    0,
    0,
    0,
    391,
    389,
    1,
    0,
    0,
    0,
    391,
    392,
    1,
    0,
    0,
    0,
    392,
    394,
    1,
    0,
    0,
    0,
    393,
    391,
    1,
    0,
    0,
    0,
    394,
    398,
    5,
    34,
    0,
    0,
    395,
    397,
    5,
    12,
    0,
    0,
    396,
    395,
    1,
    0,
    0,
    0,
    397,
    400,
    1,
    0,
    0,
    0,
    398,
    396,
    1,
    0,
    0,
    0,
    398,
    399,
    1,
    0,
    0,
    0,
    399,
    401,
    1,
    0,
    0,
    0,
    400,
    398,
    1,
    0,
    0,
    0,
    401,
    403,
    3,
    68,
    34,
    0,
    402,
    377,
    1,
    0,
    0,
    0,
    403,
    406,
    1,
    0,
    0,
    0,
    404,
    402,
    1,
    0,
    0,
    0,
    404,
    405,
    1,
    0,
    0,
    0,
    405,
    408,
    1,
    0,
    0,
    0,
    406,
    404,
    1,
    0,
    0,
    0,
    407,
    335,
    1,
    0,
    0,
    0,
    407,
    408,
    1,
    0,
    0,
    0,
    408,
    412,
    1,
    0,
    0,
    0,
    409,
    411,
    5,
    12,
    0,
    0,
    410,
    409,
    1,
    0,
    0,
    0,
    411,
    414,
    1,
    0,
    0,
    0,
    412,
    410,
    1,
    0,
    0,
    0,
    412,
    413,
    1,
    0,
    0,
    0,
    413,
    415,
    1,
    0,
    0,
    0,
    414,
    412,
    1,
    0,
    0,
    0,
    415,
    418,
    5,
    3,
    0,
    0,
    416,
    417,
    5,
    11,
    0,
    0,
    417,
    419,
    3,
    6,
    3,
    0,
    418,
    416,
    1,
    0,
    0,
    0,
    418,
    419,
    1,
    0,
    0,
    0,
    419,
    420,
    1,
    0,
    0,
    0,
    420,
    421,
    5,
    11,
    0,
    0,
    421,
    422,
    5,
    25,
    0,
    0,
    422,
    423,
    5,
    12,
    0,
    0,
    423,
    424,
    5,
    24,
    0,
    0,
    424,
    17,
    1,
    0,
    0,
    0,
    425,
    428,
    5,
    28,
    0,
    0,
    426,
    427,
    5,
    11,
    0,
    0,
    427,
    429,
    3,
    6,
    3,
    0,
    428,
    426,
    1,
    0,
    0,
    0,
    428,
    429,
    1,
    0,
    0,
    0,
    429,
    430,
    1,
    0,
    0,
    0,
    430,
    431,
    5,
    11,
    0,
    0,
    431,
    432,
    5,
    29,
    0,
    0,
    432,
    433,
    5,
    12,
    0,
    0,
    433,
    436,
    5,
    56,
    0,
    0,
    434,
    435,
    5,
    11,
    0,
    0,
    435,
    437,
    3,
    6,
    3,
    0,
    436,
    434,
    1,
    0,
    0,
    0,
    436,
    437,
    1,
    0,
    0,
    0,
    437,
    438,
    1,
    0,
    0,
    0,
    438,
    439,
    5,
    11,
    0,
    0,
    439,
    440,
    5,
    25,
    0,
    0,
    440,
    441,
    5,
    12,
    0,
    0,
    441,
    442,
    5,
    28,
    0,
    0,
    442,
    19,
    1,
    0,
    0,
    0,
    443,
    444,
    5,
    30,
    0,
    0,
    444,
    445,
    5,
    12,
    0,
    0,
    445,
    446,
    3,
    58,
    29,
    0,
    446,
    21,
    1,
    0,
    0,
    0,
    447,
    451,
    5,
    24,
    0,
    0,
    448,
    450,
    5,
    12,
    0,
    0,
    449,
    448,
    1,
    0,
    0,
    0,
    450,
    453,
    1,
    0,
    0,
    0,
    451,
    449,
    1,
    0,
    0,
    0,
    451,
    452,
    1,
    0,
    0,
    0,
    452,
    454,
    1,
    0,
    0,
    0,
    453,
    451,
    1,
    0,
    0,
    0,
    454,
    530,
    5,
    1,
    0,
    0,
    455,
    457,
    5,
    12,
    0,
    0,
    456,
    455,
    1,
    0,
    0,
    0,
    457,
    460,
    1,
    0,
    0,
    0,
    458,
    456,
    1,
    0,
    0,
    0,
    458,
    459,
    1,
    0,
    0,
    0,
    459,
    461,
    1,
    0,
    0,
    0,
    460,
    458,
    1,
    0,
    0,
    0,
    461,
    495,
    5,
    56,
    0,
    0,
    462,
    464,
    5,
    12,
    0,
    0,
    463,
    462,
    1,
    0,
    0,
    0,
    464,
    467,
    1,
    0,
    0,
    0,
    465,
    463,
    1,
    0,
    0,
    0,
    465,
    466,
    1,
    0,
    0,
    0,
    466,
    468,
    1,
    0,
    0,
    0,
    467,
    465,
    1,
    0,
    0,
    0,
    468,
    472,
    5,
    34,
    0,
    0,
    469,
    471,
    5,
    12,
    0,
    0,
    470,
    469,
    1,
    0,
    0,
    0,
    471,
    474,
    1,
    0,
    0,
    0,
    472,
    470,
    1,
    0,
    0,
    0,
    472,
    473,
    1,
    0,
    0,
    0,
    473,
    475,
    1,
    0,
    0,
    0,
    474,
    472,
    1,
    0,
    0,
    0,
    475,
    496,
    3,
    68,
    34,
    0,
    476,
    478,
    5,
    12,
    0,
    0,
    477,
    476,
    1,
    0,
    0,
    0,
    478,
    481,
    1,
    0,
    0,
    0,
    479,
    477,
    1,
    0,
    0,
    0,
    479,
    480,
    1,
    0,
    0,
    0,
    480,
    482,
    1,
    0,
    0,
    0,
    481,
    479,
    1,
    0,
    0,
    0,
    482,
    486,
    5,
    2,
    0,
    0,
    483,
    485,
    5,
    12,
    0,
    0,
    484,
    483,
    1,
    0,
    0,
    0,
    485,
    488,
    1,
    0,
    0,
    0,
    486,
    484,
    1,
    0,
    0,
    0,
    486,
    487,
    1,
    0,
    0,
    0,
    487,
    489,
    1,
    0,
    0,
    0,
    488,
    486,
    1,
    0,
    0,
    0,
    489,
    491,
    5,
    56,
    0,
    0,
    490,
    479,
    1,
    0,
    0,
    0,
    491,
    494,
    1,
    0,
    0,
    0,
    492,
    490,
    1,
    0,
    0,
    0,
    492,
    493,
    1,
    0,
    0,
    0,
    493,
    496,
    1,
    0,
    0,
    0,
    494,
    492,
    1,
    0,
    0,
    0,
    495,
    465,
    1,
    0,
    0,
    0,
    495,
    492,
    1,
    0,
    0,
    0,
    496,
    527,
    1,
    0,
    0,
    0,
    497,
    499,
    5,
    12,
    0,
    0,
    498,
    497,
    1,
    0,
    0,
    0,
    499,
    502,
    1,
    0,
    0,
    0,
    500,
    498,
    1,
    0,
    0,
    0,
    500,
    501,
    1,
    0,
    0,
    0,
    501,
    503,
    1,
    0,
    0,
    0,
    502,
    500,
    1,
    0,
    0,
    0,
    503,
    507,
    5,
    2,
    0,
    0,
    504,
    506,
    5,
    12,
    0,
    0,
    505,
    504,
    1,
    0,
    0,
    0,
    506,
    509,
    1,
    0,
    0,
    0,
    507,
    505,
    1,
    0,
    0,
    0,
    507,
    508,
    1,
    0,
    0,
    0,
    508,
    510,
    1,
    0,
    0,
    0,
    509,
    507,
    1,
    0,
    0,
    0,
    510,
    514,
    5,
    56,
    0,
    0,
    511,
    513,
    5,
    12,
    0,
    0,
    512,
    511,
    1,
    0,
    0,
    0,
    513,
    516,
    1,
    0,
    0,
    0,
    514,
    512,
    1,
    0,
    0,
    0,
    514,
    515,
    1,
    0,
    0,
    0,
    515,
    517,
    1,
    0,
    0,
    0,
    516,
    514,
    1,
    0,
    0,
    0,
    517,
    521,
    5,
    34,
    0,
    0,
    518,
    520,
    5,
    12,
    0,
    0,
    519,
    518,
    1,
    0,
    0,
    0,
    520,
    523,
    1,
    0,
    0,
    0,
    521,
    519,
    1,
    0,
    0,
    0,
    521,
    522,
    1,
    0,
    0,
    0,
    522,
    524,
    1,
    0,
    0,
    0,
    523,
    521,
    1,
    0,
    0,
    0,
    524,
    526,
    3,
    68,
    34,
    0,
    525,
    500,
    1,
    0,
    0,
    0,
    526,
    529,
    1,
    0,
    0,
    0,
    527,
    525,
    1,
    0,
    0,
    0,
    527,
    528,
    1,
    0,
    0,
    0,
    528,
    531,
    1,
    0,
    0,
    0,
    529,
    527,
    1,
    0,
    0,
    0,
    530,
    458,
    1,
    0,
    0,
    0,
    530,
    531,
    1,
    0,
    0,
    0,
    531,
    535,
    1,
    0,
    0,
    0,
    532,
    534,
    5,
    12,
    0,
    0,
    533,
    532,
    1,
    0,
    0,
    0,
    534,
    537,
    1,
    0,
    0,
    0,
    535,
    533,
    1,
    0,
    0,
    0,
    535,
    536,
    1,
    0,
    0,
    0,
    536,
    538,
    1,
    0,
    0,
    0,
    537,
    535,
    1,
    0,
    0,
    0,
    538,
    554,
    5,
    3,
    0,
    0,
    539,
    540,
    5,
    11,
    0,
    0,
    540,
    542,
    3,
    6,
    3,
    0,
    541,
    539,
    1,
    0,
    0,
    0,
    541,
    542,
    1,
    0,
    0,
    0,
    542,
    543,
    1,
    0,
    0,
    0,
    543,
    544,
    5,
    11,
    0,
    0,
    544,
    545,
    5,
    25,
    0,
    0,
    545,
    546,
    5,
    12,
    0,
    0,
    546,
    555,
    5,
    24,
    0,
    0,
    547,
    549,
    5,
    12,
    0,
    0,
    548,
    547,
    1,
    0,
    0,
    0,
    549,
    552,
    1,
    0,
    0,
    0,
    550,
    548,
    1,
    0,
    0,
    0,
    550,
    551,
    1,
    0,
    0,
    0,
    551,
    553,
    1,
    0,
    0,
    0,
    552,
    550,
    1,
    0,
    0,
    0,
    553,
    555,
    3,
    2,
    1,
    0,
    554,
    541,
    1,
    0,
    0,
    0,
    554,
    550,
    1,
    0,
    0,
    0,
    555,
    23,
    1,
    0,
    0,
    0,
    556,
    560,
    5,
    56,
    0,
    0,
    557,
    559,
    5,
    12,
    0,
    0,
    558,
    557,
    1,
    0,
    0,
    0,
    559,
    562,
    1,
    0,
    0,
    0,
    560,
    558,
    1,
    0,
    0,
    0,
    560,
    561,
    1,
    0,
    0,
    0,
    561,
    563,
    1,
    0,
    0,
    0,
    562,
    560,
    1,
    0,
    0,
    0,
    563,
    633,
    5,
    1,
    0,
    0,
    564,
    566,
    5,
    12,
    0,
    0,
    565,
    564,
    1,
    0,
    0,
    0,
    566,
    569,
    1,
    0,
    0,
    0,
    567,
    565,
    1,
    0,
    0,
    0,
    567,
    568,
    1,
    0,
    0,
    0,
    568,
    570,
    1,
    0,
    0,
    0,
    569,
    567,
    1,
    0,
    0,
    0,
    570,
    604,
    5,
    56,
    0,
    0,
    571,
    573,
    5,
    12,
    0,
    0,
    572,
    571,
    1,
    0,
    0,
    0,
    573,
    576,
    1,
    0,
    0,
    0,
    574,
    572,
    1,
    0,
    0,
    0,
    574,
    575,
    1,
    0,
    0,
    0,
    575,
    577,
    1,
    0,
    0,
    0,
    576,
    574,
    1,
    0,
    0,
    0,
    577,
    581,
    5,
    34,
    0,
    0,
    578,
    580,
    5,
    12,
    0,
    0,
    579,
    578,
    1,
    0,
    0,
    0,
    580,
    583,
    1,
    0,
    0,
    0,
    581,
    579,
    1,
    0,
    0,
    0,
    581,
    582,
    1,
    0,
    0,
    0,
    582,
    584,
    1,
    0,
    0,
    0,
    583,
    581,
    1,
    0,
    0,
    0,
    584,
    605,
    3,
    68,
    34,
    0,
    585,
    587,
    5,
    12,
    0,
    0,
    586,
    585,
    1,
    0,
    0,
    0,
    587,
    590,
    1,
    0,
    0,
    0,
    588,
    586,
    1,
    0,
    0,
    0,
    588,
    589,
    1,
    0,
    0,
    0,
    589,
    591,
    1,
    0,
    0,
    0,
    590,
    588,
    1,
    0,
    0,
    0,
    591,
    595,
    5,
    2,
    0,
    0,
    592,
    594,
    5,
    12,
    0,
    0,
    593,
    592,
    1,
    0,
    0,
    0,
    594,
    597,
    1,
    0,
    0,
    0,
    595,
    593,
    1,
    0,
    0,
    0,
    595,
    596,
    1,
    0,
    0,
    0,
    596,
    598,
    1,
    0,
    0,
    0,
    597,
    595,
    1,
    0,
    0,
    0,
    598,
    600,
    5,
    56,
    0,
    0,
    599,
    588,
    1,
    0,
    0,
    0,
    600,
    603,
    1,
    0,
    0,
    0,
    601,
    599,
    1,
    0,
    0,
    0,
    601,
    602,
    1,
    0,
    0,
    0,
    602,
    605,
    1,
    0,
    0,
    0,
    603,
    601,
    1,
    0,
    0,
    0,
    604,
    574,
    1,
    0,
    0,
    0,
    604,
    601,
    1,
    0,
    0,
    0,
    605,
    630,
    1,
    0,
    0,
    0,
    606,
    610,
    5,
    2,
    0,
    0,
    607,
    609,
    5,
    12,
    0,
    0,
    608,
    607,
    1,
    0,
    0,
    0,
    609,
    612,
    1,
    0,
    0,
    0,
    610,
    608,
    1,
    0,
    0,
    0,
    610,
    611,
    1,
    0,
    0,
    0,
    611,
    613,
    1,
    0,
    0,
    0,
    612,
    610,
    1,
    0,
    0,
    0,
    613,
    617,
    5,
    56,
    0,
    0,
    614,
    616,
    5,
    12,
    0,
    0,
    615,
    614,
    1,
    0,
    0,
    0,
    616,
    619,
    1,
    0,
    0,
    0,
    617,
    615,
    1,
    0,
    0,
    0,
    617,
    618,
    1,
    0,
    0,
    0,
    618,
    620,
    1,
    0,
    0,
    0,
    619,
    617,
    1,
    0,
    0,
    0,
    620,
    624,
    5,
    34,
    0,
    0,
    621,
    623,
    5,
    12,
    0,
    0,
    622,
    621,
    1,
    0,
    0,
    0,
    623,
    626,
    1,
    0,
    0,
    0,
    624,
    622,
    1,
    0,
    0,
    0,
    624,
    625,
    1,
    0,
    0,
    0,
    625,
    627,
    1,
    0,
    0,
    0,
    626,
    624,
    1,
    0,
    0,
    0,
    627,
    629,
    3,
    68,
    34,
    0,
    628,
    606,
    1,
    0,
    0,
    0,
    629,
    632,
    1,
    0,
    0,
    0,
    630,
    628,
    1,
    0,
    0,
    0,
    630,
    631,
    1,
    0,
    0,
    0,
    631,
    634,
    1,
    0,
    0,
    0,
    632,
    630,
    1,
    0,
    0,
    0,
    633,
    567,
    1,
    0,
    0,
    0,
    633,
    634,
    1,
    0,
    0,
    0,
    634,
    638,
    1,
    0,
    0,
    0,
    635,
    637,
    5,
    12,
    0,
    0,
    636,
    635,
    1,
    0,
    0,
    0,
    637,
    640,
    1,
    0,
    0,
    0,
    638,
    636,
    1,
    0,
    0,
    0,
    638,
    639,
    1,
    0,
    0,
    0,
    639,
    641,
    1,
    0,
    0,
    0,
    640,
    638,
    1,
    0,
    0,
    0,
    641,
    645,
    5,
    3,
    0,
    0,
    642,
    644,
    5,
    12,
    0,
    0,
    643,
    642,
    1,
    0,
    0,
    0,
    644,
    647,
    1,
    0,
    0,
    0,
    645,
    643,
    1,
    0,
    0,
    0,
    645,
    646,
    1,
    0,
    0,
    0,
    646,
    648,
    1,
    0,
    0,
    0,
    647,
    645,
    1,
    0,
    0,
    0,
    648,
    652,
    5,
    4,
    0,
    0,
    649,
    651,
    5,
    12,
    0,
    0,
    650,
    649,
    1,
    0,
    0,
    0,
    651,
    654,
    1,
    0,
    0,
    0,
    652,
    650,
    1,
    0,
    0,
    0,
    652,
    653,
    1,
    0,
    0,
    0,
    653,
    655,
    1,
    0,
    0,
    0,
    654,
    652,
    1,
    0,
    0,
    0,
    655,
    697,
    3,
    28,
    14,
    0,
    656,
    659,
    5,
    57,
    0,
    0,
    657,
    659,
    3,
    26,
    13,
    0,
    658,
    656,
    1,
    0,
    0,
    0,
    658,
    657,
    1,
    0,
    0,
    0,
    659,
    679,
    1,
    0,
    0,
    0,
    660,
    662,
    5,
    12,
    0,
    0,
    661,
    660,
    1,
    0,
    0,
    0,
    662,
    665,
    1,
    0,
    0,
    0,
    663,
    661,
    1,
    0,
    0,
    0,
    663,
    664,
    1,
    0,
    0,
    0,
    664,
    666,
    1,
    0,
    0,
    0,
    665,
    663,
    1,
    0,
    0,
    0,
    666,
    670,
    5,
    2,
    0,
    0,
    667,
    669,
    5,
    12,
    0,
    0,
    668,
    667,
    1,
    0,
    0,
    0,
    669,
    672,
    1,
    0,
    0,
    0,
    670,
    668,
    1,
    0,
    0,
    0,
    670,
    671,
    1,
    0,
    0,
    0,
    671,
    675,
    1,
    0,
    0,
    0,
    672,
    670,
    1,
    0,
    0,
    0,
    673,
    676,
    5,
    57,
    0,
    0,
    674,
    676,
    3,
    26,
    13,
    0,
    675,
    673,
    1,
    0,
    0,
    0,
    675,
    674,
    1,
    0,
    0,
    0,
    676,
    678,
    1,
    0,
    0,
    0,
    677,
    663,
    1,
    0,
    0,
    0,
    678,
    681,
    1,
    0,
    0,
    0,
    679,
    677,
    1,
    0,
    0,
    0,
    679,
    680,
    1,
    0,
    0,
    0,
    680,
    685,
    1,
    0,
    0,
    0,
    681,
    679,
    1,
    0,
    0,
    0,
    682,
    684,
    5,
    12,
    0,
    0,
    683,
    682,
    1,
    0,
    0,
    0,
    684,
    687,
    1,
    0,
    0,
    0,
    685,
    683,
    1,
    0,
    0,
    0,
    685,
    686,
    1,
    0,
    0,
    0,
    686,
    688,
    1,
    0,
    0,
    0,
    687,
    685,
    1,
    0,
    0,
    0,
    688,
    692,
    5,
    4,
    0,
    0,
    689,
    691,
    5,
    12,
    0,
    0,
    690,
    689,
    1,
    0,
    0,
    0,
    691,
    694,
    1,
    0,
    0,
    0,
    692,
    690,
    1,
    0,
    0,
    0,
    692,
    693,
    1,
    0,
    0,
    0,
    693,
    695,
    1,
    0,
    0,
    0,
    694,
    692,
    1,
    0,
    0,
    0,
    695,
    697,
    3,
    28,
    14,
    0,
    696,
    556,
    1,
    0,
    0,
    0,
    696,
    658,
    1,
    0,
    0,
    0,
    697,
    25,
    1,
    0,
    0,
    0,
    698,
    700,
    5,
    56,
    0,
    0,
    699,
    701,
    3,
    70,
    35,
    0,
    700,
    699,
    1,
    0,
    0,
    0,
    700,
    701,
    1,
    0,
    0,
    0,
    701,
    27,
    1,
    0,
    0,
    0,
    702,
    719,
    3,
    30,
    15,
    0,
    703,
    705,
    5,
    12,
    0,
    0,
    704,
    703,
    1,
    0,
    0,
    0,
    705,
    708,
    1,
    0,
    0,
    0,
    706,
    704,
    1,
    0,
    0,
    0,
    706,
    707,
    1,
    0,
    0,
    0,
    707,
    709,
    1,
    0,
    0,
    0,
    708,
    706,
    1,
    0,
    0,
    0,
    709,
    713,
    5,
    31,
    0,
    0,
    710,
    712,
    5,
    12,
    0,
    0,
    711,
    710,
    1,
    0,
    0,
    0,
    712,
    715,
    1,
    0,
    0,
    0,
    713,
    711,
    1,
    0,
    0,
    0,
    713,
    714,
    1,
    0,
    0,
    0,
    714,
    716,
    1,
    0,
    0,
    0,
    715,
    713,
    1,
    0,
    0,
    0,
    716,
    718,
    3,
    30,
    15,
    0,
    717,
    706,
    1,
    0,
    0,
    0,
    718,
    721,
    1,
    0,
    0,
    0,
    719,
    717,
    1,
    0,
    0,
    0,
    719,
    720,
    1,
    0,
    0,
    0,
    720,
    29,
    1,
    0,
    0,
    0,
    721,
    719,
    1,
    0,
    0,
    0,
    722,
    739,
    3,
    32,
    16,
    0,
    723,
    725,
    5,
    12,
    0,
    0,
    724,
    723,
    1,
    0,
    0,
    0,
    725,
    728,
    1,
    0,
    0,
    0,
    726,
    724,
    1,
    0,
    0,
    0,
    726,
    727,
    1,
    0,
    0,
    0,
    727,
    729,
    1,
    0,
    0,
    0,
    728,
    726,
    1,
    0,
    0,
    0,
    729,
    733,
    5,
    32,
    0,
    0,
    730,
    732,
    5,
    12,
    0,
    0,
    731,
    730,
    1,
    0,
    0,
    0,
    732,
    735,
    1,
    0,
    0,
    0,
    733,
    731,
    1,
    0,
    0,
    0,
    733,
    734,
    1,
    0,
    0,
    0,
    734,
    736,
    1,
    0,
    0,
    0,
    735,
    733,
    1,
    0,
    0,
    0,
    736,
    738,
    3,
    32,
    16,
    0,
    737,
    726,
    1,
    0,
    0,
    0,
    738,
    741,
    1,
    0,
    0,
    0,
    739,
    737,
    1,
    0,
    0,
    0,
    739,
    740,
    1,
    0,
    0,
    0,
    740,
    31,
    1,
    0,
    0,
    0,
    741,
    739,
    1,
    0,
    0,
    0,
    742,
    759,
    3,
    34,
    17,
    0,
    743,
    745,
    5,
    12,
    0,
    0,
    744,
    743,
    1,
    0,
    0,
    0,
    745,
    748,
    1,
    0,
    0,
    0,
    746,
    744,
    1,
    0,
    0,
    0,
    746,
    747,
    1,
    0,
    0,
    0,
    747,
    749,
    1,
    0,
    0,
    0,
    748,
    746,
    1,
    0,
    0,
    0,
    749,
    753,
    5,
    33,
    0,
    0,
    750,
    752,
    5,
    12,
    0,
    0,
    751,
    750,
    1,
    0,
    0,
    0,
    752,
    755,
    1,
    0,
    0,
    0,
    753,
    751,
    1,
    0,
    0,
    0,
    753,
    754,
    1,
    0,
    0,
    0,
    754,
    756,
    1,
    0,
    0,
    0,
    755,
    753,
    1,
    0,
    0,
    0,
    756,
    758,
    3,
    34,
    17,
    0,
    757,
    746,
    1,
    0,
    0,
    0,
    758,
    761,
    1,
    0,
    0,
    0,
    759,
    757,
    1,
    0,
    0,
    0,
    759,
    760,
    1,
    0,
    0,
    0,
    760,
    33,
    1,
    0,
    0,
    0,
    761,
    759,
    1,
    0,
    0,
    0,
    762,
    779,
    3,
    36,
    18,
    0,
    763,
    765,
    5,
    12,
    0,
    0,
    764,
    763,
    1,
    0,
    0,
    0,
    765,
    768,
    1,
    0,
    0,
    0,
    766,
    764,
    1,
    0,
    0,
    0,
    766,
    767,
    1,
    0,
    0,
    0,
    767,
    769,
    1,
    0,
    0,
    0,
    768,
    766,
    1,
    0,
    0,
    0,
    769,
    773,
    7,
    1,
    0,
    0,
    770,
    772,
    5,
    12,
    0,
    0,
    771,
    770,
    1,
    0,
    0,
    0,
    772,
    775,
    1,
    0,
    0,
    0,
    773,
    771,
    1,
    0,
    0,
    0,
    773,
    774,
    1,
    0,
    0,
    0,
    774,
    776,
    1,
    0,
    0,
    0,
    775,
    773,
    1,
    0,
    0,
    0,
    776,
    778,
    3,
    36,
    18,
    0,
    777,
    766,
    1,
    0,
    0,
    0,
    778,
    781,
    1,
    0,
    0,
    0,
    779,
    777,
    1,
    0,
    0,
    0,
    779,
    780,
    1,
    0,
    0,
    0,
    780,
    35,
    1,
    0,
    0,
    0,
    781,
    779,
    1,
    0,
    0,
    0,
    782,
    799,
    3,
    38,
    19,
    0,
    783,
    785,
    5,
    12,
    0,
    0,
    784,
    783,
    1,
    0,
    0,
    0,
    785,
    788,
    1,
    0,
    0,
    0,
    786,
    784,
    1,
    0,
    0,
    0,
    786,
    787,
    1,
    0,
    0,
    0,
    787,
    789,
    1,
    0,
    0,
    0,
    788,
    786,
    1,
    0,
    0,
    0,
    789,
    793,
    7,
    2,
    0,
    0,
    790,
    792,
    5,
    12,
    0,
    0,
    791,
    790,
    1,
    0,
    0,
    0,
    792,
    795,
    1,
    0,
    0,
    0,
    793,
    791,
    1,
    0,
    0,
    0,
    793,
    794,
    1,
    0,
    0,
    0,
    794,
    796,
    1,
    0,
    0,
    0,
    795,
    793,
    1,
    0,
    0,
    0,
    796,
    798,
    3,
    38,
    19,
    0,
    797,
    786,
    1,
    0,
    0,
    0,
    798,
    801,
    1,
    0,
    0,
    0,
    799,
    797,
    1,
    0,
    0,
    0,
    799,
    800,
    1,
    0,
    0,
    0,
    800,
    37,
    1,
    0,
    0,
    0,
    801,
    799,
    1,
    0,
    0,
    0,
    802,
    819,
    3,
    40,
    20,
    0,
    803,
    805,
    5,
    12,
    0,
    0,
    804,
    803,
    1,
    0,
    0,
    0,
    805,
    808,
    1,
    0,
    0,
    0,
    806,
    804,
    1,
    0,
    0,
    0,
    806,
    807,
    1,
    0,
    0,
    0,
    807,
    809,
    1,
    0,
    0,
    0,
    808,
    806,
    1,
    0,
    0,
    0,
    809,
    813,
    7,
    3,
    0,
    0,
    810,
    812,
    5,
    12,
    0,
    0,
    811,
    810,
    1,
    0,
    0,
    0,
    812,
    815,
    1,
    0,
    0,
    0,
    813,
    811,
    1,
    0,
    0,
    0,
    813,
    814,
    1,
    0,
    0,
    0,
    814,
    816,
    1,
    0,
    0,
    0,
    815,
    813,
    1,
    0,
    0,
    0,
    816,
    818,
    3,
    40,
    20,
    0,
    817,
    806,
    1,
    0,
    0,
    0,
    818,
    821,
    1,
    0,
    0,
    0,
    819,
    817,
    1,
    0,
    0,
    0,
    819,
    820,
    1,
    0,
    0,
    0,
    820,
    39,
    1,
    0,
    0,
    0,
    821,
    819,
    1,
    0,
    0,
    0,
    822,
    839,
    3,
    42,
    21,
    0,
    823,
    825,
    5,
    12,
    0,
    0,
    824,
    823,
    1,
    0,
    0,
    0,
    825,
    828,
    1,
    0,
    0,
    0,
    826,
    824,
    1,
    0,
    0,
    0,
    826,
    827,
    1,
    0,
    0,
    0,
    827,
    829,
    1,
    0,
    0,
    0,
    828,
    826,
    1,
    0,
    0,
    0,
    829,
    833,
    7,
    4,
    0,
    0,
    830,
    832,
    5,
    12,
    0,
    0,
    831,
    830,
    1,
    0,
    0,
    0,
    832,
    835,
    1,
    0,
    0,
    0,
    833,
    831,
    1,
    0,
    0,
    0,
    833,
    834,
    1,
    0,
    0,
    0,
    834,
    836,
    1,
    0,
    0,
    0,
    835,
    833,
    1,
    0,
    0,
    0,
    836,
    838,
    3,
    42,
    21,
    0,
    837,
    826,
    1,
    0,
    0,
    0,
    838,
    841,
    1,
    0,
    0,
    0,
    839,
    837,
    1,
    0,
    0,
    0,
    839,
    840,
    1,
    0,
    0,
    0,
    840,
    41,
    1,
    0,
    0,
    0,
    841,
    839,
    1,
    0,
    0,
    0,
    842,
    845,
    3,
    44,
    22,
    0,
    843,
    844,
    5,
    5,
    0,
    0,
    844,
    846,
    3,
    44,
    22,
    0,
    845,
    843,
    1,
    0,
    0,
    0,
    845,
    846,
    1,
    0,
    0,
    0,
    846,
    849,
    1,
    0,
    0,
    0,
    847,
    848,
    5,
    5,
    0,
    0,
    848,
    850,
    3,
    44,
    22,
    0,
    849,
    847,
    1,
    0,
    0,
    0,
    849,
    850,
    1,
    0,
    0,
    0,
    850,
    43,
    1,
    0,
    0,
    0,
    851,
    855,
    5,
    41,
    0,
    0,
    852,
    854,
    5,
    12,
    0,
    0,
    853,
    852,
    1,
    0,
    0,
    0,
    854,
    857,
    1,
    0,
    0,
    0,
    855,
    853,
    1,
    0,
    0,
    0,
    855,
    856,
    1,
    0,
    0,
    0,
    856,
    858,
    1,
    0,
    0,
    0,
    857,
    855,
    1,
    0,
    0,
    0,
    858,
    861,
    3,
    46,
    23,
    0,
    859,
    861,
    3,
    46,
    23,
    0,
    860,
    851,
    1,
    0,
    0,
    0,
    860,
    859,
    1,
    0,
    0,
    0,
    861,
    45,
    1,
    0,
    0,
    0,
    862,
    879,
    3,
    50,
    25,
    0,
    863,
    865,
    5,
    12,
    0,
    0,
    864,
    863,
    1,
    0,
    0,
    0,
    865,
    868,
    1,
    0,
    0,
    0,
    866,
    864,
    1,
    0,
    0,
    0,
    866,
    867,
    1,
    0,
    0,
    0,
    867,
    869,
    1,
    0,
    0,
    0,
    868,
    866,
    1,
    0,
    0,
    0,
    869,
    873,
    5,
    45,
    0,
    0,
    870,
    872,
    5,
    12,
    0,
    0,
    871,
    870,
    1,
    0,
    0,
    0,
    872,
    875,
    1,
    0,
    0,
    0,
    873,
    871,
    1,
    0,
    0,
    0,
    873,
    874,
    1,
    0,
    0,
    0,
    874,
    876,
    1,
    0,
    0,
    0,
    875,
    873,
    1,
    0,
    0,
    0,
    876,
    878,
    3,
    48,
    24,
    0,
    877,
    866,
    1,
    0,
    0,
    0,
    878,
    881,
    1,
    0,
    0,
    0,
    879,
    877,
    1,
    0,
    0,
    0,
    879,
    880,
    1,
    0,
    0,
    0,
    880,
    47,
    1,
    0,
    0,
    0,
    881,
    879,
    1,
    0,
    0,
    0,
    882,
    886,
    5,
    41,
    0,
    0,
    883,
    885,
    5,
    12,
    0,
    0,
    884,
    883,
    1,
    0,
    0,
    0,
    885,
    888,
    1,
    0,
    0,
    0,
    886,
    884,
    1,
    0,
    0,
    0,
    886,
    887,
    1,
    0,
    0,
    0,
    887,
    889,
    1,
    0,
    0,
    0,
    888,
    886,
    1,
    0,
    0,
    0,
    889,
    892,
    3,
    50,
    25,
    0,
    890,
    892,
    3,
    50,
    25,
    0,
    891,
    882,
    1,
    0,
    0,
    0,
    891,
    890,
    1,
    0,
    0,
    0,
    892,
    49,
    1,
    0,
    0,
    0,
    893,
    897,
    7,
    5,
    0,
    0,
    894,
    896,
    5,
    12,
    0,
    0,
    895,
    894,
    1,
    0,
    0,
    0,
    896,
    899,
    1,
    0,
    0,
    0,
    897,
    895,
    1,
    0,
    0,
    0,
    897,
    898,
    1,
    0,
    0,
    0,
    898,
    900,
    1,
    0,
    0,
    0,
    899,
    897,
    1,
    0,
    0,
    0,
    900,
    903,
    3,
    52,
    26,
    0,
    901,
    903,
    3,
    52,
    26,
    0,
    902,
    893,
    1,
    0,
    0,
    0,
    902,
    901,
    1,
    0,
    0,
    0,
    903,
    51,
    1,
    0,
    0,
    0,
    904,
    905,
    3,
    54,
    27,
    0,
    905,
    53,
    1,
    0,
    0,
    0,
    906,
    911,
    3,
    58,
    29,
    0,
    907,
    910,
    3,
    70,
    35,
    0,
    908,
    910,
    3,
    56,
    28,
    0,
    909,
    907,
    1,
    0,
    0,
    0,
    909,
    908,
    1,
    0,
    0,
    0,
    910,
    913,
    1,
    0,
    0,
    0,
    911,
    909,
    1,
    0,
    0,
    0,
    911,
    912,
    1,
    0,
    0,
    0,
    912,
    55,
    1,
    0,
    0,
    0,
    913,
    911,
    1,
    0,
    0,
    0,
    914,
    941,
    5,
    1,
    0,
    0,
    915,
    917,
    5,
    12,
    0,
    0,
    916,
    915,
    1,
    0,
    0,
    0,
    917,
    920,
    1,
    0,
    0,
    0,
    918,
    916,
    1,
    0,
    0,
    0,
    918,
    919,
    1,
    0,
    0,
    0,
    919,
    921,
    1,
    0,
    0,
    0,
    920,
    918,
    1,
    0,
    0,
    0,
    921,
    938,
    3,
    28,
    14,
    0,
    922,
    924,
    5,
    12,
    0,
    0,
    923,
    922,
    1,
    0,
    0,
    0,
    924,
    927,
    1,
    0,
    0,
    0,
    925,
    923,
    1,
    0,
    0,
    0,
    925,
    926,
    1,
    0,
    0,
    0,
    926,
    928,
    1,
    0,
    0,
    0,
    927,
    925,
    1,
    0,
    0,
    0,
    928,
    932,
    5,
    2,
    0,
    0,
    929,
    931,
    5,
    12,
    0,
    0,
    930,
    929,
    1,
    0,
    0,
    0,
    931,
    934,
    1,
    0,
    0,
    0,
    932,
    930,
    1,
    0,
    0,
    0,
    932,
    933,
    1,
    0,
    0,
    0,
    933,
    935,
    1,
    0,
    0,
    0,
    934,
    932,
    1,
    0,
    0,
    0,
    935,
    937,
    3,
    28,
    14,
    0,
    936,
    925,
    1,
    0,
    0,
    0,
    937,
    940,
    1,
    0,
    0,
    0,
    938,
    936,
    1,
    0,
    0,
    0,
    938,
    939,
    1,
    0,
    0,
    0,
    939,
    942,
    1,
    0,
    0,
    0,
    940,
    938,
    1,
    0,
    0,
    0,
    941,
    918,
    1,
    0,
    0,
    0,
    941,
    942,
    1,
    0,
    0,
    0,
    942,
    946,
    1,
    0,
    0,
    0,
    943,
    945,
    5,
    12,
    0,
    0,
    944,
    943,
    1,
    0,
    0,
    0,
    945,
    948,
    1,
    0,
    0,
    0,
    946,
    944,
    1,
    0,
    0,
    0,
    946,
    947,
    1,
    0,
    0,
    0,
    947,
    949,
    1,
    0,
    0,
    0,
    948,
    946,
    1,
    0,
    0,
    0,
    949,
    950,
    5,
    3,
    0,
    0,
    950,
    57,
    1,
    0,
    0,
    0,
    951,
    955,
    5,
    1,
    0,
    0,
    952,
    954,
    7,
    0,
    0,
    0,
    953,
    952,
    1,
    0,
    0,
    0,
    954,
    957,
    1,
    0,
    0,
    0,
    955,
    953,
    1,
    0,
    0,
    0,
    955,
    956,
    1,
    0,
    0,
    0,
    956,
    958,
    1,
    0,
    0,
    0,
    957,
    955,
    1,
    0,
    0,
    0,
    958,
    962,
    3,
    28,
    14,
    0,
    959,
    961,
    7,
    0,
    0,
    0,
    960,
    959,
    1,
    0,
    0,
    0,
    961,
    964,
    1,
    0,
    0,
    0,
    962,
    960,
    1,
    0,
    0,
    0,
    962,
    963,
    1,
    0,
    0,
    0,
    963,
    965,
    1,
    0,
    0,
    0,
    964,
    962,
    1,
    0,
    0,
    0,
    965,
    966,
    5,
    3,
    0,
    0,
    966,
    969,
    1,
    0,
    0,
    0,
    967,
    969,
    3,
    60,
    30,
    0,
    968,
    951,
    1,
    0,
    0,
    0,
    968,
    967,
    1,
    0,
    0,
    0,
    969,
    59,
    1,
    0,
    0,
    0,
    970,
    980,
    3,
    80,
    40,
    0,
    971,
    980,
    5,
    52,
    0,
    0,
    972,
    980,
    3,
    94,
    47,
    0,
    973,
    980,
    3,
    62,
    31,
    0,
    974,
    980,
    5,
    56,
    0,
    0,
    975,
    980,
    5,
    57,
    0,
    0,
    976,
    980,
    3,
    64,
    32,
    0,
    977,
    980,
    3,
    22,
    11,
    0,
    978,
    980,
    3,
    66,
    33,
    0,
    979,
    970,
    1,
    0,
    0,
    0,
    979,
    971,
    1,
    0,
    0,
    0,
    979,
    972,
    1,
    0,
    0,
    0,
    979,
    973,
    1,
    0,
    0,
    0,
    979,
    974,
    1,
    0,
    0,
    0,
    979,
    975,
    1,
    0,
    0,
    0,
    979,
    976,
    1,
    0,
    0,
    0,
    979,
    977,
    1,
    0,
    0,
    0,
    979,
    978,
    1,
    0,
    0,
    0,
    980,
    61,
    1,
    0,
    0,
    0,
    981,
    985,
    5,
    48,
    0,
    0,
    982,
    984,
    5,
    12,
    0,
    0,
    983,
    982,
    1,
    0,
    0,
    0,
    984,
    987,
    1,
    0,
    0,
    0,
    985,
    983,
    1,
    0,
    0,
    0,
    985,
    986,
    1,
    0,
    0,
    0,
    986,
    988,
    1,
    0,
    0,
    0,
    987,
    985,
    1,
    0,
    0,
    0,
    988,
    989,
    3,
    38,
    19,
    0,
    989,
    990,
    5,
    12,
    0,
    0,
    990,
    994,
    3,
    84,
    42,
    0,
    991,
    993,
    5,
    12,
    0,
    0,
    992,
    991,
    1,
    0,
    0,
    0,
    993,
    996,
    1,
    0,
    0,
    0,
    994,
    992,
    1,
    0,
    0,
    0,
    994,
    995,
    1,
    0,
    0,
    0,
    995,
    997,
    1,
    0,
    0,
    0,
    996,
    994,
    1,
    0,
    0,
    0,
    997,
    998,
    5,
    49,
    0,
    0,
    998,
    63,
    1,
    0,
    0,
    0,
    999,
    1026,
    5,
    46,
    0,
    0,
    1e3,
    1002,
    7,
    0,
    0,
    0,
    1001,
    1e3,
    1,
    0,
    0,
    0,
    1002,
    1005,
    1,
    0,
    0,
    0,
    1003,
    1001,
    1,
    0,
    0,
    0,
    1003,
    1004,
    1,
    0,
    0,
    0,
    1004,
    1006,
    1,
    0,
    0,
    0,
    1005,
    1003,
    1,
    0,
    0,
    0,
    1006,
    1023,
    3,
    78,
    39,
    0,
    1007,
    1009,
    7,
    0,
    0,
    0,
    1008,
    1007,
    1,
    0,
    0,
    0,
    1009,
    1012,
    1,
    0,
    0,
    0,
    1010,
    1008,
    1,
    0,
    0,
    0,
    1010,
    1011,
    1,
    0,
    0,
    0,
    1011,
    1013,
    1,
    0,
    0,
    0,
    1012,
    1010,
    1,
    0,
    0,
    0,
    1013,
    1017,
    5,
    2,
    0,
    0,
    1014,
    1016,
    7,
    0,
    0,
    0,
    1015,
    1014,
    1,
    0,
    0,
    0,
    1016,
    1019,
    1,
    0,
    0,
    0,
    1017,
    1015,
    1,
    0,
    0,
    0,
    1017,
    1018,
    1,
    0,
    0,
    0,
    1018,
    1020,
    1,
    0,
    0,
    0,
    1019,
    1017,
    1,
    0,
    0,
    0,
    1020,
    1022,
    3,
    78,
    39,
    0,
    1021,
    1010,
    1,
    0,
    0,
    0,
    1022,
    1025,
    1,
    0,
    0,
    0,
    1023,
    1021,
    1,
    0,
    0,
    0,
    1023,
    1024,
    1,
    0,
    0,
    0,
    1024,
    1027,
    1,
    0,
    0,
    0,
    1025,
    1023,
    1,
    0,
    0,
    0,
    1026,
    1003,
    1,
    0,
    0,
    0,
    1026,
    1027,
    1,
    0,
    0,
    0,
    1027,
    1031,
    1,
    0,
    0,
    0,
    1028,
    1030,
    7,
    0,
    0,
    0,
    1029,
    1028,
    1,
    0,
    0,
    0,
    1030,
    1033,
    1,
    0,
    0,
    0,
    1031,
    1029,
    1,
    0,
    0,
    0,
    1031,
    1032,
    1,
    0,
    0,
    0,
    1032,
    1034,
    1,
    0,
    0,
    0,
    1033,
    1031,
    1,
    0,
    0,
    0,
    1034,
    1144,
    5,
    47,
    0,
    0,
    1035,
    1062,
    5,
    48,
    0,
    0,
    1036,
    1038,
    7,
    0,
    0,
    0,
    1037,
    1036,
    1,
    0,
    0,
    0,
    1038,
    1041,
    1,
    0,
    0,
    0,
    1039,
    1037,
    1,
    0,
    0,
    0,
    1039,
    1040,
    1,
    0,
    0,
    0,
    1040,
    1042,
    1,
    0,
    0,
    0,
    1041,
    1039,
    1,
    0,
    0,
    0,
    1042,
    1059,
    3,
    78,
    39,
    0,
    1043,
    1045,
    7,
    0,
    0,
    0,
    1044,
    1043,
    1,
    0,
    0,
    0,
    1045,
    1048,
    1,
    0,
    0,
    0,
    1046,
    1044,
    1,
    0,
    0,
    0,
    1046,
    1047,
    1,
    0,
    0,
    0,
    1047,
    1049,
    1,
    0,
    0,
    0,
    1048,
    1046,
    1,
    0,
    0,
    0,
    1049,
    1053,
    5,
    2,
    0,
    0,
    1050,
    1052,
    7,
    0,
    0,
    0,
    1051,
    1050,
    1,
    0,
    0,
    0,
    1052,
    1055,
    1,
    0,
    0,
    0,
    1053,
    1051,
    1,
    0,
    0,
    0,
    1053,
    1054,
    1,
    0,
    0,
    0,
    1054,
    1056,
    1,
    0,
    0,
    0,
    1055,
    1053,
    1,
    0,
    0,
    0,
    1056,
    1058,
    3,
    78,
    39,
    0,
    1057,
    1046,
    1,
    0,
    0,
    0,
    1058,
    1061,
    1,
    0,
    0,
    0,
    1059,
    1057,
    1,
    0,
    0,
    0,
    1059,
    1060,
    1,
    0,
    0,
    0,
    1060,
    1063,
    1,
    0,
    0,
    0,
    1061,
    1059,
    1,
    0,
    0,
    0,
    1062,
    1039,
    1,
    0,
    0,
    0,
    1062,
    1063,
    1,
    0,
    0,
    0,
    1063,
    1067,
    1,
    0,
    0,
    0,
    1064,
    1066,
    7,
    0,
    0,
    0,
    1065,
    1064,
    1,
    0,
    0,
    0,
    1066,
    1069,
    1,
    0,
    0,
    0,
    1067,
    1065,
    1,
    0,
    0,
    0,
    1067,
    1068,
    1,
    0,
    0,
    0,
    1068,
    1070,
    1,
    0,
    0,
    0,
    1069,
    1067,
    1,
    0,
    0,
    0,
    1070,
    1144,
    5,
    49,
    0,
    0,
    1071,
    1098,
    5,
    46,
    0,
    0,
    1072,
    1074,
    7,
    0,
    0,
    0,
    1073,
    1072,
    1,
    0,
    0,
    0,
    1074,
    1077,
    1,
    0,
    0,
    0,
    1075,
    1073,
    1,
    0,
    0,
    0,
    1075,
    1076,
    1,
    0,
    0,
    0,
    1076,
    1078,
    1,
    0,
    0,
    0,
    1077,
    1075,
    1,
    0,
    0,
    0,
    1078,
    1095,
    3,
    28,
    14,
    0,
    1079,
    1081,
    7,
    0,
    0,
    0,
    1080,
    1079,
    1,
    0,
    0,
    0,
    1081,
    1084,
    1,
    0,
    0,
    0,
    1082,
    1080,
    1,
    0,
    0,
    0,
    1082,
    1083,
    1,
    0,
    0,
    0,
    1083,
    1085,
    1,
    0,
    0,
    0,
    1084,
    1082,
    1,
    0,
    0,
    0,
    1085,
    1089,
    5,
    2,
    0,
    0,
    1086,
    1088,
    7,
    0,
    0,
    0,
    1087,
    1086,
    1,
    0,
    0,
    0,
    1088,
    1091,
    1,
    0,
    0,
    0,
    1089,
    1087,
    1,
    0,
    0,
    0,
    1089,
    1090,
    1,
    0,
    0,
    0,
    1090,
    1092,
    1,
    0,
    0,
    0,
    1091,
    1089,
    1,
    0,
    0,
    0,
    1092,
    1094,
    3,
    28,
    14,
    0,
    1093,
    1082,
    1,
    0,
    0,
    0,
    1094,
    1097,
    1,
    0,
    0,
    0,
    1095,
    1093,
    1,
    0,
    0,
    0,
    1095,
    1096,
    1,
    0,
    0,
    0,
    1096,
    1099,
    1,
    0,
    0,
    0,
    1097,
    1095,
    1,
    0,
    0,
    0,
    1098,
    1075,
    1,
    0,
    0,
    0,
    1098,
    1099,
    1,
    0,
    0,
    0,
    1099,
    1103,
    1,
    0,
    0,
    0,
    1100,
    1102,
    7,
    0,
    0,
    0,
    1101,
    1100,
    1,
    0,
    0,
    0,
    1102,
    1105,
    1,
    0,
    0,
    0,
    1103,
    1101,
    1,
    0,
    0,
    0,
    1103,
    1104,
    1,
    0,
    0,
    0,
    1104,
    1106,
    1,
    0,
    0,
    0,
    1105,
    1103,
    1,
    0,
    0,
    0,
    1106,
    1144,
    5,
    47,
    0,
    0,
    1107,
    1134,
    5,
    48,
    0,
    0,
    1108,
    1110,
    7,
    0,
    0,
    0,
    1109,
    1108,
    1,
    0,
    0,
    0,
    1110,
    1113,
    1,
    0,
    0,
    0,
    1111,
    1109,
    1,
    0,
    0,
    0,
    1111,
    1112,
    1,
    0,
    0,
    0,
    1112,
    1114,
    1,
    0,
    0,
    0,
    1113,
    1111,
    1,
    0,
    0,
    0,
    1114,
    1131,
    3,
    28,
    14,
    0,
    1115,
    1117,
    7,
    0,
    0,
    0,
    1116,
    1115,
    1,
    0,
    0,
    0,
    1117,
    1120,
    1,
    0,
    0,
    0,
    1118,
    1116,
    1,
    0,
    0,
    0,
    1118,
    1119,
    1,
    0,
    0,
    0,
    1119,
    1121,
    1,
    0,
    0,
    0,
    1120,
    1118,
    1,
    0,
    0,
    0,
    1121,
    1125,
    5,
    2,
    0,
    0,
    1122,
    1124,
    7,
    0,
    0,
    0,
    1123,
    1122,
    1,
    0,
    0,
    0,
    1124,
    1127,
    1,
    0,
    0,
    0,
    1125,
    1123,
    1,
    0,
    0,
    0,
    1125,
    1126,
    1,
    0,
    0,
    0,
    1126,
    1128,
    1,
    0,
    0,
    0,
    1127,
    1125,
    1,
    0,
    0,
    0,
    1128,
    1130,
    3,
    28,
    14,
    0,
    1129,
    1118,
    1,
    0,
    0,
    0,
    1130,
    1133,
    1,
    0,
    0,
    0,
    1131,
    1129,
    1,
    0,
    0,
    0,
    1131,
    1132,
    1,
    0,
    0,
    0,
    1132,
    1135,
    1,
    0,
    0,
    0,
    1133,
    1131,
    1,
    0,
    0,
    0,
    1134,
    1111,
    1,
    0,
    0,
    0,
    1134,
    1135,
    1,
    0,
    0,
    0,
    1135,
    1139,
    1,
    0,
    0,
    0,
    1136,
    1138,
    7,
    0,
    0,
    0,
    1137,
    1136,
    1,
    0,
    0,
    0,
    1138,
    1141,
    1,
    0,
    0,
    0,
    1139,
    1137,
    1,
    0,
    0,
    0,
    1139,
    1140,
    1,
    0,
    0,
    0,
    1140,
    1142,
    1,
    0,
    0,
    0,
    1141,
    1139,
    1,
    0,
    0,
    0,
    1142,
    1144,
    5,
    49,
    0,
    0,
    1143,
    999,
    1,
    0,
    0,
    0,
    1143,
    1035,
    1,
    0,
    0,
    0,
    1143,
    1071,
    1,
    0,
    0,
    0,
    1143,
    1107,
    1,
    0,
    0,
    0,
    1144,
    65,
    1,
    0,
    0,
    0,
    1145,
    1146,
    5,
    27,
    0,
    0,
    1146,
    1147,
    5,
    12,
    0,
    0,
    1147,
    1149,
    5,
    56,
    0,
    0,
    1148,
    1150,
    3,
    56,
    28,
    0,
    1149,
    1148,
    1,
    0,
    0,
    0,
    1149,
    1150,
    1,
    0,
    0,
    0,
    1150,
    67,
    1,
    0,
    0,
    0,
    1151,
    1157,
    3,
    82,
    41,
    0,
    1152,
    1157,
    3,
    80,
    40,
    0,
    1153,
    1157,
    5,
    52,
    0,
    0,
    1154,
    1157,
    3,
    94,
    47,
    0,
    1155,
    1157,
    3,
    64,
    32,
    0,
    1156,
    1151,
    1,
    0,
    0,
    0,
    1156,
    1152,
    1,
    0,
    0,
    0,
    1156,
    1153,
    1,
    0,
    0,
    0,
    1156,
    1154,
    1,
    0,
    0,
    0,
    1156,
    1155,
    1,
    0,
    0,
    0,
    1157,
    69,
    1,
    0,
    0,
    0,
    1158,
    1161,
    3,
    72,
    36,
    0,
    1159,
    1161,
    3,
    74,
    37,
    0,
    1160,
    1158,
    1,
    0,
    0,
    0,
    1160,
    1159,
    1,
    0,
    0,
    0,
    1161,
    71,
    1,
    0,
    0,
    0,
    1162,
    1166,
    5,
    46,
    0,
    0,
    1163,
    1165,
    5,
    12,
    0,
    0,
    1164,
    1163,
    1,
    0,
    0,
    0,
    1165,
    1168,
    1,
    0,
    0,
    0,
    1166,
    1164,
    1,
    0,
    0,
    0,
    1166,
    1167,
    1,
    0,
    0,
    0,
    1167,
    1171,
    1,
    0,
    0,
    0,
    1168,
    1166,
    1,
    0,
    0,
    0,
    1169,
    1172,
    3,
    28,
    14,
    0,
    1170,
    1172,
    5,
    42,
    0,
    0,
    1171,
    1169,
    1,
    0,
    0,
    0,
    1171,
    1170,
    1,
    0,
    0,
    0,
    1172,
    1192,
    1,
    0,
    0,
    0,
    1173,
    1175,
    5,
    12,
    0,
    0,
    1174,
    1173,
    1,
    0,
    0,
    0,
    1175,
    1178,
    1,
    0,
    0,
    0,
    1176,
    1174,
    1,
    0,
    0,
    0,
    1176,
    1177,
    1,
    0,
    0,
    0,
    1177,
    1179,
    1,
    0,
    0,
    0,
    1178,
    1176,
    1,
    0,
    0,
    0,
    1179,
    1183,
    5,
    2,
    0,
    0,
    1180,
    1182,
    5,
    12,
    0,
    0,
    1181,
    1180,
    1,
    0,
    0,
    0,
    1182,
    1185,
    1,
    0,
    0,
    0,
    1183,
    1181,
    1,
    0,
    0,
    0,
    1183,
    1184,
    1,
    0,
    0,
    0,
    1184,
    1188,
    1,
    0,
    0,
    0,
    1185,
    1183,
    1,
    0,
    0,
    0,
    1186,
    1189,
    3,
    28,
    14,
    0,
    1187,
    1189,
    5,
    42,
    0,
    0,
    1188,
    1186,
    1,
    0,
    0,
    0,
    1188,
    1187,
    1,
    0,
    0,
    0,
    1189,
    1191,
    1,
    0,
    0,
    0,
    1190,
    1176,
    1,
    0,
    0,
    0,
    1191,
    1194,
    1,
    0,
    0,
    0,
    1192,
    1190,
    1,
    0,
    0,
    0,
    1192,
    1193,
    1,
    0,
    0,
    0,
    1193,
    1198,
    1,
    0,
    0,
    0,
    1194,
    1192,
    1,
    0,
    0,
    0,
    1195,
    1197,
    5,
    12,
    0,
    0,
    1196,
    1195,
    1,
    0,
    0,
    0,
    1197,
    1200,
    1,
    0,
    0,
    0,
    1198,
    1196,
    1,
    0,
    0,
    0,
    1198,
    1199,
    1,
    0,
    0,
    0,
    1199,
    1201,
    1,
    0,
    0,
    0,
    1200,
    1198,
    1,
    0,
    0,
    0,
    1201,
    1243,
    5,
    47,
    0,
    0,
    1202,
    1206,
    5,
    48,
    0,
    0,
    1203,
    1205,
    5,
    12,
    0,
    0,
    1204,
    1203,
    1,
    0,
    0,
    0,
    1205,
    1208,
    1,
    0,
    0,
    0,
    1206,
    1204,
    1,
    0,
    0,
    0,
    1206,
    1207,
    1,
    0,
    0,
    0,
    1207,
    1211,
    1,
    0,
    0,
    0,
    1208,
    1206,
    1,
    0,
    0,
    0,
    1209,
    1212,
    3,
    28,
    14,
    0,
    1210,
    1212,
    5,
    42,
    0,
    0,
    1211,
    1209,
    1,
    0,
    0,
    0,
    1211,
    1210,
    1,
    0,
    0,
    0,
    1212,
    1232,
    1,
    0,
    0,
    0,
    1213,
    1215,
    5,
    12,
    0,
    0,
    1214,
    1213,
    1,
    0,
    0,
    0,
    1215,
    1218,
    1,
    0,
    0,
    0,
    1216,
    1214,
    1,
    0,
    0,
    0,
    1216,
    1217,
    1,
    0,
    0,
    0,
    1217,
    1219,
    1,
    0,
    0,
    0,
    1218,
    1216,
    1,
    0,
    0,
    0,
    1219,
    1223,
    5,
    2,
    0,
    0,
    1220,
    1222,
    5,
    12,
    0,
    0,
    1221,
    1220,
    1,
    0,
    0,
    0,
    1222,
    1225,
    1,
    0,
    0,
    0,
    1223,
    1221,
    1,
    0,
    0,
    0,
    1223,
    1224,
    1,
    0,
    0,
    0,
    1224,
    1228,
    1,
    0,
    0,
    0,
    1225,
    1223,
    1,
    0,
    0,
    0,
    1226,
    1229,
    3,
    28,
    14,
    0,
    1227,
    1229,
    5,
    42,
    0,
    0,
    1228,
    1226,
    1,
    0,
    0,
    0,
    1228,
    1227,
    1,
    0,
    0,
    0,
    1229,
    1231,
    1,
    0,
    0,
    0,
    1230,
    1216,
    1,
    0,
    0,
    0,
    1231,
    1234,
    1,
    0,
    0,
    0,
    1232,
    1230,
    1,
    0,
    0,
    0,
    1232,
    1233,
    1,
    0,
    0,
    0,
    1233,
    1238,
    1,
    0,
    0,
    0,
    1234,
    1232,
    1,
    0,
    0,
    0,
    1235,
    1237,
    5,
    12,
    0,
    0,
    1236,
    1235,
    1,
    0,
    0,
    0,
    1237,
    1240,
    1,
    0,
    0,
    0,
    1238,
    1236,
    1,
    0,
    0,
    0,
    1238,
    1239,
    1,
    0,
    0,
    0,
    1239,
    1241,
    1,
    0,
    0,
    0,
    1240,
    1238,
    1,
    0,
    0,
    0,
    1241,
    1243,
    5,
    49,
    0,
    0,
    1242,
    1162,
    1,
    0,
    0,
    0,
    1242,
    1202,
    1,
    0,
    0,
    0,
    1243,
    73,
    1,
    0,
    0,
    0,
    1244,
    1245,
    5,
    8,
    0,
    0,
    1245,
    1247,
    3,
    76,
    38,
    0,
    1246,
    1244,
    1,
    0,
    0,
    0,
    1247,
    1248,
    1,
    0,
    0,
    0,
    1248,
    1246,
    1,
    0,
    0,
    0,
    1248,
    1249,
    1,
    0,
    0,
    0,
    1249,
    75,
    1,
    0,
    0,
    0,
    1250,
    1251,
    7,
    6,
    0,
    0,
    1251,
    77,
    1,
    0,
    0,
    0,
    1252,
    1256,
    3,
    76,
    38,
    0,
    1253,
    1255,
    7,
    0,
    0,
    0,
    1254,
    1253,
    1,
    0,
    0,
    0,
    1255,
    1258,
    1,
    0,
    0,
    0,
    1256,
    1254,
    1,
    0,
    0,
    0,
    1256,
    1257,
    1,
    0,
    0,
    0,
    1257,
    1259,
    1,
    0,
    0,
    0,
    1258,
    1256,
    1,
    0,
    0,
    0,
    1259,
    1263,
    5,
    5,
    0,
    0,
    1260,
    1262,
    7,
    0,
    0,
    0,
    1261,
    1260,
    1,
    0,
    0,
    0,
    1262,
    1265,
    1,
    0,
    0,
    0,
    1263,
    1261,
    1,
    0,
    0,
    0,
    1263,
    1264,
    1,
    0,
    0,
    0,
    1264,
    1266,
    1,
    0,
    0,
    0,
    1265,
    1263,
    1,
    0,
    0,
    0,
    1266,
    1267,
    3,
    28,
    14,
    0,
    1267,
    79,
    1,
    0,
    0,
    0,
    1268,
    1269,
    7,
    7,
    0,
    0,
    1269,
    81,
    1,
    0,
    0,
    0,
    1270,
    1271,
    5,
    41,
    0,
    0,
    1271,
    1272,
    3,
    80,
    40,
    0,
    1272,
    83,
    1,
    0,
    0,
    0,
    1273,
    1280,
    3,
    86,
    43,
    0,
    1274,
    1275,
    5,
    12,
    0,
    0,
    1275,
    1276,
    5,
    53,
    0,
    0,
    1276,
    1277,
    5,
    12,
    0,
    0,
    1277,
    1279,
    3,
    86,
    43,
    0,
    1278,
    1274,
    1,
    0,
    0,
    0,
    1279,
    1282,
    1,
    0,
    0,
    0,
    1280,
    1278,
    1,
    0,
    0,
    0,
    1280,
    1281,
    1,
    0,
    0,
    0,
    1281,
    85,
    1,
    0,
    0,
    0,
    1282,
    1280,
    1,
    0,
    0,
    0,
    1283,
    1300,
    3,
    88,
    44,
    0,
    1284,
    1286,
    5,
    12,
    0,
    0,
    1285,
    1284,
    1,
    0,
    0,
    0,
    1286,
    1289,
    1,
    0,
    0,
    0,
    1287,
    1285,
    1,
    0,
    0,
    0,
    1287,
    1288,
    1,
    0,
    0,
    0,
    1288,
    1290,
    1,
    0,
    0,
    0,
    1289,
    1287,
    1,
    0,
    0,
    0,
    1290,
    1294,
    7,
    8,
    0,
    0,
    1291,
    1293,
    5,
    12,
    0,
    0,
    1292,
    1291,
    1,
    0,
    0,
    0,
    1293,
    1296,
    1,
    0,
    0,
    0,
    1294,
    1292,
    1,
    0,
    0,
    0,
    1294,
    1295,
    1,
    0,
    0,
    0,
    1295,
    1297,
    1,
    0,
    0,
    0,
    1296,
    1294,
    1,
    0,
    0,
    0,
    1297,
    1299,
    3,
    88,
    44,
    0,
    1298,
    1287,
    1,
    0,
    0,
    0,
    1299,
    1302,
    1,
    0,
    0,
    0,
    1300,
    1298,
    1,
    0,
    0,
    0,
    1300,
    1301,
    1,
    0,
    0,
    0,
    1301,
    87,
    1,
    0,
    0,
    0,
    1302,
    1300,
    1,
    0,
    0,
    0,
    1303,
    1307,
    5,
    50,
    0,
    0,
    1304,
    1306,
    5,
    12,
    0,
    0,
    1305,
    1304,
    1,
    0,
    0,
    0,
    1306,
    1309,
    1,
    0,
    0,
    0,
    1307,
    1305,
    1,
    0,
    0,
    0,
    1307,
    1308,
    1,
    0,
    0,
    0,
    1308,
    1310,
    1,
    0,
    0,
    0,
    1309,
    1307,
    1,
    0,
    0,
    0,
    1310,
    1311,
    5,
    43,
    0,
    0,
    1311,
    1315,
    1,
    0,
    0,
    0,
    1312,
    1314,
    5,
    12,
    0,
    0,
    1313,
    1312,
    1,
    0,
    0,
    0,
    1314,
    1317,
    1,
    0,
    0,
    0,
    1315,
    1313,
    1,
    0,
    0,
    0,
    1315,
    1316,
    1,
    0,
    0,
    0,
    1316,
    1318,
    1,
    0,
    0,
    0,
    1317,
    1315,
    1,
    0,
    0,
    0,
    1318,
    1321,
    3,
    90,
    45,
    0,
    1319,
    1320,
    5,
    12,
    0,
    0,
    1320,
    1322,
    5,
    55,
    0,
    0,
    1321,
    1319,
    1,
    0,
    0,
    0,
    1321,
    1322,
    1,
    0,
    0,
    0,
    1322,
    1325,
    1,
    0,
    0,
    0,
    1323,
    1324,
    5,
    12,
    0,
    0,
    1324,
    1326,
    5,
    54,
    0,
    0,
    1325,
    1323,
    1,
    0,
    0,
    0,
    1325,
    1326,
    1,
    0,
    0,
    0,
    1326,
    1337,
    1,
    0,
    0,
    0,
    1327,
    1330,
    3,
    90,
    45,
    0,
    1328,
    1329,
    5,
    12,
    0,
    0,
    1329,
    1331,
    5,
    55,
    0,
    0,
    1330,
    1328,
    1,
    0,
    0,
    0,
    1330,
    1331,
    1,
    0,
    0,
    0,
    1331,
    1334,
    1,
    0,
    0,
    0,
    1332,
    1333,
    5,
    12,
    0,
    0,
    1333,
    1335,
    5,
    54,
    0,
    0,
    1334,
    1332,
    1,
    0,
    0,
    0,
    1334,
    1335,
    1,
    0,
    0,
    0,
    1335,
    1337,
    1,
    0,
    0,
    0,
    1336,
    1303,
    1,
    0,
    0,
    0,
    1336,
    1327,
    1,
    0,
    0,
    0,
    1337,
    89,
    1,
    0,
    0,
    0,
    1338,
    1364,
    3,
    92,
    46,
    0,
    1339,
    1341,
    5,
    12,
    0,
    0,
    1340,
    1339,
    1,
    0,
    0,
    0,
    1341,
    1344,
    1,
    0,
    0,
    0,
    1342,
    1340,
    1,
    0,
    0,
    0,
    1342,
    1343,
    1,
    0,
    0,
    0,
    1343,
    1345,
    1,
    0,
    0,
    0,
    1344,
    1342,
    1,
    0,
    0,
    0,
    1345,
    1353,
    5,
    45,
    0,
    0,
    1346,
    1348,
    5,
    12,
    0,
    0,
    1347,
    1346,
    1,
    0,
    0,
    0,
    1348,
    1351,
    1,
    0,
    0,
    0,
    1349,
    1347,
    1,
    0,
    0,
    0,
    1349,
    1350,
    1,
    0,
    0,
    0,
    1350,
    1352,
    1,
    0,
    0,
    0,
    1351,
    1349,
    1,
    0,
    0,
    0,
    1352,
    1354,
    5,
    41,
    0,
    0,
    1353,
    1349,
    1,
    0,
    0,
    0,
    1353,
    1354,
    1,
    0,
    0,
    0,
    1354,
    1358,
    1,
    0,
    0,
    0,
    1355,
    1357,
    5,
    12,
    0,
    0,
    1356,
    1355,
    1,
    0,
    0,
    0,
    1357,
    1360,
    1,
    0,
    0,
    0,
    1358,
    1356,
    1,
    0,
    0,
    0,
    1358,
    1359,
    1,
    0,
    0,
    0,
    1359,
    1361,
    1,
    0,
    0,
    0,
    1360,
    1358,
    1,
    0,
    0,
    0,
    1361,
    1363,
    7,
    7,
    0,
    0,
    1362,
    1342,
    1,
    0,
    0,
    0,
    1363,
    1366,
    1,
    0,
    0,
    0,
    1364,
    1362,
    1,
    0,
    0,
    0,
    1364,
    1365,
    1,
    0,
    0,
    0,
    1365,
    91,
    1,
    0,
    0,
    0,
    1366,
    1364,
    1,
    0,
    0,
    0,
    1367,
    1372,
    5,
    56,
    0,
    0,
    1368,
    1369,
    5,
    12,
    0,
    0,
    1369,
    1371,
    5,
    56,
    0,
    0,
    1370,
    1368,
    1,
    0,
    0,
    0,
    1371,
    1374,
    1,
    0,
    0,
    0,
    1372,
    1370,
    1,
    0,
    0,
    0,
    1372,
    1373,
    1,
    0,
    0,
    0,
    1373,
    1392,
    1,
    0,
    0,
    0,
    1374,
    1372,
    1,
    0,
    0,
    0,
    1375,
    1379,
    5,
    1,
    0,
    0,
    1376,
    1378,
    5,
    12,
    0,
    0,
    1377,
    1376,
    1,
    0,
    0,
    0,
    1378,
    1381,
    1,
    0,
    0,
    0,
    1379,
    1377,
    1,
    0,
    0,
    0,
    1379,
    1380,
    1,
    0,
    0,
    0,
    1380,
    1382,
    1,
    0,
    0,
    0,
    1381,
    1379,
    1,
    0,
    0,
    0,
    1382,
    1386,
    3,
    84,
    42,
    0,
    1383,
    1385,
    5,
    12,
    0,
    0,
    1384,
    1383,
    1,
    0,
    0,
    0,
    1385,
    1388,
    1,
    0,
    0,
    0,
    1386,
    1384,
    1,
    0,
    0,
    0,
    1386,
    1387,
    1,
    0,
    0,
    0,
    1387,
    1389,
    1,
    0,
    0,
    0,
    1388,
    1386,
    1,
    0,
    0,
    0,
    1389,
    1390,
    5,
    3,
    0,
    0,
    1390,
    1392,
    1,
    0,
    0,
    0,
    1391,
    1367,
    1,
    0,
    0,
    0,
    1391,
    1375,
    1,
    0,
    0,
    0,
    1392,
    93,
    1,
    0,
    0,
    0,
    1393,
    1394,
    5,
    61,
    0,
    0,
    1394,
    95,
    1,
    0,
    0,
    0,
    206,
    99,
    106,
    111,
    117,
    120,
    134,
    140,
    148,
    155,
    160,
    166,
    169,
    175,
    195,
    202,
    209,
    216,
    223,
    227,
    231,
    246,
    252,
    263,
    270,
    274,
    278,
    287,
    294,
    298,
    302,
    306,
    313,
    315,
    328,
    335,
    342,
    349,
    356,
    363,
    369,
    372,
    377,
    384,
    391,
    398,
    404,
    407,
    412,
    418,
    428,
    436,
    451,
    458,
    465,
    472,
    479,
    486,
    492,
    495,
    500,
    507,
    514,
    521,
    527,
    530,
    535,
    541,
    550,
    554,
    560,
    567,
    574,
    581,
    588,
    595,
    601,
    604,
    610,
    617,
    624,
    630,
    633,
    638,
    645,
    652,
    658,
    663,
    670,
    675,
    679,
    685,
    692,
    696,
    700,
    706,
    713,
    719,
    726,
    733,
    739,
    746,
    753,
    759,
    766,
    773,
    779,
    786,
    793,
    799,
    806,
    813,
    819,
    826,
    833,
    839,
    845,
    849,
    855,
    860,
    866,
    873,
    879,
    886,
    891,
    897,
    902,
    909,
    911,
    918,
    925,
    932,
    938,
    941,
    946,
    955,
    962,
    968,
    979,
    985,
    994,
    1003,
    1010,
    1017,
    1023,
    1026,
    1031,
    1039,
    1046,
    1053,
    1059,
    1062,
    1067,
    1075,
    1082,
    1089,
    1095,
    1098,
    1103,
    1111,
    1118,
    1125,
    1131,
    1134,
    1139,
    1143,
    1149,
    1156,
    1160,
    1166,
    1171,
    1176,
    1183,
    1188,
    1192,
    1198,
    1206,
    1211,
    1216,
    1223,
    1228,
    1232,
    1238,
    1242,
    1248,
    1256,
    1263,
    1280,
    1287,
    1294,
    1300,
    1307,
    1315,
    1321,
    1325,
    1330,
    1334,
    1336,
    1342,
    1349,
    1353,
    1358,
    1364,
    1372,
    1379,
    1386,
    1391
  ];
  var atn2 = new M.atn.ATNDeserializer().deserialize(serializedATN2);
  var decisionsToDFA2 = atn2.decisionToState.map((ds, index) => new M.dfa.DFA(ds, index));
  var sharedContextCache = new M.atn.PredictionContextCache();
  var _FormulaParser = class _FormulaParser extends M.Parser {
    constructor(input) {
      super(input);
      this._interp = new M.atn.ParserATNSimulator(this, atn2, decisionsToDFA2, sharedContextCache);
      this.ruleNames = _FormulaParser.ruleNames;
      this.literalNames = _FormulaParser.literalNames;
      this.symbolicNames = _FormulaParser.symbolicNames;
    }
    lines() {
      let localctx = new LinesContext(this, this._ctx, this.state);
      this.enterRule(localctx, 0, _FormulaParser.RULE_lines);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 99;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 11 || _la === 12) {
          this.state = 96;
          _la = this._input.LA(1);
          if (!(_la === 11 || _la === 12)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 101;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 120;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & 1562427586) !== 0 || (_la - 41 & ~31) === 0 && (1 << _la - 41 & 1150625) !== 0) {
          this.state = 102;
          this.expression();
          this.state = 111;
          this._errHandler.sync(this);
          var _alt = this._interp.adaptivePredict(this._input, 2, this._ctx);
          while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              this.state = 104;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              do {
                this.state = 103;
                this.match(_FormulaParser.R__);
                this.state = 106;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              } while (_la === 11);
              this.state = 108;
              this.expression();
            }
            this.state = 113;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 2, this._ctx);
          }
          this.state = 117;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === 11 || _la === 12) {
            this.state = 114;
            _la = this._input.LA(1);
            if (!(_la === 11 || _la === 12)) {
              this._errHandler.recoverInline(this);
            } else {
              this._errHandler.reportMatch(this);
              this.consume();
            }
            this.state = 119;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
        }
        this.state = 122;
        this.match(_FormulaParser.EOF);
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    expression() {
      let localctx = new ExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 2, _FormulaParser.RULE_expression);
      try {
        this.state = 134;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 5, this._ctx);
        switch (la_) {
          case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 124;
            this.assignment();
            break;
          case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 125;
            this.logicalExpression();
            break;
          case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 126;
            this.whileLoop();
            break;
          case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 127;
            this.forLoop();
            break;
          case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 128;
            this.forInLoop();
            break;
          case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 129;
            this.ifThenElse();
            break;
          case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 130;
            this.functionDef();
            break;
          case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 131;
            this.returnExp();
            break;
          case 9:
            this.enterOuterAlt(localctx, 9);
            this.state = 132;
            this.tryCatch();
            break;
          case 10:
            this.enterOuterAlt(localctx, 10);
            this.state = 133;
            this.throwExp();
            break;
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    returnExp() {
      let localctx = new ReturnExpContext(this, this._ctx, this.state);
      this.enterRule(localctx, 4, _FormulaParser.RULE_returnExp);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 136;
        this.match(_FormulaParser.RETURNSTATEMENT);
        this.state = 140;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 12) {
          this.state = 137;
          this.match(_FormulaParser.R_);
          this.state = 142;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 143;
        this.logicalExpression();
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    innerBlock() {
      let localctx = new InnerBlockContext(this, this._ctx, this.state);
      this.enterRule(localctx, 6, _FormulaParser.RULE_innerBlock);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 148;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 7, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 145;
            _la = this._input.LA(1);
            if (!(_la === 11 || _la === 12)) {
              this._errHandler.recoverInline(this);
            } else {
              this._errHandler.reportMatch(this);
              this.consume();
            }
          }
          this.state = 150;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 7, this._ctx);
        }
        this.state = 169;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if ((_la & ~31) === 0 && (1 << _la & 1562427586) !== 0 || (_la - 41 & ~31) === 0 && (1 << _la - 41 & 1150625) !== 0) {
          this.state = 151;
          this.expression();
          this.state = 160;
          this._errHandler.sync(this);
          var _alt = this._interp.adaptivePredict(this._input, 9, this._ctx);
          while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              this.state = 153;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              do {
                this.state = 152;
                this.match(_FormulaParser.R__);
                this.state = 155;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              } while (_la === 11);
              this.state = 157;
              this.expression();
            }
            this.state = 162;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 9, this._ctx);
          }
          this.state = 166;
          this._errHandler.sync(this);
          var _alt = this._interp.adaptivePredict(this._input, 10, this._ctx);
          while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              this.state = 163;
              _la = this._input.LA(1);
              if (!(_la === 11 || _la === 12)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
            }
            this.state = 168;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 10, this._ctx);
          }
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    whileLoop() {
      let localctx = new WhileLoopContext(this, this._ctx, this.state);
      this.enterRule(localctx, 8, _FormulaParser.RULE_whileLoop);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 171;
        this.match(_FormulaParser.WHILESTATEMENT);
        this.state = 175;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 12) {
          this.state = 172;
          this.match(_FormulaParser.R_);
          this.state = 177;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 178;
        this.logicalExpression();
        this.state = 179;
        this.match(_FormulaParser.R__);
        this.state = 180;
        this.innerBlock();
        this.state = 182;
        this.match(_FormulaParser.R__);
        this.state = 183;
        this.match(_FormulaParser.ENDBLOCK);
        this.state = 184;
        this.match(_FormulaParser.R_);
        this.state = 185;
        this.match(_FormulaParser.LOOPSTATEMENT);
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    forLoop() {
      let localctx = new ForLoopContext(this, this._ctx, this.state);
      this.enterRule(localctx, 10, _FormulaParser.RULE_forLoop);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 187;
        this.match(_FormulaParser.FORSTATEMENT);
        this.state = 188;
        this.match(_FormulaParser.R_);
        this.state = 189;
        this.match(_FormulaParser.IDENT);
        this.state = 190;
        this.match(_FormulaParser.R_);
        this.state = 191;
        this.match(_FormulaParser.FROMSTATEMENT);
        this.state = 195;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 12) {
          this.state = 192;
          this.match(_FormulaParser.R_);
          this.state = 197;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 198;
        this.logicalExpression();
        this.state = 202;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 12) {
          this.state = 199;
          this.match(_FormulaParser.R_);
          this.state = 204;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 205;
        this.match(_FormulaParser.TOSTATEMENT);
        this.state = 209;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 12) {
          this.state = 206;
          this.match(_FormulaParser.R_);
          this.state = 211;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 212;
        this.logicalExpression();
        this.state = 227;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === 12 || _la === 19) {
          this.state = 216;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === 12) {
            this.state = 213;
            this.match(_FormulaParser.R_);
            this.state = 218;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
          this.state = 219;
          this.match(_FormulaParser.BYSTATEMENT);
          this.state = 223;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === 12) {
            this.state = 220;
            this.match(_FormulaParser.R_);
            this.state = 225;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
          this.state = 226;
          this.logicalExpression();
        }
        this.state = 231;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 19, this._ctx);
        if (la_ === 1) {
          this.state = 229;
          this.match(_FormulaParser.R__);
          this.state = 230;
          this.innerBlock();
        }
        this.state = 233;
        this.match(_FormulaParser.R__);
        this.state = 234;
        this.match(_FormulaParser.ENDBLOCK);
        this.state = 235;
        this.match(_FormulaParser.R_);
        this.state = 236;
        this.match(_FormulaParser.LOOPSTATEMENT);
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    forInLoop() {
      let localctx = new ForInLoopContext(this, this._ctx, this.state);
      this.enterRule(localctx, 12, _FormulaParser.RULE_forInLoop);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 238;
        this.match(_FormulaParser.FORSTATEMENT);
        this.state = 239;
        this.match(_FormulaParser.R_);
        this.state = 240;
        this.match(_FormulaParser.IDENT);
        this.state = 241;
        this.match(_FormulaParser.R_);
        this.state = 242;
        this.match(_FormulaParser.INSTATEMENT);
        this.state = 246;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 12) {
          this.state = 243;
          this.match(_FormulaParser.R_);
          this.state = 248;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 249;
        this.logicalExpression();
        this.state = 252;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 21, this._ctx);
        if (la_ === 1) {
          this.state = 250;
          this.match(_FormulaParser.R__);
          this.state = 251;
          this.innerBlock();
        }
        this.state = 254;
        this.match(_FormulaParser.R__);
        this.state = 255;
        this.match(_FormulaParser.ENDBLOCK);
        this.state = 256;
        this.match(_FormulaParser.R_);
        this.state = 257;
        this.match(_FormulaParser.LOOPSTATEMENT);
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    ifThenElse() {
      let localctx = new IfThenElseContext(this, this._ctx, this.state);
      this.enterRule(localctx, 14, _FormulaParser.RULE_ifThenElse);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 259;
        this.match(_FormulaParser.IFSTATEMENT);
        this.state = 263;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 12) {
          this.state = 260;
          this.match(_FormulaParser.R_);
          this.state = 265;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 266;
        this.logicalExpression();
        this.state = 270;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 23, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 267;
            _la = this._input.LA(1);
            if (!(_la === 11 || _la === 12)) {
              this._errHandler.recoverInline(this);
            } else {
              this._errHandler.reportMatch(this);
              this.consume();
            }
          }
          this.state = 272;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 23, this._ctx);
        }
        this.state = 274;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === 22) {
          this.state = 273;
          this.match(_FormulaParser.THENSTATEMENT);
        }
        this.state = 278;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 25, this._ctx);
        if (la_ === 1) {
          this.state = 276;
          this.match(_FormulaParser.R__);
          this.state = 277;
          this.innerBlock();
        }
        this.state = 306;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 30, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 280;
            this.match(_FormulaParser.R__);
            this.state = 281;
            this.match(_FormulaParser.ELSESTATEMENT);
            this.state = 282;
            this.match(_FormulaParser.R_);
            this.state = 283;
            this.match(_FormulaParser.IFSTATEMENT);
            this.state = 287;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 284;
              this.match(_FormulaParser.R_);
              this.state = 289;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 290;
            this.logicalExpression();
            this.state = 294;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input, 27, this._ctx);
            while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                this.state = 291;
                _la = this._input.LA(1);
                if (!(_la === 11 || _la === 12)) {
                  this._errHandler.recoverInline(this);
                } else {
                  this._errHandler.reportMatch(this);
                  this.consume();
                }
              }
              this.state = 296;
              this._errHandler.sync(this);
              _alt = this._interp.adaptivePredict(this._input, 27, this._ctx);
            }
            this.state = 298;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            if (_la === 22) {
              this.state = 297;
              this.match(_FormulaParser.THENSTATEMENT);
            }
            this.state = 302;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input, 29, this._ctx);
            if (la_ === 1) {
              this.state = 300;
              this.match(_FormulaParser.R__);
              this.state = 301;
              this.innerBlock();
            }
          }
          this.state = 308;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 30, this._ctx);
        }
        this.state = 315;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 32, this._ctx);
        if (la_ === 1) {
          this.state = 309;
          this.match(_FormulaParser.R__);
          this.state = 310;
          this.match(_FormulaParser.ELSESTATEMENT);
          this.state = 313;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 31, this._ctx);
          if (la_ === 1) {
            this.state = 311;
            this.match(_FormulaParser.R__);
            this.state = 312;
            this.innerBlock();
          }
        }
        this.state = 317;
        this.match(_FormulaParser.R__);
        this.state = 318;
        this.match(_FormulaParser.ENDBLOCK);
        this.state = 319;
        this.match(_FormulaParser.R_);
        this.state = 320;
        this.match(_FormulaParser.IFSTATEMENT);
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    functionDef() {
      let localctx = new FunctionDefContext(this, this._ctx, this.state);
      this.enterRule(localctx, 16, _FormulaParser.RULE_functionDef);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 322;
        this.match(_FormulaParser.FUNCTIONSTATEMENT);
        this.state = 323;
        this.match(_FormulaParser.R_);
        this.state = 324;
        this.match(_FormulaParser.IDENT);
        this.state = 328;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 12) {
          this.state = 325;
          this.match(_FormulaParser.R_);
          this.state = 330;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 331;
        this.match(_FormulaParser.T__0);
        this.state = 407;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 46, this._ctx);
        if (la_ === 1) {
          this.state = 335;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === 12) {
            this.state = 332;
            this.match(_FormulaParser.R_);
            this.state = 337;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
          this.state = 338;
          this.match(_FormulaParser.IDENT);
          this.state = 372;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 40, this._ctx);
          switch (la_) {
            case 1:
              this.state = 342;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 339;
                this.match(_FormulaParser.R_);
                this.state = 344;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 345;
              this.match(_FormulaParser.EQUALS);
              this.state = 349;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 346;
                this.match(_FormulaParser.R_);
                this.state = 351;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 352;
              this.defaultValue();
              break;
            case 2:
              this.state = 369;
              this._errHandler.sync(this);
              var _alt = this._interp.adaptivePredict(this._input, 39, this._ctx);
              while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
                if (_alt === 1) {
                  this.state = 356;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  while (_la === 12) {
                    this.state = 353;
                    this.match(_FormulaParser.R_);
                    this.state = 358;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  }
                  this.state = 359;
                  this.match(_FormulaParser.T__1);
                  this.state = 363;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  while (_la === 12) {
                    this.state = 360;
                    this.match(_FormulaParser.R_);
                    this.state = 365;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  }
                  this.state = 366;
                  this.match(_FormulaParser.IDENT);
                }
                this.state = 371;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input, 39, this._ctx);
              }
              break;
          }
          this.state = 404;
          this._errHandler.sync(this);
          var _alt = this._interp.adaptivePredict(this._input, 45, this._ctx);
          while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              this.state = 377;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 374;
                this.match(_FormulaParser.R_);
                this.state = 379;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 380;
              this.match(_FormulaParser.T__1);
              this.state = 384;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 381;
                this.match(_FormulaParser.R_);
                this.state = 386;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 387;
              this.match(_FormulaParser.IDENT);
              this.state = 391;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 388;
                this.match(_FormulaParser.R_);
                this.state = 393;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 394;
              this.match(_FormulaParser.EQUALS);
              this.state = 398;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 395;
                this.match(_FormulaParser.R_);
                this.state = 400;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 401;
              this.defaultValue();
            }
            this.state = 406;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 45, this._ctx);
          }
        }
        this.state = 412;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 12) {
          this.state = 409;
          this.match(_FormulaParser.R_);
          this.state = 414;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 415;
        this.match(_FormulaParser.T__2);
        this.state = 418;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 48, this._ctx);
        if (la_ === 1) {
          this.state = 416;
          this.match(_FormulaParser.R__);
          this.state = 417;
          this.innerBlock();
        }
        this.state = 420;
        this.match(_FormulaParser.R__);
        this.state = 421;
        this.match(_FormulaParser.ENDBLOCK);
        this.state = 422;
        this.match(_FormulaParser.R_);
        this.state = 423;
        this.match(_FormulaParser.FUNCTIONSTATEMENT);
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    tryCatch() {
      let localctx = new TryCatchContext(this, this._ctx, this.state);
      this.enterRule(localctx, 18, _FormulaParser.RULE_tryCatch);
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 425;
        this.match(_FormulaParser.TRYSTATEMENT);
        this.state = 428;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 49, this._ctx);
        if (la_ === 1) {
          this.state = 426;
          this.match(_FormulaParser.R__);
          this.state = 427;
          this.innerBlock();
        }
        this.state = 430;
        this.match(_FormulaParser.R__);
        this.state = 431;
        this.match(_FormulaParser.CATCHSTATEMENT);
        this.state = 432;
        this.match(_FormulaParser.R_);
        this.state = 433;
        this.match(_FormulaParser.IDENT);
        this.state = 436;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 50, this._ctx);
        if (la_ === 1) {
          this.state = 434;
          this.match(_FormulaParser.R__);
          this.state = 435;
          this.innerBlock();
        }
        this.state = 438;
        this.match(_FormulaParser.R__);
        this.state = 439;
        this.match(_FormulaParser.ENDBLOCK);
        this.state = 440;
        this.match(_FormulaParser.R_);
        this.state = 441;
        this.match(_FormulaParser.TRYSTATEMENT);
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    throwExp() {
      let localctx = new ThrowExpContext(this, this._ctx, this.state);
      this.enterRule(localctx, 20, _FormulaParser.RULE_throwExp);
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 443;
        this.match(_FormulaParser.THROWSTATEMENT);
        this.state = 444;
        this.match(_FormulaParser.R_);
        this.state = 445;
        this.primaryExpression();
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    anonFunctionDef() {
      let localctx = new AnonFunctionDefContext(this, this._ctx, this.state);
      this.enterRule(localctx, 22, _FormulaParser.RULE_anonFunctionDef);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 447;
        this.match(_FormulaParser.FUNCTIONSTATEMENT);
        this.state = 451;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 12) {
          this.state = 448;
          this.match(_FormulaParser.R_);
          this.state = 453;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 454;
        this.match(_FormulaParser.T__0);
        this.state = 530;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 64, this._ctx);
        if (la_ === 1) {
          this.state = 458;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === 12) {
            this.state = 455;
            this.match(_FormulaParser.R_);
            this.state = 460;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
          this.state = 461;
          this.match(_FormulaParser.IDENT);
          this.state = 495;
          this._errHandler.sync(this);
          var la_ = this._interp.adaptivePredict(this._input, 58, this._ctx);
          switch (la_) {
            case 1:
              this.state = 465;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 462;
                this.match(_FormulaParser.R_);
                this.state = 467;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 468;
              this.match(_FormulaParser.EQUALS);
              this.state = 472;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 469;
                this.match(_FormulaParser.R_);
                this.state = 474;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 475;
              this.defaultValue();
              break;
            case 2:
              this.state = 492;
              this._errHandler.sync(this);
              var _alt = this._interp.adaptivePredict(this._input, 57, this._ctx);
              while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
                if (_alt === 1) {
                  this.state = 479;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  while (_la === 12) {
                    this.state = 476;
                    this.match(_FormulaParser.R_);
                    this.state = 481;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  }
                  this.state = 482;
                  this.match(_FormulaParser.T__1);
                  this.state = 486;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  while (_la === 12) {
                    this.state = 483;
                    this.match(_FormulaParser.R_);
                    this.state = 488;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  }
                  this.state = 489;
                  this.match(_FormulaParser.IDENT);
                }
                this.state = 494;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input, 57, this._ctx);
              }
              break;
          }
          this.state = 527;
          this._errHandler.sync(this);
          var _alt = this._interp.adaptivePredict(this._input, 63, this._ctx);
          while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              this.state = 500;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 497;
                this.match(_FormulaParser.R_);
                this.state = 502;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 503;
              this.match(_FormulaParser.T__1);
              this.state = 507;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 504;
                this.match(_FormulaParser.R_);
                this.state = 509;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 510;
              this.match(_FormulaParser.IDENT);
              this.state = 514;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 511;
                this.match(_FormulaParser.R_);
                this.state = 516;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 517;
              this.match(_FormulaParser.EQUALS);
              this.state = 521;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 518;
                this.match(_FormulaParser.R_);
                this.state = 523;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 524;
              this.defaultValue();
            }
            this.state = 529;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 63, this._ctx);
          }
        }
        this.state = 535;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 12) {
          this.state = 532;
          this.match(_FormulaParser.R_);
          this.state = 537;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 538;
        this.match(_FormulaParser.T__2);
        this.state = 554;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case 11:
            this.state = 541;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input, 66, this._ctx);
            if (la_ === 1) {
              this.state = 539;
              this.match(_FormulaParser.R__);
              this.state = 540;
              this.innerBlock();
            }
            this.state = 543;
            this.match(_FormulaParser.R__);
            this.state = 544;
            this.match(_FormulaParser.ENDBLOCK);
            this.state = 545;
            this.match(_FormulaParser.R_);
            this.state = 546;
            this.match(_FormulaParser.FUNCTIONSTATEMENT);
            break;
          case 1:
          case 6:
          case 7:
          case 12:
          case 14:
          case 15:
          case 21:
          case 24:
          case 26:
          case 27:
          case 28:
          case 30:
          case 41:
          case 46:
          case 48:
          case 50:
          case 51:
          case 52:
          case 56:
          case 57:
          case 61:
            this.state = 550;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 547;
              this.match(_FormulaParser.R_);
              this.state = 552;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 553;
            this.expression();
            break;
          default:
            throw new M.error.NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    assignment() {
      let localctx = new AssignmentContext(this, this._ctx, this.state);
      this.enterRule(localctx, 24, _FormulaParser.RULE_assignment);
      var _la = 0;
      try {
        this.state = 696;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 92, this._ctx);
        switch (la_) {
          case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 556;
            this.match(_FormulaParser.IDENT);
            this.state = 560;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 557;
              this.match(_FormulaParser.R_);
              this.state = 562;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 563;
            this.match(_FormulaParser.T__0);
            this.state = 633;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input, 81, this._ctx);
            if (la_ === 1) {
              this.state = 567;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 564;
                this.match(_FormulaParser.R_);
                this.state = 569;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 570;
              this.match(_FormulaParser.IDENT);
              this.state = 604;
              this._errHandler.sync(this);
              var la_ = this._interp.adaptivePredict(this._input, 76, this._ctx);
              switch (la_) {
                case 1:
                  this.state = 574;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  while (_la === 12) {
                    this.state = 571;
                    this.match(_FormulaParser.R_);
                    this.state = 576;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  }
                  this.state = 577;
                  this.match(_FormulaParser.EQUALS);
                  this.state = 581;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  while (_la === 12) {
                    this.state = 578;
                    this.match(_FormulaParser.R_);
                    this.state = 583;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  }
                  this.state = 584;
                  this.defaultValue();
                  break;
                case 2:
                  this.state = 601;
                  this._errHandler.sync(this);
                  var _alt = this._interp.adaptivePredict(this._input, 75, this._ctx);
                  while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
                    if (_alt === 1) {
                      this.state = 588;
                      this._errHandler.sync(this);
                      _la = this._input.LA(1);
                      while (_la === 12) {
                        this.state = 585;
                        this.match(_FormulaParser.R_);
                        this.state = 590;
                        this._errHandler.sync(this);
                        _la = this._input.LA(1);
                      }
                      this.state = 591;
                      this.match(_FormulaParser.T__1);
                      this.state = 595;
                      this._errHandler.sync(this);
                      _la = this._input.LA(1);
                      while (_la === 12) {
                        this.state = 592;
                        this.match(_FormulaParser.R_);
                        this.state = 597;
                        this._errHandler.sync(this);
                        _la = this._input.LA(1);
                      }
                      this.state = 598;
                      this.match(_FormulaParser.IDENT);
                    }
                    this.state = 603;
                    this._errHandler.sync(this);
                    _alt = this._interp.adaptivePredict(this._input, 75, this._ctx);
                  }
                  break;
              }
              this.state = 630;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 2) {
                this.state = 606;
                this.match(_FormulaParser.T__1);
                this.state = 610;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === 12) {
                  this.state = 607;
                  this.match(_FormulaParser.R_);
                  this.state = 612;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 613;
                this.match(_FormulaParser.IDENT);
                this.state = 617;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === 12) {
                  this.state = 614;
                  this.match(_FormulaParser.R_);
                  this.state = 619;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 620;
                this.match(_FormulaParser.EQUALS);
                this.state = 624;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === 12) {
                  this.state = 621;
                  this.match(_FormulaParser.R_);
                  this.state = 626;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 627;
                this.defaultValue();
                this.state = 632;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
            }
            this.state = 638;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 635;
              this.match(_FormulaParser.R_);
              this.state = 640;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 641;
            this.match(_FormulaParser.T__2);
            this.state = 645;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 642;
              this.match(_FormulaParser.R_);
              this.state = 647;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 648;
            this.match(_FormulaParser.T__3);
            this.state = 652;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 649;
              this.match(_FormulaParser.R_);
              this.state = 654;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 655;
            this.logicalExpression();
            break;
          case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 658;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case 57:
                this.state = 656;
                this.match(_FormulaParser.PRIMITIVE);
                break;
              case 56:
                this.state = 657;
                this.assigned();
                break;
              default:
                throw new M.error.NoViableAltException(this);
            }
            this.state = 679;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input, 89, this._ctx);
            while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                this.state = 663;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === 12) {
                  this.state = 660;
                  this.match(_FormulaParser.R_);
                  this.state = 665;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 666;
                this.match(_FormulaParser.T__1);
                this.state = 670;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === 12) {
                  this.state = 667;
                  this.match(_FormulaParser.R_);
                  this.state = 672;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 675;
                this._errHandler.sync(this);
                switch (this._input.LA(1)) {
                  case 57:
                    this.state = 673;
                    this.match(_FormulaParser.PRIMITIVE);
                    break;
                  case 56:
                    this.state = 674;
                    this.assigned();
                    break;
                  default:
                    throw new M.error.NoViableAltException(this);
                }
              }
              this.state = 681;
              this._errHandler.sync(this);
              _alt = this._interp.adaptivePredict(this._input, 89, this._ctx);
            }
            this.state = 685;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 682;
              this.match(_FormulaParser.R_);
              this.state = 687;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 688;
            this.match(_FormulaParser.T__3);
            this.state = 692;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 689;
              this.match(_FormulaParser.R_);
              this.state = 694;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 695;
            this.logicalExpression();
            break;
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    assigned() {
      let localctx = new AssignedContext(this, this._ctx, this.state);
      this.enterRule(localctx, 26, _FormulaParser.RULE_assigned);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 698;
        this.match(_FormulaParser.IDENT);
        this.state = 700;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if (_la === 8 || _la === 46 || _la === 48) {
          this.state = 699;
          this.selector();
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    logicalExpression() {
      let localctx = new LogicalExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 28, _FormulaParser.RULE_logicalExpression);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 702;
        this.booleanXORExpression();
        this.state = 719;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 96, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 706;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 703;
              this.match(_FormulaParser.R_);
              this.state = 708;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 709;
            this.match(_FormulaParser.OR);
            this.state = 713;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 710;
              this.match(_FormulaParser.R_);
              this.state = 715;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 716;
            this.booleanXORExpression();
          }
          this.state = 721;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 96, this._ctx);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    booleanXORExpression() {
      let localctx = new BooleanXORExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 30, _FormulaParser.RULE_booleanXORExpression);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 722;
        this.booleanAndExpression();
        this.state = 739;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 99, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 726;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 723;
              this.match(_FormulaParser.R_);
              this.state = 728;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 729;
            this.match(_FormulaParser.XOR);
            this.state = 733;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 730;
              this.match(_FormulaParser.R_);
              this.state = 735;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 736;
            this.booleanAndExpression();
          }
          this.state = 741;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 99, this._ctx);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    booleanAndExpression() {
      let localctx = new BooleanAndExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 32, _FormulaParser.RULE_booleanAndExpression);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 742;
        this.equalityExpression();
        this.state = 759;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 102, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 746;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 743;
              this.match(_FormulaParser.R_);
              this.state = 748;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 749;
            this.match(_FormulaParser.AND);
            this.state = 753;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 750;
              this.match(_FormulaParser.R_);
              this.state = 755;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 756;
            this.equalityExpression();
          }
          this.state = 761;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 102, this._ctx);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    equalityExpression() {
      let localctx = new EqualityExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 34, _FormulaParser.RULE_equalityExpression);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 762;
        this.relationalExpression();
        this.state = 779;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 105, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 766;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 763;
              this.match(_FormulaParser.R_);
              this.state = 768;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 769;
            _la = this._input.LA(1);
            if (!(_la === 34 || _la === 35)) {
              this._errHandler.recoverInline(this);
            } else {
              this._errHandler.reportMatch(this);
              this.consume();
            }
            this.state = 773;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 770;
              this.match(_FormulaParser.R_);
              this.state = 775;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 776;
            this.relationalExpression();
          }
          this.state = 781;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 105, this._ctx);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    relationalExpression() {
      let localctx = new RelationalExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 36, _FormulaParser.RULE_relationalExpression);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 782;
        this.additiveExpression();
        this.state = 799;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 108, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 786;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 783;
              this.match(_FormulaParser.R_);
              this.state = 788;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 789;
            _la = this._input.LA(1);
            if (!((_la - 36 & ~31) === 0 && (1 << _la - 36 & 15) !== 0)) {
              this._errHandler.recoverInline(this);
            } else {
              this._errHandler.reportMatch(this);
              this.consume();
            }
            this.state = 793;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 790;
              this.match(_FormulaParser.R_);
              this.state = 795;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 796;
            this.additiveExpression();
          }
          this.state = 801;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 108, this._ctx);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    additiveExpression() {
      let localctx = new AdditiveExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 38, _FormulaParser.RULE_additiveExpression);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 802;
        this.multiplicativeExpression();
        this.state = 819;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 111, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 806;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 803;
              this.match(_FormulaParser.R_);
              this.state = 808;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 809;
            _la = this._input.LA(1);
            if (!(_la === 40 || _la === 41)) {
              this._errHandler.recoverInline(this);
            } else {
              this._errHandler.reportMatch(this);
              this.consume();
            }
            this.state = 813;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 810;
              this.match(_FormulaParser.R_);
              this.state = 815;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 816;
            this.multiplicativeExpression();
          }
          this.state = 821;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 111, this._ctx);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    multiplicativeExpression() {
      let localctx = new MultiplicativeExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 40, _FormulaParser.RULE_multiplicativeExpression);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 822;
        this.arrayExpression();
        this.state = 839;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 114, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 826;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 823;
              this.match(_FormulaParser.R_);
              this.state = 828;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 829;
            _la = this._input.LA(1);
            if (!((_la - 42 & ~31) === 0 && (1 << _la - 42 & 7) !== 0)) {
              this._errHandler.recoverInline(this);
            } else {
              this._errHandler.reportMatch(this);
              this.consume();
            }
            this.state = 833;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 830;
              this.match(_FormulaParser.R_);
              this.state = 835;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 836;
            this.arrayExpression();
          }
          this.state = 841;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 114, this._ctx);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    arrayExpression() {
      let localctx = new ArrayExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 42, _FormulaParser.RULE_arrayExpression);
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 842;
        this.negationExpression();
        this.state = 845;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 115, this._ctx);
        if (la_ === 1) {
          this.state = 843;
          this.match(_FormulaParser.T__4);
          this.state = 844;
          this.negationExpression();
        }
        this.state = 849;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 116, this._ctx);
        if (la_ === 1) {
          this.state = 847;
          this.match(_FormulaParser.T__4);
          this.state = 848;
          this.negationExpression();
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    negationExpression() {
      let localctx = new NegationExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 44, _FormulaParser.RULE_negationExpression);
      var _la = 0;
      try {
        this.state = 860;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case 41:
            this.enterOuterAlt(localctx, 1);
            this.state = 851;
            this.match(_FormulaParser.MINUS);
            this.state = 855;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 852;
              this.match(_FormulaParser.R_);
              this.state = 857;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 858;
            this.powerExpression();
            break;
          case 1:
          case 6:
          case 7:
          case 24:
          case 27:
          case 46:
          case 48:
          case 50:
          case 51:
          case 52:
          case 56:
          case 57:
          case 61:
            this.enterOuterAlt(localctx, 2);
            this.state = 859;
            this.powerExpression();
            break;
          default:
            throw new M.error.NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    powerExpression() {
      let localctx = new PowerExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 46, _FormulaParser.RULE_powerExpression);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 862;
        this.unaryExpression();
        this.state = 879;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 121, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 866;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 863;
              this.match(_FormulaParser.R_);
              this.state = 868;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 869;
            this.match(_FormulaParser.POW);
            this.state = 873;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 870;
              this.match(_FormulaParser.R_);
              this.state = 875;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 876;
            this.unaryOrNegate();
          }
          this.state = 881;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 121, this._ctx);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    unaryOrNegate() {
      let localctx = new UnaryOrNegateContext(this, this._ctx, this.state);
      this.enterRule(localctx, 48, _FormulaParser.RULE_unaryOrNegate);
      var _la = 0;
      try {
        this.state = 891;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case 41:
            this.enterOuterAlt(localctx, 1);
            this.state = 882;
            this.match(_FormulaParser.MINUS);
            this.state = 886;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 883;
              this.match(_FormulaParser.R_);
              this.state = 888;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 889;
            this.unaryExpression();
            break;
          case 1:
          case 6:
          case 7:
          case 24:
          case 27:
          case 46:
          case 48:
          case 50:
          case 51:
          case 52:
          case 56:
          case 57:
          case 61:
            this.enterOuterAlt(localctx, 2);
            this.state = 890;
            this.unaryExpression();
            break;
          default:
            throw new M.error.NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    unaryExpression() {
      let localctx = new UnaryExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 50, _FormulaParser.RULE_unaryExpression);
      var _la = 0;
      try {
        this.state = 902;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case 6:
          case 7:
            this.enterOuterAlt(localctx, 1);
            this.state = 893;
            _la = this._input.LA(1);
            if (!(_la === 6 || _la === 7)) {
              this._errHandler.recoverInline(this);
            } else {
              this._errHandler.reportMatch(this);
              this.consume();
            }
            this.state = 897;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 894;
              this.match(_FormulaParser.R_);
              this.state = 899;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 900;
            this.innerPrimaryExpression();
            break;
          case 1:
          case 24:
          case 27:
          case 46:
          case 48:
          case 50:
          case 51:
          case 52:
          case 56:
          case 57:
          case 61:
            this.enterOuterAlt(localctx, 2);
            this.state = 901;
            this.innerPrimaryExpression();
            break;
          default:
            throw new M.error.NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    innerPrimaryExpression() {
      let localctx = new InnerPrimaryExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 52, _FormulaParser.RULE_innerPrimaryExpression);
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 904;
        this.selectionExpression();
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    selectionExpression() {
      let localctx = new SelectionExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 54, _FormulaParser.RULE_selectionExpression);
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 906;
        this.primaryExpression();
        this.state = 911;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 127, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 909;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case 8:
              case 46:
              case 48:
                this.state = 907;
                this.selector();
                break;
              case 1:
                this.state = 908;
                this.funCall();
                break;
              default:
                throw new M.error.NoViableAltException(this);
            }
          }
          this.state = 913;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 127, this._ctx);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    funCall() {
      let localctx = new FunCallContext(this, this._ctx, this.state);
      this.enterRule(localctx, 56, _FormulaParser.RULE_funCall);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 914;
        this.match(_FormulaParser.T__0);
        this.state = 941;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 132, this._ctx);
        if (la_ === 1) {
          this.state = 918;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
          while (_la === 12) {
            this.state = 915;
            this.match(_FormulaParser.R_);
            this.state = 920;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
          }
          this.state = 921;
          this.logicalExpression();
          this.state = 938;
          this._errHandler.sync(this);
          var _alt = this._interp.adaptivePredict(this._input, 131, this._ctx);
          while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
            if (_alt === 1) {
              this.state = 925;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 922;
                this.match(_FormulaParser.R_);
                this.state = 927;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 928;
              this.match(_FormulaParser.T__1);
              this.state = 932;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 929;
                this.match(_FormulaParser.R_);
                this.state = 934;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 935;
              this.logicalExpression();
            }
            this.state = 940;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input, 131, this._ctx);
          }
        }
        this.state = 946;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 12) {
          this.state = 943;
          this.match(_FormulaParser.R_);
          this.state = 948;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 949;
        this.match(_FormulaParser.T__2);
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    primaryExpression() {
      let localctx = new PrimaryExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 58, _FormulaParser.RULE_primaryExpression);
      var _la = 0;
      try {
        this.state = 968;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 951;
            this.match(_FormulaParser.T__0);
            this.state = 955;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 11 || _la === 12) {
              this.state = 952;
              _la = this._input.LA(1);
              if (!(_la === 11 || _la === 12)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 957;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 958;
            this.logicalExpression();
            this.state = 962;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 11 || _la === 12) {
              this.state = 959;
              _la = this._input.LA(1);
              if (!(_la === 11 || _la === 12)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 964;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 965;
            this.match(_FormulaParser.T__2);
            break;
          case 24:
          case 27:
          case 46:
          case 48:
          case 50:
          case 51:
          case 52:
          case 56:
          case 57:
          case 61:
            this.enterOuterAlt(localctx, 2);
            this.state = 967;
            this.value();
            break;
          default:
            throw new M.error.NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    value() {
      let localctx = new ValueContext(this, this._ctx, this.state);
      this.enterRule(localctx, 60, _FormulaParser.RULE_value);
      try {
        this.state = 979;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 137, this._ctx);
        switch (la_) {
          case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 970;
            this.number();
            break;
          case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 971;
            this.match(_FormulaParser.BOOL);
            break;
          case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 972;
            this.string();
            break;
          case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 973;
            this.material();
            break;
          case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 974;
            this.match(_FormulaParser.IDENT);
            break;
          case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 975;
            this.match(_FormulaParser.PRIMITIVE);
            break;
          case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 976;
            this.array();
            break;
          case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 977;
            this.anonFunctionDef();
            break;
          case 9:
            this.enterOuterAlt(localctx, 9);
            this.state = 978;
            this.newObject();
            break;
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    material() {
      let localctx = new MaterialContext(this, this._ctx, this.state);
      this.enterRule(localctx, 62, _FormulaParser.RULE_material);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 981;
        this.match(_FormulaParser.LCURL);
        this.state = 985;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 12) {
          this.state = 982;
          this.match(_FormulaParser.R_);
          this.state = 987;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 988;
        this.additiveExpression();
        this.state = 989;
        this.match(_FormulaParser.R_);
        this.state = 990;
        this.unitMultiplicativeExpression();
        this.state = 994;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 12) {
          this.state = 991;
          this.match(_FormulaParser.R_);
          this.state = 996;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 997;
        this.match(_FormulaParser.RCURL);
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    array() {
      let localctx = new ArrayContext(this, this._ctx, this.state);
      this.enterRule(localctx, 64, _FormulaParser.RULE_array);
      var _la = 0;
      try {
        this.state = 1143;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 164, this._ctx);
        switch (la_) {
          case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 999;
            this.match(_FormulaParser.LARR);
            this.state = 1026;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input, 144, this._ctx);
            if (la_ === 1) {
              this.state = 1003;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 11 || _la === 12) {
                this.state = 1e3;
                _la = this._input.LA(1);
                if (!(_la === 11 || _la === 12)) {
                  this._errHandler.recoverInline(this);
                } else {
                  this._errHandler.reportMatch(this);
                  this.consume();
                }
                this.state = 1005;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 1006;
              this.label();
              this.state = 1023;
              this._errHandler.sync(this);
              var _alt = this._interp.adaptivePredict(this._input, 143, this._ctx);
              while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
                if (_alt === 1) {
                  this.state = 1010;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  while (_la === 11 || _la === 12) {
                    this.state = 1007;
                    _la = this._input.LA(1);
                    if (!(_la === 11 || _la === 12)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 1012;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  }
                  this.state = 1013;
                  this.match(_FormulaParser.T__1);
                  this.state = 1017;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  while (_la === 11 || _la === 12) {
                    this.state = 1014;
                    _la = this._input.LA(1);
                    if (!(_la === 11 || _la === 12)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 1019;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  }
                  this.state = 1020;
                  this.label();
                }
                this.state = 1025;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input, 143, this._ctx);
              }
            }
            this.state = 1031;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 11 || _la === 12) {
              this.state = 1028;
              _la = this._input.LA(1);
              if (!(_la === 11 || _la === 12)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 1033;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1034;
            this.match(_FormulaParser.RARR);
            break;
          case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1035;
            this.match(_FormulaParser.LCURL);
            this.state = 1062;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input, 150, this._ctx);
            if (la_ === 1) {
              this.state = 1039;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 11 || _la === 12) {
                this.state = 1036;
                _la = this._input.LA(1);
                if (!(_la === 11 || _la === 12)) {
                  this._errHandler.recoverInline(this);
                } else {
                  this._errHandler.reportMatch(this);
                  this.consume();
                }
                this.state = 1041;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 1042;
              this.label();
              this.state = 1059;
              this._errHandler.sync(this);
              var _alt = this._interp.adaptivePredict(this._input, 149, this._ctx);
              while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
                if (_alt === 1) {
                  this.state = 1046;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  while (_la === 11 || _la === 12) {
                    this.state = 1043;
                    _la = this._input.LA(1);
                    if (!(_la === 11 || _la === 12)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 1048;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  }
                  this.state = 1049;
                  this.match(_FormulaParser.T__1);
                  this.state = 1053;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  while (_la === 11 || _la === 12) {
                    this.state = 1050;
                    _la = this._input.LA(1);
                    if (!(_la === 11 || _la === 12)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 1055;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  }
                  this.state = 1056;
                  this.label();
                }
                this.state = 1061;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input, 149, this._ctx);
              }
            }
            this.state = 1067;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 11 || _la === 12) {
              this.state = 1064;
              _la = this._input.LA(1);
              if (!(_la === 11 || _la === 12)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 1069;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1070;
            this.match(_FormulaParser.RCURL);
            break;
          case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1071;
            this.match(_FormulaParser.LARR);
            this.state = 1098;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input, 156, this._ctx);
            if (la_ === 1) {
              this.state = 1075;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 11 || _la === 12) {
                this.state = 1072;
                _la = this._input.LA(1);
                if (!(_la === 11 || _la === 12)) {
                  this._errHandler.recoverInline(this);
                } else {
                  this._errHandler.reportMatch(this);
                  this.consume();
                }
                this.state = 1077;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 1078;
              this.logicalExpression();
              this.state = 1095;
              this._errHandler.sync(this);
              var _alt = this._interp.adaptivePredict(this._input, 155, this._ctx);
              while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
                if (_alt === 1) {
                  this.state = 1082;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  while (_la === 11 || _la === 12) {
                    this.state = 1079;
                    _la = this._input.LA(1);
                    if (!(_la === 11 || _la === 12)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 1084;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  }
                  this.state = 1085;
                  this.match(_FormulaParser.T__1);
                  this.state = 1089;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  while (_la === 11 || _la === 12) {
                    this.state = 1086;
                    _la = this._input.LA(1);
                    if (!(_la === 11 || _la === 12)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 1091;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  }
                  this.state = 1092;
                  this.logicalExpression();
                }
                this.state = 1097;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input, 155, this._ctx);
              }
            }
            this.state = 1103;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 11 || _la === 12) {
              this.state = 1100;
              _la = this._input.LA(1);
              if (!(_la === 11 || _la === 12)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 1105;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1106;
            this.match(_FormulaParser.RARR);
            break;
          case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 1107;
            this.match(_FormulaParser.LCURL);
            this.state = 1134;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input, 162, this._ctx);
            if (la_ === 1) {
              this.state = 1111;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 11 || _la === 12) {
                this.state = 1108;
                _la = this._input.LA(1);
                if (!(_la === 11 || _la === 12)) {
                  this._errHandler.recoverInline(this);
                } else {
                  this._errHandler.reportMatch(this);
                  this.consume();
                }
                this.state = 1113;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 1114;
              this.logicalExpression();
              this.state = 1131;
              this._errHandler.sync(this);
              var _alt = this._interp.adaptivePredict(this._input, 161, this._ctx);
              while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
                if (_alt === 1) {
                  this.state = 1118;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  while (_la === 11 || _la === 12) {
                    this.state = 1115;
                    _la = this._input.LA(1);
                    if (!(_la === 11 || _la === 12)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 1120;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  }
                  this.state = 1121;
                  this.match(_FormulaParser.T__1);
                  this.state = 1125;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                  while (_la === 11 || _la === 12) {
                    this.state = 1122;
                    _la = this._input.LA(1);
                    if (!(_la === 11 || _la === 12)) {
                      this._errHandler.recoverInline(this);
                    } else {
                      this._errHandler.reportMatch(this);
                      this.consume();
                    }
                    this.state = 1127;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                  }
                  this.state = 1128;
                  this.logicalExpression();
                }
                this.state = 1133;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input, 161, this._ctx);
              }
            }
            this.state = 1139;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 11 || _la === 12) {
              this.state = 1136;
              _la = this._input.LA(1);
              if (!(_la === 11 || _la === 12)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);
                this.consume();
              }
              this.state = 1141;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1142;
            this.match(_FormulaParser.RCURL);
            break;
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    newObject() {
      let localctx = new NewObjectContext(this, this._ctx, this.state);
      this.enterRule(localctx, 66, _FormulaParser.RULE_newObject);
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1145;
        this.match(_FormulaParser.NEWSTATEMENT);
        this.state = 1146;
        this.match(_FormulaParser.R_);
        this.state = 1147;
        this.match(_FormulaParser.IDENT);
        this.state = 1149;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input, 165, this._ctx);
        if (la_ === 1) {
          this.state = 1148;
          this.funCall();
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    defaultValue() {
      let localctx = new DefaultValueContext(this, this._ctx, this.state);
      this.enterRule(localctx, 68, _FormulaParser.RULE_defaultValue);
      try {
        this.state = 1156;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case 41:
            this.enterOuterAlt(localctx, 1);
            this.state = 1151;
            this.negnumber();
            break;
          case 50:
          case 51:
            this.enterOuterAlt(localctx, 2);
            this.state = 1152;
            this.number();
            break;
          case 52:
            this.enterOuterAlt(localctx, 3);
            this.state = 1153;
            this.match(_FormulaParser.BOOL);
            break;
          case 61:
            this.enterOuterAlt(localctx, 4);
            this.state = 1154;
            this.string();
            break;
          case 46:
          case 48:
            this.enterOuterAlt(localctx, 5);
            this.state = 1155;
            this.array();
            break;
          default:
            throw new M.error.NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    selector() {
      let localctx = new SelectorContext(this, this._ctx, this.state);
      this.enterRule(localctx, 70, _FormulaParser.RULE_selector);
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1160;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case 46:
          case 48:
            this.state = 1158;
            this.minarray();
            break;
          case 8:
            this.state = 1159;
            this.dotselector();
            break;
          default:
            throw new M.error.NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    minarray() {
      let localctx = new MinarrayContext(this, this._ctx, this.state);
      this.enterRule(localctx, 72, _FormulaParser.RULE_minarray);
      var _la = 0;
      try {
        this.state = 1242;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case 46:
            this.enterOuterAlt(localctx, 1);
            this.state = 1162;
            this.match(_FormulaParser.LARR);
            this.state = 1166;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 1163;
              this.match(_FormulaParser.R_);
              this.state = 1168;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1171;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case 1:
              case 6:
              case 7:
              case 24:
              case 27:
              case 41:
              case 46:
              case 48:
              case 50:
              case 51:
              case 52:
              case 56:
              case 57:
              case 61:
                this.state = 1169;
                this.logicalExpression();
                break;
              case 42:
                this.state = 1170;
                this.match(_FormulaParser.MULT);
                break;
              default:
                throw new M.error.NoViableAltException(this);
            }
            this.state = 1192;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input, 173, this._ctx);
            while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                this.state = 1176;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === 12) {
                  this.state = 1173;
                  this.match(_FormulaParser.R_);
                  this.state = 1178;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 1179;
                this.match(_FormulaParser.T__1);
                this.state = 1183;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === 12) {
                  this.state = 1180;
                  this.match(_FormulaParser.R_);
                  this.state = 1185;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 1188;
                this._errHandler.sync(this);
                switch (this._input.LA(1)) {
                  case 1:
                  case 6:
                  case 7:
                  case 24:
                  case 27:
                  case 41:
                  case 46:
                  case 48:
                  case 50:
                  case 51:
                  case 52:
                  case 56:
                  case 57:
                  case 61:
                    this.state = 1186;
                    this.logicalExpression();
                    break;
                  case 42:
                    this.state = 1187;
                    this.match(_FormulaParser.MULT);
                    break;
                  default:
                    throw new M.error.NoViableAltException(this);
                }
              }
              this.state = 1194;
              this._errHandler.sync(this);
              _alt = this._interp.adaptivePredict(this._input, 173, this._ctx);
            }
            this.state = 1198;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 1195;
              this.match(_FormulaParser.R_);
              this.state = 1200;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1201;
            this.match(_FormulaParser.RARR);
            break;
          case 48:
            this.enterOuterAlt(localctx, 2);
            this.state = 1202;
            this.match(_FormulaParser.LCURL);
            this.state = 1206;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 1203;
              this.match(_FormulaParser.R_);
              this.state = 1208;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1211;
            this._errHandler.sync(this);
            switch (this._input.LA(1)) {
              case 1:
              case 6:
              case 7:
              case 24:
              case 27:
              case 41:
              case 46:
              case 48:
              case 50:
              case 51:
              case 52:
              case 56:
              case 57:
              case 61:
                this.state = 1209;
                this.logicalExpression();
                break;
              case 42:
                this.state = 1210;
                this.match(_FormulaParser.MULT);
                break;
              default:
                throw new M.error.NoViableAltException(this);
            }
            this.state = 1232;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input, 180, this._ctx);
            while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                this.state = 1216;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === 12) {
                  this.state = 1213;
                  this.match(_FormulaParser.R_);
                  this.state = 1218;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 1219;
                this.match(_FormulaParser.T__1);
                this.state = 1223;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while (_la === 12) {
                  this.state = 1220;
                  this.match(_FormulaParser.R_);
                  this.state = 1225;
                  this._errHandler.sync(this);
                  _la = this._input.LA(1);
                }
                this.state = 1228;
                this._errHandler.sync(this);
                switch (this._input.LA(1)) {
                  case 1:
                  case 6:
                  case 7:
                  case 24:
                  case 27:
                  case 41:
                  case 46:
                  case 48:
                  case 50:
                  case 51:
                  case 52:
                  case 56:
                  case 57:
                  case 61:
                    this.state = 1226;
                    this.logicalExpression();
                    break;
                  case 42:
                    this.state = 1227;
                    this.match(_FormulaParser.MULT);
                    break;
                  default:
                    throw new M.error.NoViableAltException(this);
                }
              }
              this.state = 1234;
              this._errHandler.sync(this);
              _alt = this._interp.adaptivePredict(this._input, 180, this._ctx);
            }
            this.state = 1238;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 1235;
              this.match(_FormulaParser.R_);
              this.state = 1240;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1241;
            this.match(_FormulaParser.RCURL);
            break;
          default:
            throw new M.error.NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    dotselector() {
      let localctx = new DotselectorContext(this, this._ctx, this.state);
      this.enterRule(localctx, 74, _FormulaParser.RULE_dotselector);
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1246;
        this._errHandler.sync(this);
        var _alt = 1;
        do {
          switch (_alt) {
            case 1:
              this.state = 1244;
              this.match(_FormulaParser.T__7);
              this.state = 1245;
              this.arrayName();
              break;
            default:
              throw new M.error.NoViableAltException(this);
          }
          this.state = 1248;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 183, this._ctx);
        } while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER);
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    arrayName() {
      let localctx = new ArrayNameContext(this, this._ctx, this.state);
      this.enterRule(localctx, 76, _FormulaParser.RULE_arrayName);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1250;
        _la = this._input.LA(1);
        if (!((_la - 42 & ~31) === 0 && (1 << _la - 42 & 540673) !== 0)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    label() {
      let localctx = new LabelContext(this, this._ctx, this.state);
      this.enterRule(localctx, 78, _FormulaParser.RULE_label);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1252;
        this.arrayName();
        this.state = 1256;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 11 || _la === 12) {
          this.state = 1253;
          _la = this._input.LA(1);
          if (!(_la === 11 || _la === 12)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 1258;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 1259;
        this.match(_FormulaParser.T__4);
        this.state = 1263;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while (_la === 11 || _la === 12) {
          this.state = 1260;
          _la = this._input.LA(1);
          if (!(_la === 11 || _la === 12)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);
            this.consume();
          }
          this.state = 1265;
          this._errHandler.sync(this);
          _la = this._input.LA(1);
        }
        this.state = 1266;
        this.logicalExpression();
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    number() {
      let localctx = new NumberContext(this, this._ctx, this.state);
      this.enterRule(localctx, 80, _FormulaParser.RULE_number);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1268;
        _la = this._input.LA(1);
        if (!(_la === 50 || _la === 51)) {
          this._errHandler.recoverInline(this);
        } else {
          this._errHandler.reportMatch(this);
          this.consume();
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    negnumber() {
      let localctx = new NegnumberContext(this, this._ctx, this.state);
      this.enterRule(localctx, 82, _FormulaParser.RULE_negnumber);
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1270;
        this.match(_FormulaParser.MINUS);
        this.state = 1271;
        this.number();
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    unitMultiplicativeExpression() {
      let localctx = new UnitMultiplicativeExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 84, _FormulaParser.RULE_unitMultiplicativeExpression);
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1273;
        this.unitInnerMultiplicativeExpression();
        this.state = 1280;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 186, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 1274;
            this.match(_FormulaParser.R_);
            this.state = 1275;
            this.match(_FormulaParser.PER);
            this.state = 1276;
            this.match(_FormulaParser.R_);
            this.state = 1277;
            this.unitInnerMultiplicativeExpression();
          }
          this.state = 1282;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 186, this._ctx);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    unitInnerMultiplicativeExpression() {
      let localctx = new UnitInnerMultiplicativeExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 86, _FormulaParser.RULE_unitInnerMultiplicativeExpression);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1283;
        this.unitClump();
        this.state = 1300;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 189, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 1287;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 1284;
              this.match(_FormulaParser.R_);
              this.state = 1289;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1290;
            _la = this._input.LA(1);
            if (!(_la === 42 || _la === 43)) {
              this._errHandler.recoverInline(this);
            } else {
              this._errHandler.reportMatch(this);
              this.consume();
            }
            this.state = 1294;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 1291;
              this.match(_FormulaParser.R_);
              this.state = 1296;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1297;
            this.unitClump();
          }
          this.state = 1302;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 189, this._ctx);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    unitClump() {
      let localctx = new UnitClumpContext(this, this._ctx, this.state);
      this.enterRule(localctx, 88, _FormulaParser.RULE_unitClump);
      var _la = 0;
      try {
        this.state = 1336;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case 50:
            this.enterOuterAlt(localctx, 1);
            this.state = 1303;
            this.match(_FormulaParser.INTEGER);
            this.state = 1307;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 1304;
              this.match(_FormulaParser.R_);
              this.state = 1309;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1310;
            this.match(_FormulaParser.DIV);
            this.state = 1315;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 1312;
              this.match(_FormulaParser.R_);
              this.state = 1317;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1318;
            this.unitPowerExpression();
            this.state = 1321;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input, 192, this._ctx);
            if (la_ === 1) {
              this.state = 1319;
              this.match(_FormulaParser.R_);
              this.state = 1320;
              this.match(_FormulaParser.CUBED);
            }
            this.state = 1325;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input, 193, this._ctx);
            if (la_ === 1) {
              this.state = 1323;
              this.match(_FormulaParser.R_);
              this.state = 1324;
              this.match(_FormulaParser.SQUARED);
            }
            break;
          case 1:
          case 56:
            this.enterOuterAlt(localctx, 2);
            this.state = 1327;
            this.unitPowerExpression();
            this.state = 1330;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input, 194, this._ctx);
            if (la_ === 1) {
              this.state = 1328;
              this.match(_FormulaParser.R_);
              this.state = 1329;
              this.match(_FormulaParser.CUBED);
            }
            this.state = 1334;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input, 195, this._ctx);
            if (la_ === 1) {
              this.state = 1332;
              this.match(_FormulaParser.R_);
              this.state = 1333;
              this.match(_FormulaParser.SQUARED);
            }
            break;
          default:
            throw new M.error.NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    unitPowerExpression() {
      let localctx = new UnitPowerExpressionContext(this, this._ctx, this.state);
      this.enterRule(localctx, 90, _FormulaParser.RULE_unitPowerExpression);
      var _la = 0;
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1338;
        this.unit();
        this.state = 1364;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input, 201, this._ctx);
        while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
          if (_alt === 1) {
            this.state = 1342;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 1339;
              this.match(_FormulaParser.R_);
              this.state = 1344;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1345;
            this.match(_FormulaParser.POW);
            this.state = 1353;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input, 199, this._ctx);
            if (la_ === 1) {
              this.state = 1349;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
              while (_la === 12) {
                this.state = 1346;
                this.match(_FormulaParser.R_);
                this.state = 1351;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
              }
              this.state = 1352;
              this.match(_FormulaParser.MINUS);
            }
            this.state = 1358;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 1355;
              this.match(_FormulaParser.R_);
              this.state = 1360;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1361;
            _la = this._input.LA(1);
            if (!(_la === 50 || _la === 51)) {
              this._errHandler.recoverInline(this);
            } else {
              this._errHandler.reportMatch(this);
              this.consume();
            }
          }
          this.state = 1366;
          this._errHandler.sync(this);
          _alt = this._interp.adaptivePredict(this._input, 201, this._ctx);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    unit() {
      let localctx = new UnitContext(this, this._ctx, this.state);
      this.enterRule(localctx, 92, _FormulaParser.RULE_unit);
      var _la = 0;
      try {
        this.state = 1391;
        this._errHandler.sync(this);
        switch (this._input.LA(1)) {
          case 56:
            this.enterOuterAlt(localctx, 1);
            this.state = 1367;
            this.match(_FormulaParser.IDENT);
            this.state = 1372;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input, 202, this._ctx);
            while (_alt != 2 && _alt != M.atn.ATN.INVALID_ALT_NUMBER) {
              if (_alt === 1) {
                this.state = 1368;
                this.match(_FormulaParser.R_);
                this.state = 1369;
                this.match(_FormulaParser.IDENT);
              }
              this.state = 1374;
              this._errHandler.sync(this);
              _alt = this._interp.adaptivePredict(this._input, 202, this._ctx);
            }
            break;
          case 1:
            this.enterOuterAlt(localctx, 2);
            this.state = 1375;
            this.match(_FormulaParser.T__0);
            this.state = 1379;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 1376;
              this.match(_FormulaParser.R_);
              this.state = 1381;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1382;
            this.unitMultiplicativeExpression();
            this.state = 1386;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while (_la === 12) {
              this.state = 1383;
              this.match(_FormulaParser.R_);
              this.state = 1388;
              this._errHandler.sync(this);
              _la = this._input.LA(1);
            }
            this.state = 1389;
            this.match(_FormulaParser.T__2);
            break;
          default:
            throw new M.error.NoViableAltException(this);
        }
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
    string() {
      let localctx = new StringContext(this, this._ctx, this.state);
      this.enterRule(localctx, 94, _FormulaParser.RULE_string);
      try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1393;
        this.match(_FormulaParser.STRING);
      } catch (re) {
        if (re instanceof M.error.RecognitionException) {
          localctx.exception = re;
          this._errHandler.reportError(this, re);
          this._errHandler.recover(this, re);
        } else {
          throw re;
        }
      } finally {
        this.exitRule();
      }
      return localctx;
    }
  };
  __publicField(_FormulaParser, "grammarFileName", "Formula.g");
  __publicField(_FormulaParser, "literalNames", [
    null,
    "'('",
    "','",
    "')'",
    "'<-'",
    "':'",
    "'!'",
    "'not'",
    "'.'",
    null,
    null,
    null,
    null,
    null,
    "'while'",
    "'for'",
    "'from'",
    "'in'",
    "'to'",
    "'by'",
    "'loop'",
    "'if'",
    "'then'",
    "'else'",
    "'function'",
    "'end'",
    "'return'",
    "'new'",
    "'try'",
    "'catch'",
    "'throw'",
    null,
    "'xor'",
    null,
    null,
    null,
    "'<'",
    "'<='",
    "'>'",
    "'>='",
    "'+'",
    "'-'",
    "'*'",
    "'/'",
    null,
    "'^'",
    null,
    null,
    "'{'",
    "'}'",
    null,
    null,
    null,
    "'per'",
    "'squared'",
    "'cubed'",
    null,
    null,
    "'['",
    "']'"
  ]);
  __publicField(_FormulaParser, "symbolicNames", [
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    "COMMENT",
    "LINE_COMMENT",
    "R__",
    "R_",
    "NEWLINES",
    "WHILESTATEMENT",
    "FORSTATEMENT",
    "FROMSTATEMENT",
    "INSTATEMENT",
    "TOSTATEMENT",
    "BYSTATEMENT",
    "LOOPSTATEMENT",
    "IFSTATEMENT",
    "THENSTATEMENT",
    "ELSESTATEMENT",
    "FUNCTIONSTATEMENT",
    "ENDBLOCK",
    "RETURNSTATEMENT",
    "NEWSTATEMENT",
    "TRYSTATEMENT",
    "CATCHSTATEMENT",
    "THROWSTATEMENT",
    "OR",
    "XOR",
    "AND",
    "EQUALS",
    "NOTEQUALS",
    "LT",
    "LTEQ",
    "GT",
    "GTEQ",
    "PLUS",
    "MINUS",
    "MULT",
    "DIV",
    "MOD",
    "POW",
    "LARR",
    "RARR",
    "LCURL",
    "RCURL",
    "INTEGER",
    "FLOAT",
    "BOOL",
    "PER",
    "SQUARED",
    "CUBED",
    "IDENT",
    "PRIMITIVE",
    "LBRACKET",
    "RBRACKET",
    "SPACE",
    "STRING"
  ]);
  __publicField(_FormulaParser, "ruleNames", [
    "lines",
    "expression",
    "returnExp",
    "innerBlock",
    "whileLoop",
    "forLoop",
    "forInLoop",
    "ifThenElse",
    "functionDef",
    "tryCatch",
    "throwExp",
    "anonFunctionDef",
    "assignment",
    "assigned",
    "logicalExpression",
    "booleanXORExpression",
    "booleanAndExpression",
    "equalityExpression",
    "relationalExpression",
    "additiveExpression",
    "multiplicativeExpression",
    "arrayExpression",
    "negationExpression",
    "powerExpression",
    "unaryOrNegate",
    "unaryExpression",
    "innerPrimaryExpression",
    "selectionExpression",
    "funCall",
    "primaryExpression",
    "value",
    "material",
    "array",
    "newObject",
    "defaultValue",
    "selector",
    "minarray",
    "dotselector",
    "arrayName",
    "label",
    "number",
    "negnumber",
    "unitMultiplicativeExpression",
    "unitInnerMultiplicativeExpression",
    "unitClump",
    "unitPowerExpression",
    "unit",
    "string"
  ]);
  var FormulaParser = _FormulaParser;
  FormulaParser.EOF = M.Token.EOF;
  FormulaParser.T__0 = 1;
  FormulaParser.T__1 = 2;
  FormulaParser.T__2 = 3;
  FormulaParser.T__3 = 4;
  FormulaParser.T__4 = 5;
  FormulaParser.T__5 = 6;
  FormulaParser.T__6 = 7;
  FormulaParser.T__7 = 8;
  FormulaParser.COMMENT = 9;
  FormulaParser.LINE_COMMENT = 10;
  FormulaParser.R__ = 11;
  FormulaParser.R_ = 12;
  FormulaParser.NEWLINES = 13;
  FormulaParser.WHILESTATEMENT = 14;
  FormulaParser.FORSTATEMENT = 15;
  FormulaParser.FROMSTATEMENT = 16;
  FormulaParser.INSTATEMENT = 17;
  FormulaParser.TOSTATEMENT = 18;
  FormulaParser.BYSTATEMENT = 19;
  FormulaParser.LOOPSTATEMENT = 20;
  FormulaParser.IFSTATEMENT = 21;
  FormulaParser.THENSTATEMENT = 22;
  FormulaParser.ELSESTATEMENT = 23;
  FormulaParser.FUNCTIONSTATEMENT = 24;
  FormulaParser.ENDBLOCK = 25;
  FormulaParser.RETURNSTATEMENT = 26;
  FormulaParser.NEWSTATEMENT = 27;
  FormulaParser.TRYSTATEMENT = 28;
  FormulaParser.CATCHSTATEMENT = 29;
  FormulaParser.THROWSTATEMENT = 30;
  FormulaParser.OR = 31;
  FormulaParser.XOR = 32;
  FormulaParser.AND = 33;
  FormulaParser.EQUALS = 34;
  FormulaParser.NOTEQUALS = 35;
  FormulaParser.LT = 36;
  FormulaParser.LTEQ = 37;
  FormulaParser.GT = 38;
  FormulaParser.GTEQ = 39;
  FormulaParser.PLUS = 40;
  FormulaParser.MINUS = 41;
  FormulaParser.MULT = 42;
  FormulaParser.DIV = 43;
  FormulaParser.MOD = 44;
  FormulaParser.POW = 45;
  FormulaParser.LARR = 46;
  FormulaParser.RARR = 47;
  FormulaParser.LCURL = 48;
  FormulaParser.RCURL = 49;
  FormulaParser.INTEGER = 50;
  FormulaParser.FLOAT = 51;
  FormulaParser.BOOL = 52;
  FormulaParser.PER = 53;
  FormulaParser.SQUARED = 54;
  FormulaParser.CUBED = 55;
  FormulaParser.IDENT = 56;
  FormulaParser.PRIMITIVE = 57;
  FormulaParser.LBRACKET = 58;
  FormulaParser.RBRACKET = 59;
  FormulaParser.SPACE = 60;
  FormulaParser.STRING = 61;
  FormulaParser.RULE_lines = 0;
  FormulaParser.RULE_expression = 1;
  FormulaParser.RULE_returnExp = 2;
  FormulaParser.RULE_innerBlock = 3;
  FormulaParser.RULE_whileLoop = 4;
  FormulaParser.RULE_forLoop = 5;
  FormulaParser.RULE_forInLoop = 6;
  FormulaParser.RULE_ifThenElse = 7;
  FormulaParser.RULE_functionDef = 8;
  FormulaParser.RULE_tryCatch = 9;
  FormulaParser.RULE_throwExp = 10;
  FormulaParser.RULE_anonFunctionDef = 11;
  FormulaParser.RULE_assignment = 12;
  FormulaParser.RULE_assigned = 13;
  FormulaParser.RULE_logicalExpression = 14;
  FormulaParser.RULE_booleanXORExpression = 15;
  FormulaParser.RULE_booleanAndExpression = 16;
  FormulaParser.RULE_equalityExpression = 17;
  FormulaParser.RULE_relationalExpression = 18;
  FormulaParser.RULE_additiveExpression = 19;
  FormulaParser.RULE_multiplicativeExpression = 20;
  FormulaParser.RULE_arrayExpression = 21;
  FormulaParser.RULE_negationExpression = 22;
  FormulaParser.RULE_powerExpression = 23;
  FormulaParser.RULE_unaryOrNegate = 24;
  FormulaParser.RULE_unaryExpression = 25;
  FormulaParser.RULE_innerPrimaryExpression = 26;
  FormulaParser.RULE_selectionExpression = 27;
  FormulaParser.RULE_funCall = 28;
  FormulaParser.RULE_primaryExpression = 29;
  FormulaParser.RULE_value = 30;
  FormulaParser.RULE_material = 31;
  FormulaParser.RULE_array = 32;
  FormulaParser.RULE_newObject = 33;
  FormulaParser.RULE_defaultValue = 34;
  FormulaParser.RULE_selector = 35;
  FormulaParser.RULE_minarray = 36;
  FormulaParser.RULE_dotselector = 37;
  FormulaParser.RULE_arrayName = 38;
  FormulaParser.RULE_label = 39;
  FormulaParser.RULE_number = 40;
  FormulaParser.RULE_negnumber = 41;
  FormulaParser.RULE_unitMultiplicativeExpression = 42;
  FormulaParser.RULE_unitInnerMultiplicativeExpression = 43;
  FormulaParser.RULE_unitClump = 44;
  FormulaParser.RULE_unitPowerExpression = 45;
  FormulaParser.RULE_unit = 46;
  FormulaParser.RULE_string = 47;
  var LinesContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "expression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(ExpressionContext);
        } else {
          return this.getTypedRuleContext(ExpressionContext, i2);
        }
      });
      __publicField(this, "R__", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R__);
        } else {
          return this.getToken(FormulaParser.R__, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_lines;
    }
    EOF() {
      return this.getToken(FormulaParser.EOF, 0);
    }
  };
  var ExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_expression;
    }
    assignment() {
      return this.getTypedRuleContext(AssignmentContext, 0);
    }
    logicalExpression() {
      return this.getTypedRuleContext(LogicalExpressionContext, 0);
    }
    whileLoop() {
      return this.getTypedRuleContext(WhileLoopContext, 0);
    }
    forLoop() {
      return this.getTypedRuleContext(ForLoopContext, 0);
    }
    forInLoop() {
      return this.getTypedRuleContext(ForInLoopContext, 0);
    }
    ifThenElse() {
      return this.getTypedRuleContext(IfThenElseContext, 0);
    }
    functionDef() {
      return this.getTypedRuleContext(FunctionDefContext, 0);
    }
    returnExp() {
      return this.getTypedRuleContext(ReturnExpContext, 0);
    }
    tryCatch() {
      return this.getTypedRuleContext(TryCatchContext, 0);
    }
    throwExp() {
      return this.getTypedRuleContext(ThrowExpContext, 0);
    }
  };
  var ReturnExpContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_returnExp;
    }
    RETURNSTATEMENT() {
      return this.getToken(FormulaParser.RETURNSTATEMENT, 0);
    }
    logicalExpression() {
      return this.getTypedRuleContext(LogicalExpressionContext, 0);
    }
  };
  var InnerBlockContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "expression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(ExpressionContext);
        } else {
          return this.getTypedRuleContext(ExpressionContext, i2);
        }
      });
      __publicField(this, "R__", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R__);
        } else {
          return this.getToken(FormulaParser.R__, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_innerBlock;
    }
  };
  var WhileLoopContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "R__", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R__);
        } else {
          return this.getToken(FormulaParser.R__, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_whileLoop;
    }
    WHILESTATEMENT() {
      return this.getToken(FormulaParser.WHILESTATEMENT, 0);
    }
    logicalExpression() {
      return this.getTypedRuleContext(LogicalExpressionContext, 0);
    }
    ENDBLOCK() {
      return this.getToken(FormulaParser.ENDBLOCK, 0);
    }
    LOOPSTATEMENT() {
      return this.getToken(FormulaParser.LOOPSTATEMENT, 0);
    }
    innerBlock() {
      return this.getTypedRuleContext(InnerBlockContext, 0);
    }
  };
  var ForLoopContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      __publicField(this, "logicalExpression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(LogicalExpressionContext);
        } else {
          return this.getTypedRuleContext(LogicalExpressionContext, i2);
        }
      });
      __publicField(this, "R__", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R__);
        } else {
          return this.getToken(FormulaParser.R__, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_forLoop;
    }
    FORSTATEMENT() {
      return this.getToken(FormulaParser.FORSTATEMENT, 0);
    }
    IDENT() {
      return this.getToken(FormulaParser.IDENT, 0);
    }
    FROMSTATEMENT() {
      return this.getToken(FormulaParser.FROMSTATEMENT, 0);
    }
    TOSTATEMENT() {
      return this.getToken(FormulaParser.TOSTATEMENT, 0);
    }
    ENDBLOCK() {
      return this.getToken(FormulaParser.ENDBLOCK, 0);
    }
    LOOPSTATEMENT() {
      return this.getToken(FormulaParser.LOOPSTATEMENT, 0);
    }
    BYSTATEMENT() {
      return this.getToken(FormulaParser.BYSTATEMENT, 0);
    }
    innerBlock() {
      return this.getTypedRuleContext(InnerBlockContext, 0);
    }
  };
  var ForInLoopContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      __publicField(this, "R__", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R__);
        } else {
          return this.getToken(FormulaParser.R__, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_forInLoop;
    }
    FORSTATEMENT() {
      return this.getToken(FormulaParser.FORSTATEMENT, 0);
    }
    IDENT() {
      return this.getToken(FormulaParser.IDENT, 0);
    }
    INSTATEMENT() {
      return this.getToken(FormulaParser.INSTATEMENT, 0);
    }
    logicalExpression() {
      return this.getTypedRuleContext(LogicalExpressionContext, 0);
    }
    ENDBLOCK() {
      return this.getToken(FormulaParser.ENDBLOCK, 0);
    }
    LOOPSTATEMENT() {
      return this.getToken(FormulaParser.LOOPSTATEMENT, 0);
    }
    innerBlock() {
      return this.getTypedRuleContext(InnerBlockContext, 0);
    }
  };
  var IfThenElseContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "IFSTATEMENT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.IFSTATEMENT);
        } else {
          return this.getToken(FormulaParser.IFSTATEMENT, i2);
        }
      });
      __publicField(this, "logicalExpression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(LogicalExpressionContext);
        } else {
          return this.getTypedRuleContext(LogicalExpressionContext, i2);
        }
      });
      __publicField(this, "R__", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R__);
        } else {
          return this.getToken(FormulaParser.R__, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      __publicField(this, "THENSTATEMENT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.THENSTATEMENT);
        } else {
          return this.getToken(FormulaParser.THENSTATEMENT, i2);
        }
      });
      __publicField(this, "innerBlock", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(InnerBlockContext);
        } else {
          return this.getTypedRuleContext(InnerBlockContext, i2);
        }
      });
      __publicField(this, "ELSESTATEMENT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.ELSESTATEMENT);
        } else {
          return this.getToken(FormulaParser.ELSESTATEMENT, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_ifThenElse;
    }
    ENDBLOCK() {
      return this.getToken(FormulaParser.ENDBLOCK, 0);
    }
  };
  var FunctionDefContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "FUNCTIONSTATEMENT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.FUNCTIONSTATEMENT);
        } else {
          return this.getToken(FormulaParser.FUNCTIONSTATEMENT, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      __publicField(this, "IDENT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.IDENT);
        } else {
          return this.getToken(FormulaParser.IDENT, i2);
        }
      });
      __publicField(this, "R__", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R__);
        } else {
          return this.getToken(FormulaParser.R__, i2);
        }
      });
      __publicField(this, "EQUALS", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.EQUALS);
        } else {
          return this.getToken(FormulaParser.EQUALS, i2);
        }
      });
      __publicField(this, "defaultValue", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(DefaultValueContext);
        } else {
          return this.getTypedRuleContext(DefaultValueContext, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_functionDef;
    }
    ENDBLOCK() {
      return this.getToken(FormulaParser.ENDBLOCK, 0);
    }
    innerBlock() {
      return this.getTypedRuleContext(InnerBlockContext, 0);
    }
  };
  var TryCatchContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "TRYSTATEMENT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.TRYSTATEMENT);
        } else {
          return this.getToken(FormulaParser.TRYSTATEMENT, i2);
        }
      });
      __publicField(this, "R__", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R__);
        } else {
          return this.getToken(FormulaParser.R__, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      __publicField(this, "innerBlock", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(InnerBlockContext);
        } else {
          return this.getTypedRuleContext(InnerBlockContext, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_tryCatch;
    }
    CATCHSTATEMENT() {
      return this.getToken(FormulaParser.CATCHSTATEMENT, 0);
    }
    IDENT() {
      return this.getToken(FormulaParser.IDENT, 0);
    }
    ENDBLOCK() {
      return this.getToken(FormulaParser.ENDBLOCK, 0);
    }
  };
  var ThrowExpContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_throwExp;
    }
    THROWSTATEMENT() {
      return this.getToken(FormulaParser.THROWSTATEMENT, 0);
    }
    R_() {
      return this.getToken(FormulaParser.R_, 0);
    }
    primaryExpression() {
      return this.getTypedRuleContext(PrimaryExpressionContext, 0);
    }
  };
  var AnonFunctionDefContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "FUNCTIONSTATEMENT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.FUNCTIONSTATEMENT);
        } else {
          return this.getToken(FormulaParser.FUNCTIONSTATEMENT, i2);
        }
      });
      __publicField(this, "IDENT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.IDENT);
        } else {
          return this.getToken(FormulaParser.IDENT, i2);
        }
      });
      __publicField(this, "R__", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R__);
        } else {
          return this.getToken(FormulaParser.R__, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      __publicField(this, "EQUALS", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.EQUALS);
        } else {
          return this.getToken(FormulaParser.EQUALS, i2);
        }
      });
      __publicField(this, "defaultValue", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(DefaultValueContext);
        } else {
          return this.getTypedRuleContext(DefaultValueContext, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_anonFunctionDef;
    }
    expression() {
      return this.getTypedRuleContext(ExpressionContext, 0);
    }
    ENDBLOCK() {
      return this.getToken(FormulaParser.ENDBLOCK, 0);
    }
    innerBlock() {
      return this.getTypedRuleContext(InnerBlockContext, 0);
    }
  };
  var AssignmentContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "IDENT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.IDENT);
        } else {
          return this.getToken(FormulaParser.IDENT, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      __publicField(this, "EQUALS", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.EQUALS);
        } else {
          return this.getToken(FormulaParser.EQUALS, i2);
        }
      });
      __publicField(this, "defaultValue", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(DefaultValueContext);
        } else {
          return this.getTypedRuleContext(DefaultValueContext, i2);
        }
      });
      __publicField(this, "PRIMITIVE", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.PRIMITIVE);
        } else {
          return this.getToken(FormulaParser.PRIMITIVE, i2);
        }
      });
      __publicField(this, "assigned", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(AssignedContext);
        } else {
          return this.getTypedRuleContext(AssignedContext, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_assignment;
    }
    logicalExpression() {
      return this.getTypedRuleContext(LogicalExpressionContext, 0);
    }
  };
  var AssignedContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_assigned;
    }
    IDENT() {
      return this.getToken(FormulaParser.IDENT, 0);
    }
    selector() {
      return this.getTypedRuleContext(SelectorContext, 0);
    }
  };
  var LogicalExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "booleanXORExpression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(BooleanXORExpressionContext);
        } else {
          return this.getTypedRuleContext(BooleanXORExpressionContext, i2);
        }
      });
      __publicField(this, "OR", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.OR);
        } else {
          return this.getToken(FormulaParser.OR, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_logicalExpression;
    }
  };
  var BooleanXORExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "booleanAndExpression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(BooleanAndExpressionContext);
        } else {
          return this.getTypedRuleContext(BooleanAndExpressionContext, i2);
        }
      });
      __publicField(this, "XOR", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.XOR);
        } else {
          return this.getToken(FormulaParser.XOR, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_booleanXORExpression;
    }
  };
  var BooleanAndExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "equalityExpression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(EqualityExpressionContext);
        } else {
          return this.getTypedRuleContext(EqualityExpressionContext, i2);
        }
      });
      __publicField(this, "AND", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.AND);
        } else {
          return this.getToken(FormulaParser.AND, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_booleanAndExpression;
    }
  };
  var EqualityExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "relationalExpression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(RelationalExpressionContext);
        } else {
          return this.getTypedRuleContext(RelationalExpressionContext, i2);
        }
      });
      __publicField(this, "EQUALS", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.EQUALS);
        } else {
          return this.getToken(FormulaParser.EQUALS, i2);
        }
      });
      __publicField(this, "NOTEQUALS", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.NOTEQUALS);
        } else {
          return this.getToken(FormulaParser.NOTEQUALS, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_equalityExpression;
    }
  };
  var RelationalExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "additiveExpression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(AdditiveExpressionContext);
        } else {
          return this.getTypedRuleContext(AdditiveExpressionContext, i2);
        }
      });
      __publicField(this, "LT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.LT);
        } else {
          return this.getToken(FormulaParser.LT, i2);
        }
      });
      __publicField(this, "LTEQ", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.LTEQ);
        } else {
          return this.getToken(FormulaParser.LTEQ, i2);
        }
      });
      __publicField(this, "GT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.GT);
        } else {
          return this.getToken(FormulaParser.GT, i2);
        }
      });
      __publicField(this, "GTEQ", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.GTEQ);
        } else {
          return this.getToken(FormulaParser.GTEQ, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_relationalExpression;
    }
  };
  var AdditiveExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "multiplicativeExpression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(MultiplicativeExpressionContext);
        } else {
          return this.getTypedRuleContext(MultiplicativeExpressionContext, i2);
        }
      });
      __publicField(this, "PLUS", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.PLUS);
        } else {
          return this.getToken(FormulaParser.PLUS, i2);
        }
      });
      __publicField(this, "MINUS", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.MINUS);
        } else {
          return this.getToken(FormulaParser.MINUS, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_additiveExpression;
    }
  };
  var MultiplicativeExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "arrayExpression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(ArrayExpressionContext);
        } else {
          return this.getTypedRuleContext(ArrayExpressionContext, i2);
        }
      });
      __publicField(this, "MULT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.MULT);
        } else {
          return this.getToken(FormulaParser.MULT, i2);
        }
      });
      __publicField(this, "DIV", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.DIV);
        } else {
          return this.getToken(FormulaParser.DIV, i2);
        }
      });
      __publicField(this, "MOD", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.MOD);
        } else {
          return this.getToken(FormulaParser.MOD, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_multiplicativeExpression;
    }
  };
  var ArrayExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "negationExpression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(NegationExpressionContext);
        } else {
          return this.getTypedRuleContext(NegationExpressionContext, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_arrayExpression;
    }
  };
  var NegationExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_negationExpression;
    }
    MINUS() {
      return this.getToken(FormulaParser.MINUS, 0);
    }
    powerExpression() {
      return this.getTypedRuleContext(PowerExpressionContext, 0);
    }
  };
  var PowerExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "POW", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.POW);
        } else {
          return this.getToken(FormulaParser.POW, i2);
        }
      });
      __publicField(this, "unaryOrNegate", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(UnaryOrNegateContext);
        } else {
          return this.getTypedRuleContext(UnaryOrNegateContext, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_powerExpression;
    }
    unaryExpression() {
      return this.getTypedRuleContext(UnaryExpressionContext, 0);
    }
  };
  var UnaryOrNegateContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_unaryOrNegate;
    }
    MINUS() {
      return this.getToken(FormulaParser.MINUS, 0);
    }
    unaryExpression() {
      return this.getTypedRuleContext(UnaryExpressionContext, 0);
    }
  };
  var UnaryExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_unaryExpression;
    }
    innerPrimaryExpression() {
      return this.getTypedRuleContext(InnerPrimaryExpressionContext, 0);
    }
  };
  var InnerPrimaryExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_innerPrimaryExpression;
    }
    selectionExpression() {
      return this.getTypedRuleContext(SelectionExpressionContext, 0);
    }
  };
  var SelectionExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "selector", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(SelectorContext);
        } else {
          return this.getTypedRuleContext(SelectorContext, i2);
        }
      });
      __publicField(this, "funCall", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(FunCallContext);
        } else {
          return this.getTypedRuleContext(FunCallContext, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_selectionExpression;
    }
    primaryExpression() {
      return this.getTypedRuleContext(PrimaryExpressionContext, 0);
    }
  };
  var FunCallContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "logicalExpression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(LogicalExpressionContext);
        } else {
          return this.getTypedRuleContext(LogicalExpressionContext, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_funCall;
    }
  };
  var PrimaryExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "R__", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R__);
        } else {
          return this.getToken(FormulaParser.R__, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_primaryExpression;
    }
    logicalExpression() {
      return this.getTypedRuleContext(LogicalExpressionContext, 0);
    }
    value() {
      return this.getTypedRuleContext(ValueContext, 0);
    }
  };
  var ValueContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_value;
    }
    number() {
      return this.getTypedRuleContext(NumberContext, 0);
    }
    BOOL() {
      return this.getToken(FormulaParser.BOOL, 0);
    }
    string() {
      return this.getTypedRuleContext(StringContext, 0);
    }
    material() {
      return this.getTypedRuleContext(MaterialContext, 0);
    }
    IDENT() {
      return this.getToken(FormulaParser.IDENT, 0);
    }
    PRIMITIVE() {
      return this.getToken(FormulaParser.PRIMITIVE, 0);
    }
    array() {
      return this.getTypedRuleContext(ArrayContext, 0);
    }
    anonFunctionDef() {
      return this.getTypedRuleContext(AnonFunctionDefContext, 0);
    }
    newObject() {
      return this.getTypedRuleContext(NewObjectContext, 0);
    }
  };
  var MaterialContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_material;
    }
    LCURL() {
      return this.getToken(FormulaParser.LCURL, 0);
    }
    additiveExpression() {
      return this.getTypedRuleContext(AdditiveExpressionContext, 0);
    }
    unitMultiplicativeExpression() {
      return this.getTypedRuleContext(UnitMultiplicativeExpressionContext, 0);
    }
    RCURL() {
      return this.getToken(FormulaParser.RCURL, 0);
    }
  };
  var ArrayContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "label", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(LabelContext);
        } else {
          return this.getTypedRuleContext(LabelContext, i2);
        }
      });
      __publicField(this, "R__", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R__);
        } else {
          return this.getToken(FormulaParser.R__, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      __publicField(this, "logicalExpression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(LogicalExpressionContext);
        } else {
          return this.getTypedRuleContext(LogicalExpressionContext, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_array;
    }
    LARR() {
      return this.getToken(FormulaParser.LARR, 0);
    }
    RARR() {
      return this.getToken(FormulaParser.RARR, 0);
    }
    LCURL() {
      return this.getToken(FormulaParser.LCURL, 0);
    }
    RCURL() {
      return this.getToken(FormulaParser.RCURL, 0);
    }
  };
  var NewObjectContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_newObject;
    }
    NEWSTATEMENT() {
      return this.getToken(FormulaParser.NEWSTATEMENT, 0);
    }
    R_() {
      return this.getToken(FormulaParser.R_, 0);
    }
    IDENT() {
      return this.getToken(FormulaParser.IDENT, 0);
    }
    funCall() {
      return this.getTypedRuleContext(FunCallContext, 0);
    }
  };
  var DefaultValueContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_defaultValue;
    }
    negnumber() {
      return this.getTypedRuleContext(NegnumberContext, 0);
    }
    number() {
      return this.getTypedRuleContext(NumberContext, 0);
    }
    BOOL() {
      return this.getToken(FormulaParser.BOOL, 0);
    }
    string() {
      return this.getTypedRuleContext(StringContext, 0);
    }
    array() {
      return this.getTypedRuleContext(ArrayContext, 0);
    }
  };
  var SelectorContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_selector;
    }
    minarray() {
      return this.getTypedRuleContext(MinarrayContext, 0);
    }
    dotselector() {
      return this.getTypedRuleContext(DotselectorContext, 0);
    }
  };
  var MinarrayContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "logicalExpression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(LogicalExpressionContext);
        } else {
          return this.getTypedRuleContext(LogicalExpressionContext, i2);
        }
      });
      __publicField(this, "MULT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.MULT);
        } else {
          return this.getToken(FormulaParser.MULT, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_minarray;
    }
    LARR() {
      return this.getToken(FormulaParser.LARR, 0);
    }
    RARR() {
      return this.getToken(FormulaParser.RARR, 0);
    }
    LCURL() {
      return this.getToken(FormulaParser.LCURL, 0);
    }
    RCURL() {
      return this.getToken(FormulaParser.RCURL, 0);
    }
  };
  var DotselectorContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "arrayName", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(ArrayNameContext);
        } else {
          return this.getTypedRuleContext(ArrayNameContext, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_dotselector;
    }
  };
  var ArrayNameContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_arrayName;
    }
    IDENT() {
      return this.getToken(FormulaParser.IDENT, 0);
    }
    STRING() {
      return this.getToken(FormulaParser.STRING, 0);
    }
    MULT() {
      return this.getToken(FormulaParser.MULT, 0);
    }
  };
  var LabelContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "R__", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R__);
        } else {
          return this.getToken(FormulaParser.R__, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_label;
    }
    arrayName() {
      return this.getTypedRuleContext(ArrayNameContext, 0);
    }
    logicalExpression() {
      return this.getTypedRuleContext(LogicalExpressionContext, 0);
    }
  };
  var NumberContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_number;
    }
    INTEGER() {
      return this.getToken(FormulaParser.INTEGER, 0);
    }
    FLOAT() {
      return this.getToken(FormulaParser.FLOAT, 0);
    }
  };
  var NegnumberContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_negnumber;
    }
    MINUS() {
      return this.getToken(FormulaParser.MINUS, 0);
    }
    number() {
      return this.getTypedRuleContext(NumberContext, 0);
    }
  };
  var UnitMultiplicativeExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "unitInnerMultiplicativeExpression", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(UnitInnerMultiplicativeExpressionContext);
        } else {
          return this.getTypedRuleContext(UnitInnerMultiplicativeExpressionContext, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      __publicField(this, "PER", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.PER);
        } else {
          return this.getToken(FormulaParser.PER, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_unitMultiplicativeExpression;
    }
  };
  var UnitInnerMultiplicativeExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "unitClump", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTypedRuleContexts(UnitClumpContext);
        } else {
          return this.getTypedRuleContext(UnitClumpContext, i2);
        }
      });
      __publicField(this, "MULT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.MULT);
        } else {
          return this.getToken(FormulaParser.MULT, i2);
        }
      });
      __publicField(this, "DIV", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.DIV);
        } else {
          return this.getToken(FormulaParser.DIV, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_unitInnerMultiplicativeExpression;
    }
  };
  var UnitClumpContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_unitClump;
    }
    unitPowerExpression() {
      return this.getTypedRuleContext(UnitPowerExpressionContext, 0);
    }
    INTEGER() {
      return this.getToken(FormulaParser.INTEGER, 0);
    }
    DIV() {
      return this.getToken(FormulaParser.DIV, 0);
    }
    CUBED() {
      return this.getToken(FormulaParser.CUBED, 0);
    }
    SQUARED() {
      return this.getToken(FormulaParser.SQUARED, 0);
    }
  };
  var UnitPowerExpressionContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "POW", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.POW);
        } else {
          return this.getToken(FormulaParser.POW, i2);
        }
      });
      __publicField(this, "INTEGER", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.INTEGER);
        } else {
          return this.getToken(FormulaParser.INTEGER, i2);
        }
      });
      __publicField(this, "FLOAT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.FLOAT);
        } else {
          return this.getToken(FormulaParser.FLOAT, i2);
        }
      });
      __publicField(this, "MINUS", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.MINUS);
        } else {
          return this.getToken(FormulaParser.MINUS, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_unitPowerExpression;
    }
    unit() {
      return this.getTypedRuleContext(UnitContext, 0);
    }
  };
  var UnitContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      __publicField(this, "IDENT", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.IDENT);
        } else {
          return this.getToken(FormulaParser.IDENT, i2);
        }
      });
      __publicField(this, "R_", function(i2) {
        if (i2 === void 0) {
          i2 = null;
        }
        if (i2 === null) {
          return this.getTokens(FormulaParser.R_);
        } else {
          return this.getToken(FormulaParser.R_, i2);
        }
      });
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_unit;
    }
    unitMultiplicativeExpression() {
      return this.getTypedRuleContext(UnitMultiplicativeExpressionContext, 0);
    }
  };
  var StringContext = class extends M.ParserRuleContext {
    constructor(parser, parent, invokingState) {
      if (parent === void 0) {
        parent = null;
      }
      if (invokingState === void 0 || invokingState === null) {
        invokingState = -1;
      }
      super(parent, invokingState);
      this.parser = parser;
      this.ruleIndex = FormulaParser.RULE_string;
    }
    STRING() {
      return this.getToken(FormulaParser.STRING, 0);
    }
  };
  FormulaParser.LinesContext = LinesContext;
  FormulaParser.ExpressionContext = ExpressionContext;
  FormulaParser.ReturnExpContext = ReturnExpContext;
  FormulaParser.InnerBlockContext = InnerBlockContext;
  FormulaParser.WhileLoopContext = WhileLoopContext;
  FormulaParser.ForLoopContext = ForLoopContext;
  FormulaParser.ForInLoopContext = ForInLoopContext;
  FormulaParser.IfThenElseContext = IfThenElseContext;
  FormulaParser.FunctionDefContext = FunctionDefContext;
  FormulaParser.TryCatchContext = TryCatchContext;
  FormulaParser.ThrowExpContext = ThrowExpContext;
  FormulaParser.AnonFunctionDefContext = AnonFunctionDefContext;
  FormulaParser.AssignmentContext = AssignmentContext;
  FormulaParser.AssignedContext = AssignedContext;
  FormulaParser.LogicalExpressionContext = LogicalExpressionContext;
  FormulaParser.BooleanXORExpressionContext = BooleanXORExpressionContext;
  FormulaParser.BooleanAndExpressionContext = BooleanAndExpressionContext;
  FormulaParser.EqualityExpressionContext = EqualityExpressionContext;
  FormulaParser.RelationalExpressionContext = RelationalExpressionContext;
  FormulaParser.AdditiveExpressionContext = AdditiveExpressionContext;
  FormulaParser.MultiplicativeExpressionContext = MultiplicativeExpressionContext;
  FormulaParser.ArrayExpressionContext = ArrayExpressionContext;
  FormulaParser.NegationExpressionContext = NegationExpressionContext;
  FormulaParser.PowerExpressionContext = PowerExpressionContext;
  FormulaParser.UnaryOrNegateContext = UnaryOrNegateContext;
  FormulaParser.UnaryExpressionContext = UnaryExpressionContext;
  FormulaParser.InnerPrimaryExpressionContext = InnerPrimaryExpressionContext;
  FormulaParser.SelectionExpressionContext = SelectionExpressionContext;
  FormulaParser.FunCallContext = FunCallContext;
  FormulaParser.PrimaryExpressionContext = PrimaryExpressionContext;
  FormulaParser.ValueContext = ValueContext;
  FormulaParser.MaterialContext = MaterialContext;
  FormulaParser.ArrayContext = ArrayContext;
  FormulaParser.NewObjectContext = NewObjectContext;
  FormulaParser.DefaultValueContext = DefaultValueContext;
  FormulaParser.SelectorContext = SelectorContext;
  FormulaParser.MinarrayContext = MinarrayContext;
  FormulaParser.DotselectorContext = DotselectorContext;
  FormulaParser.ArrayNameContext = ArrayNameContext;
  FormulaParser.LabelContext = LabelContext;
  FormulaParser.NumberContext = NumberContext;
  FormulaParser.NegnumberContext = NegnumberContext;
  FormulaParser.UnitMultiplicativeExpressionContext = UnitMultiplicativeExpressionContext;
  FormulaParser.UnitInnerMultiplicativeExpressionContext = UnitInnerMultiplicativeExpressionContext;
  FormulaParser.UnitClumpContext = UnitClumpContext;
  FormulaParser.UnitPowerExpressionContext = UnitPowerExpressionContext;
  FormulaParser.UnitContext = UnitContext;
  FormulaParser.StringContext = StringContext;

  // ../insight-maker-simulation/src/formula/Formula.js
  var PARENT_SYMBOL = /* @__PURE__ */ Symbol("-parent");
  function bootCalc(simulate) {
    simulate.coreBank = /* @__PURE__ */ new Map();
    simulate.coreBank.set(PARENT_SYMBOL, null);
    simulate.varBank = /* @__PURE__ */ new Map();
    simulate.varBank.set(PARENT_SYMBOL, null);
    simulate.varBank.set("e", new Material(Math.E));
    simulate.varBank.set("pi", new Material(Math.PI));
    simulate.varBank.set("phi", new Material(1.61803399));
    createFunctions2(simulate);
    createFunctions(simulate);
  }
  function getInnerBlock(node, parser, source) {
    let innerBlock = node.children.find((x2) => x2 instanceof FormulaParser.InnerBlockContext);
    if (!innerBlock || !innerBlock.children) {
      return new TreeNode("", "LINES", {
        line: node.start.line,
        source
      });
    }
    return convertToObject(innerBlock, parser, source);
  }
  var PrimitiveStore = class {
    /**
     * @param {any} primitive
     * @param {string} type
     */
    constructor(primitive, type) {
      this.primitive = primitive;
      this.type = type;
    }
  };
  function toNum(x2) {
    if (x2 instanceof Material || x2 instanceof SPrimitive || x2 instanceof Vector || x2 instanceof UserFunction || x2 instanceof SPopulation) {
      return (
        /** @type {any} */
        x2.toNum()
      );
    }
    if (x2 instanceof Function) {
      return x2([]);
    }
    return (
      /** @type {any} */
      x2.valueOf()
    );
  }
  var UserFunction = class {
    constructor() {
      this.localScope = void 0;
      this.defaults = void 0;
      this.fn = void 0;
    }
    toNum() {
      return this.fn([]);
    }
  };
  var StringObject = {};
  var VectorObject = {};
  function getErrorSnippet(input, line, column) {
    const PADDING_CHARS = 4;
    const lines = input.split("\n");
    if (line < 1 || line > lines.length) {
      return null;
    }
    const errorLine = lines[line - 1];
    const start2 = Math.max(0, column - PADDING_CHARS);
    const end = Math.min(errorLine.length, column + PADDING_CHARS);
    const prefix = start2 > 0 ? "..." : "";
    const suffix = end < errorLine.length ? "..." : "";
    return prefix + errorLine.substring(start2, end) + suffix;
  }
  function createTree(input, source, simulate) {
    simulate.evaluatingPosition = {
      line: 1,
      source
    };
    const chars = new M.InputStream(input);
    const lexer = new FormulaLexer(chars);
    lexer.removeErrorListeners();
    lexer.addErrorListener({
      syntaxError: (recognizer, offendingSymbol, line, column, msg, err) => {
        simulate.evaluatingPosition.line = line;
        let snippet = getErrorSnippet(input, line, column);
        if (snippet !== null) {
          snippet = ` at "${snippet}"`;
        } else {
          snippet = "";
        }
        throw new ModelError(`Invalid equation syntax${snippet}`, {
          code: 9e3
        });
      }
    });
    const tokens = new M.CommonTokenStream(lexer);
    const parser = new FormulaParser(tokens);
    parser._interp.predictionMode = M.atn.PredictionMode.SLL;
    parser.errorHandler = new M.error.BailErrorStrategy();
    parser.removeErrorListeners();
    parser.addErrorListener({
      syntaxError: (recognizer, offendingSymbol, line, column, msg, err) => {
        simulate.evaluatingPosition.line = line;
        throw new ModelError(`Invalid equation syntax at "${getErrorSnippet(input, line, column)}"`, {
          code: 9e3
        });
      },
      reportAttemptingFullContext: (...args) => {
      },
      reportAmbiguity: (...args) => {
      },
      reportContextSensitivity: (...args) => {
      }
    });
    const parsedTree = parser.lines();
    removeWhitespaceTokens(parsedTree);
    let root2 = convertToObject(parsedTree, parser, source);
    return root2;
  }
  function removeWhitespaceTokens(node) {
    if (node.children) {
      node.children = node.children.filter((x2) => {
        if (x2.symbol?.type === FormulaLexer.R_ || x2.symbol?.type === FormulaLexer.R__) {
          return false;
        }
        removeWhitespaceTokens(x2);
        return true;
      });
    }
  }
  function trimTree(root2, nodeBase2, simulate) {
    return trimNode(root2, nodeBase2, simulate);
  }
  function evaluateTree(root2, varBank, simulate) {
    simulate.evaluatingPosition = {
      line: null,
      source: null
    };
    try {
      return evaluateNode(root2, varBank, simulate);
    } catch (err) {
      if (err.returnVal) {
        return err.data;
      } else {
        throw err;
      }
    }
  }
  var TreeNode = class _TreeNode {
    /**
     * @param {string} text
     * @param {string} typeName
     * @param {{ line: number, source: string }} position
     * @param {any[]=} children
     */
    constructor(text, typeName, position2, children3 = []) {
      this.origText = text;
      this.text = text.toLowerCase();
      this.typeName = typeName;
      this.position = position2;
      this.children = children3;
      this.functionFingerprint = null;
      this.delayEvalParams = null;
    }
    cloneStructure() {
      let res = new _TreeNode(this.origText, this.typeName, this.position);
      res.children = this.children.map((child) => {
        if (child instanceof _TreeNode) {
          return child.cloneStructure();
        }
        console.error(this, child);
        throw new TypeError("Unknown structure clone type");
      });
      return res;
    }
  };
  function flatChildrenToTreeRight(node, fn2, parser, source) {
    let children3 = node.children.slice();
    let isFirst = true;
    while (children3.length > 1) {
      let right = children3.pop();
      let operator = children3.pop();
      let left = children3.pop();
      let current = fn2(operator);
      current.children = [convertToObject(left, parser, source), isFirst ? convertToObject(right, parser, source) : right];
      children3.push(current);
      isFirst = false;
    }
    return children3[0];
  }
  function flatChildrenToTreeLeft(node, fn2, parser, source) {
    let children3 = node.children.slice();
    let isFirst = true;
    while (children3.length > 1) {
      let left = children3.shift();
      let operator = children3.shift();
      let right = children3.shift();
      let current = fn2(operator);
      current.children = [isFirst ? convertToObject(left, parser, source) : left, convertToObject(right, parser, source)];
      children3.unshift(current);
      isFirst = false;
    }
    return children3[0];
  }
  var nodeTexts = /* @__PURE__ */ new WeakMap();
  function getNodeText(node) {
    let t2 = nodeTexts.get(node);
    if (t2 !== void 0) {
      return t2;
    }
    let text = node.getText();
    nodeTexts.set(node, text);
    return text;
  }
  function convertToObject(node, parser, source) {
    let ruleIndex = node.ruleIndex;
    if (ruleIndex === FormulaParser.RULE_lines) {
      let current = new TreeNode("", "LINES", {
        line: node.start.line,
        source
      });
      let children3 = node.children;
      for (let i2 = 0; i2 < children3.length; i2++) {
        if (getNodeText(children3[i2]) === "<EOF>") {
          continue;
        }
        if (getNodeText(children3[i2]) === "\n" || getNodeText(children3[i2]) === "\r\n") {
          continue;
        }
        current.children.push(convertToObject(children3[i2], parser, source));
        if (!current.position?.line && current.children[current.children.length - 1].position?.line) {
          current.position = current.children[current.children.length - 1].position;
        }
      }
      return current;
    } else if (ruleIndex === FormulaParser.RULE_multiplicativeExpression) {
      if (node.children.length > 1) {
        return flatChildrenToTreeLeft(node, (op) => {
          let operator = getNodeText(op);
          return new TreeNode("", operator === "*" ? "MULT" : operator === "/" ? "DIV" : "MOD", {
            // @ts-ignore
            line: (op.start || op.symbol).line,
            source
          });
        }, parser, source);
      }
    } else if (ruleIndex === FormulaParser.RULE_number) {
      let current = new TreeNode(getNodeText(node), "FLOAT", {
        line: node.start.line,
        source
      });
      return current;
    } else if (ruleIndex === FormulaParser.RULE_value) {
      let token = node.children[0];
      let symbol = token.symbol;
      if (symbol) {
        if (symbol.type === FormulaLexer.BOOL) {
          return new TreeNode(getNodeText(token), getNodeText(token).toLowerCase() === "true" ? "TRUE" : "FALSE", {
            line: symbol.line,
            source
          });
        } else if (symbol.type === FormulaLexer.STRING) {
          return new TreeNode(getNodeText(token), "STRING", {
            line: symbol.line,
            source
          });
        } else if (symbol.type === FormulaLexer.IDENT) {
          return new TreeNode(getNodeText(token), "IDENT", {
            line: symbol.line,
            source
          });
        } else if (symbol.type === FormulaLexer.PRIMITIVE) {
          return new TreeNode(getNodeText(token), "PRIMITIVE", {
            line: node.start.line,
            source
          });
        }
      }
    } else if (node.symbol?.type === FormulaLexer.BOOL) {
      return new TreeNode("", getNodeText(node).toLowerCase() === "true" ? "TRUE" : "FALSE", {
        // @ts-ignore
        line: node.symbol.line,
        source
      });
    } else if (ruleIndex === FormulaParser.RULE_returnExp) {
      let current = new TreeNode("return", "RETURN", {
        line: node.start.line,
        source
      }, [convertToObject(node.children[1], parser, source)]);
      return current;
    } else if (ruleIndex === FormulaParser.RULE_throwExp) {
      let current = new TreeNode("", "THROW", {
        line: node.start.line,
        source
      }, [convertToObject(node.children[1], parser, source)]);
      return current;
    } else if (ruleIndex === FormulaParser.RULE_additiveExpression) {
      if (node.children.length > 1) {
        return flatChildrenToTreeLeft(node, (op) => {
          let operator = getNodeText(op);
          return new TreeNode(getNodeText(op), operator === "+" ? "PLUS" : "MINUS", {
            // @ts-ignore
            line: (op.start || op.symbol).line,
            source
          });
        }, parser, source);
      }
    } else if (ruleIndex === FormulaParser.RULE_powerExpression) {
      if (node.children.length > 1) {
        return flatChildrenToTreeRight(node, (op) => {
          return new TreeNode("", "POWER", {
            // @ts-ignore
            line: (op.start || op.symbol).line,
            source
          });
        }, parser, source);
      }
    } else if (ruleIndex === FormulaParser.RULE_unaryOrNegate) {
      if (node.children.length > 1) {
        let current = new TreeNode("", "NEGATE", {
          line: node.start.line,
          source
        });
        current.children = [convertToObject(node.children[1], parser, source)];
        return current;
      }
    } else if (ruleIndex === FormulaParser.RULE_arrayExpression) {
      if (node.children.length > 1) {
        let current = new TreeNode("", "RANGE", {
          line: node.start.line,
          source
        });
        current.children = [convertToObject(node.children[0], parser, source), convertToObject(node.children[2], parser, source)];
        if (node.children.length > 3) {
          current.children.push(convertToObject(node.children[4], parser, source));
        }
        return current;
      }
    } else if (ruleIndex === FormulaParser.RULE_unaryExpression) {
      if (node.children.length > 1) {
        let current = new TreeNode("", "NOT", {
          line: node.start.line,
          source
        });
        current.children = [convertToObject(node.children[1], parser, source)];
        return current;
      }
    } else if (ruleIndex === FormulaParser.RULE_booleanXORExpression) {
      if (node.children.length > 1) {
        return flatChildrenToTreeLeft(node, (op) => {
          return new TreeNode("", "XOR", {
            // @ts-ignore
            line: (op.start || op.symbol).line,
            source
          });
        }, parser, source);
      }
    } else if (ruleIndex === FormulaParser.RULE_equalityExpression) {
      if (node.children.length > 1) {
        return flatChildrenToTreeLeft(node, (op) => {
          let operator = getNodeText(op);
          return new TreeNode("", operator === "=" || operator === "==" ? "EQUALS" : "NOTEQUALS", {
            // @ts-ignore
            line: (op.start || op.symbol).line,
            source
          });
        }, parser, source);
      }
    } else if (ruleIndex === FormulaParser.RULE_relationalExpression) {
      if (node.children.length > 1) {
        return flatChildrenToTreeLeft(node, (op) => {
          let operator = getNodeText(op);
          return new TreeNode("", operator === "<" ? "LT" : operator === ">" ? "GT" : operator === "<=" ? "LTEQ" : "GTEQ", {
            // @ts-ignore
            line: (op.start || op.symbol).line,
            source
          });
        }, parser, source);
      }
    } else if (ruleIndex === FormulaParser.RULE_logicalExpression) {
      if (node.children.length > 1) {
        return flatChildrenToTreeLeft(node, (op) => {
          return new TreeNode("", "OR", {
            // @ts-ignore
            line: (op.start || op.symbol).line,
            source
          });
        }, parser, source);
      }
    } else if (ruleIndex === FormulaParser.RULE_booleanAndExpression) {
      if (node.children.length > 1) {
        return flatChildrenToTreeLeft(
          node,
          (op) => {
            return new TreeNode("", "AND", {
              // @ts-ignore
              line: (op.start || op.symbol).line,
              source
            });
          },
          parser,
          source
        );
      }
    } else if (ruleIndex === FormulaParser.RULE_negnumber) {
      return new TreeNode(getNodeText(node), "FLOAT", {
        line: node.start.line,
        source
      });
    } else if (ruleIndex === FormulaParser.RULE_negationExpression) {
      if (node.children.length > 1) {
        let current = new TreeNode("", "NEGATE", {
          line: node.start.line,
          source
        });
        current.children = [convertToObject(node.children[1], parser, source)];
        return current;
      }
    } else if (ruleIndex === FormulaParser.RULE_anonFunctionDef) {
      let current = new TreeNode("", "ANONFUNCTION", {
        line: node.start.line,
        source
      });
      let params = new TreeNode("", "PARAMS", {
        line: node.start.line,
        source
      });
      let defaults = new TreeNode("", "DEFAULTS", {
        line: node.start.line,
        source
      });
      params.children = [];
      defaults.children = [];
      for (let i2 = 2; i2 < node.children.length; i2++) {
        if (getNodeText(node.children[i2]) === ")") {
          break;
        }
        if (getNodeText(node.children[i2]) === ",") {
          continue;
        }
        params.children.push(new TreeNode(getNodeText(node.children[i2]), "IDENT", {
          line: node.start.line,
          source
        }));
        if (getNodeText(node.children[i2 + 1]) === "=") {
          defaults.children.push(convertToObject(node.children[i2 + 2], parser, source));
          i2 += 2;
        }
      }
      current.children = [params, defaults];
      if (node.children[node.children.length - 1] instanceof FormulaParser.ExpressionContext) {
        current.children.push(convertToObject(node.children[node.children.length - 1], parser, source));
      } else {
        current.children.push(getInnerBlock(node, parser, source));
      }
      return current;
    } else if (ruleIndex === FormulaParser.RULE_functionDef) {
      let current = new TreeNode("", "FUNCTION", {
        line: node.start.line,
        source
      });
      let params = new TreeNode("", "PARAMS", {
        line: node.start.line,
        source
      });
      let defaults = new TreeNode("", "DEFAULTS", {
        line: node.start.line,
        source
      });
      params.children.push(new TreeNode(getNodeText(node.children[1]), "IDENT", {
        line: node.start.line,
        source
      }));
      for (let i2 = 3; i2 < node.children.length; i2++) {
        if (getNodeText(node.children[i2]) === ")") {
          break;
        }
        if (getNodeText(node.children[i2]) === ",") {
          continue;
        }
        params.children.push(new TreeNode(getNodeText(node.children[i2]), "IDENT", {
          line: node.start.line,
          source
        }));
        if (getNodeText(node.children[i2 + 1]) === "=") {
          defaults.children.push(convertToObject(node.children[i2 + 2], parser, source));
          i2 += 2;
        }
      }
      current.children = [params, defaults, getInnerBlock(node, parser, source)];
      return current;
    } else if (ruleIndex === FormulaParser.RULE_innerBlock) {
      let current = new TreeNode("", "LINES", {
        line: node.start.line,
        source
      });
      for (let i2 = 0; i2 < node.children?.length; i2++) {
        if (getNodeText(node.children[i2]) === "\n" || getNodeText(node.children[i2]) === "\r\n") {
          continue;
        }
        current.children.push(convertToObject(node.children[i2], parser, source));
      }
      return current;
    } else if (ruleIndex === FormulaParser.RULE_newObject) {
      let current = new TreeNode("", "NEW", {
        line: node.start.line,
        source
      });
      current.children = [new TreeNode(getNodeText(node.children[1]), "IDENT", {
        line: node.start.line,
        source
      })];
      if (node.children.length > 2) {
        current.children.push(convertToObject(node.children[2], parser, source));
      }
      return current;
    } else if (ruleIndex === FormulaParser.RULE_whileLoop) {
      let current = new TreeNode("", "WHILE", {
        line: node.start.line,
        source
      });
      current.children = [
        convertToObject(node.children[1], parser, source),
        getInnerBlock(node, parser, source)
      ];
      return current;
    } else if (ruleIndex === FormulaParser.RULE_forLoop) {
      let current = new TreeNode("", "FOR", {
        line: node.start.line,
        source
      });
      current.children = [
        new TreeNode(getNodeText(node.children[1]), "IDENT", {
          line: node.start.line,
          source
        }),
        new TreeNode(
          "",
          "PARAMS",
          {
            line: node.start.line,
            source
          },
          node.children.filter((x2) => x2 instanceof FormulaParser.LogicalExpressionContext).map((x2) => convertToObject(x2, parser, source))
        ),
        getInnerBlock(node, parser, source)
      ];
      return current;
    } else if (ruleIndex === FormulaParser.RULE_forInLoop) {
      let current = new TreeNode("", "FORIN", {
        line: node.start.line,
        source
      });
      current.children = [
        new TreeNode(getNodeText(node.children[1]), "IDENT", {
          line: node.start.line,
          source
        }),
        convertToObject(node.children[3], parser, source),
        getInnerBlock(node, parser, source)
      ];
      return current;
    } else if (ruleIndex === FormulaParser.RULE_ifThenElse) {
      let current = new TreeNode("", "IFTHENELSE", {
        line: node.start.line,
        source
      });
      let innerBlocks = [];
      let potentialInnerBlocks = node.children.filter((x2) => x2 instanceof FormulaParser.InnerBlockContext || x2.symbol?.type === FormulaLexer.ELSESTATEMENT || x2.symbol?.type === FormulaLexer.ENDBLOCK);
      let hadBlock = false;
      for (let i2 = 0; i2 < potentialInnerBlocks.length; i2++) {
        if (potentialInnerBlocks[i2] instanceof FormulaParser.InnerBlockContext) {
          hadBlock = true;
          innerBlocks.push(convertToObject(potentialInnerBlocks[i2], parser, source));
        } else {
          if (!hadBlock) {
            innerBlocks.push(new TreeNode("", "LINES", {
              line: node.start.line,
              source
            }));
          }
          hadBlock = false;
        }
      }
      current.children = [
        new TreeNode(
          "",
          "PARAMS",
          {
            line: node.start.line,
            source
          },
          node.children.filter((x2) => x2 instanceof FormulaParser.LogicalExpressionContext).map((x2) => convertToObject(x2, parser, source))
        ),
        new TreeNode(
          "",
          "PARAMS",
          {
            line: node.start.line,
            source
          },
          innerBlocks
        )
      ];
      return current;
    } else if (ruleIndex === FormulaParser.RULE_tryCatch) {
      let current = new TreeNode("", "TRYCATCH", {
        line: node.start.line,
        source
      });
      let innerBlocks = [];
      let potentialInnerBlocks = node.children.filter((x2) => x2 instanceof FormulaParser.InnerBlockContext || x2.symbol?.type === FormulaLexer.CATCHSTATEMENT || x2.symbol?.type === FormulaLexer.ENDBLOCK);
      let hadBlock = false;
      for (let i2 = 0; i2 < potentialInnerBlocks.length; i2++) {
        if (potentialInnerBlocks[i2] instanceof FormulaParser.InnerBlockContext) {
          hadBlock = true;
          innerBlocks.push(convertToObject(potentialInnerBlocks[i2], parser, source));
        } else {
          if (!hadBlock) {
            innerBlocks.push(new TreeNode("", "LINES", {
              line: node.start.line,
              source
            }));
          }
          hadBlock = false;
        }
      }
      current.children = innerBlocks;
      current.children.push(new TreeNode(getNodeText(node.children.find((x2) => x2?.symbol?.type === FormulaLexer.IDENT)), "IDENT", {
        line: node.start.line,
        source
      }));
      return current;
    } else if (ruleIndex === FormulaParser.RULE_assignment) {
      if (getNodeText(node.children[1]) === "(") {
        let current = new TreeNode("", "FUNCTION", {
          line: node.start.line,
          source
        });
        let params = new TreeNode("", "PARAMS", {
          line: node.start.line,
          source
        });
        let defaults = new TreeNode("", "DEFAULTS", {
          line: node.start.line,
          source
        });
        params.children.push(new TreeNode(getNodeText(node.children[0]), "IDENT", {
          line: node.start.line,
          source
        }));
        for (let i2 = 2; i2 < node.children.length; i2++) {
          if (getNodeText(node.children[i2]) === "<-") {
            break;
          }
          if (getNodeText(node.children[i2]) === "," || getNodeText(node.children[i2]) === ")") {
            continue;
          }
          params.children.push(new TreeNode(getNodeText(node.children[i2]), "IDENT", {
            line: node.start.line,
            source
          }));
          if (getNodeText(node.children[i2 + 1]) === "=") {
            defaults.children.push(convertToObject(node.children[i2 + 2], parser, source));
            i2 += 2;
          }
        }
        current.children = [params, defaults, convertToObject(node.children[node.children.length - 1], parser, source)];
        return current;
      } else {
        let current = new TreeNode("", "ASSIGN", {
          line: node.start.line,
          source
        });
        for (let i2 = 0; i2 < node.children.length; i2++) {
          if (getNodeText(node.children[i2]) === ",") {
            continue;
          }
          if (getNodeText(node.children[i2]) === "<-") {
            continue;
          }
          if (node.children[i2].symbol?.type === FormulaLexer.PRIMITIVE) {
            current.children.push(new TreeNode(getNodeText(node.children[i2]), "PRIMITIVE", {
              // @ts-ignore
              line: node.children[i2].symbol.line,
              source
            }));
          } else {
            current.children.push(convertToObject(node.children[i2], parser, source));
          }
        }
        return current;
      }
    } else if (ruleIndex === FormulaParser.RULE_assigned) {
      let current = new TreeNode("", "ASSIGNED", {
        line: node.start.line,
        source
      });
      current.children = [
        new TreeNode(getNodeText(node.children[0]), "IDENT", {
          line: node.start.line,
          source
        })
      ];
      for (let i2 = 1; i2 < node.children.length; i2++) {
        current.children.push(convertToObject(node.children[i2], parser, source));
      }
      return current;
    } else if (ruleIndex === FormulaParser.RULE_string) {
      let current = new TreeNode(getNodeText(node), "STRING", {
        line: node.start.line,
        source
      });
      return current;
    } else if (ruleIndex === FormulaParser.RULE_innerPrimaryExpression) {
      let current = new TreeNode("", "INNER", {
        line: node.start.line,
        source
      });
      if (node.children[0] instanceof FormulaParser.SelectionExpressionContext) {
        let selectionExpression = (
          /** @type {any} */
          node.children[0]
        );
        current.children.push(convertToObject(selectionExpression.children[0], parser, source));
        for (let i2 = 1; i2 < selectionExpression.children.length; i2++) {
          current.children.push(convertToObject(selectionExpression.children[i2], parser, source));
        }
      } else {
        for (let i2 = 0; i2 < node.children.length; i2++) {
          current.children.push(convertToObject(node.children[i2], parser, source));
        }
      }
      return current;
    } else if (ruleIndex === FormulaParser.RULE_primaryExpression) {
      if (getNodeText(node.children[0]) === "(") {
        return convertToObject(node.children[1], parser, source);
      }
      return convertToObject(node.children[0], parser, source);
    } else if (ruleIndex === FormulaParser.RULE_selector) {
      let current = new TreeNode("", "SELECTOR", {
        line: node.start.line,
        source
      });
      if (node.children[0] instanceof FormulaParser.MinarrayContext) {
        let minArray = (
          /** @type {any} */
          node.children[0]
        );
        for (let i2 = 1; i2 < minArray.children.length - 1; i2++) {
          if (getNodeText(minArray.children[i2]) === ",") {
            continue;
          }
          if (getNodeText(minArray.children[i2]) === "*") {
            current.children.push(new TreeNode(getNodeText(minArray.children[i2]), "MULT", {
              line: minArray.children[i2].symbol.line,
              source
            }));
            continue;
          }
          current.children.push(convertToObject(minArray.children[i2], parser, source));
        }
      } else {
        current.children = [convertToObject(node.children[0], parser, source)];
      }
      return current;
    } else if (ruleIndex === FormulaParser.RULE_dotselector) {
      let current = new TreeNode("", "DOTSELECTOR", {
        line: node.start.line,
        source
      });
      for (let i2 = 0; i2 < node.children.length; i2++) {
        if (getNodeText(node.children[i2]) === ".") {
          continue;
        }
        current.children.push(convertToObject(node.children[i2], parser, source));
      }
      return current;
    } else if (ruleIndex === FormulaParser.RULE_arrayName) {
      let token = node.children[0];
      let symbol = token.symbol;
      let newNode = null;
      if (symbol.type === FormulaLexer.STRING) {
        newNode = new TreeNode(token.getText(), "STRING", {
          line: symbol.line,
          source
        });
      } else if (symbol.type === FormulaLexer.IDENT) {
        newNode = new TreeNode(token.getText(), "IDENT", {
          line: symbol.line,
          source
        });
      } else if (symbol.type === FormulaLexer.MULT) {
        newNode = new TreeNode(token.getText(), "MULT", {
          line: symbol.line,
          source
        });
      } else {
        console.error(symbol);
        throw new Error("Invalid type - dotselector");
      }
      return newNode;
    } else if (ruleIndex === FormulaParser.RULE_funCall) {
      let current = new TreeNode("", "FUNCALL", {
        line: node.start.line,
        source
      });
      for (let i2 = 1; i2 < node.children.length - 1; i2++) {
        if (getNodeText(node.children[i2]) === ",") {
          continue;
        }
        current.children.push(convertToObject(node.children[i2], parser, source));
      }
      return current;
    } else if (ruleIndex === FormulaParser.RULE_material) {
      let current = new TreeNode(getNodeText(node), "MATERIAL", {
        line: node.start.line,
        source
      });
      current.children = [convertToObject(node.children[2], parser, source), convertToObject(node.children[1], parser, source)];
      return current;
    } else if (ruleIndex === FormulaParser.RULE_unitMultiplicativeExpression) {
      if (node.children.length > 1) {
        return flatChildrenToTreeLeft(node, (op) => {
          return new TreeNode("", "PER", {
            // @ts-ignore
            line: (op.start || op.symbol).line,
            source
          });
        }, parser, source);
      }
    } else if (ruleIndex === FormulaParser.RULE_unitInnerMultiplicativeExpression) {
      if (node.children.length > 1) {
        return flatChildrenToTreeLeft(node, (op) => {
          let operator = getNodeText(op);
          return new TreeNode("", operator === "*" ? "MULT" : "DIV", {
            // @ts-ignore
            line: (op.start || op.symbol).line,
            source
          });
        }, parser, source);
      }
    } else if (ruleIndex === FormulaParser.RULE_unitPowerExpression) {
      if (node.children.length > 1) {
        let children3 = (
          /** @type {any} */
          node.children.slice()
        );
        let isFirst = true;
        while (children3.length > 1) {
          let left = children3.shift();
          let operator = children3.shift();
          let minus2;
          let right;
          let minusOrRight = children3.shift();
          if (getNodeText(minusOrRight) === "-") {
            minus2 = minusOrRight;
            right = children3.pop();
          } else {
            right = minusOrRight;
          }
          let current = new TreeNode("", "POW", {
            // @ts-ignore
            line: (operator.start || operator.symbol).line,
            source
          });
          current.children = [isFirst ? convertToObject(left, parser, source) : left, new TreeNode(getNodeText(right), "FLOAT", {
            line: right.symbol.line,
            source
          })];
          if (minus2) {
            current.children.splice(1, 0, new TreeNode("", "MINUS", {
              // @ts-ignore
              line: (minus2.start || minus2.symbol).line,
              source
            }));
          }
          children3.push(current);
          isFirst = false;
        }
        return children3[0];
      }
    } else if (ruleIndex === FormulaParser.RULE_unitClump) {
      if (Number.isInteger(+getNodeText(node.children[0]))) {
        let current = new TreeNode("", "UNITCLUMP", {
          line: node.start.line,
          source
        });
        current.children = [convertToObject(node.children[2], parser, source), new TreeNode("", "NEGATE", {
          line: node.start.line,
          source
        })];
        for (let i2 = 3; i2 < node.children.length; i2++) {
          if (getNodeText(node.children[i2]).toLowerCase() === "cubed") {
            current.children.push(new TreeNode("", "CUBED", {
              line: node.start.line,
              source
            }));
          } else if (getNodeText(node.children[i2]).toLowerCase() === "squared") {
            current.children.push(new TreeNode("", "SQUARED", {
              line: node.start.line,
              source
            }));
          }
        }
        return current;
      } else {
        let current = new TreeNode("", "UNITCLUMP", {
          line: node.start.line,
          source
        });
        current.children = [convertToObject(node.children[0], parser, source)];
        for (let i2 = 1; i2 < node.children.length; i2++) {
          if (getNodeText(node.children[i2]).toLowerCase() === "cubed") {
            current.children.push(new TreeNode("", "CUBED", {
              line: node.start.line,
              source
            }));
          } else if (getNodeText(node.children[i2]).toLowerCase() === "squared") {
            current.children.push(new TreeNode("", "SQUARED", {
              line: node.start.line,
              source
            }));
          }
        }
        return current;
      }
    } else if (ruleIndex === FormulaParser.RULE_unit) {
      if (getNodeText(node.children[0]) === "(") {
        let current = new TreeNode("", "UNITCLUMP", {
          line: node.start.line,
          source
        });
        current.children = [convertToObject(node.children[1], parser, source)];
        return current;
      } else {
        let current = new TreeNode("", "UNIT", {
          line: node.start.line,
          source
        });
        for (let i2 = 0; i2 < node.children.length; i2++) {
          let token = node.children[i2];
          let symbol = token.symbol;
          current.children.push(new TreeNode(token.getText(), "IDENT", {
            line: symbol.line,
            source
          }));
        }
        return current;
      }
    } else if (ruleIndex === FormulaParser.RULE_array) {
      let current = new TreeNode("", "ARRAY", {
        line: node.start.line,
        source
      });
      for (let i2 = 1; i2 < node.children.length - 1; i2++) {
        if (getNodeText(node.children[i2]) === "{" || getNodeText(node.children[i2]) === "," || getNodeText(node.children[i2]) === "\n" || getNodeText(node.children[i2]) === "\r\n" || getNodeText(node.children[i2]) === "}") {
          continue;
        }
        if (node.children[i2] instanceof FormulaParser.LabelContext) {
          current.children.push(convertToObject(node.children[i2], parser, source));
        } else {
          current.children.push(new TreeNode(getNodeText(node), "LABEL", {
            line: node.start.line,
            source
          }, [convertToObject(node.children[i2], parser, source)]));
        }
      }
      return current;
    } else if (ruleIndex === FormulaParser.RULE_label) {
      let current = new TreeNode(getNodeText(node), "LABEL", {
        line: node.start.line,
        source
      });
      let children3 = node.children.slice();
      children3 = children3.filter((child) => getNodeText(child) !== "\n" && getNodeText(child) !== "\r\n");
      if (children3.length === 1) {
        current.children = [convertToObject(children3[0], parser, source)];
      } else {
        current.children = [convertToObject(children3[2], parser, source), convertToObject(children3[0], parser, source)];
      }
      return current;
    }
    if (node.children.length === 1) {
      return convertToObject(node.children[0], parser, source);
    }
    throw new ModelError("Unknown invalid equation syntax", {
      code: 9002
    });
  }
  var funcEvalMap = /* @__PURE__ */ Object.create(null);
  funcEvalMap["LINES"] = function(node, scope, simulate) {
    if (!node.children.length) {
      return new Material(0);
    }
    let response;
    for (let child of node.children) {
      if (child.text === "return") {
        throw { returnVal: true, data: evaluateNode(child.children[0], scope, simulate) };
      } else {
        response = evaluateNode(child, scope, simulate);
      }
    }
    return response;
  };
  funcEvalMap["NEGATE"] = function(node, scope, simulate) {
    return negate(toNum(evaluateNode(node.children[0], scope, simulate)));
  };
  function negate(x2) {
    if (x2 instanceof Vector) {
      return (
        /** @type {any} */
        x2.cloneApply(negate)
      );
    } else if (x2 instanceof Material) {
      return (
        /** @type {any} */
        new Material(fn["-"](x2.value), x2.units)
      );
    }
    if (typeof x2 === "boolean") {
      throw new ModelError("Cannot convert Booleans to Numbers.", {
        code: 7001
      });
    }
    if (x2 instanceof String || typeof x2 === "string") {
      throw new ModelError("Cannot convert Strings to Numbers.", {
        code: 7002
      });
    }
    if (x2 instanceof SAgent) {
      throw new ModelError("Cannot convert Agents to Numbers.", {
        code: 7003
      });
    }
    throw new ModelError("Invalid type - negate", {
      code: 7004
    });
  }
  funcEvalMap["AND"] = function(node, scope, simulate) {
    return funAnd(toNum(evaluateNode(node.children[0], scope, simulate)), toNum(evaluateNode(node.children[1], scope, simulate)));
  };
  function funAnd(lhs, rhs) {
    if (lhs instanceof Vector) {
      return lhs.cloneCombine(rhs, funAnd, false);
    } else if (rhs instanceof Vector) {
      return rhs.cloneCombine(lhs, funAnd, true);
    }
    return trueValue(lhs) && trueValue(rhs);
  }
  funcEvalMap["OR"] = function(node, scope, simulate) {
    return funOr(toNum(evaluateNode(node.children[0], scope, simulate)), toNum(evaluateNode(node.children[1], scope, simulate)));
  };
  function funOr(lhs, rhs) {
    if (lhs instanceof Vector) {
      return lhs.cloneCombine(rhs, funOr, false);
    } else if (rhs instanceof Vector) {
      return rhs.cloneCombine(lhs, funOr, true);
    }
    return trueValue(lhs) || trueValue(rhs);
  }
  funcEvalMap["XOR"] = function(node, scope, simulate) {
    return funXor(toNum(evaluateNode(node.children[0], scope, simulate)), toNum(evaluateNode(node.children[1], scope, simulate)));
  };
  function funXor(lhs, rhs) {
    if (lhs instanceof Vector) {
      return lhs.cloneCombine(rhs, funXor, false);
    } else if (rhs instanceof Vector) {
      return rhs.cloneCombine(lhs, funXor, true);
    }
    return (trueValue(lhs) || trueValue(rhs)) && !(trueValue(lhs) && trueValue(rhs));
  }
  funcEvalMap["NOT"] = function(node, scope, simulate) {
    return fNot(toNum(evaluateNode(node.children[0], scope, simulate)));
  };
  function fNot(x2) {
    if (x2 instanceof Vector) {
      return x2.cloneApply(fNot);
    }
    return !trueValue(x2);
  }
  funcEvalMap["NOTEQUALS"] = function(node, scope, simulate) {
    return neq(
      toNum(evaluateNode(node.children[0], scope, simulate)),
      toNum(evaluateNode(node.children[1], scope, simulate)),
      node.children[0],
      node.children[1]
    );
  };
  function neq(lhs, rhs, lhsNode, rhsNode) {
    if (typeof lhs === "boolean" && !(rhs instanceof Vector) || typeof rhs === "boolean" && !(lhs instanceof Vector)) {
      return trueValue(lhs) !== trueValue(rhs);
    }
    if ((lhs instanceof String || typeof lhs === "string") && !(rhs instanceof Vector) || (rhs instanceof String || typeof rhs === "string") && !(lhs instanceof Vector)) {
      return ("" + lhs).toLowerCase() !== ("" + rhs).toLowerCase();
    }
    if (lhs instanceof Vector) {
      return lhs.cloneCombine(rhs, neq, false);
    } else if (rhs instanceof Vector) {
      return rhs.cloneCombine(lhs, neq, true);
    }
    if (!(lhs instanceof Material) || !(rhs instanceof Material)) {
      return lhs !== rhs;
    }
    let scale = 1;
    if (lhs.units !== rhs.units) {
      scale = convertUnits(rhs.units, lhs.units);
      if (scale === 0) {
        unitAlert(lhs, rhs, "inequality comparison", "<>", lhsNode, rhsNode);
      }
    }
    return !fn["="](lhs.value, scale === 1 ? rhs.value : fn["*"](rhs.value, scale));
  }
  funcEvalMap["EQUALS"] = function(node, scope, simulate) {
    return eq(
      toNum(evaluateNode(node.children[0], scope, simulate)),
      toNum(evaluateNode(node.children[1], scope, simulate)),
      node.children[0],
      node.children[1],
      true
    );
  };
  function eq(lhs, rhs, lhsNode, rhsNode, allowVectorReturn = false) {
    if (typeof lhs === "boolean" && !(rhs instanceof Vector) || typeof rhs === "boolean" && !(lhs instanceof Vector)) {
      return trueValue(lhs) === trueValue(rhs);
    }
    if ((typeof lhs === "string" || lhs instanceof String) && !(rhs instanceof Vector) || (typeof rhs === "string" || rhs instanceof String) && !(lhs instanceof Vector)) {
      return ("" + lhs).toLowerCase() === ("" + rhs).toLowerCase();
    }
    if (allowVectorReturn) {
      if (lhs instanceof Vector) {
        return lhs.cloneCombine(rhs, (a2, b2) => eq(a2, b2, void 0, void 0, true), false);
      } else if (rhs instanceof Vector) {
        return rhs.cloneCombine(lhs, (a2, b2) => eq(a2, b2, void 0, void 0, true), true);
      }
    } else {
      if (lhs instanceof Vector || rhs instanceof Vector) {
        if (lhs instanceof Vector && rhs instanceof Vector) {
          return lhs.equals(rhs);
        }
        return false;
      }
    }
    if (!(lhs instanceof Material) || !(rhs instanceof Material)) {
      return lhs === rhs;
    }
    let scale = 1;
    if (lhs.units !== rhs.units) {
      scale = convertUnits(rhs.units, lhs.units);
      if (scale === 0) {
        unitAlert(lhs, rhs, "equality comparison", "=", lhsNode, rhsNode);
      }
    }
    return fn["="](lhs.value, scale === 1 ? rhs.value : fn["*"](rhs.value, scale));
  }
  function comparisonValid(lhs, rhs) {
    if (lhs instanceof String || typeof lhs === "string" || rhs instanceof String || typeof rhs === "string") {
      throw new ModelError("Cannot use Strings in logical inequality comparisons.", {
        code: 7005
      });
    }
    if (lhs instanceof Boolean || typeof lhs === "boolean" || rhs instanceof Boolean || typeof rhs === "boolean") {
      throw new ModelError("Cannot use Booleans in logical inequality comparisons.", {
        code: 7006
      });
    }
    if (lhs instanceof SAgent || rhs instanceof SAgent) {
      throw new ModelError("Cannot use Agents in logical inequality comparisons.", {
        code: 7007
      });
    }
  }
  funcEvalMap["LT"] = function(node, scope, simulate) {
    return lessThan(
      toNum(evaluateNode(node.children[0], scope, simulate)),
      toNum(evaluateNode(node.children[1], scope, simulate)),
      node.children[0],
      node.children[1]
    );
  };
  function lessThan(lhs, rhs, lhsNode, rhsNode) {
    comparisonValid(lhs, rhs);
    if (lhs instanceof Vector) {
      return lhs.cloneCombine(rhs, lessThan, false);
    } else if (rhs instanceof Vector) {
      return rhs.cloneCombine(lhs, lessThan, true);
    } else if (lhs instanceof Material && rhs instanceof Material) {
      let scale = 1;
      if (lhs.units !== rhs.units) {
        scale = convertUnits(rhs.units, lhs.units);
        if (scale === 0) {
          unitAlert(lhs, rhs, "comparison", "<", lhsNode, rhsNode);
        }
      }
      return fn["<"](lhs.value, scale === 1 ? rhs.value : fn["*"](scale, rhs.value));
    }
    throw new ModelError("Invalid type - lessThan", {
      code: 7008
    });
  }
  funcEvalMap["LTEQ"] = function(node, scope, simulate) {
    return lessThanEq(
      toNum(evaluateNode(node.children[0], scope, simulate)),
      toNum(evaluateNode(node.children[1], scope, simulate)),
      node.children[0],
      node.children[1]
    );
  };
  function lessThanEq(lhs, rhs, lhsNode, rhsNode) {
    comparisonValid(lhs, rhs);
    if (lhs instanceof Vector) {
      return lhs.cloneCombine(rhs, lessThanEq, false);
    } else if (rhs instanceof Vector) {
      return rhs.cloneCombine(lhs, lessThanEq, true);
    } else if (lhs instanceof Material && rhs instanceof Material) {
      let scale = 1;
      if (lhs.units !== rhs.units) {
        scale = convertUnits(rhs.units, lhs.units);
        if (scale === 0) {
          unitAlert(lhs, rhs, "comparison", "<=", lhsNode, rhsNode);
        }
      }
      return fn["<="](lhs.value, scale === 1 ? rhs.value : fn["*"](scale, rhs.value));
    }
    throw new ModelError("Invalid type - lessThanEq", {
      code: 7009
    });
  }
  funcEvalMap["GT"] = function(node, scope, simulate) {
    return greaterThan(
      toNum(evaluateNode(node.children[0], scope, simulate)),
      toNum(evaluateNode(node.children[1], scope, simulate)),
      node.children[0],
      node.children[1]
    );
  };
  function greaterThan(lhs, rhs, lhsNode, rhsNode) {
    comparisonValid(lhs, rhs);
    if (lhs instanceof Vector) {
      return lhs.cloneCombine(rhs, greaterThan, false);
    } else if (rhs instanceof Vector) {
      return rhs.cloneCombine(lhs, greaterThan, true);
    } else if (lhs instanceof Material && rhs instanceof Material) {
      let scale = 1;
      if (lhs.units !== rhs.units) {
        scale = convertUnits(rhs.units, lhs.units);
        if (scale === 0) {
          unitAlert(lhs, rhs, "comparison", ">", lhsNode, rhsNode);
        }
      }
      return fn[">"](lhs.value, scale === 1 ? rhs.value : fn["*"](scale, rhs.value));
    }
    throw new ModelError("Invalid type - greaterThan", {
      code: 7010
    });
  }
  funcEvalMap["GTEQ"] = function(node, scope, simulate) {
    return greaterThanEq(
      toNum(evaluateNode(node.children[0], scope, simulate)),
      toNum(evaluateNode(node.children[1], scope, simulate)),
      node.children[0],
      node.children[1]
    );
  };
  function greaterThanEq(lhs, rhs, lhsNode, rhsNode) {
    comparisonValid(lhs, rhs);
    if (lhs instanceof Vector) {
      return lhs.cloneCombine(rhs, greaterThanEq, false);
    } else if (rhs instanceof Vector) {
      return rhs.cloneCombine(lhs, greaterThanEq, true);
    } else if (lhs instanceof Material && rhs instanceof Material) {
      let scale = 1;
      if (lhs.units !== rhs.units) {
        scale = convertUnits(rhs.units, lhs.units);
        if (scale === 0) {
          unitAlert(lhs, rhs, "comparison", ">=", lhsNode, rhsNode);
        }
      }
      return fn[">="](lhs.value, scale === 1 ? rhs.value : fn["*"](scale, rhs.value));
    }
    throw new ModelError("Invalid type - greaterThanEq", {
      code: 7011
    });
  }
  funcEvalMap["PLUS"] = function(node, scope, simulate) {
    return plus(
      toNum(evaluateNode(node.children[0], scope, simulate)),
      toNum(evaluateNode(node.children[1], scope, simulate)),
      node.children[0],
      node.children[1]
    );
  };
  function plus(lhs, rhs, lhsNode, rhsNode) {
    if (lhs instanceof Vector) {
      return lhs.cloneCombine(rhs, plus, false);
    } else if (rhs instanceof Vector) {
      return rhs.cloneCombine(lhs, plus, true);
    } else if (lhs instanceof Material && rhs instanceof Material) {
      let explicitUnits = true;
      let scale = 1;
      if (lhs.units !== rhs.units) {
        scale = convertUnits(rhs.units, lhs.units);
        if (scale === 0) {
          unitAlert(lhs, rhs, "addition", "+", lhsNode, rhsNode);
        } else if (scale !== 1) {
          explicitUnits = false;
        }
      }
      return (
        /** @type {any} */
        new Material(
          fn["+"](lhs.value, scale === 1 ? rhs.value : fn["*"](rhs.value, scale)),
          lhs.units,
          explicitUnits && lhs.explicitUnits && rhs.explicitUnits
        )
      );
    }
    if (typeof lhs === "boolean" || typeof rhs === "boolean") {
      throw new ModelError("Cannot convert Booleans to Numbers.", {
        code: 7012
      });
    }
    if (lhs instanceof SAgent || rhs instanceof SAgent) {
      throw new ModelError("Cannot convert Agents to Numbers.", {
        code: 7013
      });
    }
    if (typeof lhs === "string" || lhs instanceof String || typeof rhs === "string" || rhs instanceof String) {
      let s2 = lhs.toString() + rhs.toString();
      return (
        /** @type {any} */
        s2
      );
    }
    throw new ModelError("Invalid type - plus", {
      code: 7014
    });
  }
  funcEvalMap["MINUS"] = function(node, scope, simulate) {
    return minus(
      toNum(evaluateNode(node.children[0], scope, simulate)),
      toNum(evaluateNode(node.children[1], scope, simulate)),
      node.children[0],
      node.children[1]
    );
  };
  function minus(lhs, rhs, lhsNode, rhsNode) {
    if (lhs instanceof Vector) {
      return lhs.cloneCombine(rhs, minus, false);
    } else if (rhs instanceof Vector) {
      return rhs.cloneCombine(lhs, minus, true);
    } else if (lhs instanceof Material && rhs instanceof Material) {
      let explicitUnits = true;
      let scale = 1;
      if (lhs.units !== rhs.units) {
        scale = convertUnits(rhs.units, lhs.units);
        if (scale === 0) {
          unitAlert(lhs, rhs, "subtraction", "-", lhsNode, rhsNode);
        } else if (scale !== 1) {
          explicitUnits = false;
        }
      }
      return (
        /** @type {any} */
        new Material(
          fn["-"](lhs.value, scale === 1 ? rhs.value : fn["*"](rhs.value, scale)),
          lhs.units,
          explicitUnits && lhs.explicitUnits && rhs.explicitUnits
        )
      );
    }
    if (typeof lhs === "boolean" || typeof rhs === "boolean") {
      throw new ModelError("Cannot convert Booleans to Numbers.", {
        code: 7015
      });
    }
    if (lhs instanceof SAgent || rhs instanceof SAgent) {
      throw new ModelError("Cannot convert Agents to Numbers.", {
        code: 7016
      });
    }
    if (typeof lhs === "string" || lhs instanceof String || typeof rhs === "string" || rhs instanceof String) {
      throw new ModelError("Cannot convert Strings to Numbers.", {
        code: 7017
      });
    }
    throw new ModelError("Invalid type - minus", {
      code: 7018
    });
  }
  funcEvalMap["MULT"] = function(node, scope, simulate) {
    return mult(toNum(evaluateNode(node.children[0], scope, simulate)), toNum(evaluateNode(node.children[1], scope, simulate)));
  };
  function mult(lhs, rhs) {
    if (lhs instanceof Vector) {
      return lhs.cloneCombine(rhs, mult, false);
    } else if (rhs instanceof Vector) {
      return rhs.cloneCombine(lhs, mult, true);
    } else if (lhs instanceof Material && rhs instanceof Material) {
      let x2 = fn["*"](lhs.value, rhs.value);
      if (lhs.units && rhs.units) {
        let [scale, newUnits, explicit] = lhs.units.multiply(rhs.units, true);
        if (scale === 1) {
          return (
            /** @type {any} */
            new Material(
              x2,
              newUnits,
              explicit && lhs.explicitUnits && rhs.explicitUnits
            )
          );
        } else {
          return (
            /** @type {any} */
            new Material(
              fn["*"](x2, scale),
              newUnits,
              explicit && lhs.explicitUnits && rhs.explicitUnits
            )
          );
        }
      } else if (lhs.units) {
        return (
          /** @type {any} */
          new Material(x2, lhs.units)
        );
      } else if (rhs.units) {
        return (
          /** @type {any} */
          new Material(x2, rhs.units)
        );
      }
      return (
        /** @type {any} */
        new Material(x2)
      );
    }
    if (typeof lhs === "boolean" || typeof rhs === "boolean") {
      throw new ModelError("Cannot convert Booleans to Numbers.", {
        code: 7019
      });
    }
    if (lhs instanceof SAgent || rhs instanceof SAgent) {
      throw new ModelError("Cannot convert Agents to Numbers.", {
        code: 7020
      });
    }
    if (typeof lhs === "string" || lhs instanceof String || typeof rhs === "string" || rhs instanceof String) {
      throw new ModelError("Cannot convert Strings to Numbers.", {
        code: 7021
      });
    }
    throw new ModelError("Invalid type - mult", {
      code: 7022
    });
  }
  funcEvalMap["DIV"] = function(node, scope, simulate) {
    return div(toNum(evaluateNode(node.children[0], scope, simulate)), toNum(evaluateNode(node.children[1], scope, simulate)));
  };
  function div(lhs, rhs) {
    if (lhs instanceof Vector) {
      return lhs.cloneCombine(rhs, div, false);
    } else if (rhs instanceof Vector) {
      return rhs.cloneCombine(lhs, div, true);
    } else if (lhs instanceof Material && rhs instanceof Material) {
      let x2 = fn["/"](lhs.value, rhs.value);
      if (lhs.units && rhs.units) {
        let [scale, newUnits, explicit] = lhs.units.multiply(rhs.units, false);
        if (scale === 1) {
          return (
            /** @type {any} */
            new Material(
              x2,
              newUnits,
              explicit && lhs.explicitUnits && rhs.explicitUnits
            )
          );
        } else {
          return (
            /** @type {any} */
            new Material(
              fn["*"](x2, scale),
              newUnits,
              explicit && lhs.explicitUnits && rhs.explicitUnits
            )
          );
        }
      } else if (lhs.units) {
        return (
          /** @type {any} */
          new Material(x2, lhs.units)
        );
      } else if (rhs.units) {
        return (
          /** @type {any} */
          new Material(x2, rhs.units.power(-1))
        );
      }
      return (
        /** @type {any} */
        new Material(x2)
      );
    }
    if (typeof lhs === "boolean" || typeof rhs === "boolean") {
      throw new ModelError("Cannot convert Booleans to Numbers.", {
        code: 7023
      });
    }
    if (lhs instanceof SAgent || rhs instanceof SAgent) {
      throw new ModelError("Cannot convert Agents to Numbers.", {
        code: 7024
      });
    }
    if (typeof lhs === "string" || lhs instanceof String || typeof rhs === "string" || rhs instanceof String) {
      throw new ModelError("Cannot convert Strings to Numbers.", {
        code: 7025
      });
    }
    throw new ModelError("Invalid type - div", {
      code: 7026
    });
  }
  funcEvalMap["POWER"] = function(node, scope, simulate) {
    if (node.children.length === 1) {
      return evaluateNode(node.children[0], scope, simulate);
    }
    let rhs = toNum(evaluateNode(node.children[node.children.length - 1], scope, simulate));
    for (let j = node.children.length - 1; j > 0; j--) {
      let lhs = toNum(evaluateNode(node.children[j - 1], scope, simulate));
      if (rhs instanceof Vector || !rhs.units) {
        rhs = power(lhs, rhs);
      } else {
        throw new ModelError("Exponents may not have units.", {
          code: 7027
        });
      }
    }
    return rhs;
  };
  function power(lhs, rhs) {
    if (lhs instanceof Vector) {
      return lhs.cloneCombine(rhs, power, false);
    } else if (rhs instanceof Vector) {
      return rhs.cloneCombine(lhs, power, true);
    } else if (lhs instanceof Material && rhs instanceof Material) {
      let x2 = lhs.value;
      let y2 = rhs.value;
      if (x2 < 0 && y2 !== Math.round(y2)) {
        throw new ModelError(`Cannot take a negative number (${x2}) to a fractional power (${y2}).`, {
          code: 7028
        });
      }
      return (
        /** @type {any} */
        new Material(fn.expt(x2, y2), lhs.units ? lhs.units.power(y2) : void 0)
      );
    }
    if (typeof lhs === "boolean" || typeof rhs === "boolean") {
      throw new ModelError("Cannot convert Booleans to Numbers.", {
        code: 7029
      });
    }
    if (lhs instanceof SAgent || rhs instanceof SAgent) {
      throw new ModelError("Cannot convert Agents to Numbers.", {
        code: 7030
      });
    }
    if (typeof lhs === "string" || lhs instanceof String || typeof rhs === "string" || rhs instanceof String) {
      throw new ModelError("Cannot convert Strings to Numbers.", {
        code: 7031
      });
    }
    throw new ModelError("Invalid type - power", {
      code: 7032
    });
  }
  funcEvalMap["MOD"] = function(node, scope, simulate) {
    return doMod(toNum(evaluateNode(node.children[0], scope, simulate)), toNum(evaluateNode(node.children[1], scope, simulate)));
  };
  function doMod(lhs, rhs) {
    if (lhs instanceof Vector) {
      return lhs.cloneCombine(rhs, doMod, false);
    } else if (rhs instanceof Vector) {
      return rhs.cloneCombine(lhs, doMod, true);
    } else if (lhs instanceof Material && rhs instanceof Material) {
      if (!rhs.units) {
        return (
          /** @type {any} */
          new Material(fn.mod(lhs.value, rhs.value), lhs.units)
        );
      } else {
        throw new ModelError('The right hand side of "mod" may not have units.', {
          code: 7033
        });
      }
    }
    if (typeof lhs === "boolean" || typeof rhs === "boolean") {
      throw new ModelError("Cannot convert Booleans to Numbers.", {
        code: 7034
      });
    }
    if (lhs instanceof SAgent || rhs instanceof SAgent) {
      throw new ModelError("Cannot convert Agents to Numbers.", {
        code: 7035
      });
    }
    if (typeof lhs === "string" || lhs instanceof String || typeof rhs === "string" || rhs instanceof String) {
      throw new ModelError("Cannot convert Strings to Numbers.", {
        code: 7036
      });
    }
    throw new ModelError("Invalid type - mod", {
      code: 7037
    });
  }
  funcEvalMap["IDENT"] = function(node, scope, simulate) {
    let varName = node.text;
    while (!scope.has(varName)) {
      if (scope.get(PARENT_SYMBOL)) {
        scope = scope.get(PARENT_SYMBOL);
      } else {
        throw new ModelError(`The variable or function "${node.origText}" does not exist.`, {
          code: 7038
        });
      }
    }
    let v2 = scope.get(varName);
    if (v2 instanceof TreeNode && v2.typeName === "ARRAY") {
      v2 = evaluateNode(v2, scope, simulate);
    }
    if (v2.fullClone && !(v2 instanceof Vector)) {
      return v2.fullClone();
    } else {
      return v2;
    }
  };
  funcEvalMap["NEW"] = function(node, scope, simulate) {
    let base = evaluateNode(node.children[0], scope, simulate);
    if (base instanceof Vector) {
      let n2 = new Vector([], simulate, void 0, base);
      let constructor;
      let r2;
      try {
        r2 = selectFromVector(base, simulate, "constructor");
        constructor = r2.data;
      } catch (err) {
      }
      if (!constructor) {
        if (node.children.length === 2 && node.children[1].children.length > 0) {
          throw new ModelError(`No constructor available for '${node.children[0].text}'.`, {
            code: 7039
          });
        }
      } else {
        if (node.children.length === 2) {
          callFunction(constructor, node.children[1], simulate, scope, n2, r2.parent);
        } else {
          callFunction(constructor, { children: [] }, simulate, scope, n2, r2.parent);
        }
      }
      return n2;
    } else {
      throw new ModelError("'New' can only be use to create instances of Vectors.", {
        code: 7040
      });
    }
  };
  funcEvalMap["INNER"] = function(node, scope, simulate) {
    let base = evaluateNode(node.children[0], scope, simulate);
    if (node.children.length === 2 && node.children[1].typeName === "FUNCALL") {
      return callFunction(base, node.children[1], simulate, scope);
    }
    let lastSelf;
    let lastBase;
    if (scope.get("self") && node.children[0].text === "parent") {
      lastSelf = scope.get("self");
    } else if (!(base instanceof Function || base instanceof UserFunction)) {
      lastSelf = base;
    }
    for (let i2 = 1; i2 < node.children.length; i2++) {
      if (node.children[i2].typeName === "SELECTOR") {
        if (node.children[i2].children[0].typeName === "DOTSELECTOR") {
          for (let j = 0; j < node.children[i2].children[0].children.length; j++) {
            let res = [];
            if (node.children[i2].children[0].children[j].text) {
              res.push(node.children[i2].children[0].children[j].text);
            } else {
              res.push(node.children[i2].children[0].children[j].valueOf());
            }
            try {
              base = selectFromMatrix(base, simulate, res);
            } catch (err) {
              if (base instanceof SPrimitive && !(base instanceof SAgent)) {
                base = toNum(base);
                j--;
              } else {
                throw err;
              }
            }
            if (!(base instanceof Function || base instanceof UserFunction)) {
              lastSelf = base;
              lastBase = base;
            }
          }
        } else {
          if (base instanceof SPrimitive) {
            base = toNum(base);
            if (!(base instanceof Function || base instanceof UserFunction)) {
              lastSelf = base;
              lastBase = base;
            }
          }
          try {
            base = selectFromMatrix(base, simulate, createMatrixSelector(node.children[i2], scope, 0, simulate));
          } catch (err) {
            if (base instanceof SPrimitive) {
              base = toNum(base);
              i2--;
            } else {
              throw err;
            }
          }
          if (!(base instanceof Function || base instanceof UserFunction)) {
            lastSelf = base;
            lastBase = base;
          }
        }
      } else {
        base = callFunction(base, node.children[i2], simulate, scope, lastSelf, lastBase);
        if (!(base instanceof Function || base instanceof UserFunction)) {
          lastSelf = base;
          lastBase = base;
        }
      }
    }
    return base;
  };
  var fingerprintCounter = 0;
  function callFunction(base, node, simulate, scope, lastSelf, lastBase) {
    if (typeof base !== "function" && !(base instanceof UserFunction)) {
      throw new ModelError("Trying to call a non-function.", {
        code: 7041
      });
    }
    let vals = [];
    let fingerprint = "";
    if (node instanceof Array) {
      vals = node;
    } else {
      if (!node.functionFingerprint) {
        node.functionFingerprint = "FINGERPRINT-" + fingerprintCounter++;
      }
      fingerprint = node.functionFingerprint;
      if (base.delayEvalParams) {
        for (let j = 0; j < node.children.length; j++) {
          vals.push({ node: node.children[j], scope });
        }
      } else {
        for (let j = 0; j < node.children.length; j++) {
          let item = evaluateNode(node.children[j], scope, simulate);
          if (item.fullClone && !(item instanceof Vector)) {
            item = item.fullClone();
          }
          vals.push(item);
        }
      }
    }
    let fn2;
    if (base.fn) {
      fn2 = base.fn;
    } else {
      node.delayEvalParams = base.delayEvalParams;
      fn2 = base;
    }
    let oldPosition = simulate.evaluatingPosition;
    let x2 = fn2(vals, fingerprint, lastSelf, lastBase);
    simulate.evaluatingPosition = oldPosition;
    return x2;
  }
  function createMatrixSelector(node, scope, offset, simulate) {
    let selector3 = [];
    offset = offset || 0;
    for (let i2 = offset; i2 < node.children.length; i2++) {
      let child = node.children[i2];
      if (child.typeName === "MULT") {
        selector3.push("*");
      } else {
        let x2 = evaluateNode(node.children[i2], scope, simulate);
        if (typeof x2 === "function" || x2 instanceof UserFunction) {
          let fn2;
          if (typeof x2 === "function") {
            fn2 = x2;
          } else {
            fn2 = x2.fn;
          }
          (function(f2) {
            selector3.push((x3) => {
              if (!x3[0].stackApply) {
                throw new ModelError("Can't apply function across elements of non-vector.", {
                  code: 7042
                });
              }
              return x3[0].stackApply((x4) => {
                return f2([x4]);
              });
            });
          })(fn2);
        } else {
          selector3.push(toNum(x2));
        }
      }
    }
    return selector3;
  }
  funcEvalMap["ARRAY"] = function(node, scope, simulate) {
    if (node.children.length === 1 && node.children[0] instanceof Vector) {
      return node.children[0].fullClone();
    }
    let vals = [];
    let names = [];
    let hasName = false;
    for (let i2 = 0; i2 < node.children.length; i2++) {
      vals.push(evaluateNode(node.children[i2].children[0], scope, simulate));
      if (node.children[i2].children.length > 1) {
        if (node.children[i2].children[1].text) {
          names.push(node.children[i2].children[1].origText);
        } else {
          names.push(node.children[i2].children[1].valueOf());
        }
        hasName = true;
      } else {
        names.push(void 0);
      }
    }
    return new Vector(vals, simulate, hasName ? names : void 0);
  };
  funcEvalMap["RANGE"] = function(node, scope, simulate) {
    if (node.children.length === 1) {
      return evaluateNode(node.children[0], scope, simulate);
    }
    let vals = [];
    let start2 = toNum(evaluateNode(node.children[0], scope, simulate));
    let end = toNum(evaluateNode(node.children[node.children.length - 1], scope, simulate));
    if (!(start2 instanceof Material) || !(end instanceof Material)) {
      throw new ModelError("Range elements must be numbers.", {
        code: 7043
      });
    }
    vals.push(start2.fullClone());
    if (start2.units !== end.units) {
      let scale = convertUnits(start2.units, end.units);
      if (scale !== 1) {
        throw new ModelError("Units on both sides of ':' must be equal.", {
          code: 7044
        });
      }
    }
    let step = node.children.length === 2 ? new Material(1, start2.units) : toNum(evaluateNode(node.children[1], scope, simulate));
    if (!(step instanceof Material)) {
      throw new ModelError("Range elements must be numbers.", {
        code: 7045
      });
    }
    if (eq(start2, end)) {
    } else if (lessThan(start2, end)) {
      if (step.value <= 0) {
        throw new ModelError(`Step size must be positive to range from ${start2} to ${end}, got ${step.value}`, {
          code: 7046
        });
      }
      let it = plus(start2, step);
      while (lessThanEq(it, end)) {
        vals.push(it);
        it = plus(it, step);
      }
    } else if (greaterThan(start2, end)) {
      if (node.children.length === 2) {
        step = negate(step);
      } else {
        if (step.value >= 0) {
          throw new ModelError(`Step size must be negative to range from ${start2} to ${end}, got ${step.value}`, {
            code: 7046
          });
        }
      }
      let it = plus(start2, step);
      while (greaterThanEq(it, end)) {
        vals.push(it);
        it = plus(it, step);
      }
    }
    return new Vector(vals, simulate);
  };
  function makeFunctionCall(varName, varNames, varDefaults, node, scope, simulate) {
    let fn2 = new UserFunction();
    fn2.localScope = /* @__PURE__ */ Object.create(null);
    fn2.localScope["nVars"] = varNames.length;
    for (let i2 = 0; i2 < varNames.length; i2++) {
      fn2.localScope[i2 + ""] = varNames[i2];
    }
    fn2.defaults = varDefaults;
    fn2.fn = function(x2, fingerPrint, lastSelf, lastBase) {
      let minLength = x2.length;
      for (let i2 = 0; i2 < x2.length; i2++) {
        if (x2[i2].optional) {
          minLength--;
        }
      }
      if (fn2.localScope["nVars"] - fn2.defaults.length > x2.length || minLength > fn2.localScope["nVars"]) {
        let names = [];
        for (let i2 = 0; i2 < fn2.localScope["nVars"]; i2++) {
          if (fn2.defaults.length - (fn2.localScope["nVars"] - i2) > -1) {
            names.push(fn2.localScope[i2 + ""] + "=" + fn2.defaults[fn2.defaults.length - (fn2.localScope["nVars"] - i2)]);
          } else {
            names.push(fn2.localScope[i2 + ""]);
          }
        }
        throw new ModelError("Wrong number of parameters for " + varName + "(" + names.join(", ") + ").", {
          code: 7049
        });
      }
      let localScope = /* @__PURE__ */ new Map([
        [PARENT_SYMBOL, scope]
      ]);
      for (let i2 = 0; i2 < x2.length; i2++) {
        localScope.set(fn2.localScope[i2 + ""], x2[i2]);
      }
      for (let i2 = x2.length; i2 < fn2.localScope["nVars"]; i2++) {
        localScope.set(fn2.localScope[i2 + ""], fn2.defaults[fn2.defaults.length - (fn2.localScope["nVars"] - i2)]);
      }
      if (lastSelf) {
        if (!localScope.has("self")) {
          localScope.set("self", lastSelf);
        }
      }
      if (lastBase) {
        if (lastBase.parent) {
          localScope.set("parent", lastBase.parent);
        }
      }
      try {
        return evaluateNode(node, localScope, simulate);
      } catch (err) {
        if (err.returnVal) {
          return err.data;
        } else {
          throw err;
        }
      }
    };
    return fn2;
  }
  funcEvalMap["THROW"] = function(node, scope, simulate) {
    throw new ModelError(evaluateNode(node.children[0], scope, simulate), {
      code: 1e4
    });
  };
  funcEvalMap["TRYCATCH"] = function(node, scope, simulate) {
    try {
      return evaluateNode(node.children[0], scope, simulate);
    } catch (err) {
      let localScope = /* @__PURE__ */ new Map([[PARENT_SYMBOL, scope]]);
      if (err instanceof ModelError) {
        localScope.set(node.children[2].text, stringify(err.message, simulate));
      } else {
        localScope.set(node.children[2].text, stringify("An error has occurred.", simulate));
      }
      return evaluateNode(node.children[1], localScope, simulate);
    }
  };
  funcEvalMap["WHILE"] = function(node, scope, simulate) {
    let lastResult = new Material(0);
    let innerScope = /* @__PURE__ */ new Map([[PARENT_SYMBOL, scope]]);
    while (trueValue(toNum(evaluateNode(node.children[0], scope, simulate)))) {
      lastResult = evaluateNode(node.children[1], innerScope, simulate);
    }
    return lastResult;
  };
  funcEvalMap["IFTHENELSE"] = function(node, scope, simulate) {
    let innerScope = /* @__PURE__ */ new Map([[PARENT_SYMBOL, scope]]);
    let i2;
    for (i2 = 0; i2 < node.children[0].children.length; i2++) {
      if (trueValue(toNum(evaluateNode(node.children[0].children[i2], scope, simulate)))) {
        return evaluateNode(node.children[1].children[i2], innerScope, simulate);
      }
    }
    if (node.children[0].children.length !== node.children[1].children.length) {
      return evaluateNode(node.children[1].children[i2], innerScope, simulate);
    }
    return new Material(0);
  };
  funcEvalMap["FORIN"] = function(node, scope, simulate) {
    let lastResult = new Material(0);
    let id2 = node.children[0].text;
    let innerScope = /* @__PURE__ */ new Map([[PARENT_SYMBOL, scope]]);
    let vec = evaluateNode(node.children[1], scope, simulate);
    if (!(vec instanceof Vector)) {
      throw new ModelError("The in argument of a For-In loop must be a vector.", {
        code: 7050
      });
    }
    for (let i2 = 0; i2 < vec.items.length; i2++) {
      innerScope.set(id2, vec.items[i2]);
      lastResult = evaluateNode(node.children[2], innerScope, simulate);
    }
    return lastResult;
  };
  funcEvalMap["FOR"] = function(node, scope, simulate) {
    let lastResult = new Material(0);
    let id2 = node.children[0].text;
    let start2 = toNum(evaluateNode(node.children[1].children[0], scope, simulate));
    let by = new Material(1);
    if (node.children[1].children.length === 3) {
      by = toNum(evaluateNode(node.children[1].children[2], scope, simulate));
    }
    let innerScope = /* @__PURE__ */ new Map([[PARENT_SYMBOL, scope]]);
    innerScope.set(id2, start2);
    while (fn[by.value >= 0 ? "<=" : ">="](innerScope.get(id2).value, toNum(evaluateNode(node.children[1].children[1], scope, simulate)))) {
      lastResult = evaluateNode(node.children[2], innerScope, simulate);
      innerScope.set(id2, plus(innerScope.get(id2), by));
    }
    return lastResult;
  };
  funcEvalMap["FUNCTION"] = function(node, scope, simulate) {
    let id2 = node.children[0].children[0].text;
    functionGenerator(id2, node.children[0], node.children[1], node.children[2], scope, simulate);
    return `"${id2}" defined`;
  };
  funcEvalMap["ANONFUNCTION"] = function(node, scope, simulate) {
    return functionGenerator(null, node.children[0], node.children[1], node.children[2], scope, simulate);
  };
  funcEvalMap["ASSIGN"] = function(node, scope, simulate) {
    let items = node.children.length - 1;
    let x2 = evaluateNode(node.children[node.children.length - 1], scope, simulate);
    if (items > 1 && (!(x2 instanceof Vector) || x2.items.length < items)) {
      throw new ModelError("Too few elements returned for assignment.", {
        code: 7051
      });
    }
    for (let i2 = 0; i2 < items; i2++) {
      if (node.children[i2] instanceof PrimitiveStore) {
        if (items === 1) {
          node.children[i2].primitive.setValue(x2);
        } else {
          node.children[i2].primitive.setValue(x2.items[i2]);
        }
      } else {
        let varName = node.children[i2].children[0].text;
        let selector3;
        if (node.children[i2].children.length > 1) {
          selector3 = createSelector(node.children[i2].children[1], scope, simulate);
        }
        let origScope = scope;
        while (scope.get(PARENT_SYMBOL) !== null) {
          if (scope.has(varName)) {
            break;
          }
          scope = scope.get(PARENT_SYMBOL);
        }
        if (scope.get(PARENT_SYMBOL) === null && !scope.has(varName)) {
          scope = origScope;
        }
        let v2;
        if (items === 1) {
          v2 = x2;
        } else {
          v2 = x2.items[i2];
        }
        if (node.children[i2].children.length === 1) {
          scope.set(varName, v2);
        } else {
          if (scope.has(varName)) {
            selectFromMatrix(scope.get(varName), simulate, selector3, v2);
          } else {
            throw new ModelError(`The variable '${node.children[i2].children[0].origText}' does not exist.`, {
              code: 7052
            });
          }
        }
      }
    }
    if (items > 1) {
      return new Vector(x2.items.slice(0, items), simulate);
    } else {
      return x2;
    }
  };
  function createSelector(node, scope, simulate) {
    if (node.children[0].typeName === "DOTSELECTOR") {
      let res = [];
      for (let i2 = 0; i2 < node.children[0].children.length; i2++) {
        if (node.children[0].children[i2].text) {
          res.push(node.children[0].children[i2].text);
        } else {
          res.push(node.children[0].children[i2].valueOf());
        }
      }
      return res;
    } else {
      return createMatrixSelector(node, scope, 0, simulate);
    }
  }
  funcEvalMap["MATERIAL"] = function(node, scope, simulate) {
    let v2 = toNum(evaluateNode(node.children[0], scope, simulate));
    if (v2.units) {
      throw new ModelError("Cannot create material where numeric part itself has units.", {
        code: 7053
      });
    }
    return new Material(v2.value, node.children[1]);
  };
  function functionGenerator(varName, paramNames, paramDefaults, code, scope, simulate) {
    let varNames = [];
    let varDefaults = [];
    for (let i2 = varName === null ? 0 : 1; i2 < paramNames.children.length; i2++) {
      varNames.push(paramNames.children[i2].text);
    }
    for (let i2 = 0; i2 < paramDefaults.children.length; i2++) {
      varDefaults.push(paramDefaults.children[i2]);
    }
    if (varName === null) {
      return makeFunctionCall("Function", varNames, varDefaults, code, scope, simulate);
    } else {
      scope.set(varName, makeFunctionCall(varName, varNames, varDefaults, code, scope, simulate));
    }
  }
  var unitEvalMap = /* @__PURE__ */ Object.create(null);
  unitEvalMap["MULT"] = function(node) {
    return evaluateUnits(node.children[0]).concat(evaluateUnits(node.children[1]));
  };
  unitEvalMap["POW"] = function(node) {
    let rhsMult = 1;
    let rhsLoc = 1;
    let lhsLoc = 0;
    if (node.children.length === 3 + lhsLoc) {
      rhsMult = rhsMult * -1;
      rhsLoc++;
    }
    let lhs = evaluateUnits(node.children[lhsLoc]);
    let rhs = evaluateUnits(node.children[rhsLoc]) * rhsMult;
    if (lhs instanceof Array) {
      for (let i2 = 0; i2 < lhs.length; i2++) {
        lhs[i2].exponent = lhs[i2].exponent * rhs;
      }
      return lhs;
    } else {
      return Math.pow(lhs, rhs);
    }
  };
  unitEvalMap["DIV"] = function(node) {
    let lhs = evaluateUnits(node.children[0]);
    let rhs = evaluateUnits(node.children[1]);
    for (let i2 = 0; i2 < rhs.length; i2++) {
      rhs[i2].exponent = rhs[i2].exponent * -1;
    }
    return lhs.concat(rhs);
  };
  unitEvalMap["PER"] = unitEvalMap["DIV"];
  unitEvalMap["UNIT"] = function(node) {
    let unitName = "";
    for (let i2 = 0; i2 < node.children.length; i2++) {
      unitName = unitName + node.children[i2].text;
      if (i2 < node.children.length - 1) {
        unitName = unitName + " ";
      }
    }
    return [{
      id: unitName,
      exponent: 1
    }];
  };
  unitEvalMap["UNITCLUMP"] = function(node) {
    let x2 = evaluateUnits(node.children[0]);
    if (node.children.length > 1) {
      for (let i2 = 1; i2 < node.children.length; i2++) {
        if (node.children[i2].typeName === "NEGATE") {
          for (let j = 0; j < x2.length; j++) {
            x2[j].exponent = x2[j].exponent * -1;
          }
        } else if (node.children[i2].typeName === "SQUARED") {
          for (let j = 0; j < x2.length; j++) {
            x2[j].exponent = x2[j].exponent * 2;
          }
        } else if (node.children[i2].typeName === "CUBED") {
          for (let j = 0; j < x2.length; j++) {
            x2[j].exponent = x2[j].exponent * 3;
          }
        }
      }
    }
    return x2;
  };
  unitEvalMap["INTEGER"] = function(node) {
    return parseInt(node.text, 10);
  };
  unitEvalMap["FLOAT"] = function(node) {
    return parseFloat(node.text);
  };
  function evaluateUnits(node) {
    if (node instanceof Material) {
      return node.value;
    }
    return unitEvalMap[node.typeName](node);
  }
  function evaluateNode(node, scope, simulate) {
    if (node instanceof TreeNode) {
      simulate.evaluatingPosition = node.position || simulate.evaluatingPosition;
      return funcEvalMap[node.typeName](node, scope, simulate);
    } else if (node instanceof PrimitiveStore) {
      if (node.type === "totalValue") {
        if (!node.primitive.totalContents) {
          throw new ModelError("You can only use the double-bracket notation for total conveyor contents on Stock primitives.", {
            code: 7054
          });
        }
        return node.primitive.totalContents();
      } else if (node.type === "object") {
        return node.primitive;
      }
    } else {
      return node;
    }
  }
  var trimEvalMap = /* @__PURE__ */ Object.create(null);
  trimEvalMap["POWER"] = function(node, scope, simulate) {
    if (node.children.length === 1) {
      return trimNode(node.children[0], scope, simulate);
    } else {
      let n2 = new TreeNode(node.origText, node.typeName, node.position);
      for (let i2 = 0; i2 < node.children.length; i2++) {
        n2.children.push(trimNode(node.children[i2], scope, simulate));
      }
      return n2;
    }
  };
  trimEvalMap["INNER"] = function(node, scope, simulate) {
    if (node.children.length === 1) {
      return trimNode(node.children[0], scope, simulate);
    } else {
      let n2 = new TreeNode(node.origText, node.typeName, node.position);
      for (let i2 = 0; i2 < node.children.length; i2++) {
        n2.children.push(trimNode(node.children[i2], scope, simulate));
      }
      return n2;
    }
  };
  trimEvalMap["RANGE"] = trimEvalMap["POWER"];
  trimEvalMap["TRUE"] = function() {
    return true;
  };
  trimEvalMap["FALSE"] = function() {
    return false;
  };
  trimEvalMap["STRING"] = function(node, scope, simulate) {
    let sub = node.origText.slice(1, node.origText.length - 1);
    let s2;
    if (node.origText[0] === '"') {
      s2 = sub.replace(/\\(.)/g, (match, ch) => {
        switch (ch) {
          case "\\":
            return "\\";
          case '"':
            return '"';
          case "'":
            return "'";
          case "t":
            return "	";
          case "b":
            return "\b";
          case "f":
            return "\f";
          case "n":
            return "\n";
          case "r":
            return "\r";
          default:
            return match;
        }
      });
    } else {
      s2 = sub;
    }
    s2 = new String(s2);
    s2.vector = new Vector([], simulate, [], simulate.coreBank.get("stringbase"));
    return s2;
  };
  trimEvalMap["INTEGER"] = function(node) {
    return new Material(+node.text);
  };
  trimEvalMap["MATERIAL"] = function(node, scope, simulate) {
    let x2 = trimNode(node.children[1], scope, simulate);
    let units = evaluateUnits(node.children[0]);
    let exponents = [], names = [];
    for (let i2 = 0; i2 < units.length; i2++) {
      let j = names.indexOf(units[i2].id);
      if (j === -1) {
        exponents.push(units[i2].exponent);
        names.push(units[i2].id);
      } else {
        exponents[j] = exponents[j] + units[i2].exponent;
      }
    }
    if (x2 instanceof Material) {
      if (x2.units) {
        throw new ModelError("Cannot create material where numeric part itself has units.", {
          code: 7055
        });
      }
      return new Material(x2.value, simulate.unitManager.getUnitStore(names, exponents, true));
    } else {
      let m2 = new TreeNode(node.origText, "MATERIAL", node.position);
      m2.children = [x2, simulate.unitManager.getUnitStore(names, exponents, true)];
      return m2;
    }
  };
  trimEvalMap["MULT"] = function(node, scope, simulate) {
    if (!node.children.length) {
      return "*";
    }
    let lhs = trimNode(node.children[0], scope, simulate);
    let rhs = trimNode(node.children[1], scope, simulate);
    if (isConst(lhs) && isConst(rhs)) {
      return mult(lhs, rhs);
    } else {
      let n2 = new TreeNode(node.origText, node.typeName, node.position);
      n2.children = [lhs, rhs];
      return n2;
    }
  };
  trimEvalMap["DIV"] = function(node, scope, simulate) {
    let lhs = trimNode(node.children[0], scope, simulate);
    let rhs = trimNode(node.children[1], scope, simulate);
    if (isConst(lhs) && isConst(rhs)) {
      return div(lhs, rhs);
    } else {
      let n2 = new TreeNode(node.origText, node.typeName, node.position);
      n2.children = [lhs, rhs];
      return n2;
    }
  };
  trimEvalMap["PLUS"] = function(node, scope, simulate) {
    let lhs = trimNode(node.children[0], scope, simulate);
    let rhs = trimNode(node.children[1], scope, simulate);
    if (isConst(lhs) && isConst(rhs)) {
      return plus(lhs, rhs, lhs, rhs);
    } else {
      let n2 = new TreeNode(node.origText, node.typeName, node.position);
      n2.children = [lhs, rhs];
      return n2;
    }
  };
  trimEvalMap["MINUS"] = function(node, scope, simulate) {
    let lhs = trimNode(node.children[0], scope, simulate);
    let rhs = trimNode(node.children[1], scope, simulate);
    if (isConst(lhs) && isConst(rhs)) {
      return minus(lhs, rhs, lhs, rhs);
    } else {
      let n2 = new TreeNode(node.origText, node.typeName, node.position);
      n2.children = [lhs, rhs];
      return n2;
    }
  };
  trimEvalMap["FLOAT"] = trimEvalMap["INTEGER"];
  trimEvalMap["PRIMITIVE"] = function(node, scope) {
    let res;
    if (node.text.slice(0, 2) === "[[") {
      res = new PrimitiveStore(scope.get(node.text.slice(2, node.text.length - 2)), "totalValue");
    } else {
      res = new PrimitiveStore(scope.get(node.text.slice(1, node.text.length - 1)), "object");
    }
    if (res.primitive === void 0) {
      throw new ModelError(`The primitive <i>${toHTML(node.origText)}</i> could not be found.`, {
        code: 7056
      });
    }
    if (res.primitive === DUPLICATE_PRIMITIVE_NAMES) {
      throw new ModelError(`The primitive name <i>${toHTML(node.origText)}</i> is ambiguous and could refer to multiple primitives.`, {
        code: 7067
      });
    }
    return res;
  };
  trimEvalMap["NEGATE"] = function(node, scope, simulate) {
    if (!node.children.length) {
      return new TreeNode(node.origText, node.typeName, node.position);
    }
    let x2 = trimNode(node.children[0], scope, simulate);
    if (isConst(x2)) {
      return negate(x2);
    } else {
      let n2 = new TreeNode(node.origText, node.typeName, node.position);
      n2.children = [x2];
      return n2;
    }
  };
  trimEvalMap["ARRAY"] = function(node, scope, simulate) {
    let n2 = new TreeNode(node.origText, node.typeName, node.position);
    let vals = [];
    let names = [];
    let hasName = false;
    for (let i2 = 0; i2 < node.children.length; i2++) {
      n2.children.push(trimNode(node.children[i2], scope, simulate));
      vals.push(n2.children[i2].children[0]);
      if (n2.children[i2].children.length > 1) {
        if (n2.children[i2].children[1].text) {
          names.push(n2.children[i2].children[1].origText);
        } else {
          names.push(n2.children[i2].children[1].valueOf());
        }
        hasName = true;
      } else {
        names.push(void 0);
      }
    }
    let allConst = true;
    for (let i2 = 0; i2 < vals.length; i2++) {
      if (!isConst(vals[i2])) {
        allConst = false;
        break;
      }
    }
    if (allConst) {
      n2.children = [new Vector(vals, simulate, hasName ? names : void 0)];
    }
    return n2;
  };
  function isConst(x2) {
    if (x2 instanceof Material || typeof x2 === "string" || x2 instanceof String || typeof x2 === "boolean" || x2 instanceof Vector) {
      return true;
    }
    return false;
  }
  function trimNode(node, primitives2, simulate) {
    if (node.typeName in trimEvalMap) {
      simulate.evaluatingPosition = node.position || simulate.evaluatingPosition;
      return trimEvalMap[node.typeName](node, primitives2, simulate);
    } else {
      let n2 = new TreeNode(node.origText, node.typeName, node.position);
      for (let i2 = 0; i2 < node.children.length; i2++) {
        n2.children.push(trimNode(node.children[i2], primitives2, simulate));
      }
      return n2;
    }
  }
  function trueValue(q) {
    if (typeof q === "boolean") {
      return q;
    } else if (q instanceof Material) {
      return neq(q.value, 0);
    } else if (q instanceof Vector) {
      throw new ModelError("Cannot convert a Vector to a boolean.", {
        code: 7057
      });
    } else if (typeof q === "string" || q instanceof String) {
      throw new ModelError("Cannot convert a String to a boolean.", {
        code: 7058
      });
    } else {
      throw new ModelError("Only numbers can be used in place of booleans.", {
        code: 7059
      });
    }
  }

  // ../insight-maker-simulation/src/Simulator.js
  var Simulator = class {
    constructor() {
      this.resultsWindow = void 0;
      this.setResultsCallback = void 0;
      this.setStatusCallback = void 0;
      this.finished = void 0;
      this.status = void 0;
      this.valueChange = void 0;
      this.transitionPrimitives = void 0;
      this.timer = void 0;
      this.displayInformation = void 0;
      this.randLoc = -1;
      this.model = null;
      this.lastRandPos = -1;
      this.previousRandLists = [];
      this.valuedPrimitives = /* @__PURE__ */ new Set();
      this.evaluatedPrimitives = /* @__PURE__ */ new Set();
      this.distanceCache = {};
      this.distanceCacheCount = 0;
      this.sliders = {};
      this.ids = {};
      this.timeToStateMapping = /* @__PURE__ */ new Map();
      this.idCount = 0;
      this.stochastic = false;
      this.RKOrder = void 0;
      this.config = null;
      this.results = void 0;
      this.evaluatingPosition = null;
      this.coreBank = /* @__PURE__ */ new Map();
      this.varBank = /* @__PURE__ */ new Map();
      this.unitManager = new UnitManager();
      this.random = null;
      this.clusters = null;
      this.timeUnitsString = null;
    }
    /**
     * @param {import('./Modeler').ModelType} model
     */
    setup(model) {
      this.simulationModel = model;
      this.solversCompletedFirstPass = 0;
      this.timeStart = this.simulationModel.timeStart;
      this.timeLength = this.simulationModel.timeLength;
      this.timePause = this.simulationModel.timePause;
      this.timeEnd = new Material(big_default(this.timeStart.value).plus(this.timeLength.value).toNumber(), this.timeLength.units);
      this.timeStep = this.simulationModel.solvers.base.timeStep;
      this.userTimeStep = this.simulationModel.solvers.base.userTimeStep;
      this.timeStepCount = Math.floor(this.timeLength.value / this.userTimeStep.value);
      this.timeUnits = this.timeStart.units;
      this.timeUnits.addBase();
      this.aggregateSeries = /* @__PURE__ */ new Map();
      this.distanceCache = {};
      this.tasks = new TaskQueue({
        start: this.timeStart,
        end: this.timeEnd
      });
    }
    /**
     * @param {string} x
     * @returns {number}
     */
    getID(x2) {
      if (!this.ids[x2]) {
        this.idCount++;
        this.ids[x2] = this.idCount;
      }
      return this.ids[x2];
    }
    time() {
      return this.tasks.time.fullClone();
    }
    timeProgressed() {
      return minus(this.time(), this.timeStart);
    }
    /**
     * @param {SPrimitive[]} valued
     * @param {SPrimitive[]} displayed
     */
    frame(valued, displayed) {
      let l2 = valued.length;
      for (let i2 = 0; i2 < l2; i2++) {
        valued[i2].storeValue();
      }
      this.printStates(displayed);
    }
    /**
     * @param {SolverType} solver
     */
    step(solver) {
      if (!solver.completedFirstPass) {
        solver.completedFirstPass = true;
        this.solversCompletedFirstPass++;
        if (this.solversCompletedFirstPass === Object.keys(this.simulationModel.solvers).length) {
          if (this.config.onCompletedFirstPass) {
            this.config.onCompletedFirstPass();
          }
        }
      }
      if (solver.displayed.length > 0) {
        for (let i2 = this.results.children[solver.displayed[0].id].results.length; i2 < this.results.times.length; i2++) {
          for (let display of solver.displayed) {
            this.results.children[display.id].results.push(this.results.data[i2][display.id]);
          }
        }
      }
      if (this.config.onStep) {
        this.config.onStep(solver);
      }
    }
    sleep(shouldUpdateValues) {
      if (this.config) {
        if (!this.config.silent) {
          this.shouldSleep = true;
          this.shouldUpdateValues = shouldUpdateValues;
        } else {
          if (this.config.onPause) {
            this.shouldSleep = true;
          }
        }
      }
    }
    resume() {
      try {
        this.run();
      } catch (err) {
        return checkErr(err, this.config, this);
      }
    }
    completed() {
      return this.terminated || this.tasks.completed();
    }
    terminate() {
      this.setStatus("TERMINATED");
      if (!this.terminated) {
        clearTimeout(this.timer);
        this.sleep();
        this.terminated = true;
      }
    }
    setStatus(s2) {
      this.status = s2;
      if (this.setStatusCallback) {
        this.setStatusCallback(s2);
      }
    }
    /**
     * @param {import("./Modeler").SimulationConfigType=} config
     * @returns
     */
    run(config) {
      this.setStatus("RUNNING");
      let me = this;
      let addPause = (time, repeat) => {
        this.tasks.add(new Task({
          time,
          expires: 1,
          name: "Interval Pause",
          priority: 1,
          action: (_task) => {
            this.sleep(true);
            if (repeat && (this.config.pauseEachTimeStep || lessThan(plus(time, this.timePause), this.timeEnd))) {
              addPause(plus(
                time,
                this.config.pauseEachTimeStep ? this.userTimeStep : this.timePause
              ), repeat);
            }
          }
        }));
        this.tasks.add(new Task({
          time,
          expires: 1,
          name: "Interval Pause",
          priority: 1,
          action: (_task) => {
            if (this.valueChange) {
              me.evaluatedPrimitives = /* @__PURE__ */ new Set();
              for (let s2 in this.simulationModel.solvers) {
                let solver = this.simulationModel.solvers[s2];
                for (let i2 = 0; i2 < solver.valued.length; i2++) {
                  solver.valued[i2].clearCached();
                }
                for (let i2 = 0; i2 < solver.flows.length; i2++) {
                  solver.flows[i2].predict(true);
                }
              }
              this.valueChange = false;
            }
          }
        }));
      };
      if (config) {
        for (let solver in this.simulationModel.solvers) {
          this.createSolver(this.simulationModel.solvers[solver]);
        }
        if (this.config.pauseEachTimeStep || this.timePause) {
          addPause(
            this.config.pauseEachTimeStep ? this.timeStart.fullClone() : plus(this.timeStart, this.timePause),
            true
          );
        }
        this.tasks.cursor = this.tasks.tasks.minNode();
      }
      this.wakeUpTime = Date.now();
      try {
        while (!this.completed()) {
          this.tasks.step();
          if (this.shouldSleep) {
            for (let solver in this.simulationModel.solvers) {
              updateDisplayed(this.simulationModel.solvers[solver], this);
            }
            if (this.setResultsCallback) {
              this.setResultsCallback(formatSimResults(this.results));
            }
            if (this.shouldUpdateValues) {
              this.setStatus("PAUSED");
              this.shouldUpdateValues = false;
            }
            if (this.config.onPause) {
              setTimeout(() => {
                let res = formatSimResults(this.results);
                let l2 = res.data.length;
                let data = res.data[l2 - 1];
                for (let key in data) {
                  if (key === "time") {
                    continue;
                  }
                  if (!res.children[key]) {
                    return;
                  }
                  if (res.children[key].results.length < l2) {
                    res.children[key].results.push(data[key]);
                  }
                }
                res.resume = this.resume.bind(this);
                res.setValue = (cell, value) => {
                  let val = simpleEquation("" + value, this, /* @__PURE__ */ new Map([[PARENT_SYMBOL, this.varBank]]));
                  let found = false;
                  [...this.valuedPrimitives.values()].forEach((x2) => {
                    if (x2.id === cell.id) {
                      found = true;
                      if (val.fullClone) {
                        x2.dna.equation = val.fullClone();
                        x2.equation = val.fullClone();
                      } else {
                        x2.dna.equation = val;
                        x2.equation = val;
                      }
                    }
                  });
                  if (found) {
                    this.valueChange = true;
                  } else {
                    throw new ModelError("Could not find the primitive to update with setValue().", {
                      code: 8002
                    });
                  }
                };
                this.config.onPause(res);
              }, 10);
            }
            this.shouldSleep = false;
            return;
          }
        }
      } catch (err) {
        if (err.simulationCommand !== "STOP") {
          throw err;
        }
      }
      this.results = formatSimResults(this.results);
      this.results.stochastic = this.stochastic;
      if (this.config.onSuccess) {
        this.config.onSuccess(this.results);
      }
      this.terminate();
      if (this.resultsWindow) {
        this.results.window = this.resultsWindow;
        for (let solver in this.simulationModel.solvers) {
          updateDisplayed(this.simulationModel.solvers[solver], this);
        }
      }
      return this.results;
    }
    progress() {
      return div(minus(this.time(), this.timeStart), this.timeLength).value;
    }
    /**
     * @param {SPrimitive[]} displayed
     */
    printStates(displayed) {
      if (!this.timeToStateMapping.has(this.tasks.time.value)) {
        let t2 = parseFloat(this.tasks.time.value.toPrecision(20));
        let newData = {};
        let i2;
        for (i2 = this.results.times.length; i2 > 0; i2--) {
          if (this.results.times[i2 - 1] < t2) {
            this.results.times.splice(i2, 0, t2);
            this.results.data.splice(i2, 0, newData);
            break;
          }
        }
        if (i2 === 0) {
          this.results.times.splice(0, 0, t2);
          this.results.data.splice(0, 0, newData);
        }
        this.timeToStateMapping.set(this.tasks.time.value, newData);
      }
      let data = this.timeToStateMapping.get(this.tasks.time.value);
      for (let i2 = 0; i2 < displayed.length; i2++) {
        let v2 = displayed[i2];
        if (!(v2 instanceof SState && data[v2.id] !== void 0)) {
          if (v2 instanceof SPopulation) {
            this.results.children[v2.id].dataMode = "agents";
            data[v2.id] = { current: v2.collectData() };
          } else {
            let x2 = v2.value();
            if (x2 instanceof Vector && !x2.names) {
              x2.recurseApply((x3) => {
                return this.adjustNum(v2, x3);
              });
              data[v2.id] = cleanData(x2);
              this.results.children[v2.id].dataMode = "auto";
            } else if (x2 instanceof Vector) {
              x2.recurseApply((x3) => {
                return this.adjustNum(v2, x3);
              });
              data[v2.id] = cleanData(x2);
            } else if (x2 instanceof SAgent) {
              data[v2.id] = x2;
              this.results.children[v2.id].dataMode = "auto";
            } else {
              data[v2.id] = cleanData(this.adjustNum(v2, x2));
            }
          }
        }
      }
    }
    /**
     * @param {SPrimitive} v
     * @param {Material} x
     *
     * @return {number}
     */
    adjustNum(v2, x2) {
      if (v2.dna.unitless && x2.units) {
        throw new ModelError(
          `The result of the calculation has units <i>${x2.units.toString()}</i>, but the primitive is unitless. Please set the units for the primitive so we can determine the proper output.`,
          {
            primitive: v2,
            showEditor: true,
            code: 8e3
          }
        );
      }
      if (v2 instanceof SState || !x2.units && !(v2 instanceof SFlow)) {
        if (typeof x2 === "object" && "value" in x2) {
          return +x2.value;
        }
        return x2;
      } else {
        let m2 = v2.matchPrimitiveUnits(x2.units);
        if (m2 === 1) {
          return x2.value;
        }
        return +fn["*"](x2.value, m2);
      }
    }
    /**
     * @param {SolverType} solver
     */
    createSolver(solver) {
      let me = this;
      let stocks = solver.stocks;
      let flows = solver.flows;
      let actions = solver.actions;
      let transitions = solver.transitions;
      let valued = solver.valued;
      valued.forEach((v2) => this.valuedPrimitives.add(v2));
      let displayed = solver.displayed;
      let id2 = solver.id;
      let timeStep = solver.timeStep;
      let RKOrder = solver.RKOrder;
      solver.RKPosition = 1;
      let index = 0;
      let times = [];
      let maxIndex = Math.ceil(new big_default(this.timeEnd.value).minus(this.timeStart.value).div(timeStep.value).toNumber());
      for (let i2 = 0; i2 <= maxIndex + 2; i2++) {
        times.push(new Material(new big_default(this.timeStart.value).plus(new big_default(i2).times(timeStep.value)).toNumber(), timeStep.units));
      }
      let addRK1Solver = (time, repeat, clear) => {
        this.tasks.add(
          new Task({
            time,
            expires: 1,
            priority: 0,
            name: "RK1 Solver - " + solver.id,
            action: (_task) => {
              me.evaluatedPrimitives = /* @__PURE__ */ new Set();
              if (clear) {
                let l3 = flows.length;
                for (let i2 = 0; i2 < l3; i2++) {
                  flows[i2].clean();
                }
                l3 = valued.length;
                for (let i2 = 0; i2 < l3; i2++) {
                  valued[i2].clearCached();
                }
              }
              this.frame(valued, displayed);
              let l2 = actions.length;
              for (let i2 = 0; i2 < l2; i2++) {
                if (!actions[i2].initialized || actions[i2].dna.recalculate && !actions[i2].block) {
                  updateTrigger.call(actions[i2]);
                }
              }
              l2 = transitions.length;
              for (let i2 = 0; i2 < l2; i2++) {
                if (!transitions[i2].initialized || transitions[i2].dna.recalculate) {
                  updateTrigger.call(transitions[i2]);
                }
              }
              this.step(solver);
              if (repeat && index <= maxIndex) {
                index++;
                addRK1Solver(times[index], true, true);
              }
            }
          })
        );
      };
      let addRK4Solver = (time, repeat) => {
        this.tasks.add(
          new Task({
            time,
            name: "RK4 Solver (Init)  - " + solver.id,
            priority: -10,
            expires: 1,
            blocker: id2 + " init",
            action: (task) => {
              let l2 = flows.length;
              for (let i2 = 0; i2 < l2; i2++) {
                flows[i2].clean();
              }
              me.evaluatedPrimitives = /* @__PURE__ */ new Set();
              l2 = valued.length;
              for (let i2 = 0; i2 < l2; i2++) {
                valued[i2].clearCached();
              }
              solver.RKPosition = 1;
              task.unblock(id2 + " start");
              task.block();
            }
          })
        );
        this.tasks.add(
          new Task({
            time,
            name: "RK4 Solver (step 1) - " + solver.id,
            priority: -5,
            expires: 4,
            blocker: id2 + " start",
            action: (task) => {
              if (solver.RKPosition > 1) {
                me.evaluatedPrimitives = /* @__PURE__ */ new Set();
                let l2 = valued.length;
                for (let i2 = 0; i2 < l2; i2++) {
                  valued[i2].clearCached();
                  valued[i2].pastValues.pop();
                }
                if (solver.RKPosition === 4) {
                  l2 = flows.length;
                  for (let i2 = 0; i2 < l2; i2++) {
                    let initialRate = flows[i2].checkRate(flows[i2].RKPrimary[0].fullClone());
                    flows[i2].doRK4Aggregation();
                    flows[i2].rate = initialRate;
                  }
                }
              }
              this.frame(valued, displayed);
              if (solver.RKPosition === 4) {
                let l2 = actions.length;
                for (let i2 = 0; i2 < l2; i2++) {
                  if (!actions[i2].initialized || actions[i2].dna.recalculate && !actions[i2].block) {
                    updateTrigger.call(actions[i2]);
                  }
                }
                l2 = transitions.length;
                for (let i2 = 0; i2 < l2; i2++) {
                  if (!transitions[i2].initialized || transitions[i2].dna.recalculate) {
                    updateTrigger.call(transitions[i2]);
                  }
                }
                task.unblock(id2 + " init");
                if (repeat && index <= maxIndex) {
                  index += 2;
                  addRK4Solver(times[index], true);
                }
                this.step(solver);
              } else if (eq(me.time(), me.timeEnd)) {
                this.step(solver);
              } else {
                let l2 = stocks.length;
                for (let i2 = 0; i2 < l2; i2++) {
                  stocks[i2].preserveLevel();
                }
              }
              task.block();
              task.unblock(id2 + " mid");
            },
            rollback: function() {
              let l2 = stocks.length;
              for (let i2 = 0; i2 < l2; i2++) {
                stocks[i2].restoreLevel();
              }
            }
          })
        );
        this.tasks.add(
          new Task({
            time: times[index + 1],
            name: "RK4 Solver (step 2,3) - " + solver.id,
            priority: -10,
            expires: 2,
            blocker: id2 + " mid",
            action: (task) => {
              me.evaluatedPrimitives = /* @__PURE__ */ new Set();
              let l2 = valued.length;
              for (let i2 = 0; i2 < l2; i2++) {
                if (!(valued[i2] instanceof SState)) {
                  valued[i2].clearCached();
                }
              }
              solver.RKPosition++;
              l2 = flows.length;
              for (let i2 = 0; i2 < l2; i2++) {
                flows[i2].rate = null;
              }
              for (let i2 = 0; i2 < l2; i2++) {
                flows[i2].value();
              }
              task.unblock(id2 + " start");
              task.block();
            },
            timeShift: () => {
              this.tasks.moveTo(times[index]);
            }
          })
        );
        this.tasks.add(
          new Task({
            time: times[index + 2],
            name: "RK4 Solver (step 4) - " + solver.id,
            priority: -30,
            expires: 1,
            action: (task) => {
              me.evaluatedPrimitives = /* @__PURE__ */ new Set();
              let l2 = valued.length;
              for (let i2 = 0; i2 < l2; i2++) {
                if (!(valued[i2] instanceof SState)) {
                  valued[i2].clearCached();
                }
              }
              solver.RKPosition++;
              l2 = flows.length;
              for (let i2 = 0; i2 < l2; i2++) {
                flows[i2].rate = null;
              }
              for (let i2 = 0; i2 < l2; i2++) {
                flows[i2].value();
              }
              task.unblock(id2 + " start");
            },
            timeShift: () => {
              this.tasks.moveTo(times[index]);
            }
          })
        );
      };
      function valMatches(val, fn2) {
        if (val instanceof Vector) {
          let matches = false;
          val.recurseApply((x2) => {
            matches = matches || fn2(x2);
          });
          return matches;
        } else {
          return fn2(val);
        }
      }
      function valHasNegative(val) {
        return val && valMatches(toNum(val), (x2) => {
          return x2 instanceof Material && x2.value < 0;
        });
      }
      function valHasPositive(val) {
        return val && valMatches(toNum(val), (x2) => {
          return x2 instanceof Material && x2.value > 0;
        });
      }
      function doFlows(timeChange, oldTime) {
        let post = [];
        for (let flow of flows) {
          if (flow.alpha && flow.alpha.dna.nonNegative && valHasPositive(flow.rate)) {
            post.push(flow);
          } else if (flow.omega && flow.omega.dna.nonNegative && valHasNegative(flow.rate)) {
            post.push(flow);
          } else {
            flow.apply(timeChange, oldTime);
          }
        }
        post.sort((a2, b2) => {
          let aOrder = me.clusters[a2.id];
          let bOrder = me.clusters[b2.id];
          if (aOrder.cluster < bOrder.cluster) {
            return -1;
          }
          if (aOrder.cluster > bOrder.cluster) {
            return 1;
          }
          if (aOrder.flow < bOrder.flow) {
            return -1;
          }
          if (aOrder.flow > bOrder.flow) {
            return 1;
          }
          return 0;
        });
        for (let p2 of post) {
          p2.apply(timeChange, oldTime);
        }
      }
      if (RKOrder === 1) {
        this.tasks.addEvent((timeChange, oldTime) => {
          doFlows(timeChange, oldTime);
        });
        addRK1Solver(this.timeStart, true);
      } else if (RKOrder === 4) {
        this.tasks.addEvent((timeChange, oldTime) => {
          if (timeChange.value > 0) {
            doFlows(timeChange, oldTime);
          }
        });
        addRK4Solver(this.timeStart, true);
      } else {
        throw new ModelError("Unknown solution algorithm.", {
          code: 8001
        });
      }
    }
  };

  // ../insight-maker-simulation/src/DNA.js
  var DNA = class {
    /**
     * @param {import("./api/Blocks").Primitive} primitive
     * @param {string=} id
     */
    constructor(primitive, id2) {
      this.primitive = primitive;
      this.id = id2 || primitive.id;
      this.name = primitive.name;
      this.units = null;
      this.solver = void 0;
      this.frozen = void 0;
      this.slider = void 0;
      this.targetId = void 0;
      this.sourceId = void 0;
      this.value = void 0;
      this.trigger = void 0;
      this.repeat = void 0;
      this.delay = void 0;
      this.stockType = void 0;
      this.recalculate = void 0;
      this.nonNegative = void 0;
      this.residency = void 0;
      this.source = void 0;
      this.interpolation = void 0;
      this.triggerValue = void 0;
      this.inputs = void 0;
      this.outputs = void 0;
      this.flowUnitless = void 0;
      this.useMaxConstraint = void 0;
      this.useMinConstraint = void 0;
      this.minConstraint = void 0;
      this.maxConstraint = void 0;
      this.toBase = void 0;
      this.unitless = void 0;
      this.equation = void 0;
      this.agents = void 0;
      this.noOutput = false;
      this.neighborProxyDNA = null;
      this.extraLinksPrimitives = [];
      this.adoptUnits = false;
    }
  };

  // ../insight-maker-simulation/vendor/graph.js
  var Graph = function() {
    this.nodeSet = {};
    this.nodes = [];
    this.edges = [];
    this.adjacency = {};
    this.nextNodeId = 0;
    this.nextEdgeId = 0;
    this.eventListeners = [];
  };
  var Node = function(id2, data) {
    this.id = id2;
    this.data = typeof data !== "undefined" ? data : {};
  };
  var Edge = function(id2, source, target, data) {
    this.id = id2;
    this.source = source;
    this.target = target;
    this.data = typeof data !== "undefined" ? data : {};
  };
  Graph.prototype.addNode = function(node) {
    if (typeof this.nodeSet[node.id] === "undefined") {
      this.nodes.push(node);
    }
    this.nodeSet[node.id] = node;
    this.notify();
    return node;
  };
  Graph.prototype.addEdge = function(edge) {
    var exists = false;
    this.edges.forEach(function(e2) {
      if (edge.id === e2.id) {
        exists = true;
      }
    });
    if (!exists) {
      this.edges.push(edge);
    }
    if (typeof this.adjacency[edge.source.id] === "undefined") {
      this.adjacency[edge.source.id] = {};
    }
    if (typeof this.adjacency[edge.source.id][edge.target.id] === "undefined") {
      this.adjacency[edge.source.id][edge.target.id] = [];
    }
    exists = false;
    this.adjacency[edge.source.id][edge.target.id].forEach(function(e2) {
      if (edge.id === e2.id) {
        exists = true;
      }
    });
    if (!exists) {
      this.adjacency[edge.source.id][edge.target.id].push(edge);
    }
    this.notify();
    return edge;
  };
  Graph.prototype.newNode = function(data) {
    var node = new Node(this.nextNodeId++, data);
    this.addNode(node);
    return node;
  };
  Graph.prototype.newEdge = function(source, target, data) {
    var edge = new Edge(this.nextEdgeId++, source, target, data);
    this.addEdge(edge);
    return edge;
  };
  Graph.prototype.getEdges = function(node1, node2) {
    if (typeof this.adjacency[node1.id] !== "undefined" && typeof this.adjacency[node1.id][node2.id] !== "undefined") {
      return this.adjacency[node1.id][node2.id];
    }
    return [];
  };
  Graph.prototype.removeNode = function(node) {
    if (typeof this.nodeSet[node.id] !== "undefined") {
      delete this.nodeSet[node.id];
    }
    for (var i2 = this.nodes.length - 1; i2 >= 0; i2--) {
      if (this.nodes[i2].id === node.id) {
        this.nodes.splice(i2, 1);
      }
    }
    this.detachNode(node);
  };
  Graph.prototype.detachNode = function(node) {
    var tmpEdges = this.edges.slice();
    tmpEdges.forEach(function(e2) {
      if (e2.source.id === node.id || e2.target.id === node.id) {
        this.removeEdge(e2);
      }
    }, this);
    this.notify();
  };
  Graph.prototype.removeEdge = function(edge) {
    for (var i2 = this.edges.length - 1; i2 >= 0; i2--) {
      if (this.edges[i2].id === edge.id) {
        this.edges.splice(i2, 1);
      }
    }
    for (var x2 in this.adjacency) {
      for (var y2 in this.adjacency[x2]) {
        var edges = this.adjacency[x2][y2];
        for (var j = edges.length - 1; j >= 0; j--) {
          if (this.adjacency[x2][y2][j].id === edge.id) {
            this.adjacency[x2][y2].splice(j, 1);
          }
        }
      }
    }
    this.notify();
  };
  Graph.prototype.merge = function(data) {
    var nodes = [];
    data.nodes.forEach(function(n2) {
      nodes.push(this.addNode(new Node(n2.id, n2.data)));
    }, this);
    data.edges.forEach(function(e2) {
      var from = nodes[e2.from];
      var to = nodes[e2.to];
      var id2 = e2.directed ? id2 = e2.type + "-" + from.id + "-" + to.id : from.id < to.id ? e2.type + "-" + from.id + "-" + to.id : e2.type + "-" + to.id + "-" + from.id;
      var edge = this.addEdge(new Edge(id2, from, to, e2.data));
      edge.data.type = e2.type;
    }, this);
  };
  Graph.prototype.filterNodes = function(fn2) {
    var tmpNodes = this.nodes.slice();
    tmpNodes.forEach(function(n2) {
      if (!fn2(n2)) {
        this.removeNode(n2);
      }
    }, this);
  };
  Graph.prototype.filterEdges = function(fn2) {
    var tmpEdges = this.edges.slice();
    tmpEdges.forEach(function(e2) {
      if (!fn2(e2)) {
        this.removeEdge(e2);
      }
    }, this);
  };
  Graph.prototype.addGraphListener = function(obj) {
    this.eventListeners.push(obj);
  };
  Graph.prototype.notify = function() {
    this.eventListeners.forEach(function(obj) {
      obj.graphChanged();
    });
  };
  var Layout = {};
  Layout.ForceDirected = function(graph, stiffness, repulsion, damping) {
    this.graph = graph;
    this.stiffness = stiffness;
    this.repulsion = repulsion;
    this.damping = damping;
    this.nodePoints = {};
    this.edgeSprings = {};
    this.getRandom = () => Math.random();
  };
  Layout.ForceDirected.prototype.point = function(node) {
    if (typeof this.nodePoints[node.id] === "undefined") {
      var mass = typeof node.data.mass !== "undefined" ? node.data.mass : 1;
      this.nodePoints[node.id] = new Layout.ForceDirected.Point(gVector.random(this.getRandom), mass);
    }
    return this.nodePoints[node.id];
  };
  Layout.ForceDirected.prototype.spring = function(edge) {
    if (typeof this.edgeSprings[edge.id] === "undefined") {
      var length = typeof edge.data.length !== "undefined" ? edge.data.length : 1;
      var existingSpring = false;
      var from = this.graph.getEdges(edge.source, edge.target);
      from.forEach(function(e2) {
        if (existingSpring === false && typeof this.edgeSprings[e2.id] !== "undefined") {
          existingSpring = this.edgeSprings[e2.id];
        }
      }, this);
      if (existingSpring !== false) {
        return new Layout.ForceDirected.Spring(existingSpring.point1, existingSpring.point2, 0, 0);
      }
      var to = this.graph.getEdges(edge.target, edge.source);
      from.forEach(function(e2) {
        if (existingSpring === false && typeof this.edgeSprings[e2.id] !== "undefined") {
          existingSpring = this.edgeSprings[e2.id];
        }
      }, this);
      if (existingSpring !== false) {
        return new Layout.ForceDirected.Spring(existingSpring.point2, existingSpring.point1, 0, 0);
      }
      this.edgeSprings[edge.id] = new Layout.ForceDirected.Spring(
        this.point(edge.source),
        this.point(edge.target),
        length,
        this.stiffness
      );
    }
    return this.edgeSprings[edge.id];
  };
  Layout.ForceDirected.prototype.eachNode = function(callback) {
    var t2 = this;
    this.graph.nodes.forEach(function(n2) {
      callback.call(t2, n2, t2.point(n2));
    });
  };
  Layout.ForceDirected.prototype.eachEdge = function(callback) {
    var t2 = this;
    this.graph.edges.forEach(function(e2) {
      callback.call(t2, e2, t2.spring(e2));
    });
  };
  Layout.ForceDirected.prototype.eachSpring = function(callback) {
    var t2 = this;
    this.graph.edges.forEach(function(e2) {
      callback.call(t2, t2.spring(e2));
    });
  };
  Layout.ForceDirected.prototype.applyCoulombsLaw = function() {
    this.eachNode(function(n1, point1) {
      this.eachNode(function(n2, point2) {
        if (point1 !== point2) {
          var d2 = point1.p.subtract(point2.p);
          var distance3 = d2.magnitude() + 0.1;
          var direction = d2.normalise();
          point1.applyForce(direction.multiply(this.repulsion).divide(distance3 * distance3 * 0.5));
          point2.applyForce(direction.multiply(this.repulsion).divide(distance3 * distance3 * -0.5));
        }
      });
    });
  };
  Layout.ForceDirected.prototype.applyHookesLaw = function() {
    this.eachSpring(function(spring) {
      var d2 = spring.point2.p.subtract(spring.point1.p);
      var displacement = spring.length - d2.magnitude();
      var direction = d2.normalise();
      spring.point1.applyForce(direction.multiply(spring.k * displacement * -0.5));
      spring.point2.applyForce(direction.multiply(spring.k * displacement * 0.5));
    });
  };
  Layout.ForceDirected.prototype.attractToCentre = function() {
    this.eachNode(function(node, point) {
      var direction = point.p.multiply(-1);
      point.applyForce(direction.multiply(this.repulsion / 50));
    });
  };
  Layout.ForceDirected.prototype.updateVelocity = function(timestep) {
    this.eachNode(function(node, point) {
      point.v = point.v.add(point.a.multiply(timestep)).multiply(this.damping);
      point.a = new gVector(0, 0);
    });
  };
  Layout.ForceDirected.prototype.updatePosition = function(timestep) {
    this.eachNode(function(node, point) {
      point.p = point.p.add(point.v.multiply(timestep));
    });
  };
  Layout.ForceDirected.prototype.totalEnergy = function(timestep) {
    var energy = 0;
    this.eachNode(function(node, point) {
      var speed = point.v.magnitude();
      energy += 0.5 * point.m * speed * speed;
    });
    return energy;
  };
  Layout.ForceDirected.prototype.nearest = function(pos) {
    var min = { node: null, point: null, distance: null };
    var t2 = this;
    this.graph.nodes.forEach(function(n2) {
      var point = t2.point(n2);
      var distance3 = point.p.subtract(pos).magnitude();
      if (min.distance === null || distance3 < min.distance) {
        min = { node: n2, point, distance: distance3 };
      }
    });
    return min;
  };
  Layout.ForceDirected.prototype.getBoundingBox = function() {
    var bottomleft = new gVector(-2, -2);
    var topright = new gVector(2, 2);
    this.eachNode(function(n2, point) {
      if (point.p.x < bottomleft.x) {
        bottomleft.x = point.p.x;
      }
      if (point.p.y < bottomleft.y) {
        bottomleft.y = point.p.y;
      }
      if (point.p.x > topright.x) {
        topright.x = point.p.x;
      }
      if (point.p.y > topright.y) {
        topright.y = point.p.y;
      }
    });
    var padding = topright.subtract(bottomleft).multiply(0.07);
    return { bottomleft: bottomleft.subtract(padding), topright: topright.add(padding) };
  };
  var gVector = function(x2, y2) {
    this.x = x2;
    this.y = y2;
  };
  gVector.random = function(fn2) {
    return new gVector(10 * (fn2() - 0.5), 10 * (fn2() - 0.5));
  };
  gVector.prototype.add = function(v2) {
    return new gVector(this.x + v2.x, this.y + v2.y);
  };
  gVector.prototype.subtract = function(v2) {
    return new gVector(this.x - v2.x, this.y - v2.y);
  };
  gVector.prototype.multiply = function(n2) {
    return new gVector(this.x * n2, this.y * n2);
  };
  gVector.prototype.divide = function(n2) {
    return new gVector(this.x / n2 || 0, this.y / n2 || 0);
  };
  gVector.prototype.magnitude = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };
  gVector.prototype.normal = function() {
    return new gVector(-this.y, this.x);
  };
  gVector.prototype.normalise = function() {
    return this.divide(this.magnitude());
  };
  Layout.ForceDirected.Point = function(position2, mass) {
    this.p = position2;
    this.m = mass;
    this.v = new gVector(0, 0);
    this.a = new gVector(0, 0);
  };
  Layout.ForceDirected.Point.prototype.applyForce = function(force) {
    this.a = this.a.add(force.divide(this.m));
  };
  Layout.ForceDirected.Spring = function(point1, point2, length, k2) {
    this.point1 = point1;
    this.point2 = point2;
    this.length = length;
    this.k = k2;
  };

  // ../insight-maker-simulation/vendor/toposort.js
  function toposort_default(edges) {
    return toposort(uniqueNodes(edges), edges);
  }
  function toposort(nodes, edges) {
    let cursor = nodes.length, sorted = new Array(cursor), visited = {}, i2 = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
    edges.forEach((edge) => {
      if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
        throw new Error("Unknown node. There is an unknown node in the supplied edges.");
      }
    });
    while (i2--) {
      if (!visited[i2]) visit(nodes[i2], i2, /* @__PURE__ */ new Set());
    }
    return sorted;
    function visit(node, i3, predecessors) {
      if (predecessors.has(node)) {
        let nodeRep;
        try {
          nodeRep = ", node was:" + JSON.stringify(node);
        } catch (e2) {
          nodeRep = "";
        }
        throw new Error("Cyclic dependency" + nodeRep);
      }
      if (!nodesHash.has(node)) {
        throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
      }
      if (visited[i3]) return;
      visited[i3] = true;
      let outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
      outgoing = Array.from(outgoing);
      if (i3 = outgoing.length) {
        predecessors.add(node);
        do {
          let child = outgoing[--i3];
          visit(child, nodesHash.get(child), predecessors);
        } while (i3);
        predecessors.delete(node);
      }
      sorted[--cursor] = node;
    }
  }
  function uniqueNodes(arr) {
    let res = /* @__PURE__ */ new Set();
    for (let i2 = 0, len = arr.length; i2 < len; i2++) {
      let edge = arr[i2];
      res.add(edge[0]);
      res.add(edge[1]);
    }
    return Array.from(res);
  }
  function makeOutgoingEdges(arr) {
    let edges = /* @__PURE__ */ new Map();
    for (let i2 = 0, len = arr.length; i2 < len; i2++) {
      let edge = arr[i2];
      if (!edges.has(edge[0])) edges.set(edge[0], /* @__PURE__ */ new Set());
      if (!edges.has(edge[1])) edges.set(edge[1], /* @__PURE__ */ new Set());
      edges.get(edge[0]).add(edge[1]);
    }
    return edges;
  }
  function makeNodesHash(arr) {
    let res = /* @__PURE__ */ new Map();
    for (let i2 = 0, len = arr.length; i2 < len; i2++) {
      res.set(arr[i2], i2);
    }
    return res;
  }

  // ../insight-maker-simulation/src/Modeler.js
  function runSimulation(config) {
    let simulate;
    try {
      simulate = new Simulator();
      simulate.model = config.model;
      return innerRunSimulation(simulate, config);
    } catch (err) {
      return checkErr(err, config, simulate);
    }
  }
  function checkErr(err, config, simulate) {
    simulate.terminate();
    let errOut;
    if (err instanceof ModelError) {
      errOut = {
        error: err.message,
        errorPrimitive: err.primitive ? simulate.model.getId(err.primitive.id) : null,
        errorCode: err.code
      };
    } else {
      console.log(err);
      if (config.processError) {
        config.processError(err);
      }
      errOut = {
        error: "An unknown simulation error occurred. Please report this issue to the Insight Maker team at <a href='mailto:support@insightmaker.com' style='color: white'>support@insightmaker.com</a>.",
        errorPrimitive: null,
        errorCode: 1
      };
      err = new ModelError(errOut.error, {
        code: 1
      });
    }
    if (!simulate.results) {
      simulate.results = {};
    }
    simulate.results.error = err.msg;
    if (errOut.error) {
      errOut.error = errOut.error.replace(/<br\s*\/?>/g, "\n").replace(/<[^>]*>?/gm, "").replaceAll("&lt;", "<").replaceAll("&gt;", ">");
    }
    if (simulate.evaluatingPosition) {
      if (simulate.evaluatingPosition.source === "macros") {
        errOut.errorPrimitive = null;
        errOut.errorSource = "GLOBALS";
        errOut.errorLine = simulate.evaluatingPosition.line;
      } else {
        if (errOut.errorPrimitive) {
          errOut.errorSource = "PRIMITIVE";
          if (simulate.evaluatingPosition.source?.startsWith("p:" + errOut.errorPrimitive.id + ":")) {
            errOut.errorLine = simulate.evaluatingPosition.line;
            let part = simulate.evaluatingPosition.source.split(":")[2];
            if (part) {
              errOut.errorSource += ":" + part.toUpperCase();
            }
          }
        }
      }
    }
    if (config.onError) {
      config.onError(errOut);
    }
    if (config.handleErrorObject) {
      err.primitive = errOut.errorPrimitive ? err.primitive : null;
      err.line = errOut.errorLine;
      err.source = errOut.errorSource;
      config.handleErrorObject(err, simulate);
    } else {
      return errOut;
    }
  }
  function innerRunSimulation(simulate, config) {
    if (config) {
      simulate.config = config;
    }
    simulate.evaluatingPosition = {
      line: null,
      source: null
    };
    if (config.resultsWindow) {
      if (!config.resultsWindow.windowContext.simulate.completed()) {
        config.resultsWindow.windowContext.simulate.terminate();
      }
      simulate.resultsWindow = config.resultsWindow;
      config.resultsWindow.windowContext.simulate = simulate;
      config.resultsWindow.data.simulation = simulate;
      config.resultsWindow.windowContext.componentRef.rerender();
      config.resultsWindow.windowContext.notFirstRun = true;
    }
    bootCalc(simulate);
    let timeUnits = simulate.model.timeUnits;
    if (!timeUnits) {
      throw new ModelError("You must set the time units in the model settings.", {
        code: 1072
      });
    }
    timeUnits = timeUnits.toLowerCase();
    simulate.timeUnitsString = timeUnits;
    let model = {};
    model.submodels = {
      // @ts-ignore
      base: {
        id: "base",
        DNAs: [],
        agents: [
          /** @type {SAgent} */
          {
            children: [],
            childrenId: {}
          }
        ],
        size: 1
      }
    };
    let customUnits = simulate.model.customUnits;
    if (customUnits) {
      let units = [];
      for (let unit of customUnits) {
        if (unit.target?.trim()) {
          let newUnit = {
            sourceString: unit.name,
            scale: unit.scale
          };
          let newTarget = createUnitStore(unit.target, simulate);
          if (!newTarget) {
            throw new ModelError('You cannot define a units synonym for "unitless".', {
              code: 1001
            });
          } else {
            newUnit.target = newTarget;
          }
          units.push(newUnit);
        }
      }
      simulate.unitManager.addUnits(units);
    }
    model.timeUnits = simulate.unitManager.getUnitStore([timeUnits], [1]);
    model.timeLength = new Material(simulate.model.timeLength, model.timeUnits);
    model.timeStart = new Material(simulate.model.timeStart || 0, model.timeUnits);
    model.timeStep = new Material(simulate.model.timeStep, model.timeUnits);
    if (model.timeStep.value <= 0 || isNaN(model.timeStep.value)) {
      throw new ModelError("The model time step must be a positive number.", {
        code: 1002
      });
    }
    if (model.timeLength.value <= 0 || isNaN(model.timeLength.value)) {
      throw new ModelError("The model time length must be a positive number.", {
        code: 1003
      });
    }
    if (simulate.model.timePause > 0) {
      model.timePause = new Material(simulate.model.timePause, model.timeUnits);
      if (model.timePause.value < model.timeStep.value) {
        throw new ModelError("Time pause cannot be smaller than the time step.", {
          code: 1004
        });
      }
    }
    simulate.timeUnits = model.timeUnits;
    let solvers = {};
    solvers.base = {
      timeStep: new Material(simulate.model.timeStep, model.timeUnits),
      algorithm: simulate.model.algorithm,
      id: "base",
      maxLoaded: -1
    };
    model.solvers = solvers;
    let folders = simulate.model.findFolders().concat(simulate.model.findAgents());
    for (let i2 = 0; i2 < folders.length; i2++) {
      let solver = folders[i2].customTimeSettings;
      if (solver) {
        if (solver.enabled) {
          solvers[folders[i2].id] = Object.assign({}, solver, { timeStep: new Material(+solver.timeStep, model.timeUnits) });
          if (solvers[folders[i2].id].timeStep.value <= 0 || isNaN(solvers[folders[i2].id].timeStep.value)) {
            throw new ModelError("The folder time step must be a positive number.", {
              primitive: folders[i2],
              showEditor: false,
              code: 1005
            });
          }
          solvers[folders[i2].id].id = folders[i2].id;
          solvers[folders[i2].id].maxLoaded = -1;
        }
      }
    }
    for (let solver of Object.values(solvers)) {
      solver.userTimeStep = solver.timeStep;
      if (solver.algorithm === "RK4") {
        solver.RKOrder = 4;
      } else {
        solver.RKOrder = 1;
      }
      if (solver.RKOrder === 4) {
        solver.timeStep = div(solver.userTimeStep, new Material(2));
      }
      solver.stocks = [];
      solver.flows = [];
      solver.transitions = [];
      solver.actions = [];
      solver.states = [];
      solver.valued = [];
      solver.displayed = [];
    }
    try {
      let completedFirstPass = function() {
        if (hasCompletedFirstPass) {
          return;
        }
        hasCompletedFirstPass = true;
        if (simulate.displayInformation.populated) {
          for (let i2 = 0; i2 < simulate.displayInformation.origIds.length; i2++) {
            let id2 = simulate.displayInformation.origIds[i2];
            let object = simulate.displayInformation.objects[i2];
            if (object instanceof SPopulation) {
              simulate.results.children[id2].states = object.stateIds;
              simulate.displayInformation.agents[id2.toString()].data = simulate.results.children[id2].data;
              simulate.displayInformation.agents[id2.toString()].results = simulate.results.children[id2].results;
            } else if (simulate.results.data[0][id2] instanceof Vector && simulate.results.data[0][id2].names) {
              let names = simulate.results.data[0][id2].fullNames();
              simulate.results.children[id2].indexedFullNames = names.slice();
              for (let j = 0; j < names.length; j++) {
                names[j] = names[j].join(", ");
              }
              simulate.results.children[id2].indexedNames = names;
            }
          }
        } else {
          simulate.displayInformation.populated = true;
          simulate.displayInformation.colors = [];
          simulate.displayInformation.icons = [];
          simulate.displayInformation.headers = [];
          simulate.displayInformation.agents = [];
          simulate.displayInformation.displayedItems = [];
          simulate.displayInformation.renderers = [];
          simulate.displayInformation.elementIds = [];
          simulate.displayInformation.res = simulate.results;
          let ids = [];
          simulate.displayInformation.origIds = simulate.displayInformation.ids.slice();
          for (let i2 = 0; i2 < simulate.displayInformation.origIds.length; i2++) {
            let id2 = simulate.displayInformation.origIds[i2];
            let object = simulate.displayInformation.objects[i2];
            let dna = object.dna;
            let image = dna.primitive._node.getAttribute("Image");
            simulate.displayInformation.displayedItems.push({
              id: id2,
              header: dna.name,
              type: dna.primitive._node.value.nodeName,
              icon: image?.startsWith("emoji:") ? image.slice(6) : null
            });
            if (object instanceof SPopulation) {
              let states = object.stateIds;
              simulate.results.children[id2].states = states;
              states.forEach((state) => {
                let innerItem = simulate.model.getId(state);
                ids.push(id2);
                simulate.displayInformation.elementIds.push("e" + id2 + "-" + state);
                simulate.displayInformation.headers.push(innerItem.name);
                simulate.displayInformation.icons.push(config.getIcon ? config.getIcon(innerItem) : null);
                simulate.displayInformation.colors.push(config.getColor ? config.getColor(innerItem) : "#000000");
                if (simulate.results.children[id2].dataMode === "float") {
                  simulate.displayInformation.renderers.push(commaStr);
                } else if (simulate.results.children[id2].dataMode === "agents") {
                  simulate.displayInformation.renderers.push((x2) => {
                    return x2;
                  });
                } else {
                  simulate.displayInformation.renderers.push(void 0);
                }
              });
              simulate.displayInformation.agents[id2.toString()] = {
                id: id2,
                item: dna.primitive,
                data: simulate.results.children[id2].data,
                results: simulate.results.children[id2].results
              };
            } else if (simulate.results.data.length && simulate.results.data[0][id2] instanceof Vector && simulate.results.data[0][id2].names) {
              let col = config.getColor ? config.getColor(dna.primitive) : "#000000";
              let icon = config.getIcon ? config.getIcon(dna.primitive) : null;
              let names = simulate.results.data[0][id2].fullNames();
              simulate.results.children[id2].indexedFullNames = names.slice();
              for (let j = 0; j < names.length; j++) {
                names[j] = names[j].join(", ");
              }
              simulate.results.children[id2].indexedNames = names;
              for (let j = 0; j < names.length; j++) {
                ids.push(id2);
                simulate.displayInformation.elementIds.push("e" + id2 + "-" + j);
                simulate.displayInformation.headers.push(dna.name + " (" + names[j] + ")");
                simulate.displayInformation.icons.push(icon);
                simulate.displayInformation.colors.push(col);
                simulate.displayInformation.renderers.push(commaStr);
              }
            } else {
              ids.push(id2);
              simulate.displayInformation.elementIds.push("e" + id2);
              simulate.displayInformation.headers.push(dna.name);
              simulate.displayInformation.icons.push(config.getIcon ? config.getIcon(dna.primitive) : null);
              simulate.displayInformation.colors.push(config.getColor ? config.getColor(dna.primitive) : "#000000");
              if (simulate.results.children[id2].dataMode === "float") {
                simulate.displayInformation.renderers.push(commaStr);
              } else {
                simulate.displayInformation.renderers.push(void 0);
              }
            }
          }
          simulate.displayInformation.store = {
            data: []
          };
          simulate.displayInformation.ids = ids;
        }
      };
      simulate.setup(model);
      if (simulate.model.globals !== void 0) {
        try {
          evaluateGlobals(simulate.model.globals, simulate);
        } catch (err) {
          if (err.simulationCommand === "STOP") {
            throw err;
          }
          let annotations = [];
          let msg = "An error with the macros prevented the simulation from running.";
          if (err instanceof ModelError) {
            msg = msg + "<br/><br/>" + err.message;
            if (simulate.evaluatingPosition?.line) {
              annotations.push({
                type: "error",
                row: simulate.evaluatingPosition.line - 1,
                text: err.message
              });
            }
          } else {
            if (err.toString) {
              if (err.match && err.match(/line (\d+)/i)) {
                let l2 = err.match(/line (\d+)/i)[1];
                annotations.push({
                  type: "error",
                  row: l2 !== void 0 ? l2 - 1 : simulate.evaluatingPosition.line - 1,
                  text: err
                });
              }
            }
            if (config.processError) {
              config.processError(err);
            }
          }
          if (config.showMacros) {
            config.showMacros(annotations);
          }
          throw new ModelError(msg, {
            code: 1e3
          });
        }
      }
      let modelItems = simulate.model.find();
      simulate.clusters = makeClusters(simulate);
      for (let item of modelItems) {
        if (item instanceof Population) {
          if (item.isInAgent()) {
            throw new ModelError(`Cannot have the agent population <i>[${toHTML(item.name)}]</i> placed within an agent folder.`, {
              primitive: item,
              showEditor: false,
              code: 1006
            });
          }
          let agentBase = item.agentBase;
          if (!agentBase || !(agentBase instanceof Agent)) {
            throw new ModelError(`You must select a base agent for the primitive <i>[${toHTML(item.name)}]</i>. You can create agent definitions using Folder primitives.`, {
              primitive: item,
              showEditor: false,
              code: 1007
            });
          }
          let x2 = new SPopulation(simulate);
          x2.dna = new DNA(item, agentBase.id);
          x2.id = item.id;
          x2.agentId = agentBase.id;
          x2.createIds();
          x2.dna.solver = folderSolvers(item, solvers);
          x2.dna.solver.displayed.push(x2);
          x2.geoDimUnits = item.geoUnits;
          x2.geoDimUnitsObject = createUnitStore(item.geoUnits, simulate, item);
          try {
            x2.geoWidth = simpleUnitsTest(
              /** @type {Material} */
              simpleEquation(item.geoWidth, simulate),
              x2.geoDimUnitsObject,
              simulate,
              item
            );
          } catch (_err) {
            throw new ModelError(`Invalid width for the agent population <i>[${toHTML(item.name)}]</i>.`, {
              primitive: item,
              showEditor: false,
              code: 1008
            });
          }
          try {
            x2.geoHeight = simpleUnitsTest(
              /** @type {Material} */
              simpleEquation(item.geoHeight, simulate),
              x2.geoDimUnitsObject,
              simulate,
              item
            );
          } catch (_err) {
            throw new ModelError(`Invalid height for the agent population <i>[${toHTML(item.name)}]</i>.`, {
              primitive: item,
              showEditor: false,
              code: 1009
            });
          }
          x2.halfWidth = div(x2.geoWidth, new Material(2));
          x2.halfHeight = div(x2.geoHeight, new Material(2));
          x2.geoWrap = item.geoWrapAround;
          x2.placement = item.geoPlacementType;
          x2.placementFunction = item.geoPlacementFunction;
          x2.network = item.networkType;
          x2.networkFunction = item.networkFunction;
          x2.agentBase = agentBase.agentParent;
          if (x2.agentBase && x2.agentBase.trim()) {
            try {
              let nodeBase2 = /* @__PURE__ */ new Map();
              let tree = trimTree(createTree(x2.agentBase, "p:" + agentBase.id + ":agentBase", simulate), nodeBase2, simulate);
              x2.agentBase = simpleEquation(x2.agentBase, simulate, simulate.varBank, null, tree);
            } catch (err) {
              console.warn(err);
              throw new ModelError(`Invalid Agent Parent for the primitive <i>[${toHTML(agentBase.name)}]</i>.`, {
                primitive: agentBase,
                showEditor: false,
                code: 1010
              });
            }
          }
          let agentNodes = agentBase.children();
          x2.DNAs = [];
          for (let agentNode of agentNodes) {
            if (modelType(agentNode)) {
              x2.DNAs.push(getDNA(agentNode, x2, solvers, simulate));
            }
            if (agentNode instanceof State) {
              x2.stateIds.add(agentNode.id);
            }
          }
          x2.size = item.populationSize;
          x2.agents = [];
          x2.dna.agents = x2;
          model.submodels[item.id] = x2;
          model.submodels.base.DNAs.push(x2.dna);
        } else if (!item.isInAgent()) {
          if (modelType(item)) {
            model.submodels.base.DNAs.push(getDNA(item, model.submodels.base, solvers, simulate));
          }
        }
      }
      for (let submodel of Object.values(model.submodels)) {
        submodel.DNAs.sort((a2, b2) => {
          if (a2.neighborProxyDNA && !b2.neighborProxyDNA) {
            return 1;
          }
          if (b2.neighborProxyDNA && !a2.neighborProxyDNA) {
            return -1;
          }
          return 0;
        });
        for (let j = 0; j < submodel.size; j++) {
          let agent2;
          if (submodel.id === "base") {
            agent2 = submodel.agents[0];
          } else {
            agent2 = new SAgent(simulate);
            agent2.container = submodel;
            agent2.index = j;
            agent2.children = [];
            agent2.childrenId = {};
            agent2.agentId = submodel.id;
            agent2.createIds();
            if (submodel.agentBase) {
              agent2.vector.parent = submodel.agentBase;
            }
            submodel.agents.push(agent2);
          }
          for (let dna of submodel.DNAs) {
            decodeDNA(dna, agent2, simulate, submodel.id !== "base");
          }
        }
      }
      for (let submodelId in model.submodels) {
        let submodel = model.submodels[submodelId];
        for (let j = 0; j < submodel.size; j++) {
          for (let i2 = 0; i2 < submodel.DNAs.length; i2++) {
            linkPrimitive(submodel.agents[j].children[i2], submodel.DNAs[i2], simulate);
          }
        }
      }
      for (let submodelId in model.submodels) {
        let submodel = model.submodels[submodelId];
        for (let j = 0; j < submodel.size; j++) {
          setAgentInitialValues(submodel.agents[j]);
        }
      }
      for (let submodel in model.submodels) {
        if (submodel !== "base") {
          try {
            buildNetwork(model.submodels[submodel], simulate);
          } catch (err) {
            let msg = "An error with the custom network function prevented the simulation from running.";
            if (err instanceof ModelError) {
              msg = msg + "<br/><br/>" + err.message;
            }
            throw new ModelError(msg, {
              primitive: model.submodels[submodel].node,
              showEditor: false,
              code: 1011
            });
          }
          try {
            buildPlacements(model.submodels[submodel], simulate);
          } catch (err) {
            let msg = "An error with the agent placement function prevented the simulation from running.";
            if (err instanceof ModelError) {
              msg = msg + "<br/><br/>" + err.message;
            }
            throw new ModelError(msg, {
              primitive: model.submodels[submodel].node,
              showEditor: false,
              code: 1012
            });
          }
        }
      }
      simulate.results = {
        times: [],
        data: [],
        timeUnits: simulate.timeUnitsString
      };
      simulate.displayInformation = {
        populated: false,
        ids: [],
        times: [],
        objects: [],
        maps: [],
        histograms: []
      };
      model.submodels["base"].agents[0].children.forEach((x2) => {
        if (!(x2 instanceof SAction || x2 instanceof STransition)) {
          if (!x2.dna.noOutput) {
            simulate.displayInformation.objects.push(x2);
            simulate.displayInformation.ids.push(x2.id);
          }
          let data = {};
          if (x2 instanceof SPopulation) {
            data.width = x2.geoWidth;
            data.height = x2.geoHeight;
            data.units = x2.geoDimUnitsObject;
            data.states = x2.states();
          } else {
            if (!x2.dna.noOutput) {
              x2.dna.solver.displayed.push(x2);
            }
          }
          if (!simulate.results.children) {
            simulate.results.children = {};
          }
          simulate.results.children[x2.id] = {
            data,
            results: [],
            dataMode: "float"
          };
        }
      });
      let hasCompletedFirstPass = false;
      if (config.silent) {
        if (config.onPause) {
          simulate.run(config);
        } else {
          return formatSimResults(simulate.run(config));
        }
      } else {
        let showRangeErrorMessage = function() {
          throw new ModelError(
            `You have ${count.value.toLocaleString()} time steps, you must reduce this. Generally 1,000 to 10,000 time steps is sufficient even for large simulations.`,
            {
              code: 9108
            }
          );
        };
        let count = div(model.timeLength, model.timeStep);
        const MAX_ARRAY_LENGTH = 4294967294;
        if (count.value > MAX_ARRAY_LENGTH) {
          showRangeErrorMessage();
        }
        try {
          for (let i2 = 0; i2 <= count.value; i2++) {
            simulate.displayInformation.times.push(plus(model.timeStart, mult(model.timeStep, new Material(i2))).value);
          }
        } catch (err) {
          if (err instanceof RangeError) {
            showRangeErrorMessage();
          } else {
            throw err;
          }
        }
        let oldSuccess = config.onSuccess;
        config.onSuccess = function(res) {
          completedFirstPass();
          for (let solver in simulate.simulationModel.solvers) {
            updateDisplayed(simulate.simulationModel.solvers[solver], simulate);
          }
          if (simulate.setResultsCallback) {
            simulate.setResultsCallback(formatSimResults(simulate.results));
          }
          if (oldSuccess) {
            oldSuccess(res);
          }
        };
        config.onCompletedFirstPass = function() {
          completedFirstPass();
        };
        let oldStep = config.onStep;
        config.onStep = function(solver) {
          let updated = false;
          let progress = simulate.progress();
          if (!simulate.shouldSleep) {
            let timeTaken = Date.now() - simulate.wakeUpTime;
            let complexityMultiplier = 1;
            if (simulate.results.times.length > 2e4) {
              complexityMultiplier = 4;
            } else if (simulate.results.times.length > 5e3) {
              complexityMultiplier = 2;
            } else if (simulate.results.times.length > 1e3) {
              complexityMultiplier = 1.3;
            }
            if (!simulate.resultsWindow && timeTaken > 100 * complexityMultiplier || timeTaken > 600 * complexityMultiplier) {
              updateDisplayed(solver, simulate);
              updated = true;
              simulate.timer = setTimeout(() => {
                simulate.resume();
              }, 20 * Math.pow(complexityMultiplier, 1.5));
              simulate.sleep();
            }
          }
          if (progress === 1 && !updated) {
            updateDisplayed(solver, simulate);
          }
          if (oldStep) {
            oldStep(solver);
          }
        };
        let oldError = config.onError;
        config.onError = function(res) {
          try {
            for (let solver in simulate.simulationModel.solvers) {
              updateDisplayed(simulate.simulationModel.solvers[solver], simulate);
            }
          } catch (err) {
          }
          if (simulate.finished) {
            simulate.finished();
          }
          if (oldError) {
            oldError(res);
          }
        };
        simulate.run(config);
      }
    } catch (err) {
      if (err.simulationCommand !== "STOP") {
        throw err;
      } else {
        if (config.silent) {
          return {
            times: [],
            value: () => {
              return [];
            },
            lastValue: () => {
            },
            error: "stop() called during initialization"
          };
        }
      }
    }
  }
  function cleanData(x2, removeVectors = false) {
    if (x2 instanceof Vector) {
      if (removeVectors) {
        if (x2.names && x2.names.length) {
          let r2 = {};
          for (let i2 = 0; i2 < x2.names.length; i2++) {
            r2[x2.names[i2]] = cleanData(x2.items[i2], removeVectors);
          }
          return r2;
        } else {
          return x2.items.map((x3) => cleanData(x3, removeVectors));
        }
      } else {
        return new Vector(x2.items.map((x3) => cleanData(x3, removeVectors)), x2.simulate, x2.names, x2.parent);
      }
    } else if (typeof x2 === "number") {
      return +x2.toPrecision(15);
    } else if (Array.isArray(x2)) {
      return x2.map((x3) => cleanData(x3, removeVectors));
    }
    return x2;
  }
  function formatSimResults(res) {
    let r2 = {};
    r2.times = res.times.slice();
    r2.data = res.data;
    r2.timeUnits = res.timeUnits;
    r2.children = res.children;
    r2.error = res.error;
    r2.errorPrimitive = res.errorPrimitive;
    r2.stochastic = res.stochastic;
    if (!r2.error) {
      r2.error = null;
      r2.errorPrimitive = null;
    }
    r2.value = function(item) {
      if (!item) {
        throw new Error("Cannot get result value() of null or undefined primitive.");
      }
      let entry = this.children[item.id];
      if (!entry) {
        throw new Error("Cannot find primitive in value() results.");
      }
      return cleanData(entry.results, true);
    };
    r2.lastValue = function(item) {
      if (!item) {
        throw new Error("Cannot get result lastValue() of null or undefined primitive.");
      }
      let entry = this.children[item.id];
      if (!entry) {
        throw new Error("Cannot find primitive in lastValue() results.");
      }
      return cleanData(entry.results[entry.results.length - 1], true);
    };
    if (r2.times) {
      r2.periods = r2.times.length;
    }
    return r2;
  }
  function createUnitStore(u2, simulate, primitive) {
    if (!u2 || u2.trim() === "" || u2.trim().toLowerCase() === "unitless") {
      return;
    }
    try {
      return simpleEquation("{1 " + u2 + "}", simulate, /* @__PURE__ */ new Map()).units;
    } catch (_err) {
      throw new ModelError(`Invalid units: "<i>${u2}</i>"`, {
        primitive,
        showEditor: true,
        code: 1012
      });
    }
  }
  function simpleEquation(eq2, simulate, scope, nodeBase2, tree) {
    if (!scope) {
      scope = /* @__PURE__ */ new Map();
    }
    if (!nodeBase2) {
      nodeBase2 = /* @__PURE__ */ new Map();
    }
    if (!tree) {
      tree = trimTree(createTree(eq2, "_", simulate), nodeBase2, simulate);
    }
    let res = evaluateTree(tree, scope, simulate);
    return res;
  }
  function simpleNum(mat, units, simulate) {
    if (mat instanceof Vector) {
      return (
        /** @type {any} */
        new Vector(mat.items.map((x2) => {
          return simpleNum(x2, units, simulate);
        }), simulate)
      );
    }
    if (mat instanceof Material) {
      if (!units && mat.units) {
        throw new ModelError(
          `The result of the calculation has units <i>${mat.units.toString()}</i>, but no units are specified for the calculation. Please set the units for the calculation so we can determine the proper output.`,
          {
            code: 1013
          }
        );
      }
      if (!mat.units) {
        return (
          /** @type {any} */
          +mat.value
        );
      } else {
        mat.units.addBase();
        units.addBase();
        return (
          /** @type {any} */
          +fn["*"](mat.value, fn["/"](mat.units.toBase, units.toBase))
        );
      }
    }
  }
  function simpleUnitsTest(mat, units, simulate, primitive = null, showEditor = false, fallbackError = "Unknown simpleUnits type") {
    if (mat instanceof Vector) {
      return (
        /** @type {any} */
        new Vector(mat.items.map((x2) => {
          return simpleUnitsTest(x2, units, simulate, primitive, showEditor, fallbackError);
        }), simulate)
      );
    }
    if (mat instanceof Material) {
      if (!mat.units && !units) {
        return (
          /** @type {any} */
          mat
        );
      } else if (!mat.units) {
        mat.units = units;
        return (
          /** @type {any} */
          mat
        );
      } else if (mat.units === units) {
        return (
          /** @type {any} */
          mat
        );
      } else {
        let scale = convertUnits(mat.units, units);
        if (scale === 0) {
          throw new ModelError(`Wrong units generated. Expected <i>${units ? units.toString() : "unitless"}</i>, and got <i>${mat.units.toString()}</i>.`, {
            primitive,
            showEditor,
            code: 1014
          });
        } else {
          mat.value = mat.value * scale;
          mat.units = units;
          return (
            /** @type {any} */
            mat
          );
        }
      }
    }
    throw new ModelError(fallbackError, {
      code: 1015
    });
  }
  function evaluateGlobals(globals, simulate) {
    evaluateTree(trimTree(createTree(globals, "macros", simulate), /* @__PURE__ */ new Map(), simulate), simulate.varBank, simulate);
  }
  function getDNA(node, submodel, solvers, simulate) {
    let dna = new DNA(node);
    let l2;
    dna.solver = folderSolvers(node, solvers);
    if (node) {
      let p2 = node.parent;
      if (p2) {
        dna.frozen = p2.frozen;
      }
    }
    if (node instanceof Variable || node instanceof Flow || node instanceof Transition2) {
      if (node.external) {
        dna.slider = true;
      }
    }
    if (node instanceof Flow || node instanceof Transition2) {
      if (node.end !== null) {
        dna.targetId = node.end.id;
      }
      if (node.start !== null) {
        dna.sourceId = node.start.id;
      }
    }
    if (node instanceof Converter) {
      dna.value = node.values;
    } else {
      try {
        if (node instanceof Stock) {
          dna.value = replaceMacros(node, dna, createTree(node.initial, "p:" + dna.id + ":initial", simulate), submodel, solvers, simulate, true);
        } else if (node instanceof Flow) {
          dna.value = replaceMacros(node, dna, createTree(node.rate, "p:" + dna.id + ":rate", simulate), submodel, solvers, simulate, false);
        } else if (node instanceof Variable) {
          dna.value = replaceMacros(node, dna, createTree(node.value, "p:" + dna.id + ":value", simulate), submodel, solvers, simulate, false);
        } else if (node instanceof State) {
          dna.value = replaceMacros(node, dna, createTree("" + node.startActive, "p:" + dna.id + ":startActive", simulate), submodel, solvers, simulate, true);
        } else if (node instanceof Transition2) {
          dna.value = replaceMacros(node, dna, createTree("" + node.value, "p:" + dna.id + ":value", simulate), submodel, solvers, simulate, false);
        } else if (node instanceof Action) {
          dna.value = replaceMacros(node, dna, createTree(node.action, "p:" + dna.id + ":action", simulate), submodel, solvers, simulate, false);
        }
      } catch (err) {
        let msg = `The primitive <i>[${toHTML(dna.name)}]</i> has an equation error that must be corrected before the model can be run.`;
        if (err instanceof ModelError) {
          msg = msg + "<br/><br/>" + err.message;
        } else {
          console.error(err);
          msg = msg + "<br/><br/>Unknown error.";
        }
        l2 = void 0;
        if (err.match && err.match(/line (\d+)/i)) {
          l2 = err.match(/line (\d+)/i)[1];
        }
        throw new ModelError(msg, {
          code: 1055,
          primitive: node,
          showEditor: true,
          line: l2,
          details: err.match ? err : void 0
        });
      }
    }
    if (node instanceof Action) {
      dna.trigger = node.trigger;
      dna.repeat = node.repeat;
      dna.recalculate = node.recalculate || node.trigger === "Condition";
      try {
        dna.triggerValue = createTree(node.value, "p:" + node.id + ":triggerValue", simulate);
      } catch (err) {
        let msg = `The trigger for <i>[${toHTML(dna.name)}]</i> has an equation error that must be corrected before the model can be run.`;
        if (err instanceof ModelError) {
          msg = msg + "<br/><br/>" + err.message;
        }
        throw new ModelError(msg, {
          code: 1056,
          primitive: node,
          showEditor: true,
          line: l2
        });
      }
    } else if (node instanceof Transition2) {
      dna.trigger = node.trigger;
      dna.repeat = node.repeat;
      dna.recalculate = node.recalculate || node.trigger === "Condition";
    } else if (node instanceof State) {
      if (node.residency === void 0 || node.residency.trim() === "") {
        dna.residency = null;
      } else {
        try {
          dna.residency = evaluateTree(trimTree(createTree(node.residency, "p:" + dna.id + ":residency", simulate), /* @__PURE__ */ new Map(), simulate), /* @__PURE__ */ new Map(), simulate);
          if (!dna.residency.units) {
            dna.residency.units = simulate.timeUnits;
          }
          if (eq(dna.residency, new Material(0, simulate.timeUnits))) {
            dna.residency = null;
          }
        } catch (err) {
          throw new ModelError("Invalid state residency.", {
            primitive: node,
            showEditor: false,
            code: 1016
          });
        }
      }
      if (dna.residency) {
        if (!(dna.residency instanceof Material)) {
          throw new ModelError("State residency must be a number.", {
            primitive: node,
            showEditor: false,
            code: 1271
          });
        }
        if (dna.residency.value < 0) {
          throw new ModelError("State residency cannot be less than 0.", {
            primitive: node,
            showEditor: false,
            code: 1272
          });
        }
      }
    } else if (node instanceof Stock) {
      dna.nonNegative = node.nonNegative;
      if (node.type === "Conveyor") {
        dna.stockType = "Conveyor";
        try {
          dna.delay = evaluateTree(trimTree(createTree(node.delay, "p:" + node.id + ":delay", simulate), /* @__PURE__ */ new Map(), simulate), /* @__PURE__ */ new Map(), simulate);
          if (!dna.delay.units) {
            dna.delay.units = simulate.timeUnits;
          }
        } catch (err) {
          throw new ModelError("Invalid stock delay.", {
            primitive: node,
            showEditor: false,
            code: 1017
          });
        }
        if (!(dna.delay instanceof Material)) {
          throw new ModelError("Stock delay must be a number.", {
            primitive: node,
            showEditor: false,
            code: 1073
          });
        }
        if (dna.delay.value < 0) {
          throw new ModelError("Stock delay cannot be less than 0.", {
            primitive: node,
            showEditor: false,
            code: 1074
          });
        }
      }
    } else if (node instanceof Flow) {
      dna.nonNegative = node.nonNegative;
    } else if (node instanceof Converter) {
      dna.interpolation = node.interpolation === "Linear" ? "linear" : "discrete";
      let data = node.values;
      if (!data || !data.length) {
        throw new ModelError(`The converter <i>[${toHTML(dna.name)}]</i> does not have any data.`, {
          primitive: node,
          showEditor: true,
          code: 1018
        });
      }
      let inp = [];
      let out = [];
      let myU;
      if (node.input === "Time") {
        myU = simulate.timeUnits;
      } else {
        let sourcePrimitive = node.input;
        if (sourcePrimitive) {
          myU = createUnitStore(sourcePrimitive.units, simulate, node);
        } else {
          throw new ModelError(`The converter <i>[${toHTML(dna.name)}]</i> does not have a source.`, {
            primitive: node,
            showEditor: true,
            code: 1019
          });
        }
      }
      dna.source = node.input === "Time" ? node.input : node.input.id;
      for (let i2 = 0; i2 < data.length; i2++) {
        inp.push(new Material(data[i2].x, myU));
        out.push(new Material(data[i2].y));
      }
      dna.inputs = inp;
      dna.outputs = out;
    }
    if (node instanceof ValuedPrimitive) {
      if (!(node instanceof Transition2) && !(node instanceof Action)) {
        let u2 = node.units;
        try {
          if (!(node instanceof Flow) || u2 && u2.trim() && u2.trim().toLowerCase() !== "unitless") {
            dna.units = createUnitStore(u2, simulate, node);
          } else {
            dna.units = simulate.timeUnits.power(-1);
            dna.flowUnitless = true;
          }
        } catch (err) {
          throw new ModelError(`Invalid units specified for primitive: "<i>${toHTML(u2)}</i>"`, {
            primitive: node,
            showEditor: true,
            code: 1020
          });
        }
      } else {
        if (dna.trigger === "Timeout") {
          dna.units = simulate.timeUnits;
        }
      }
      let constraints = node.constraints;
      dna.maxConstraint = constraints.max;
      dna.useMaxConstraint = "max" in constraints;
      dna.minConstraint = constraints.min;
      dna.useMinConstraint = "min" in constraints;
    }
    if (dna.units) {
      dna.units.addBase();
      dna.toBase = dna.units.toBase;
    }
    dna.unitless = !dna.units;
    return dna;
  }
  function folderSolvers(node, solvers) {
    if (!node) {
      return solvers.base;
    }
    if (node instanceof Population) {
      let x2 = node.agentBase;
      if (x2 && solvers[x2.id]) {
        return solvers[x2.id];
      }
    }
    let p2 = node.parent;
    if (p2 && solvers[p2.id]) {
      return solvers[p2.id];
    }
    return folderSolvers(p2, solvers);
  }
  function decodeDNA(dna, agent2, simulate, inContainer) {
    let x2;
    if (dna.primitive instanceof Variable) {
      x2 = new SVariable(simulate);
    } else if (dna.primitive instanceof State) {
      x2 = new SState(simulate);
    } else if (dna.primitive instanceof Transition2) {
      x2 = new STransition(simulate);
    } else if (dna.primitive instanceof Action) {
      x2 = new SAction(simulate);
    } else if (dna.primitive instanceof Stock) {
      x2 = new SStock(simulate);
    } else if (dna.primitive instanceof Flow) {
      x2 = new SFlow(simulate);
    } else if (dna.primitive instanceof Converter) {
      x2 = new SConverter(simulate);
    }
    if (x2) {
      x2.dna = dna;
      x2.id = dna.id;
      if (inContainer) {
        x2.index = agent2.index;
        x2.agentId = agent2.agentId;
        x2.container = agent2;
        x2.createIds();
      }
      x2.frozen = dna.frozen;
      agent2.children.push(x2);
      agent2.childrenId[x2.id] = x2;
      if (dna.slider) {
        if (simulate.sliders[dna.id]) {
          simulate.sliders[dna.id].push(x2);
        } else {
          simulate.sliders[dna.id] = [x2];
        }
      }
      if (x2 instanceof SAction) {
        dna.solver.actions.push(x2);
      } else if (x2 instanceof STransition) {
        dna.solver.transitions.push(x2);
      } else if (!(x2 instanceof SPopulation)) {
        dna.solver.valued.push(x2);
        if (x2 instanceof SFlow) {
          dna.solver.flows.push(x2);
        } else if (x2 instanceof SStock) {
          dna.solver.stocks.push(x2);
        } else if (x2 instanceof SState) {
          dna.solver.states.push(x2);
        }
      }
      if (dna.neighborProxyDNA) {
        x2.neighborProxyPrimitive = agent2.children.find((x3) => x3.dna === dna.neighborProxyDNA);
      }
    } else if (dna.primitive instanceof Population) {
      agent2.children.push(dna.agents);
      agent2.childrenId[dna.id] = dna.agents;
    }
  }
  function linkPrimitive(primitive, dna, simulate) {
    if (!(primitive instanceof SPopulation)) {
      let myNeighborhood = getPrimitiveNeighborhood(primitive.neighborProxyPrimitive ? primitive.neighborProxyPrimitive : primitive, primitive.neighborProxyPrimitive ? primitive.dna.neighborProxyDNA : dna, simulate, primitive.dna.extraLinksPrimitives);
      if (primitive instanceof SFlow || primitive instanceof STransition) {
        let localNeighborhood = myNeighborhood;
        if (primitive.neighborProxyPrimitive) {
          localNeighborhood = getPrimitiveNeighborhood(primitive, dna, simulate, primitive.dna.extraLinksPrimitives);
        }
        let alpha = null, omega = null;
        if (localNeighborhood.has("[alpha")) {
          alpha = /** @type {any} */
          localNeighborhood.get("[alpha");
        }
        if (localNeighborhood.has("[omega")) {
          omega = /** @type {any} */
          localNeighborhood.get("[omega");
        }
        if (primitive instanceof STransition) {
          if (alpha && !(alpha instanceof SState)) {
            throw new ModelError(`The start of the primitive <i>[${dna.name}]</i> must be a state.`, {
              primitive: dna.primitive,
              showEditor: false,
              code: 1060
            });
          }
          if (omega && !(omega instanceof SState)) {
            throw new ModelError(`The end of the primitive <i>[${dna.name}]</i> must be a state.`, {
              primitive: dna.primitive,
              showEditor: false,
              code: 1061
            });
          }
        }
        if (primitive instanceof SFlow) {
          if (alpha && !(alpha instanceof SStock)) {
            throw new ModelError(`The start of the primitive <i>[${dna.name}]</i> must be a stock.`, {
              primitive: dna.primitive,
              showEditor: false,
              code: 1062
            });
          }
          if (omega && !(omega instanceof SStock)) {
            throw new ModelError(`The end of the primitive <i>[${dna.name}]</i> must be a stock.`, {
              primitive: dna.primitive,
              showEditor: false,
              code: 1063
            });
          }
        }
        primitive.setEnds(alpha, omega);
      }
      if (primitive instanceof SAction) {
        try {
          primitive.equation = trimTree(dna.triggerValue, myNeighborhood, primitive.simulate);
        } catch (err) {
          let msg = `The primitive <i>[${toHTML(dna.name)}]</i> has an equation error that must be corrected before the model can be run.`;
          if (err instanceof ModelError) {
            msg = msg + "<br/><br/>" + err.message;
          }
          throw new ModelError(msg, {
            primitive: dna.primitive,
            showEditor: false,
            code: 1064
          });
        }
        try {
          primitive.action = trimTree(dna.value, myNeighborhood, primitive.simulate);
        } catch (err) {
          let msg = `The primitive <i>[${toHTML(dna.name)}]</i> has an equation error that must be corrected before the model can be run.`;
          if (err instanceof ModelError) {
            msg = msg + "<br/><br/>" + err.message;
          }
          let l2 = void 0;
          if (err.match && err.match(/line (\d+)/i)) {
            l2 = err.match(/line (\d+)/i)[1];
          }
          throw new ModelError(msg, {
            primitive: dna.primitive,
            showEditor: true,
            code: 1065,
            line: l2,
            details: err.match ? err : void 0
          });
        }
      } else if (primitive instanceof SConverter) {
        if (dna.source === "Time") {
          primitive.setSource("*time");
        } else {
          let source = dna.source;
          let sourceSet = false;
          let neighborIds = getPrimitiveNeighborhood(primitive, dna, simulate, [], true);
          for (let neighborId of neighborIds.keys()) {
            if (source === neighborId) {
              primitive.setSource(neighborIds.get(neighborId));
              sourceSet = true;
              break;
            }
          }
          if (!sourceSet) {
            throw new ModelError("Converter source could not be found. Please redefine it.", {
              primitive: dna.primitive,
              showEditor: false,
              code: 1066
            });
          }
        }
      } else {
        primitive.setEquation(dna.value, myNeighborhood);
      }
    }
  }
  function setAgentInitialValues(agent2) {
    for (let child of agent2.children) {
      if (child instanceof SStock) {
        child.setDelay();
        try {
          child.setInitialValue();
        } catch (err) {
          if (err instanceof ModelError) {
            if (!err.primitive) {
              err.primitive = child.orig();
            }
            throw err;
          } else {
            throw err;
          }
        }
      } else if (child instanceof SState) {
        try {
          if (child.active === null) {
            child.setInitialActive(true);
          }
        } catch (err) {
          if (err instanceof ModelError) {
            if (!err.primitive) {
              err.primitive = child.orig();
            }
            throw err;
          } else {
            throw err;
          }
        }
      }
    }
  }
  function buildNetwork(submodel, simulate) {
    if (submodel.network === "Custom Function") {
      let neighbors = getPrimitiveNeighborhood(submodel, submodel.dna, simulate, []);
      let tree = trimTree(createTree(submodel.networkFunction, "p:" + submodel.id + ":networkFunction", simulate), neighbors, simulate);
      for (let i2 = 0; i2 < submodel.agents.length - 1; i2++) {
        for (let j = i2 + 1; j < submodel.agents.length; j++) {
          if (trueValue(simpleEquation(submodel.networkFunction, simulate, /* @__PURE__ */ new Map([
            [PARENT_SYMBOL, simulate.varBank],
            ["a", submodel.agents[i2]],
            ["b", submodel.agents[j]]
          ]), neighbors, tree))) {
            submodel.agents[i2].connect(submodel.agents[j]);
          }
        }
      }
    } else if (submodel.network === "None") {
    } else {
      throw new ModelError(`Unknown network type: ${toHTML(submodel.network)}.`, {
        primitive: submodel.node,
        showEditor: false,
        code: 1024
      });
    }
  }
  function buildPlacements(submodel, simulate) {
    let tree;
    let wCount;
    let hCount;
    if (submodel.placement === "Random") {
      for (let agent2 of submodel.agents) {
        agent2.location = new Vector([mult(submodel.geoWidth, new Material(Rand(simulate))), mult(submodel.geoHeight, new Material(Rand(simulate)))], simulate, ["x", "y"]);
      }
    } else if (submodel.placement === "Custom Function") {
      submodel.agents.forEach((s2) => {
        let n2 = getPrimitiveNeighborhood(submodel, submodel.dna, simulate, []);
        n2.set("self", s2);
        s2.location = simpleUnitsTest(
          /** @type {Vector} */
          simpleEquation(submodel.placementFunction, simulate, /* @__PURE__ */ new Map([
            [PARENT_SYMBOL, simulate.varBank],
            ["self", s2]
          ]), n2),
          submodel.geoDimUnitsObject,
          simulate,
          null,
          null,
          "Agent placement functions must return a two element vector"
        );
        validateAgentLocation(s2.location, submodel.node);
        if (!s2.location.names) {
          s2.location.names = ["x", "y"];
          s2.location.namesLC = ["x", "y"];
        }
      });
    } else if (submodel.placement === "Grid") {
      tree = trimTree(createTree("{x: x*width(self), y: y*height(self)}", "_", simulate), /* @__PURE__ */ new Map(), simulate);
      let size = submodel.agents.length;
      let ratio = (
        /** @type {number} */
        simpleNum(simpleEquation("width(self)/height(self)", simulate, /* @__PURE__ */ new Map([
          [PARENT_SYMBOL, simulate.varBank],
          ["self", submodel]
        ]), /* @__PURE__ */ new Map()), submodel.geoDimUnitsObject, simulate)
      );
      hCount = Math.sqrt(size / ratio);
      wCount = Math.floor(hCount * ratio);
      hCount = Math.ceil(hCount);
      if (hCount * wCount < size) {
        wCount = wCount + 1;
      }
      let j = 0;
      submodel.agents.forEach((s2) => {
        let xPos = (j % wCount + 0.5) / wCount;
        let yPos = (Math.floor(j / wCount) + 0.5) / hCount;
        s2.location = simpleUnitsTest(
          /** @type {Vector} */
          simpleEquation(null, simulate, /* @__PURE__ */ new Map([
            ["self", s2],
            ["x", new Material(xPos)],
            ["y", new Material(yPos)],
            [PARENT_SYMBOL, simulate.varBank]
          ]), /* @__PURE__ */ new Map(), tree),
          submodel.geoDimUnitsObject,
          simulate
        );
        j++;
      });
    } else if (submodel.placement === "Ellipse") {
      tree = trimTree(createTree("{width(self), height(self)}/2+{sin(index(self)/size*2*3.14159), cos(index(self)/size*2*3.14159)}*{width(self), height(self)}/2", "_", simulate), /* @__PURE__ */ new Map(), simulate);
      let size = new Material(submodel.agents.length);
      submodel.agents.forEach((s2) => {
        s2.location = simpleUnitsTest(
          /** @type {Vector} */
          simpleEquation(null, simulate, /* @__PURE__ */ new Map([
            ["self", s2],
            ["size", size],
            [PARENT_SYMBOL, simulate.varBank]
          ]), /* @__PURE__ */ new Map(), tree),
          submodel.geoDimUnitsObject,
          simulate
        );
      });
    } else if (submodel.placement === "Network") {
      tree = trimTree(createTree("{x: x*width(self), y: y*height(self)}", "_", simulate), /* @__PURE__ */ new Map(), simulate);
      let graph = new Graph();
      let nodes = submodel.agents.map((s2) => {
        return graph.newNode({
          data: s2
        });
      });
      let getNode = function(item) {
        for (let node of nodes) {
          if (node.data.data === item) {
            return node;
          }
        }
        return null;
      };
      submodel.agents.forEach((a2) => {
        a2.connected.forEach((target) => {
          graph.newEdge(getNode(a2), getNode(target));
        });
      });
      let layout = new Layout.ForceDirected(graph, 400, 600, 0.5);
      layout.getRandom = () => Rand(simulate);
      for (let i2 = 0; i2 < 60; i2++) {
        layout.applyCoulombsLaw();
        layout.applyHookesLaw();
        layout.attractToCentre();
        layout.updateVelocity(0.03);
        layout.updatePosition(0.03);
      }
      let bb = layout.getBoundingBox();
      bb.width = bb.topright.x - bb.bottomleft.x;
      bb.height = bb.topright.y - bb.bottomleft.y;
      let scalePoint = function(p2) {
        return {
          x: (p2.x - bb.bottomleft.x) / bb.width,
          y: (p2.y - bb.bottomleft.y) / bb.height
        };
      };
      layout.eachNode((node, point) => {
        let p2 = scalePoint(point.p);
        node.data.data.location = simpleUnitsTest(simpleEquation(null, simulate, /* @__PURE__ */ new Map([
          ["self", submodel],
          ["x", new Material(p2.x)],
          ["y", new Material(p2.y)],
          [PARENT_SYMBOL, simulate.varBank]
        ]), /* @__PURE__ */ new Map(), tree), submodel.geoDimUnitsObject, simulate);
      });
    } else {
      throw new ModelError(`Unknown placement type: ${toHTML(submodel.placement)}.`, {
        primitive: submodel.node,
        showEditor: false,
        code: 1021
      });
    }
  }
  var DUPLICATE_PRIMITIVE_NAMES = /* @__PURE__ */ Symbol("DUPLICATE_PRIMITIVE_NAMES");
  function getPrimitiveNeighborhood(primitive, dna, simulate, extraLinksPrimitives, useIdKeys = false) {
    let neighbors = dna.primitive.neighbors();
    if (extraLinksPrimitives) {
      for (let link of extraLinksPrimitives) {
        neighbors.push({
          item: link,
          type: "direct"
        });
      }
    }
    let placeholders = /* @__PURE__ */ new Map();
    let ns = /* @__PURE__ */ new Map([[
      "self",
      primitive
    ]]);
    if (primitive instanceof SPopulation) {
      for (let dna2 of primitive.DNAs) {
        placeholders.set(dna2.name.toLowerCase(), new Placeholder(dna2, primitive, simulate));
      }
    }
    for (let neighbor of neighbors) {
      let addNeighbor = function(name, item2) {
        if (useIdKeys) {
          ns.set(item2.id, item2);
          return;
        }
        let isPlaceholder = item2 instanceof Placeholder;
        if (ns.has(name) && !(ns.get(name) instanceof Placeholder)) {
          if (ns.get(name) !== item2) {
            if (!isPlaceholder) {
              ns.set(name, DUPLICATE_PRIMITIVE_NAMES);
            }
          }
        } else {
          ns.set(name, item2);
        }
        if (!isPlaceholder) {
          if (primitive instanceof SFlow || primitive instanceof STransition) {
            if (dna.targetId === item2.id) {
              ns.set("[omega", item2);
            } else if (dna.sourceId === item2.id) {
              ns.set("[alpha", item2);
            }
          }
        }
      };
      let item = neighbor.item;
      if (item instanceof Population) {
        addNeighbor(primitive.simulate.simulationModel.submodels[item.id].dna.name.toLowerCase(), primitive.simulate.simulationModel.submodels[item.id]);
        for (let dna2 of primitive.simulate.simulationModel.submodels[item.id].DNAs) {
          addNeighbor(dna2.name.toLowerCase(), new Placeholder(dna2, primitive, simulate));
        }
      } else if (neighbor.type !== "agent") {
        let found = false;
        if (primitive.container) {
          if (primitive.container.childrenId[item.id]) {
            addNeighbor(
              primitive.container.childrenId[item.id].dna.name.toLowerCase(),
              primitive.container.childrenId[item.id]
            );
            found = true;
          }
        }
        if (!found) {
          if (primitive.simulate.simulationModel.submodels["base"]["agents"][0].childrenId[item.id]) {
            addNeighbor(primitive.simulate.simulationModel.submodels["base"]["agents"][0].childrenId[item.id].dna.name.toLowerCase(), primitive.simulate.simulationModel.submodels["base"]["agents"][0].childrenId[item.id]);
            found = true;
          }
        }
        if (!found && (primitive instanceof SFlow || primitive instanceof STransition) && item === simulate.model.getId(item.id)) {
          if (primitive instanceof SFlow) {
            throw new ModelError("Flow primitives may not cross agent boundaries.", {
              primitive: dna.primitive,
              showEditor: false,
              code: 1070
            });
          } else {
            throw new ModelError("Transition primitives may not cross agent boundaries.", {
              primitive: dna.primitive,
              showEditor: false,
              code: 1071
            });
          }
        }
      }
    }
    for (let key of placeholders.keys()) {
      if (!ns.has(key)) {
        ns.set(key, placeholders.get(key));
      }
    }
    return ns;
  }
  function modelType(node) {
    return node instanceof Stock || node instanceof Flow || node instanceof State || node instanceof Transition2 || node instanceof Converter || node instanceof Variable || node instanceof Action || node instanceof Population;
  }
  function updateDisplayed(solver, simulate) {
    let displayed = solver.displayed;
    if (simulate.displayInformation.store) {
      for (let k2 = simulate.displayInformation.store.data.length; k2 < simulate.results.times.length; k2++) {
        let inStore = simulate.displayInformation.store.data[k2];
        let d2 = {};
        if (!inStore) {
          d2["id"] = k2;
          d2["Time"] = simulate.results.times[k2];
        }
        if (displayed.length > 0) {
          if (simulate.results.data[k2][displayed[0].id] === void 0) {
          } else {
            for (let j = 0; j < displayed.length; j++) {
              let i2 = simulate.displayInformation.ids.indexOf(displayed[j].id);
              if (i2 > -1) {
                if (simulate.results.children[simulate.displayInformation.ids[i2]].states) {
                  let states = simulate.results.children[simulate.displayInformation.ids[i2]].states;
                  if (simulate.results.data[k2][displayed[j].id]) {
                    let current = simulate.results.data[k2][displayed[j].id].current;
                    let tally = {};
                    for (let item of current) {
                      if (item.state) {
                        for (let state of item.state) {
                          tally[state.id.toString()] = tally[state.id.toString()] + 1 || 1;
                        }
                      }
                    }
                    let q = 0;
                    states.forEach((state) => {
                      d2[simulate.displayInformation.elementIds[i2 + q]] = tally[state] || 0;
                      q++;
                    });
                  }
                } else if (simulate.results.children[simulate.displayInformation.ids[i2]].indexedNames) {
                  let z = 0;
                  while (i2 < simulate.displayInformation.ids.length && simulate.displayInformation.ids[i2] === displayed[j].id) {
                    try {
                      d2[simulate.displayInformation.elementIds[i2]] = selectFromMatrix(simulate.results.data[k2][displayed[j].id].fullClone(), simulate, simulate.results.children[simulate.displayInformation.ids[i2]].indexedFullNames[z].slice());
                    } catch (err) {
                      throw new ModelError("Cannot change vector keys during a simulation.", {
                        primitive: displayed[j].dna.primitive,
                        showEditor: true,
                        code: 1022
                      });
                    }
                    z++;
                    i2++;
                  }
                } else {
                  d2[simulate.displayInformation.elementIds[i2]] = simulate.results.data[k2][displayed[j].id];
                }
              }
            }
          }
        }
        if (inStore) {
          Object.assign(inStore, d2);
        } else {
          simulate.displayInformation.store.data.push(d2);
        }
      }
      if (!simulate.resultsWindow) {
        simulate.resultsWindow = simulate.config.createResultsWindow(simulate);
      }
    }
  }
  function validateAgentLocation(location, primitive) {
    let invalidLocationError = () => {
      throw new ModelError("Agent placement functions must return a two element vector", {
        primitive,
        showEditor: false,
        code: 1023
      });
    };
    if (!(location instanceof Vector)) {
      invalidLocationError();
    }
    if (location.length() !== 2) {
      invalidLocationError();
    }
    if (!(location.items[0] instanceof Material)) {
      invalidLocationError();
    }
    if (!(location.items[1] instanceof Material)) {
      invalidLocationError();
    }
  }
  function makeClusters(simulate) {
    let ordering = {};
    let flows = simulate.model.findFlows();
    let clusterId = 0;
    while (flows.length) {
      clusterId++;
      let flow = flows[0];
      let cluster = {
        availableFlows: flows,
        edges: [],
        stockSet: /* @__PURE__ */ new Set(),
        flowSet: /* @__PURE__ */ new Set(),
        simulate
      };
      clusterAddFlow(cluster, flow);
      let sorted;
      try {
        sorted = toposort_default(cluster.edges);
      } catch (_err) {
        let items = [...cluster.flowSet.values()];
        items.sort((a2, b2) => a2.id - b2.id);
        let flowCount2 = 0;
        for (let flow2 of items) {
          flowCount2++;
          ordering[flow2.id] = {
            cluster: clusterId,
            flow: flowCount2
          };
        }
        continue;
      }
      let flowCount = 0;
      for (let item of sorted) {
        if (item instanceof Flow) {
          flowCount++;
          ordering[item.id] = {
            cluster: clusterId,
            flow: flowCount
          };
        }
      }
    }
    return ordering;
  }
  function clusterAddFlow(cluster, flow) {
    cluster.flowSet.add(flow);
    cluster.availableFlows.splice(cluster.availableFlows.indexOf(flow), 1);
    let alpha = flow.start;
    let omega = flow.end;
    if (alpha && alpha.nonNegative) {
      cluster.edges.push([alpha, flow]);
      if (!cluster.stockSet.has(alpha)) {
        cluster.stockSet.add(alpha);
        clusterAddStock(cluster, alpha);
      }
    }
    if (omega && omega.nonNegative) {
      cluster.edges.push([flow, omega]);
      if (!cluster.stockSet.has(omega)) {
        cluster.stockSet.add(omega);
        clusterAddStock(cluster, omega);
      }
    }
  }
  function clusterAddStock(cluster, stock) {
    let found = true;
    while (found) {
      found = false;
      for (let flow of cluster.availableFlows) {
        let alpha = flow.start;
        let omega = flow.end;
        if (alpha === stock || omega === stock) {
          clusterAddFlow(cluster, flow);
          found = true;
          break;
        }
      }
    }
  }
  var macroCounter = 0;
  function delayGenerator(parameters, primitiveDNA, node, submodel, solvers, simulate) {
    let {
      input,
      initialValue,
      period,
      order
    } = parameters;
    order = evaluateTree(trimTree(order, /* @__PURE__ */ new Map(), simulate), /* @__PURE__ */ new Map(), simulate).value;
    if (order < 1 || order !== Math.floor(order)) {
      throw new ModelError("DelayN order must be an integer greater than or equal to 1.", {
        primitive: primitiveDNA.primitive,
        showEditor: true,
        code: 1078
      });
    }
    let m2 = new Model();
    let outflowName = "__DelayN Outflow " + macroCounter++;
    let stockNames = [];
    let stocks = [];
    let flows = [];
    for (let i2 = 0; i2 < order; i2++) {
      stockNames.push("__DelayN Stock " + macroCounter++);
      stocks.push(m2.Stock({
        name: stockNames[stockNames.length - 1],
        initial: "(iv) || (i)"
      }));
      stocks[i2]._node.id = "" + Math.random();
    }
    let f2 = m2.Flow(null, stocks[0], {
      name: "DelayN Inflow",
      rate: "(i)",
      nonNegative: false
    });
    f2._node.id = "" + Math.random();
    flows.push(f2);
    for (let i2 = 1; i2 < order; i2++) {
      f2 = m2.Flow(stocks[i2 - 1], stocks[i2], {
        name: "DelayN Flow " + i2,
        rate: "(alpha) / (p/order)",
        nonNegative: false
      });
      f2._node.id = "" + Math.random();
      flows.push(f2);
    }
    f2 = m2.Flow(stocks[order - 1], null, {
      name: outflowName,
      rate: "(alpha) / (p/order)",
      nonNegative: false
    });
    f2._node.id = "" + Math.random();
    flows.push(f2);
    period = new TreeNode("LINES", "LINES", node.position, [
      // create temp variable with unitless value
      new TreeNode("ASSIGN", "ASSIGN", node.position, [
        new TreeNode("ASSIGNED", "ASSIGNED", node.position, [
          new TreeNode("__tmp_macro_period", "IDENT", node.position)
        ]),
        new TreeNode("INNER", "INNER", node.position, [
          new TreeNode("RemoveUnits", "IDENT", node.position),
          new TreeNode("FUNCALL", "FUNCALL", node.position, [
            period,
            new TreeNode('"' + simulate.timeUnitsString + '"', "STRING", node.position)
          ])
        ])
      ]),
      // assert it's greater than 0
      new TreeNode("INNER", "INNER", node.position, [
        new TreeNode("Assert", "IDENT", node.position),
        new TreeNode("FUNCALL", "FUNCALL", node.position, [
          // Code for:
          //   > not contains({PERIOD > 0}, false)
          // this confirms all the values in period are greater than 0
          // period can be a scalar or vector
          new TreeNode("NOT", "NOT", node.position, [
            new TreeNode("INNER", "INNER", node.position, [
              new TreeNode("Contains", "IDENT", node.position),
              new TreeNode("FUNCALL", "FUNCALL", node.position, [
                new TreeNode("ARRAY", "ARRAY", node.position, [
                  new TreeNode("LABEL", "LABEL", node.position, [
                    new TreeNode("INNER", "INNER", node.position, [
                      new TreeNode(">", "GT", node.position, [
                        new TreeNode("__tmp_macro_period", "IDENT", node.position),
                        new TreeNode("0", "INTEGER", node.position)
                      ])
                    ])
                  ])
                ]),
                new TreeNode("FALSE", "FALSE", node.position)
              ])
            ])
          ]),
          new TreeNode('"Period for Delay() must be greater than 0."', "STRING", node.position)
        ])
      ]),
      // return it
      new TreeNode("__tmp_macro_period", "IDENT", node.position)
    ]);
    let periodOverOrder = new TreeNode("DIV", "DIV", node.position, [
      period,
      new TreeNode("" + order, "INTEGER", node.position)
    ]);
    let sDNAs = stocks.map((s2) => getDNA(s2, submodel, solvers, simulate));
    let fDNAs = flows.map((i2) => getDNA(i2, submodel, solvers, simulate));
    for (let i2 = 1; i2 < fDNAs.length; i2++) {
      fDNAs[i2].extraLinksPrimitives.push(stocks[i2 - 1]);
    }
    primitiveDNA.extraLinksPrimitives.push(flows[flows.length - 1]);
    fDNAs[0].value = input.cloneStructure();
    let init2 = new TreeNode("MULT", "MULT", node.position, [
      initialValue ? initialValue.cloneStructure() : input.cloneStructure(),
      periodOverOrder.cloneStructure()
    ]);
    for (let i2 = 0; i2 < sDNAs.length; i2++) {
      sDNAs[i2].value = init2.cloneStructure();
    }
    for (let i2 = 1; i2 < fDNAs.length; i2++) {
      fDNAs[i2].value = new TreeNode("DIV", "DIV", node.position, [
        new TreeNode("[" + stockNames[i2 - 1] + "]", "PRIMITIVE", node.position),
        periodOverOrder.cloneStructure()
      ]);
    }
    for (let i2 = 0; i2 < sDNAs.length; i2++) {
      sDNAs[i2].noOutput = true;
      sDNAs[i2].adoptUnits = true;
      sDNAs[i2].neighborProxyDNA = primitiveDNA;
      submodel.DNAs.push(sDNAs[i2]);
    }
    for (let i2 = 0; i2 < fDNAs.length; i2++) {
      fDNAs[i2].noOutput = true;
      fDNAs[i2].adoptUnits = true;
      fDNAs[i2].neighborProxyDNA = primitiveDNA;
      submodel.DNAs.push(fDNAs[i2]);
    }
    return new TreeNode("[" + outflowName + "]", "PRIMITIVE", node.position);
  }
  function smoothGenerator(parameters, primitiveDNA, node, submodel, solvers, simulate) {
    let {
      input,
      initialValue,
      period,
      order
    } = parameters;
    order = evaluateTree(trimTree(order, /* @__PURE__ */ new Map(), simulate), /* @__PURE__ */ new Map(), simulate).value;
    if (order < 1 || order !== Math.floor(order)) {
      throw new ModelError("SmoothN order must be an integer greater than or equal to 1.", {
        primitive: primitiveDNA.primitive,
        showEditor: true,
        code: 1079
      });
    }
    let m2 = new Model();
    let stockNames = [];
    let stocks = [];
    let flows = [];
    for (let i2 = 0; i2 < order; i2++) {
      stockNames.push("__SmoothN Stock " + macroCounter++);
      stocks.push(m2.Stock({
        name: stockNames[stockNames.length - 1],
        initial: "(iv) || (i)"
      }));
      stocks[i2]._node.id = "" + Math.random();
    }
    for (let i2 = 0; i2 < order; i2++) {
      let f2 = m2.Flow(null, stocks[i2], {
        name: "SmoothN Flow " + i2,
        rate: "(alpha) / (p/order)",
        nonNegative: false
      });
      f2._node.id = "" + Math.random();
      flows.push(f2);
    }
    period = new TreeNode("LINES", "LINES", node.position, [
      // create temp variable with unitless value
      new TreeNode("ASSIGN", "ASSIGN", node.position, [
        new TreeNode("ASSIGNED", "ASSIGNED", node.position, [
          new TreeNode("__tmp_macro_period", "IDENT", node.position)
        ]),
        new TreeNode("INNER", "INNER", node.position, [
          new TreeNode("RemoveUnits", "IDENT", node.position),
          new TreeNode("FUNCALL", "FUNCALL", node.position, [
            period,
            new TreeNode('"' + simulate.timeUnitsString + '"', "STRING", node.position)
          ])
        ])
      ]),
      // assert it's greater than 0
      new TreeNode("INNER", "INNER", node.position, [
        new TreeNode("Assert", "IDENT", node.position),
        new TreeNode("FUNCALL", "FUNCALL", node.position, [
          // Code for:
          //   > not contains({PERIOD > 0}, false)
          // this confirms all the values in period are greater than 0
          // period can be a scalar or vector
          new TreeNode("NOT", "NOT", node.position, [
            new TreeNode("INNER", "INNER", node.position, [
              new TreeNode("Contains", "IDENT", node.position),
              new TreeNode("FUNCALL", "FUNCALL", node.position, [
                new TreeNode("ARRAY", "ARRAY", node.position, [
                  new TreeNode("LABEL", "LABEL", node.position, [
                    new TreeNode("INNER", "INNER", node.position, [
                      new TreeNode(">", "GT", node.position, [
                        new TreeNode("__tmp_macro_period", "IDENT", node.position),
                        new TreeNode("0", "INTEGER", node.position)
                      ])
                    ])
                  ])
                ]),
                new TreeNode("FALSE", "FALSE", node.position)
              ])
            ])
          ]),
          new TreeNode('"Period for Smooth() must be greater than 0."', "STRING", node.position)
        ])
      ]),
      // return it
      new TreeNode("__tmp_macro_period", "IDENT", node.position)
    ]);
    let periodOverOrder = new TreeNode("DIV", "DIV", node.position, [
      period,
      new TreeNode("" + order, "INTEGER", node.position)
    ]);
    let sDNAs = stocks.map((s2) => getDNA(s2, submodel, solvers, simulate));
    let fDNAs = flows.map((i2) => getDNA(i2, submodel, solvers, simulate));
    for (let i2 = 0; i2 < order; i2++) {
      fDNAs[i2].extraLinksPrimitives.push(stocks[i2]);
      if (i2 > 0) {
        fDNAs[i2].extraLinksPrimitives.push(stocks[i2 - 1]);
      }
    }
    primitiveDNA.extraLinksPrimitives.push(stocks[stocks.length - 1]);
    for (let i2 = 0; i2 < order; i2++) {
      sDNAs[i2].value = initialValue ? initialValue.cloneStructure() : input.cloneStructure();
    }
    for (let i2 = 0; i2 < order; i2++) {
      fDNAs[i2].value = new TreeNode("DIV", "DIV", node.position, [
        new TreeNode("MINUS", "MINUS", node.position, [
          i2 === 0 ? input.cloneStructure() : new TreeNode("[" + stockNames[i2 - 1] + "]", "PRIMITIVE", node.position),
          new TreeNode("[" + stockNames[i2] + "]", "PRIMITIVE", node.position)
        ]),
        periodOverOrder.cloneStructure()
      ]);
    }
    for (let i2 = 0; i2 < order; i2++) {
      fDNAs[i2].noOutput = true;
      fDNAs[i2].adoptUnits = true;
      fDNAs[i2].neighborProxyDNA = primitiveDNA;
      submodel.DNAs.push(fDNAs[i2]);
      sDNAs[i2].noOutput = true;
      sDNAs[i2].adoptUnits = true;
      sDNAs[i2].neighborProxyDNA = primitiveDNA;
      submodel.DNAs.push(sDNAs[i2]);
    }
    return new TreeNode("[" + stockNames[stockNames.length - 1] + "]", "PRIMITIVE", node.position);
  }
  var MACRO_FNS = {
    "_initial": {
      replacement: (parameters) => {
        let {
          input,
          initialValue
        } = parameters;
        return initialValue ? initialValue.cloneStructure() : input.cloneStructure();
      }
    },
    "smooth": {
      replacement: (parameters, primitiveDNA, node, submodel, solvers, simulate) => {
        parameters.order = new TreeNode("1", "INTEGER", node.position);
        return smoothGenerator(parameters, primitiveDNA, node, submodel, solvers, simulate);
      }
    },
    "smoothn": {
      replacement: (...params) => smoothGenerator(...params)
    },
    "delay1": {
      replacement: (parameters, primitiveDNA, node, submodel, solvers, simulate) => {
        parameters.order = new TreeNode("1", "INTEGER", node.position);
        return delayGenerator(parameters, primitiveDNA, node, submodel, solvers, simulate);
      }
    },
    "delay3": {
      replacement: (parameters, primitiveDNA, node, submodel, solvers, simulate) => {
        parameters.order = new TreeNode("3", "INTEGER", node.position);
        return delayGenerator(parameters, primitiveDNA, node, submodel, solvers, simulate);
      }
    },
    "delayn": {
      replacement: (...params) => delayGenerator(...params)
    }
  };
  function getMacroParameters(children3, name, assigns) {
    let requiresOrder = name.toLowerCase().endsWith("n");
    if (children3.length > 3 + (requiresOrder ? 1 : 0) || children3.length < 2 + (requiresOrder ? 1 : 0)) {
      throw new ModelError(`Wrong number of parameters for ${name}().`, {
        code: 10001
      });
    }
    function pullInAssigns(node) {
      if (node.typeName === "IDENT") {
        for (let assign of assigns) {
          if (assign.target === node.text) {
            return assign.value.cloneStructure();
          }
        }
      }
      node.children = node.children.map((n2) => pullInAssigns(n2));
      return node;
    }
    if (assigns.length) {
      children3 = children3.map((n2) => pullInAssigns(n2));
    }
    return {
      input: children3[0],
      period: children3[1],
      order: requiresOrder ? children3[2] : null,
      initialValue: requiresOrder ? children3[3] : children3[2]
    };
  }
  var MACRO_FNS_NAMES = Object.keys(MACRO_FNS).filter((x2) => !x2.startsWith("_"));
  function replaceMacros(primitive, primitiveDNA, node, submodel, solvers, simulate, isInitial, assigns = []) {
    let macroName;
    let parameters;
    if (node.typeName === "INNER") {
      if (node.children.length === 2) {
        if (node.children[0].typeName === "IDENT" && MACRO_FNS_NAMES.includes(node.children[0].text)) {
          macroName = node.children[0].text;
          if (node.children[1].typeName === "FUNCALL") {
            parameters = getMacroParameters(node.children[1].children.slice(), macroName, assigns);
          }
        }
      } else if (node.children.length === 3 && node.children[0].typeName === "PRIMITIVE" && (node.children[1].typeName === "SELECTOR" && node.children[1].children[0].typeName === "DOTSELECTOR" && MACRO_FNS_NAMES.includes(node.children[1].children[0].children[0].text)) && node.children[2].typeName === "FUNCALL") {
        macroName = node.children[1].children[0].children[0].text;
        parameters = getMacroParameters([node.children[0]].concat(node.children[2].children), macroName, assigns);
      }
    }
    if (macroName) {
      if (isInitial) {
        return MACRO_FNS["_initial"].replacement(parameters, primitiveDNA, node, submodel, solvers, simulate);
      } else {
        return MACRO_FNS[macroName].replacement(parameters, primitiveDNA, node, submodel, solvers, simulate);
      }
    } else {
      node.children = node.children.map((n2) => replaceMacros(primitive, primitiveDNA, n2, submodel, solvers, simulate, isInitial, assigns));
    }
    if (node.typeName === "ASSIGN" && node.children.length === 2 && node.children[0].typeName === "ASSIGNED" && node.children[0].children.length) {
      assigns.push({
        target: node.children[0].children[0].text,
        value: node.children[1]
      });
    }
    return node;
  }

  // ../insight-maker-simulation/vendor/xmldom/conventions.js
  function freeze(object, oc) {
    if (oc === void 0) {
      oc = Object;
    }
    return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
  }
  var MIME_TYPE = freeze({
    /**
     * `text/html`, the only mime type that triggers treating an XML document as HTML.
     *
     * @see DOMParser.SupportedType.isHTML
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
     */
    HTML: "text/html",
    /**
     * Helper method to check a mime type if it indicates an HTML document
     *
     * @param {string} [value]
     * @returns {boolean}
     *
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
    isHTML: function(value) {
      return value === MIME_TYPE.HTML;
    },
    /**
     * `application/xml`, the standard mime type for XML documents.
     *
     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_APPLICATION: "application/xml",
    /**
     * `text/html`, an alias for `application/xml`.
     *
     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_TEXT: "text/xml",
    /**
     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
     * but is parsed as an XML document.
     *
     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
     */
    XML_XHTML_APPLICATION: "application/xhtml+xml",
    /**
     * `image/svg+xml`,
     *
     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
     */
    XML_SVG_IMAGE: "image/svg+xml"
  });
  var NAMESPACE = freeze({
    /**
     * The XHTML namespace.
     *
     * @see http://www.w3.org/1999/xhtml
     */
    HTML: "http://www.w3.org/1999/xhtml",
    /**
     * Checks if `uri` equals `NAMESPACE.HTML`.
     *
     * @param {string} [uri]
     *
     * @see NAMESPACE.HTML
     */
    isHTML: function(uri) {
      return uri === NAMESPACE.HTML;
    },
    /**
     * The SVG namespace.
     *
     * @see http://www.w3.org/2000/svg
     */
    SVG: "http://www.w3.org/2000/svg",
    /**
     * The `xml:` namespace.
     *
     * @see http://www.w3.org/XML/1998/namespace
     */
    XML: "http://www.w3.org/XML/1998/namespace",
    /**
     * The `xmlns:` namespace
     *
     * @see https://www.w3.org/2000/xmlns/
     */
    XMLNS: "http://www.w3.org/2000/xmlns/"
  });

  // ../insight-maker-simulation/vendor/xmldom/dom.js
  var NAMESPACE2 = NAMESPACE;
  function copy(src, dest) {
    for (var p2 in src) {
      dest[p2] = src[p2];
    }
  }
  function _extends(Class, Super) {
    var pt = Class.prototype;
    if (!(pt instanceof Super)) {
      let t2 = function() {
      };
      ;
      t2.prototype = Super.prototype;
      t2 = new t2();
      copy(pt, t2);
      Class.prototype = pt = t2;
    }
    if (pt.constructor != Class) {
      if (typeof Class != "function") {
        console.error("unknow Class:" + Class);
      }
      pt.constructor = Class;
    }
  }
  var NodeType = {};
  var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
  var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
  var TEXT_NODE = NodeType.TEXT_NODE = 3;
  var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
  var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
  var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
  var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
  var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
  var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
  var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
  var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
  var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
  var ExceptionCode = {};
  var ExceptionMessage = {};
  var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
  var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
  var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
  var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
  var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
  var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
  var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
  var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
  var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
  var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
  var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
  var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
  var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
  var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
  var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
  function DOMException(code, message) {
    if (message instanceof Error) {
      var error = message;
    } else {
      error = this;
      Error.call(this, ExceptionMessage[code]);
      this.message = ExceptionMessage[code];
      if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
    }
    error.code = code;
    if (message) this.message = this.message + ": " + message;
    return error;
  }
  DOMException.prototype = Error.prototype;
  copy(ExceptionCode, DOMException);
  function NodeList() {
  }
  NodeList.prototype = {
    /**
     * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
     * @standard level1
     */
    length: 0,
    /**
     * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
     * @standard level1
     * @param index  unsigned long 
     *   Index into the collection.
     * @return Node
     * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
     */
    item: function(index) {
      return this[index] || null;
    },
    toString: function(isHTML, nodeFilter) {
      for (var buf = [], i2 = 0; i2 < this.length; i2++) {
        serializeToString(this[i2], buf, isHTML, nodeFilter);
      }
      return buf.join("");
    }
  };
  function LiveNodeList(node, refresh) {
    this._node = node;
    this._refresh = refresh;
    _updateLiveList(this);
  }
  function _updateLiveList(list) {
    var inc = list._node._inc || list._node.ownerDocument._inc;
    if (list._inc != inc) {
      var ls = list._refresh(list._node);
      __set__(list, "length", ls.length);
      copy(ls, list);
      list._inc = inc;
    }
  }
  LiveNodeList.prototype.item = function(i2) {
    _updateLiveList(this);
    return this[i2];
  };
  _extends(LiveNodeList, NodeList);
  function NamedNodeMap() {
  }
  function _findNodeIndex(list, node) {
    var i2 = list.length;
    while (i2--) {
      if (list[i2] === node) {
        return i2;
      }
    }
  }
  function _addNamedNode(el, list, newAttr, oldAttr) {
    if (oldAttr) {
      list[_findNodeIndex(list, oldAttr)] = newAttr;
    } else {
      list[list.length++] = newAttr;
    }
    if (el) {
      newAttr.ownerElement = el;
      var doc2 = el.ownerDocument;
      if (doc2) {
        oldAttr && _onRemoveAttribute(doc2, el, oldAttr);
        _onAddAttribute(doc2, el, newAttr);
      }
    }
  }
  function _removeNamedNode(el, list, attr) {
    var i2 = _findNodeIndex(list, attr);
    if (i2 >= 0) {
      var lastIndex = list.length - 1;
      while (i2 < lastIndex) {
        list[i2] = list[++i2];
      }
      list.length = lastIndex;
      if (el) {
        var doc2 = el.ownerDocument;
        if (doc2) {
          _onRemoveAttribute(doc2, el, attr);
          attr.ownerElement = null;
        }
      }
    } else {
      throw DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
    }
  }
  NamedNodeMap.prototype = {
    length: 0,
    item: NodeList.prototype.item,
    getNamedItem: function(key) {
      var i2 = this.length;
      while (i2--) {
        var attr = this[i2];
        if (attr.nodeName == key) {
          return attr;
        }
      }
    },
    setNamedItem: function(attr) {
      var el = attr.ownerElement;
      if (el && el != this._ownerElement) {
        throw new DOMException(INUSE_ATTRIBUTE_ERR);
      }
      var oldAttr = this.getNamedItem(attr.nodeName);
      _addNamedNode(this._ownerElement, this, attr, oldAttr);
      return oldAttr;
    },
    /* returns Node */
    setNamedItemNS: function(attr) {
      var el = attr.ownerElement, oldAttr;
      if (el && el != this._ownerElement) {
        throw new DOMException(INUSE_ATTRIBUTE_ERR);
      }
      oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
      _addNamedNode(this._ownerElement, this, attr, oldAttr);
      return oldAttr;
    },
    /* returns Node */
    removeNamedItem: function(key) {
      var attr = this.getNamedItem(key);
      _removeNamedNode(this._ownerElement, this, attr);
      return attr;
    },
    // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
    //for level2
    removeNamedItemNS: function(namespaceURI, localName) {
      var attr = this.getNamedItemNS(namespaceURI, localName);
      _removeNamedNode(this._ownerElement, this, attr);
      return attr;
    },
    getNamedItemNS: function(namespaceURI, localName) {
      var i2 = this.length;
      while (i2--) {
        var node = this[i2];
        if (node.localName == localName && node.namespaceURI == namespaceURI) {
          return node;
        }
      }
      return null;
    }
  };
  function DOMImplementation() {
  }
  DOMImplementation.prototype = {
    /**
     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
     * The different implementations fairly diverged in what kind of features were reported.
     * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
     *
     * @deprecated It is deprecated and modern browsers return true in all cases.
     *
     * @param {string} feature
     * @param {string} [version]
     * @returns {boolean} always true
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
     */
    hasFeature: function(feature, version) {
      return true;
    },
    /**
     * Creates an XML Document object of the specified type with its document element.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
     * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string|null} namespaceURI
     * @param {string} qualifiedName
     * @param {DocumentType=null} doctype
     * @returns {Document}
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocument: function(namespaceURI, qualifiedName, doctype) {
      var doc2 = new Document();
      doc2.implementation = this;
      doc2.childNodes = new NodeList();
      doc2.doctype = doctype || null;
      if (doctype) {
        doc2.appendChild(doctype);
      }
      if (qualifiedName) {
        var root2 = doc2.createElementNS(namespaceURI, qualifiedName);
        doc2.appendChild(root2);
      }
      return doc2;
    },
    /**
     * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
     *
     * __This behavior is slightly different from the in the specs__:
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string} qualifiedName
     * @param {string} [publicId]
     * @param {string} [systemId]
     * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
     * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocumentType: function(qualifiedName, publicId, systemId) {
      var node = new DocumentType();
      node.name = qualifiedName;
      node.nodeName = qualifiedName;
      node.publicId = publicId || "";
      node.systemId = systemId || "";
      return node;
    }
  };
  function Node2() {
  }
  Node2.prototype = {
    firstChild: null,
    lastChild: null,
    previousSibling: null,
    nextSibling: null,
    attributes: null,
    parentNode: null,
    childNodes: null,
    ownerDocument: null,
    nodeValue: null,
    namespaceURI: null,
    prefix: null,
    localName: null,
    // Modified in DOM Level 2:
    insertBefore: function(newChild, refChild) {
      return _insertBefore(this, newChild, refChild);
    },
    replaceChild: function(newChild, oldChild) {
      this.insertBefore(newChild, oldChild);
      if (oldChild) {
        this.removeChild(oldChild);
      }
    },
    removeChild: function(oldChild) {
      return _removeChild(this, oldChild);
    },
    appendChild: function(newChild) {
      return this.insertBefore(newChild, null);
    },
    hasChildNodes: function() {
      return this.firstChild != null;
    },
    cloneNode: function(deep) {
      return cloneNode(this.ownerDocument || this, this, deep);
    },
    // Modified in DOM Level 2:
    normalize: function() {
      var child = this.firstChild;
      while (child) {
        var next = child.nextSibling;
        if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
          this.removeChild(next);
          child.appendData(next.data);
        } else {
          child.normalize();
          child = next;
        }
      }
    },
    // Introduced in DOM Level 2:
    isSupported: function(feature, version) {
      return this.ownerDocument.implementation.hasFeature(feature, version);
    },
    // Introduced in DOM Level 2:
    hasAttributes: function() {
      return this.attributes.length > 0;
    },
    lookupPrefix: function(namespaceURI) {
      var el = this;
      while (el) {
        var map = el._nsMap;
        if (map) {
          for (var n2 in map) {
            if (map[n2] == namespaceURI) {
              return n2;
            }
          }
        }
        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI: function(prefix) {
      var el = this;
      while (el) {
        var map = el._nsMap;
        if (map) {
          if (prefix in map) {
            return map[prefix];
          }
        }
        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace: function(namespaceURI) {
      var prefix = this.lookupPrefix(namespaceURI);
      return prefix == null;
    }
  };
  function _xmlEncoder(c2) {
    return c2 == "<" && "&lt;" || c2 == ">" && "&gt;" || c2 == "&" && "&amp;" || c2 == '"' && "&quot;" || "&#" + c2.charCodeAt() + ";";
  }
  copy(NodeType, Node2);
  copy(NodeType, Node2.prototype);
  function _visitNode(node, callback) {
    if (callback(node)) {
      return true;
    }
    if (node = node.firstChild) {
      do {
        if (_visitNode(node, callback)) {
          return true;
        }
      } while (node = node.nextSibling);
    }
  }
  function Document() {
  }
  function _onAddAttribute(doc2, el, newAttr) {
    doc2 && doc2._inc++;
    var ns = newAttr.namespaceURI;
    if (ns === NAMESPACE2.XMLNS) {
      el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
    }
  }
  function _onRemoveAttribute(doc2, el, newAttr, remove2) {
    doc2 && doc2._inc++;
    var ns = newAttr.namespaceURI;
    if (ns === NAMESPACE2.XMLNS) {
      delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
    }
  }
  function _onUpdateChild(doc2, el, newChild) {
    if (doc2 && doc2._inc) {
      doc2._inc++;
      var cs = el.childNodes;
      if (newChild) {
        cs[cs.length++] = newChild;
      } else {
        var child = el.firstChild;
        var i2 = 0;
        while (child) {
          cs[i2++] = child;
          child = child.nextSibling;
        }
        cs.length = i2;
      }
    }
  }
  function _removeChild(parentNode, child) {
    var previous = child.previousSibling;
    var next = child.nextSibling;
    if (previous) {
      previous.nextSibling = next;
    } else {
      parentNode.firstChild = next;
    }
    if (next) {
      next.previousSibling = previous;
    } else {
      parentNode.lastChild = previous;
    }
    _onUpdateChild(parentNode.ownerDocument, parentNode);
    return child;
  }
  function _insertBefore(parentNode, newChild, nextChild) {
    var cp = newChild.parentNode;
    if (cp) {
      cp.removeChild(newChild);
    }
    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
      var newFirst = newChild.firstChild;
      if (newFirst == null) {
        return newChild;
      }
      var newLast = newChild.lastChild;
    } else {
      newFirst = newLast = newChild;
    }
    var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;
    newFirst.previousSibling = pre;
    newLast.nextSibling = nextChild;
    if (pre) {
      pre.nextSibling = newFirst;
    } else {
      parentNode.firstChild = newFirst;
    }
    if (nextChild == null) {
      parentNode.lastChild = newLast;
    } else {
      nextChild.previousSibling = newLast;
    }
    do {
      newFirst.parentNode = parentNode;
    } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
    _onUpdateChild(parentNode.ownerDocument || parentNode, parentNode);
    if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
      newChild.firstChild = newChild.lastChild = null;
    }
    return newChild;
  }
  function _appendSingleChild(parentNode, newChild) {
    var cp = newChild.parentNode;
    if (cp) {
      var pre = parentNode.lastChild;
      cp.removeChild(newChild);
      var pre = parentNode.lastChild;
    }
    var pre = parentNode.lastChild;
    newChild.parentNode = parentNode;
    newChild.previousSibling = pre;
    newChild.nextSibling = null;
    if (pre) {
      pre.nextSibling = newChild;
    } else {
      parentNode.firstChild = newChild;
    }
    parentNode.lastChild = newChild;
    _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
    return newChild;
  }
  Document.prototype = {
    //implementation : null,
    nodeName: "#document",
    nodeType: DOCUMENT_NODE,
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function(newChild, refChild) {
      if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
        var child = newChild.firstChild;
        while (child) {
          var next = child.nextSibling;
          this.insertBefore(child, refChild);
          child = next;
        }
        return newChild;
      }
      if (this.documentElement == null && newChild.nodeType == ELEMENT_NODE) {
        this.documentElement = newChild;
      }
      return _insertBefore(this, newChild, refChild), newChild.ownerDocument = this, newChild;
    },
    removeChild: function(oldChild) {
      if (this.documentElement == oldChild) {
        this.documentElement = null;
      }
      return _removeChild(this, oldChild);
    },
    // Introduced in DOM Level 2:
    importNode: function(importedNode, deep) {
      return importNode(this, importedNode, deep);
    },
    // Introduced in DOM Level 2:
    getElementById: function(id2) {
      var rtv = null;
      _visitNode(this.documentElement, function(node) {
        if (node.nodeType == ELEMENT_NODE) {
          if (node.getAttribute("id") == id2) {
            rtv = node;
            return true;
          }
        }
      });
      return rtv;
    },
    getElementsByClassName: function(className) {
      var pattern = new RegExp("(^|\\s)" + className + "(\\s|$)");
      return new LiveNodeList(this, function(base) {
        var ls = [];
        _visitNode(base.documentElement, function(node) {
          if (node !== base && node.nodeType == ELEMENT_NODE) {
            if (pattern.test(node.getAttribute("class"))) {
              ls.push(node);
            }
          }
        });
        return ls;
      });
    },
    //document factory method:
    createElement: function(tagName) {
      var node = new Element();
      node.ownerDocument = this;
      node.nodeName = tagName;
      node.tagName = tagName;
      node.localName = tagName;
      node.childNodes = new NodeList();
      var attrs = node.attributes = new NamedNodeMap();
      attrs._ownerElement = node;
      return node;
    },
    createDocumentFragment: function() {
      var node = new DocumentFragment();
      node.ownerDocument = this;
      node.childNodes = new NodeList();
      return node;
    },
    createTextNode: function(data) {
      var node = new Text();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createComment: function(data) {
      var node = new Comment();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createCDATASection: function(data) {
      var node = new CDATASection();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createProcessingInstruction: function(target, data) {
      var node = new ProcessingInstruction();
      node.ownerDocument = this;
      node.tagName = node.target = target;
      node.nodeValue = node.data = data;
      return node;
    },
    createAttribute: function(name) {
      var node = new Attr();
      node.ownerDocument = this;
      node.name = name;
      node.nodeName = name;
      node.localName = name;
      node.specified = true;
      return node;
    },
    createEntityReference: function(name) {
      var node = new EntityReference();
      node.ownerDocument = this;
      node.nodeName = name;
      return node;
    },
    // Introduced in DOM Level 2:
    createElementNS: function(namespaceURI, qualifiedName) {
      var node = new Element();
      var pl = qualifiedName.split(":");
      var attrs = node.attributes = new NamedNodeMap();
      node.childNodes = new NodeList();
      node.ownerDocument = this;
      node.nodeName = qualifiedName;
      node.tagName = qualifiedName;
      node.namespaceURI = namespaceURI;
      if (pl.length == 2) {
        node.prefix = pl[0];
        node.localName = pl[1];
      } else {
        node.localName = qualifiedName;
      }
      attrs._ownerElement = node;
      return node;
    },
    // Introduced in DOM Level 2:
    createAttributeNS: function(namespaceURI, qualifiedName) {
      var node = new Attr();
      var pl = qualifiedName.split(":");
      node.ownerDocument = this;
      node.nodeName = qualifiedName;
      node.name = qualifiedName;
      node.namespaceURI = namespaceURI;
      node.specified = true;
      if (pl.length == 2) {
        node.prefix = pl[0];
        node.localName = pl[1];
      } else {
        node.localName = qualifiedName;
      }
      return node;
    }
  };
  _extends(Document, Node2);
  function Element() {
    this._nsMap = {};
  }
  Element.prototype = {
    nodeType: ELEMENT_NODE,
    hasAttribute: function(name) {
      return this.getAttributeNode(name) != null;
    },
    getAttribute: function(name) {
      var attr = this.getAttributeNode(name);
      return attr && attr.value || "";
    },
    getAttributeNode: function(name) {
      return this.attributes.getNamedItem(name);
    },
    setAttribute: function(name, value) {
      var attr = this.ownerDocument.createAttribute(name);
      attr.value = attr.nodeValue = "" + value;
      this.setAttributeNode(attr);
    },
    removeAttribute: function(name) {
      var attr = this.getAttributeNode(name);
      attr && this.removeAttributeNode(attr);
    },
    //four real opeartion method
    appendChild: function(newChild) {
      if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
        return this.insertBefore(newChild, null);
      } else {
        return _appendSingleChild(this, newChild);
      }
    },
    setAttributeNode: function(newAttr) {
      return this.attributes.setNamedItem(newAttr);
    },
    setAttributeNodeNS: function(newAttr) {
      return this.attributes.setNamedItemNS(newAttr);
    },
    removeAttributeNode: function(oldAttr) {
      return this.attributes.removeNamedItem(oldAttr.nodeName);
    },
    //get real attribute name,and remove it by removeAttributeNode
    removeAttributeNS: function(namespaceURI, localName) {
      var old = this.getAttributeNodeNS(namespaceURI, localName);
      old && this.removeAttributeNode(old);
    },
    hasAttributeNS: function(namespaceURI, localName) {
      return this.getAttributeNodeNS(namespaceURI, localName) != null;
    },
    getAttributeNS: function(namespaceURI, localName) {
      var attr = this.getAttributeNodeNS(namespaceURI, localName);
      return attr && attr.value || "";
    },
    setAttributeNS: function(namespaceURI, qualifiedName, value) {
      var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
      attr.value = attr.nodeValue = "" + value;
      this.setAttributeNode(attr);
    },
    getAttributeNodeNS: function(namespaceURI, localName) {
      return this.attributes.getNamedItemNS(namespaceURI, localName);
    },
    getElementsByTagName: function(tagName) {
      return new LiveNodeList(this, function(base) {
        var ls = [];
        _visitNode(base, function(node) {
          if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
            ls.push(node);
          }
        });
        return ls;
      });
    },
    getElementsByTagNameNS: function(namespaceURI, localName) {
      return new LiveNodeList(this, function(base) {
        var ls = [];
        _visitNode(base, function(node) {
          if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
            ls.push(node);
          }
        });
        return ls;
      });
    }
  };
  Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
  Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
  _extends(Element, Node2);
  function Attr() {
  }
  Attr.prototype.nodeType = ATTRIBUTE_NODE;
  _extends(Attr, Node2);
  function CharacterData() {
  }
  CharacterData.prototype = {
    data: "",
    substringData: function(offset, count) {
      return this.data.substring(offset, offset + count);
    },
    appendData: function(text) {
      text = this.data + text;
      this.nodeValue = this.data = text;
      this.length = text.length;
    },
    insertData: function(offset, text) {
      this.replaceData(offset, 0, text);
    },
    appendChild: function(newChild) {
      throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
    },
    deleteData: function(offset, count) {
      this.replaceData(offset, count, "");
    },
    replaceData: function(offset, count, text) {
      var start2 = this.data.substring(0, offset);
      var end = this.data.substring(offset + count);
      text = start2 + text + end;
      this.nodeValue = this.data = text;
      this.length = text.length;
    }
  };
  _extends(CharacterData, Node2);
  function Text() {
  }
  Text.prototype = {
    nodeName: "#text",
    nodeType: TEXT_NODE,
    splitText: function(offset) {
      var text = this.data;
      var newText = text.substring(offset);
      text = text.substring(0, offset);
      this.data = this.nodeValue = text;
      this.length = text.length;
      var newNode = this.ownerDocument.createTextNode(newText);
      if (this.parentNode) {
        this.parentNode.insertBefore(newNode, this.nextSibling);
      }
      return newNode;
    }
  };
  _extends(Text, CharacterData);
  function Comment() {
  }
  Comment.prototype = {
    nodeName: "#comment",
    nodeType: COMMENT_NODE
  };
  _extends(Comment, CharacterData);
  function CDATASection() {
  }
  CDATASection.prototype = {
    nodeName: "#cdata-section",
    nodeType: CDATA_SECTION_NODE
  };
  _extends(CDATASection, CharacterData);
  function DocumentType() {
  }
  DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
  _extends(DocumentType, Node2);
  function Notation() {
  }
  Notation.prototype.nodeType = NOTATION_NODE;
  _extends(Notation, Node2);
  function Entity() {
  }
  Entity.prototype.nodeType = ENTITY_NODE;
  _extends(Entity, Node2);
  function EntityReference() {
  }
  EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
  _extends(EntityReference, Node2);
  function DocumentFragment() {
  }
  DocumentFragment.prototype.nodeName = "#document-fragment";
  DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
  _extends(DocumentFragment, Node2);
  function ProcessingInstruction() {
  }
  ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
  _extends(ProcessingInstruction, Node2);
  function XMLSerializer() {
  }
  XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
    return nodeSerializeToString.call(node, isHtml, nodeFilter);
  };
  Node2.prototype.toString = nodeSerializeToString;
  function nodeSerializeToString(isHtml, nodeFilter) {
    var buf = [];
    var refNode = this.nodeType == 9 && this.documentElement || this;
    var prefix = refNode.prefix;
    var uri = refNode.namespaceURI;
    if (uri && prefix == null) {
      var prefix = refNode.lookupPrefix(uri);
      if (prefix == null) {
        var visibleNamespaces = [
          { namespace: uri, prefix: null }
          //{namespace:uri,prefix:''}
        ];
      }
    }
    serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
    return buf.join("");
  }
  function needNamespaceDefine(node, isHTML, visibleNamespaces) {
    var prefix = node.prefix || "";
    var uri = node.namespaceURI;
    if (!uri) {
      return false;
    }
    if (prefix === "xml" && uri === NAMESPACE2.XML || uri === NAMESPACE2.XMLNS) {
      return false;
    }
    var i2 = visibleNamespaces.length;
    while (i2--) {
      var ns = visibleNamespaces[i2];
      if (ns.prefix === prefix) {
        return ns.namespace !== uri;
      }
    }
    return true;
  }
  function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
    if (nodeFilter) {
      node = nodeFilter(node);
      if (node) {
        if (typeof node == "string") {
          buf.push(node);
          return;
        }
      } else {
        return;
      }
    }
    switch (node.nodeType) {
      case ELEMENT_NODE:
        if (!visibleNamespaces) visibleNamespaces = [];
        var startVisibleNamespaces = visibleNamespaces.length;
        var attrs = node.attributes;
        var len = attrs.length;
        var child = node.firstChild;
        var nodeName = node.tagName;
        isHTML = NAMESPACE2.isHTML(node.namespaceURI) || isHTML;
        buf.push("<", nodeName);
        for (var i2 = 0; i2 < len; i2++) {
          var attr = attrs.item(i2);
          if (attr.prefix == "xmlns") {
            visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
          } else if (attr.nodeName == "xmlns") {
            visibleNamespaces.push({ prefix: "", namespace: attr.value });
          }
        }
        for (var i2 = 0; i2 < len; i2++) {
          var attr = attrs.item(i2);
          if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
            var prefix = attr.prefix || "";
            var uri = attr.namespaceURI;
            var ns = prefix ? " xmlns:" + prefix : " xmlns";
            buf.push(ns, '="', uri, '"');
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
        }
        if (needNamespaceDefine(node, isHTML, visibleNamespaces)) {
          var prefix = node.prefix || "";
          var uri = node.namespaceURI;
          var ns = prefix ? " xmlns:" + prefix : " xmlns";
          buf.push(ns, '="', uri, '"');
          visibleNamespaces.push({ prefix, namespace: uri });
        }
        if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
          buf.push(">");
          if (isHTML && /^script$/i.test(nodeName)) {
            while (child) {
              if (child.data) {
                buf.push(child.data);
              } else {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces);
              }
              child = child.nextSibling;
            }
          } else {
            while (child) {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces);
              child = child.nextSibling;
            }
          }
          buf.push("</", nodeName, ">");
        } else {
          buf.push("/>");
        }
        return;
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        var child = node.firstChild;
        while (child) {
          serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces);
          child = child.nextSibling;
        }
        return;
      case ATTRIBUTE_NODE:
        return buf.push(" ", node.name, '="', node.value.replace(/[<&"]/g, _xmlEncoder), '"');
      case TEXT_NODE:
        return buf.push(
          node.data.replace(/[<&]/g, _xmlEncoder).replace(/]]>/g, "]]&gt;")
        );
      case CDATA_SECTION_NODE:
        return buf.push("<![CDATA[", node.data, "]]>");
      case COMMENT_NODE:
        return buf.push("<!--", node.data, "-->");
      case DOCUMENT_TYPE_NODE:
        var pubid = node.publicId;
        var sysid = node.systemId;
        buf.push("<!DOCTYPE ", node.name);
        if (pubid) {
          buf.push(" PUBLIC ", pubid);
          if (sysid && sysid != ".") {
            buf.push(" ", sysid);
          }
          buf.push(">");
        } else if (sysid && sysid != ".") {
          buf.push(" SYSTEM ", sysid, ">");
        } else {
          var sub = node.internalSubset;
          if (sub) {
            buf.push(" [", sub, "]");
          }
          buf.push(">");
        }
        return;
      case PROCESSING_INSTRUCTION_NODE:
        return buf.push("<?", node.target, " ", node.data, "?>");
      case ENTITY_REFERENCE_NODE:
        return buf.push("&", node.nodeName, ";");
      //case ENTITY_NODE:
      //case NOTATION_NODE:
      default:
        buf.push("??", node.nodeName);
    }
  }
  function importNode(doc2, node, deep) {
    var node2;
    switch (node.nodeType) {
      case ELEMENT_NODE:
        node2 = node.cloneNode(false);
        node2.ownerDocument = doc2;
      //var attrs = node2.attributes;
      //var len = attrs.length;
      //for(var i=0;i<len;i++){
      //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
      //}
      case DOCUMENT_FRAGMENT_NODE:
        break;
      case ATTRIBUTE_NODE:
        deep = true;
        break;
    }
    if (!node2) {
      node2 = node.cloneNode(false);
    }
    node2.ownerDocument = doc2;
    node2.parentNode = null;
    if (deep) {
      var child = node.firstChild;
      while (child) {
        node2.appendChild(importNode(doc2, child, deep));
        child = child.nextSibling;
      }
    }
    return node2;
  }
  function cloneNode(doc2, node, deep) {
    var node2 = new node.constructor();
    for (var n2 in node) {
      var v2 = node[n2];
      if (typeof v2 != "object") {
        if (v2 != node2[n2]) {
          node2[n2] = v2;
        }
      }
    }
    if (node.childNodes) {
      node2.childNodes = new NodeList();
    }
    node2.ownerDocument = doc2;
    switch (node2.nodeType) {
      case ELEMENT_NODE:
        var attrs = node.attributes;
        var attrs2 = node2.attributes = new NamedNodeMap();
        var len = attrs.length;
        attrs2._ownerElement = node2;
        for (var i2 = 0; i2 < len; i2++) {
          node2.setAttributeNode(cloneNode(doc2, attrs.item(i2), true));
        }
        break;
        ;
      case ATTRIBUTE_NODE:
        deep = true;
    }
    if (deep) {
      var child = node.firstChild;
      while (child) {
        node2.appendChild(cloneNode(doc2, child, deep));
        child = child.nextSibling;
      }
    }
    return node2;
  }
  function __set__(object, key, value) {
    object[key] = value;
  }
  try {
    if (Object.defineProperty) {
      let getTextContent = function(node) {
        switch (node.nodeType) {
          case ELEMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            var buf = [];
            node = node.firstChild;
            while (node) {
              if (node.nodeType !== 7 && node.nodeType !== 8) {
                buf.push(getTextContent(node));
              }
              node = node.nextSibling;
            }
            return buf.join("");
          default:
            return node.nodeValue;
        }
      };
      Object.defineProperty(LiveNodeList.prototype, "length", {
        get: function() {
          _updateLiveList(this);
          return this.$$length;
        }
      });
      Object.defineProperty(Node2.prototype, "textContent", {
        get: function() {
          return getTextContent(this);
        },
        set: function(data) {
          switch (this.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              while (this.firstChild) {
                this.removeChild(this.firstChild);
              }
              if (data || String(data)) {
                this.appendChild(this.ownerDocument.createTextNode(data));
              }
              break;
            default:
              this.data = data;
              this.value = data;
              this.nodeValue = data;
          }
        }
      });
      __set__ = function(object, key, value) {
        object["$$" + key] = value;
      };
    }
  } catch (e2) {
  }

  // ../insight-maker-simulation/src/Constants.js
  var nodeBase = /* @__PURE__ */ Object.create(null);
  var defaultSolver = JSON.stringify({
    enabled: false,
    algorithm: "RK1",
    timeStep: 1
  });
  var DI = typeof window === "undefined" ? new DOMImplementation() : document.implementation;
  var doc = DI.createDocument("", "", null);
  nodeBase.text = doc.createElement("Text");
  nodeBase.text.setAttribute("name", "Text Area");
  nodeBase.text.setAttribute("LabelPosition", "Middle");
  nodeBase.folder = doc.createElement("Folder");
  nodeBase.folder.setAttribute("name", "New Folder");
  nodeBase.folder.setAttribute("Note", "");
  nodeBase.folder.setAttribute("Type", "None");
  nodeBase.folder.setAttribute("Solver", defaultSolver);
  nodeBase.folder.setAttribute("Image", "None");
  nodeBase.folder.setAttribute("FlipHorizontal", "false");
  nodeBase.folder.setAttribute("FlipVertical", "false");
  nodeBase.folder.setAttribute("LabelPosition", "Middle");
  nodeBase.folder.setAttribute("AgentBase", "");
  nodeBase.ghost = doc.createElement("Ghost");
  nodeBase.ghost.setAttribute("Source", "");
  nodeBase.picture = doc.createElement("Picture");
  nodeBase.picture.setAttribute("name", "");
  nodeBase.picture.setAttribute("Note", "");
  nodeBase.picture.setAttribute("Image", "Growth");
  nodeBase.picture.setAttribute("FlipHorizontal", "false");
  nodeBase.picture.setAttribute("FlipVertical", "false");
  nodeBase.picture.setAttribute("LabelPosition", "Bottom");
  nodeBase.display = doc.createElement("Display");
  nodeBase.display.setAttribute("name", "Default Display");
  nodeBase.display.setAttribute("Note", "");
  nodeBase.display.setAttribute("Type", "Time Series");
  nodeBase.display.setAttribute("xAxis", "Time (%u)");
  nodeBase.display.setAttribute("yAxis", "");
  nodeBase.display.setAttribute("yAxis2", "");
  nodeBase.display.setAttribute("showMarkers", "false");
  nodeBase.display.setAttribute("showLines", "true");
  nodeBase.display.setAttribute("showArea", "false");
  nodeBase.display.setAttribute("Primitives", "");
  nodeBase.display.setAttribute("Primitives2", "");
  nodeBase.display.setAttribute("AutoAddPrimitives", "false");
  nodeBase.display.setAttribute("ScatterplotOrder", "X Primitive, Y Primitive");
  nodeBase.display.setAttribute("Image", "Display");
  nodeBase.display.setAttribute("FlipHorizontal", "false");
  nodeBase.display.setAttribute("FlipVertical", "false");
  nodeBase.display.setAttribute("LabelPosition", "Bottom");
  function setValuedProperties(cell) {
    cell.setAttribute("Units", "Unitless");
    cell.setAttribute("MaxConstraintUsed", "false");
    cell.setAttribute("MinConstraintUsed", "false");
    cell.setAttribute("MaxConstraint", "100");
    cell.setAttribute("MinConstraint", "0");
    cell.setAttribute("ShowSlider", "false");
    cell.setAttribute("SliderMax", 100);
    cell.setAttribute("SliderMin", 0);
    cell.setAttribute("SliderStep", "");
  }
  nodeBase.stock = doc.createElement("Stock");
  nodeBase.stock.setAttribute("name", "New Stock");
  nodeBase.stock.setAttribute("Note", "");
  nodeBase.stock.setAttribute("InitialValue", "0");
  nodeBase.stock.setAttribute("StockMode", "Store");
  nodeBase.stock.setAttribute("Delay", "10");
  nodeBase.stock.setAttribute("Volume", "100");
  nodeBase.stock.setAttribute("NonNegative", "false");
  setValuedProperties(nodeBase.stock);
  nodeBase.stock.setAttribute("Image", "None");
  nodeBase.stock.setAttribute("FlipHorizontal", "false");
  nodeBase.stock.setAttribute("FlipVertical", "false");
  nodeBase.stock.setAttribute("LabelPosition", "Middle");
  nodeBase.state = doc.createElement("State");
  nodeBase.state.setAttribute("name", "New State");
  nodeBase.state.setAttribute("Note", "");
  nodeBase.state.setAttribute("Active", "false");
  nodeBase.state.setAttribute("Residency", "0");
  nodeBase.state.setAttribute("Image", "None");
  nodeBase.state.setAttribute("FlipHorizontal", "false");
  nodeBase.state.setAttribute("FlipVertical", "false");
  nodeBase.state.setAttribute("LabelPosition", "Middle");
  nodeBase.transition = doc.createElement("Transition");
  nodeBase.transition.setAttribute("name", "Transition");
  nodeBase.transition.setAttribute("Note", "");
  nodeBase.transition.setAttribute("Trigger", "Timeout");
  nodeBase.transition.setAttribute("Value", "1");
  nodeBase.transition.setAttribute("Repeat", "false");
  nodeBase.transition.setAttribute("Recalculate", "false");
  setValuedProperties(nodeBase.transition);
  nodeBase.action = doc.createElement("Action");
  nodeBase.action.setAttribute("name", "New Action");
  nodeBase.action.setAttribute("Note", "");
  nodeBase.action.setAttribute("Trigger", "Probability");
  nodeBase.action.setAttribute("Value", "0.5");
  nodeBase.action.setAttribute("Repeat", "true");
  nodeBase.action.setAttribute("Recalculate", "false");
  nodeBase.action.setAttribute("Action", "Self.Move({Rand(), Rand()})");
  nodeBase.agents = doc.createElement("Agents");
  nodeBase.agents.setAttribute("name", "New Agent Population");
  nodeBase.agents.setAttribute("Note", "");
  nodeBase.agents.setAttribute("Size", "100");
  nodeBase.agents.setAttribute("GeoWrap", "false");
  nodeBase.agents.setAttribute("GeoDimUnits", "Unitless");
  nodeBase.agents.setAttribute("GeoWidth", "200");
  nodeBase.agents.setAttribute("GeoHeight", "100");
  nodeBase.agents.setAttribute("Placement", "Random");
  nodeBase.agents.setAttribute("PlacementFunction", "{Rand()*Width(Self), Rand()*Height(Self)}");
  nodeBase.agents.setAttribute("Network", "None");
  nodeBase.agents.setAttribute("NetworkFunction", "RandBoolean(0.02)");
  nodeBase.agents.setAttribute("Agent", "");
  nodeBase.agents.setAttribute("Image", "None");
  nodeBase.agents.setAttribute("FlipHorizontal", "false");
  nodeBase.agents.setAttribute("FlipVertical", "false");
  nodeBase.agents.setAttribute("LabelPosition", "Middle");
  nodeBase.agents.setAttribute("ShowSlider", "false");
  nodeBase.agents.setAttribute("SliderMax", "100");
  nodeBase.agents.setAttribute("SliderMin", "0");
  nodeBase.agents.setAttribute("SliderStep", "1");
  nodeBase.variable = doc.createElement("Variable");
  nodeBase.variable.setAttribute("name", "New Variable");
  nodeBase.variable.setAttribute("Note", "");
  nodeBase.variable.setAttribute("Equation", "0");
  setValuedProperties(nodeBase.variable);
  nodeBase.variable.setAttribute("Image", "None");
  nodeBase.variable.setAttribute("FlipHorizontal", "false");
  nodeBase.variable.setAttribute("FlipVertical", "false");
  nodeBase.variable.setAttribute("LabelPosition", "Middle");
  nodeBase.button = doc.createElement("Button");
  nodeBase.button.setAttribute("name", "New Button");
  nodeBase.button.setAttribute("Note", "");
  nodeBase.button.setAttribute("Function", 'showMessage("Button action triggered!\\n\\nIf you want to edit this Action, click on the button while holding down the Shift key on your keyboard.")');
  nodeBase.button.setAttribute("Image", "None");
  nodeBase.button.setAttribute("FlipHorizontal", "false");
  nodeBase.button.setAttribute("FlipVertical", "false");
  nodeBase.button.setAttribute("LabelPosition", "Middle");
  nodeBase.converter = doc.createElement("Converter");
  nodeBase.converter.setAttribute("name", "New Converter");
  nodeBase.converter.setAttribute("Note", "");
  nodeBase.converter.setAttribute("Source", "Time");
  nodeBase.converter.setAttribute("Data", "0,0; 1,1; 2,4; 3,9");
  nodeBase.converter.setAttribute("Interpolation", "Linear");
  setValuedProperties(nodeBase.converter);
  nodeBase.converter.setAttribute("Image", "None");
  nodeBase.converter.setAttribute("FlipHorizontal", "false");
  nodeBase.converter.setAttribute("FlipVertical", "false");
  nodeBase.converter.setAttribute("LabelPosition", "Middle");
  nodeBase.flow = doc.createElement("Flow");
  nodeBase.flow.setAttribute("name", "Flow");
  nodeBase.flow.setAttribute("Note", "");
  nodeBase.flow.setAttribute("FlowRate", "0");
  nodeBase.flow.setAttribute("OnlyPositive", "true");
  nodeBase.flow.setAttribute("TimeIndependent", "false");
  setValuedProperties(nodeBase.flow);
  nodeBase.link = doc.createElement("Link");
  nodeBase.link.setAttribute("name", "Link");
  nodeBase.link.setAttribute("Note", "");
  nodeBase.link.setAttribute("BiDirectional", "false");
  nodeBase.setting = doc.createElement("Setting");
  nodeBase.setting.setAttribute("Note", "");
  nodeBase.setting.setAttribute("Version", "38");
  nodeBase.setting.setAttribute("Throttle", "1");
  nodeBase.setting.setAttribute("TimeLength", "100");
  nodeBase.setting.setAttribute("TimeStart", "0");
  nodeBase.setting.setAttribute("TimeStep", "1");
  nodeBase.setting.setAttribute("TimeUnits", "Years");
  nodeBase.setting.setAttribute("Units", "");
  nodeBase.setting.setAttribute("SolutionAlgorithm", "RK1");
  nodeBase.setting.setAttribute("BackgroundColor", "white");
  nodeBase.setting.setAttribute("Macros", "");
  nodeBase.setting.setAttribute("SensitivityPrimitives", "");
  nodeBase.setting.setAttribute("SensitivityRuns", "50");
  nodeBase.setting.setAttribute("SensitivityBounds", "50, 80, 95, 100");
  nodeBase.setting.setAttribute("SensitivityShowRuns", "false");
  nodeBase.setting.setAttribute("StyleSheet", "{}");

  // ../insight-maker-simulation/src/api/Results.js
  var Results = class {
    /**
     * @param {import("../Simulator").ResultsType} data
     * @param {Object<string, string>} nameIdMapping
     */
    constructor(data, nameIdMapping) {
      this._data = data;
      this._nameIdMapping = nameIdMapping;
      this.timeUnits = data.timeUnits;
      for (let i2 = 0; i2 < this._data.data.length; i2++) {
        let current = this._data.data[i2];
        for (let key in current) {
          current[key] = simplifyResults(current[key]);
        }
      }
    }
    times() {
      return this._data.times.slice();
    }
    /**
     * @param {import("./Blocks").Primitive[]=} primitives
     */
    table(primitives2) {
      if (primitives2) {
        let series = primitives2.map((x2) => ({ primitive: x2, series: this.series(x2) }));
        let times = this.times();
        let res = [];
        for (let i2 = 0; i2 < times.length; i2++) {
          let data = {
            _time: times[i2]
          };
          for (let item of series) {
            data[item.primitive.name] = item.series[i2];
          }
          res.push(data);
        }
        return res;
      } else {
        let res = [];
        for (let i2 = 0; i2 < this._data.data.length; i2++) {
          let data = {};
          data._time = this._data.times[i2];
          let current = this._data.data[i2];
          for (let id2 in current) {
            data[this._nameIdMapping[id2]] = current[id2];
          }
          res.push(data);
        }
        return res;
      }
    }
    /**
     * @param {import("./Blocks").Primitive} primitive
     */
    series(primitive) {
      return this._data.value(primitive._node).slice();
    }
    /**
     * @param {import("./Blocks").Primitive} primitive
     * @param {number=} time - if omitted, the last available value
     */
    value(primitive, time = null) {
      if (!primitive?._node) {
        throw new Error("Expected a primitive when calling Results.value(), got: " + primitive);
      }
      let series = this.series(primitive);
      if (time === null) {
        return series[series.length - 1];
      }
      let times = this.times();
      let index = times.indexOf(time);
      if (index === -1) {
        throw new Error("Could not find time: " + time + ". Available options are: " + JSON.stringify(times));
      }
      return series[index];
    }
  };
  function simplifyResults(x2) {
    if (x2 instanceof Vector) {
      if (x2.names) {
        let res = {};
        for (let i2 = 0; i2 < x2.names.length; i2++) {
          res[x2.names[i2]] = simplifyResults(x2.items[i2]);
        }
        return res;
      } else {
        return x2.items.map(simplifyResults);
      }
    }
    return x2;
  }

  // ../insight-maker-simulation/src/api/SimulationError.js
  var SimulationError = class _SimulationError extends Error {
    /**
     * @param {string} message
     * @param {{ source?: string, primitive?: any, line?: number, code: number }} config
     */
    constructor(message, config) {
      super(message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, _SimulationError);
      }
      this.name = "SimulationError";
      this.source = config.source;
      this.primitive = config.primitive;
      this.line = config.line;
      this.code = config.code;
      Object.defineProperty(this, "code", { enumerable: false });
      Object.defineProperty(this, "primitive", { enumerable: false });
    }
  };

  // ../insight-maker-simulation/vendor/xmldom/entities.js
  var XML_ENTITIES = freeze({ amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' });
  var HTML_ENTITIES = freeze({
    lt: "<",
    gt: ">",
    amp: "&",
    quot: '"',
    apos: "'",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    times: "\xD7",
    divide: "\xF7",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    "int": "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    euro: "\u20AC",
    trade: "\u2122",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  });

  // ../insight-maker-simulation/vendor/xmldom/sax.js
  var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
  var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
  var S_TAG = 0;
  var S_ATTR = 1;
  var S_ATTR_SPACE = 2;
  var S_EQ = 3;
  var S_ATTR_NOQUOT_VALUE = 4;
  var S_ATTR_END = 5;
  var S_TAG_SPACE = 6;
  var S_TAG_CLOSE = 7;
  function ParseError(message, locator) {
    this.message = message;
    this.locator = locator;
    if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
  }
  ParseError.prototype = new Error();
  ParseError.prototype.name = ParseError.name;
  function XMLReader() {
  }
  XMLReader.prototype = {
    parse: function(source, defaultNSMap, entityMap) {
      var domBuilder = this.domBuilder;
      domBuilder.startDocument();
      _copy(defaultNSMap, defaultNSMap = {});
      parse2(
        source,
        defaultNSMap,
        entityMap,
        domBuilder,
        this.errorHandler
      );
      domBuilder.endDocument();
    }
  };
  function parse2(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
    function fixedFromCharCode(code) {
      if (code > 65535) {
        code -= 65536;
        var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      } else {
        return String.fromCharCode(code);
      }
    }
    function entityReplacer(a3) {
      var k2 = a3.slice(1, -1);
      if (k2 in entityMap) {
        return entityMap[k2];
      } else if (k2.charAt(0) === "#") {
        return fixedFromCharCode(parseInt(k2.substr(1).replace("x", "0x")));
      } else {
        errorHandler.error("entity not found:" + a3);
        return a3;
      }
    }
    function appendText(end2) {
      if (end2 > start2) {
        var xt = source.substring(start2, end2).replace(/&#?\w+;/g, entityReplacer);
        locator && position2(start2);
        domBuilder.characters(xt, 0, end2 - start2);
        start2 = end2;
      }
    }
    function position2(p2, m2) {
      while (p2 >= lineEnd && (m2 = linePattern.exec(source))) {
        lineStart = m2.index;
        lineEnd = lineStart + m2[0].length;
        locator.lineNumber++;
      }
      locator.columnNumber = p2 - lineStart + 1;
    }
    var lineStart = 0;
    var lineEnd = 0;
    var linePattern = /.*(?:\r\n?|\n)|.*$/g;
    var locator = domBuilder.locator;
    var parseStack = [{ currentNSMap: defaultNSMapCopy }];
    var closeMap = {};
    var start2 = 0;
    while (true) {
      try {
        var tagStart = source.indexOf("<", start2);
        if (tagStart < 0) {
          if (!source.substr(start2).match(/^\s*$/)) {
            var doc2 = domBuilder.doc;
            var text = doc2.createTextNode(source.substr(start2));
            doc2.appendChild(text);
            domBuilder.currentElement = text;
          }
          return;
        }
        if (tagStart > start2) {
          appendText(tagStart);
        }
        switch (source.charAt(tagStart + 1)) {
          case "/":
            var end = source.indexOf(">", tagStart + 3);
            var tagName = source.substring(tagStart + 2, end);
            var config = parseStack.pop();
            if (end < 0) {
              tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
              errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
              end = tagStart + 1 + tagName.length;
            } else if (tagName.match(/\s</)) {
              tagName = tagName.replace(/[\s<].*/, "");
              errorHandler.error("end tag name: " + tagName + " maybe not complete");
              end = tagStart + 1 + tagName.length;
            }
            var localNSMap = config.localNSMap;
            var endMatch = config.tagName == tagName;
            var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
            if (endIgnoreCaseMach) {
              domBuilder.endElement(config.uri, config.localName, tagName);
              if (localNSMap) {
                for (var prefix in localNSMap) {
                  domBuilder.endPrefixMapping(prefix);
                }
              }
              if (!endMatch) {
                errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
              }
            } else {
              parseStack.push(config);
            }
            end++;
            break;
          // end elment
          case "?":
            locator && position2(tagStart);
            end = parseInstruction(source, tagStart, domBuilder);
            break;
          case "!":
            locator && position2(tagStart);
            end = parseDCC(source, tagStart, domBuilder, errorHandler);
            break;
          default:
            locator && position2(tagStart);
            var el = new ElementAttributes();
            var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
            var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
            var len = el.length;
            if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
              el.closed = true;
              if (!entityMap.nbsp) {
                errorHandler.warning("unclosed xml attribute");
              }
            }
            if (locator && len) {
              var locator2 = copyLocator(locator, {});
              for (var i2 = 0; i2 < len; i2++) {
                var a2 = el[i2];
                position2(a2.offset);
                a2.locator = copyLocator(locator, {});
              }
              domBuilder.locator = locator2;
              if (appendElement(el, domBuilder, currentNSMap)) {
                parseStack.push(el);
              }
              domBuilder.locator = locator;
            } else {
              if (appendElement(el, domBuilder, currentNSMap)) {
                parseStack.push(el);
              }
            }
            if (NAMESPACE.isHTML(el.uri) && !el.closed) {
              end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
            } else {
              end++;
            }
        }
      } catch (e2) {
        if (e2 instanceof ParseError) {
          throw e2;
        }
        errorHandler.error("element parse error: " + e2);
        end = -1;
      }
      if (end > start2) {
        start2 = end;
      } else {
        appendText(Math.max(tagStart, start2) + 1);
      }
    }
  }
  function copyLocator(f2, t2) {
    t2.lineNumber = f2.lineNumber;
    t2.columnNumber = f2.columnNumber;
    return t2;
  }
  function parseElementStartPart(source, start2, el, currentNSMap, entityReplacer, errorHandler) {
    function addAttribute(qname, value2, startIndex) {
      if (qname in el.attributeNames) errorHandler.fatalError("Attribute " + qname + " redefined");
      el.addValue(qname, value2, startIndex);
    }
    var attrName;
    var value;
    var p2 = ++start2;
    var s2 = S_TAG;
    while (true) {
      var c2 = source.charAt(p2);
      switch (c2) {
        case "=":
          if (s2 === S_ATTR) {
            attrName = source.slice(start2, p2);
            s2 = S_EQ;
          } else if (s2 === S_ATTR_SPACE) {
            s2 = S_EQ;
          } else {
            throw new Error("attribute equal must after attrName");
          }
          break;
        case "'":
        case '"':
          if (s2 === S_EQ || s2 === S_ATTR) {
            if (s2 === S_ATTR) {
              errorHandler.warning('attribute value must after "="');
              attrName = source.slice(start2, p2);
            }
            start2 = p2 + 1;
            p2 = source.indexOf(c2, start2);
            if (p2 > 0) {
              value = source.slice(start2, p2).replace(/&#?\w+;/g, entityReplacer);
              addAttribute(attrName, value, start2 - 1);
              s2 = S_ATTR_END;
            } else {
              throw new Error("attribute value no end '" + c2 + "' match");
            }
          } else if (s2 == S_ATTR_NOQUOT_VALUE) {
            value = source.slice(start2, p2).replace(/&#?\w+;/g, entityReplacer);
            addAttribute(attrName, value, start2);
            errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c2 + ")!!");
            start2 = p2 + 1;
            s2 = S_ATTR_END;
          } else {
            throw new Error('attribute value must after "="');
          }
          break;
        case "/":
          switch (s2) {
            case S_TAG:
              el.setTagName(source.slice(start2, p2));
            case S_ATTR_END:
            case S_TAG_SPACE:
            case S_TAG_CLOSE:
              s2 = S_TAG_CLOSE;
              el.closed = true;
            case S_ATTR_NOQUOT_VALUE:
            case S_ATTR:
            case S_ATTR_SPACE:
              break;
            //case S_EQ:
            default:
              throw new Error("attribute invalid close char('/')");
          }
          break;
        case "":
          errorHandler.error("unexpected end of input");
          if (s2 == S_TAG) {
            el.setTagName(source.slice(start2, p2));
          }
          return p2;
        case ">":
          switch (s2) {
            case S_TAG:
              el.setTagName(source.slice(start2, p2));
            case S_ATTR_END:
            case S_TAG_SPACE:
            case S_TAG_CLOSE:
              break;
            //normal
            case S_ATTR_NOQUOT_VALUE:
            //Compatible state
            case S_ATTR:
              value = source.slice(start2, p2);
              if (value.slice(-1) === "/") {
                el.closed = true;
                value = value.slice(0, -1);
              }
            case S_ATTR_SPACE:
              if (s2 === S_ATTR_SPACE) {
                value = attrName;
              }
              if (s2 == S_ATTR_NOQUOT_VALUE) {
                errorHandler.warning('attribute "' + value + '" missed quot(")!');
                addAttribute(attrName, value.replace(/&#?\w+;/g, entityReplacer), start2);
              } else {
                if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                  errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                }
                addAttribute(value, value, start2);
              }
              break;
            case S_EQ:
              throw new Error("attribute value missed!!");
          }
          return p2;
        /*xml space '\x20' | #x9 | #xD | #xA; */
        case "\x80":
          c2 = " ";
        default:
          if (c2 <= " ") {
            switch (s2) {
              case S_TAG:
                el.setTagName(source.slice(start2, p2));
                s2 = S_TAG_SPACE;
                break;
              case S_ATTR:
                attrName = source.slice(start2, p2);
                s2 = S_ATTR_SPACE;
                break;
              case S_ATTR_NOQUOT_VALUE:
                var value = source.slice(start2, p2).replace(/&#?\w+;/g, entityReplacer);
                errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                addAttribute(attrName, value, start2);
              case S_ATTR_END:
                s2 = S_TAG_SPACE;
                break;
            }
          } else {
            switch (s2) {
              //case S_TAG:void();break;
              //case S_ATTR:void();break;
              //case S_ATTR_NOQUOT_VALUE:void();break;
              case S_ATTR_SPACE:
                var tagName = el.tagName;
                if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                  errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                }
                addAttribute(attrName, attrName, start2);
                start2 = p2;
                s2 = S_ATTR;
                break;
              case S_ATTR_END:
                errorHandler.warning('attribute space is required"' + attrName + '"!!');
              case S_TAG_SPACE:
                s2 = S_ATTR;
                start2 = p2;
                break;
              case S_EQ:
                s2 = S_ATTR_NOQUOT_VALUE;
                start2 = p2;
                break;
              case S_TAG_CLOSE:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
          }
      }
      p2++;
    }
  }
  function appendElement(el, domBuilder, currentNSMap) {
    var tagName = el.tagName;
    var localNSMap = null;
    var i2 = el.length;
    while (i2--) {
      var a2 = el[i2];
      var qName = a2.qName;
      var value = a2.value;
      var nsp = qName.indexOf(":");
      if (nsp > 0) {
        var prefix = a2.prefix = qName.slice(0, nsp);
        var localName = qName.slice(nsp + 1);
        var nsPrefix = prefix === "xmlns" && localName;
      } else {
        localName = qName;
        prefix = null;
        nsPrefix = qName === "xmlns" && "";
      }
      a2.localName = localName;
      if (nsPrefix !== false) {
        if (localNSMap == null) {
          localNSMap = {};
          _copy(currentNSMap, currentNSMap = {});
        }
        currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
        a2.uri = NAMESPACE.XMLNS;
        domBuilder.startPrefixMapping(nsPrefix, value);
      }
    }
    var i2 = el.length;
    while (i2--) {
      a2 = el[i2];
      var prefix = a2.prefix;
      if (prefix) {
        if (prefix === "xml") {
          a2.uri = NAMESPACE.XML;
        }
        if (prefix !== "xmlns") {
          a2.uri = currentNSMap[prefix || ""];
        }
      }
    }
    var nsp = tagName.indexOf(":");
    if (nsp > 0) {
      prefix = el.prefix = tagName.slice(0, nsp);
      localName = el.localName = tagName.slice(nsp + 1);
    } else {
      prefix = null;
      localName = el.localName = tagName;
    }
    var ns = el.uri = currentNSMap[prefix || ""];
    domBuilder.startElement(ns, localName, tagName, el);
    if (el.closed) {
      domBuilder.endElement(ns, localName, tagName);
      if (localNSMap) {
        for (prefix in localNSMap) {
          domBuilder.endPrefixMapping(prefix);
        }
      }
    } else {
      el.currentNSMap = currentNSMap;
      el.localNSMap = localNSMap;
      return true;
    }
  }
  function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
    if (/^(?:script|textarea)$/i.test(tagName)) {
      var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
      var text = source.substring(elStartEnd + 1, elEndStart);
      if (/[&<]/.test(text)) {
        if (/^script$/i.test(tagName)) {
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
        text = text.replace(/&#?\w+;/g, entityReplacer);
        domBuilder.characters(text, 0, text.length);
        return elEndStart;
      }
    }
    return elStartEnd + 1;
  }
  function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
    var pos = closeMap[tagName];
    if (pos == null) {
      pos = source.lastIndexOf("</" + tagName + ">");
      if (pos < elStartEnd) {
        pos = source.lastIndexOf("</" + tagName);
      }
      closeMap[tagName] = pos;
    }
    return pos < elStartEnd;
  }
  function _copy(source, target) {
    for (var n2 in source) {
      target[n2] = source[n2];
    }
  }
  function parseDCC(source, start2, domBuilder, errorHandler) {
    var next = source.charAt(start2 + 2);
    switch (next) {
      case "-":
        if (source.charAt(start2 + 3) === "-") {
          var end = source.indexOf("-->", start2 + 4);
          if (end > start2) {
            domBuilder.comment(source, start2 + 4, end - start2 - 4);
            return end + 3;
          } else {
            errorHandler.error("Unclosed comment");
            return -1;
          }
        } else {
          return -1;
        }
      default:
        if (source.substr(start2 + 3, 6) == "CDATA[") {
          var end = source.indexOf("]]>", start2 + 9);
          domBuilder.startCDATA();
          domBuilder.characters(source, start2 + 9, end - start2 - 9);
          domBuilder.endCDATA();
          return end + 3;
        }
        var matchs = split(source, start2);
        var len = matchs.length;
        if (len > 1 && /!doctype/i.test(matchs[0][0])) {
          var name = matchs[1][0];
          var pubid = false;
          var sysid = false;
          if (len > 3) {
            if (/^public$/i.test(matchs[2][0])) {
              pubid = matchs[3][0];
              sysid = len > 4 && matchs[4][0];
            } else if (/^system$/i.test(matchs[2][0])) {
              sysid = matchs[3][0];
            }
          }
          var lastMatch = matchs[len - 1];
          domBuilder.startDTD(name, pubid, sysid);
          domBuilder.endDTD();
          return lastMatch.index + lastMatch[0].length;
        }
    }
    return -1;
  }
  function parseInstruction(source, start2, domBuilder) {
    var end = source.indexOf("?>", start2);
    if (end) {
      var match = source.substring(start2, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
      if (match) {
        var len = match[0].length;
        domBuilder.processingInstruction(match[1], match[2]);
        return end + 2;
      } else {
        return -1;
      }
    }
    return -1;
  }
  function ElementAttributes() {
    this.attributeNames = {};
  }
  ElementAttributes.prototype = {
    setTagName: function(tagName) {
      if (!tagNamePattern.test(tagName)) {
        throw new Error("invalid tagName:" + tagName);
      }
      this.tagName = tagName;
    },
    addValue: function(qName, value, offset) {
      if (!tagNamePattern.test(qName)) {
        throw new Error("invalid attribute:" + qName);
      }
      this.attributeNames[qName] = this.length;
      this[this.length++] = { qName, value, offset };
    },
    length: 0,
    getLocalName: function(i2) {
      return this[i2].localName;
    },
    getLocator: function(i2) {
      return this[i2].locator;
    },
    getQName: function(i2) {
      return this[i2].qName;
    },
    getURI: function(i2) {
      return this[i2].uri;
    },
    getValue: function(i2) {
      return this[i2].value;
    }
    //	,getIndex:function(uri, localName)){
    //		if(localName){
    //			
    //		}else{
    //			var qName = uri
    //		}
    //	},
    //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
    //	getType:function(uri,localName){}
    //	getType:function(i){},
  };
  function split(source, start2) {
    var match;
    var buf = [];
    var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
    reg.lastIndex = start2;
    reg.exec(source);
    while (match = reg.exec(source)) {
      buf.push(match);
      if (match[1]) return buf;
    }
  }

  // ../insight-maker-simulation/vendor/xmldom/dom-parser.js
  var DOMImplementation2 = DOMImplementation;
  var NAMESPACE3 = NAMESPACE;
  function DOMParser(options) {
    this.options = options || { locator: {} };
  }
  DOMParser.prototype.parseFromString = function(source, mimeType) {
    var options = this.options;
    var sax = new XMLReader2();
    var domBuilder = options.domBuilder || new DOMHandler();
    var errorHandler = options.errorHandler;
    var locator = options.locator;
    var defaultNSMap = options.xmlns || {};
    var isHTML = /\/x?html?$/.test(mimeType);
    var entityMap = isHTML ? HTML_ENTITIES : XML_ENTITIES;
    if (locator) {
      domBuilder.setDocumentLocator(locator);
    }
    sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
    sax.domBuilder = options.domBuilder || domBuilder;
    if (isHTML) {
      defaultNSMap[""] = NAMESPACE3.HTML;
    }
    defaultNSMap.xml = defaultNSMap.xml || NAMESPACE3.XML;
    if (source && typeof source === "string") {
      sax.parse(source, defaultNSMap, entityMap);
    } else {
      sax.errorHandler.error("invalid doc source");
    }
    return domBuilder.doc;
  };
  function buildErrorHandler(errorImpl, domBuilder, locator) {
    if (!errorImpl) {
      if (domBuilder instanceof DOMHandler) {
        return domBuilder;
      }
      errorImpl = domBuilder;
    }
    var errorHandler = {};
    var isCallback = errorImpl instanceof Function;
    locator = locator || {};
    function build(key) {
      var fn2 = errorImpl[key];
      if (!fn2 && isCallback) {
        fn2 = errorImpl.length == 2 ? function(msg) {
          errorImpl(key, msg);
        } : errorImpl;
      }
      errorHandler[key] = fn2 && function(msg) {
        fn2("[xmldom " + key + "]	" + msg + _locator(locator));
      } || function() {
      };
    }
    build("warning");
    build("error");
    build("fatalError");
    return errorHandler;
  }
  function DOMHandler() {
    this.cdata = false;
  }
  function position(locator, node) {
    node.lineNumber = locator.lineNumber;
    node.columnNumber = locator.columnNumber;
  }
  DOMHandler.prototype = {
    startDocument: function() {
      this.doc = new DOMImplementation2().createDocument(null, null, null);
      if (this.locator) {
        this.doc.documentURI = this.locator.systemId;
      }
    },
    startElement: function(namespaceURI, localName, qName, attrs) {
      var doc2 = this.doc;
      var el = doc2.createElementNS(namespaceURI, qName || localName);
      var len = attrs.length;
      appendElement2(this, el);
      this.currentElement = el;
      this.locator && position(this.locator, el);
      for (var i2 = 0; i2 < len; i2++) {
        var namespaceURI = attrs.getURI(i2);
        var value = attrs.getValue(i2);
        var qName = attrs.getQName(i2);
        var attr = doc2.createAttributeNS(namespaceURI, qName);
        this.locator && position(attrs.getLocator(i2), attr);
        attr.value = attr.nodeValue = value;
        el.setAttributeNode(attr);
      }
    },
    endElement: function(namespaceURI, localName, qName) {
      var current = this.currentElement;
      var tagName = current.tagName;
      this.currentElement = current.parentNode;
    },
    startPrefixMapping: function(prefix, uri) {
    },
    endPrefixMapping: function(prefix) {
    },
    processingInstruction: function(target, data) {
      var ins = this.doc.createProcessingInstruction(target, data);
      this.locator && position(this.locator, ins);
      appendElement2(this, ins);
    },
    ignorableWhitespace: function(ch, start2, length) {
    },
    characters: function(chars, start2, length) {
      chars = _toString.apply(this, arguments);
      if (chars) {
        if (this.cdata) {
          var charNode = this.doc.createCDATASection(chars);
        } else {
          var charNode = this.doc.createTextNode(chars);
        }
        if (this.currentElement) {
          this.currentElement.appendChild(charNode);
        } else if (/^\s*$/.test(chars)) {
          this.doc.appendChild(charNode);
        }
        this.locator && position(this.locator, charNode);
      }
    },
    skippedEntity: function(name) {
    },
    endDocument: function() {
      this.doc.normalize();
    },
    setDocumentLocator: function(locator) {
      if (this.locator = locator) {
        locator.lineNumber = 0;
      }
    },
    //LexicalHandler
    comment: function(chars, start2, length) {
      chars = _toString.apply(this, arguments);
      var comm = this.doc.createComment(chars);
      this.locator && position(this.locator, comm);
      appendElement2(this, comm);
    },
    startCDATA: function() {
      this.cdata = true;
    },
    endCDATA: function() {
      this.cdata = false;
    },
    startDTD: function(name, publicId, systemId) {
      var impl = this.doc.implementation;
      if (impl && impl.createDocumentType) {
        var dt = impl.createDocumentType(name, publicId, systemId);
        this.locator && position(this.locator, dt);
        appendElement2(this, dt);
      }
    },
    /**
     * @see org.xml.sax.ErrorHandler
     * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
     */
    warning: function(error) {
      console.warn("[xmldom warning]	" + error, _locator(this.locator));
    },
    error: function(error) {
      console.error("[xmldom error]	" + error, _locator(this.locator));
    },
    fatalError: function(error) {
      throw new ParseError2(error, this.locator);
    }
  };
  function _locator(l2) {
    if (l2) {
      return "\n@" + (l2.systemId || "") + "#[line:" + l2.lineNumber + ",col:" + l2.columnNumber + "]";
    }
  }
  function _toString(chars, start2, length) {
    if (typeof chars == "string") {
      return chars.substr(start2, length);
    } else {
      if (chars.length >= start2 + length || start2) {
        return new java.lang.String(chars, start2, length) + "";
      }
      return chars;
    }
  }
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
    DOMHandler.prototype[key] = function() {
      return null;
    };
  });
  function appendElement2(hander, node) {
    if (!hander.currentElement) {
      hander.doc.appendChild(node);
    } else {
      hander.currentElement.appendChild(node);
    }
  }
  var XMLReader2 = XMLReader;
  var ParseError2 = ParseError;

  // ../insight-maker-simulation/src/api/import_export/InsightMaker/InsightMaker.js
  function loadXML(modelString) {
    let oParser = new DOMParser();
    let data = oParser.parseFromString(modelString, "text/xml");
    let graph = graphXMLToNodes(data);
    graph.children[0].value = { nodeName: "root" };
    graph.children[0].id = "1";
    let connectors = primitives(
      /** @type {any} */
      graph,
      ["Flow", "Link", "Transition"]
    );
    let items = primitives(graph);
    connectors.forEach((x2) => {
      x2.source = null;
      x2.target = null;
      items.forEach((i2) => {
        if (x2.children[0].getAttribute("source") && x2.children[0].getAttribute("source") === i2.id) {
          x2.source = i2;
        }
        if (x2.children[0].getAttribute("target") && x2.children[0].getAttribute("target") === i2.id) {
          x2.target = i2;
        }
      });
    });
    function cleanNode(x2) {
      if (x2.children) {
        let nodes = x2.children.filter((c2) => c2.value.nodeName === "mxCell");
        if (nodes.length > 0) {
          if (nodes[0].getAttribute("parent")) {
            let parent = items.find((item) => item.id === nodes[0].getAttribute("parent"));
            if (parent && parent.value.nodeName === "Folder") {
              parent.addChild(x2);
            }
          }
        }
        x2.children = x2.children.filter((c2) => c2.value.nodeName !== "mxCell");
        for (let i2 = x2.children.length - 1; i2 >= 0; i2--) {
          cleanNode(x2.children[i2]);
        }
      }
    }
    cleanNode(graph);
    return graph;
  }
  function graphXMLToNodes(xml, parent) {
    let obj = new ModelNode();
    obj.value = xml;
    obj.parent = parent;
    if (xml.nodeType === 1) {
      if (xml.attributes.length > 0) {
        for (let j = 0; j < xml.attributes.length; j++) {
          let attribute = xml.attributes.item(j);
          obj.attributes.set(attribute.nodeName, attribute.nodeValue);
        }
        obj.id = obj.attributes.get("id");
      }
    } else if (xml.nodeType === 3) {
      return null;
    }
    if (xml.hasChildNodes()) {
      obj.children = [];
      for (let i2 = 0; i2 < xml.childNodes.length; i2++) {
        let item = xml.childNodes.item(i2);
        let x2 = graphXMLToNodes(item, obj);
        if (x2) {
          obj.addChild(x2);
        }
      }
    }
    return obj;
  }
  function loadInsightMaker(xml) {
    if (!xml) {
      throw new Error("No Insight Maker model provided");
    }
    if (!xml.includes("InsightMakerModel")) {
      throw new Error("Invalid Insight Maker model contents");
    }
    let root2 = loadXML(xml);
    let m2 = new Model();
    m2._graph = /** @type {any} */
    root2;
    primitives(m2._graph).map((x2) => x2.primitive(m2));
    m2.settings = /** @type {any} */
    primitives(m2._graph, "Setting")[0];
    removeModelGhosts(m2);
    return m2;
  }

  // ../insight-maker-simulation/src/api/Model.js
  function removeModelGhosts(model) {
    let connectors = model.findLinks();
    connectors = connectors.concat(model.findFlows()).concat(model.findTransitions());
    let items = model.find();
    let idMapping = {};
    for (let item of items) {
      idMapping[item.id] = item;
    }
    for (let connector of connectors) {
      if (connector._node.source && connector._node.source.value.nodeName === "Ghost") {
        let item = idMapping[connector._node.source.getAttribute("Source")];
        if (item) {
          connector._node.source = item._node;
        } else {
          connector.delete();
        }
      }
      if (connector._node.target && connector._node.target.value.nodeName === "Ghost") {
        let item = idMapping[connector._node.target.getAttribute("Source")];
        if (item) {
          connector._node.target = item._node;
        } else {
          connector.delete();
        }
      }
    }
  }
  var Model = class {
    /**
     * @param {ModelConfigOptions=} config
     */
    constructor(config = {}) {
      this.name = null;
      this.description = null;
      this.visualizations = [];
      this._graph = new ModelNode();
      this._graph.id = "1";
      this._graph.addChild(new ModelNode());
      this._graph.children[0].addChild(new ModelNode());
      this.settings = this._createNode("setting");
      this.p = config.primitiveFn || primitives;
      for (let key in excludeKeys(config, ["primitiveFn"])) {
        if (key in this) {
          this[key] = config[key];
        } else {
          throw new Error("Unknown model property: " + key);
        }
      }
    }
    /**
     * @param {string} type
     */
    _createNode(type) {
      let parent = this._graph.children[0].children[0];
      let node = modelNodeClone(nodeBase[type], parent);
      parent.addChild(node);
      return node;
    }
    /**
     * @param {string} type
     * @param {Primitive} alpha
     * @param {Primitive} omega
     */
    _createConnector(type, alpha, omega) {
      let parent = this._graph.children[0].children[0];
      if (alpha) {
        parent = alpha._node.parent;
      }
      if (omega) {
        parent = omega._node.parent;
      }
      let edge = modelNodeClone(nodeBase[type], parent);
      parent.addChild(edge);
      if (alpha) {
        edge.source = alpha._node;
      } else {
        edge.source = null;
      }
      if (omega) {
        edge.target = omega._node;
      } else {
        edge.target = null;
      }
      return edge;
    }
    /**
     * Checks the model for some static errors (e.g syntax errors). The model is not run and runtime errors are not checked.
     * 
     * The function returns an array of errors found.
     * 
     * @returns {ModelError[]}
     */
    check() {
      let simulate = new Simulator();
      let errors = [];
      function equationCheck(p2, eq2) {
        let tree;
        try {
          tree = createTree(eq2, "_", simulate);
        } catch (e2) {
          e2.primitive = p2;
          errors.push(e2);
          return;
        }
        let neighbors = p2.neighbors();
        let flaggedMissing = /* @__PURE__ */ new Set();
        try {
          trimTree(tree, {
            get: (name) => {
              if (!flaggedMissing.has(name)) {
                if (!neighbors.find((x2) => x2.item.name.toLowerCase() === name.toLowerCase())) {
                  flaggedMissing.add(name.toLowerCase());
                  errors.push(new ModelError("Attempted to reference [" + name + "] but it was not linked.", {
                    primitive: p2,
                    code: 9912,
                    details: name
                  }));
                }
              }
              return null;
            }
          }, simulate);
        } catch (e2) {
          return e2;
        }
        return null;
      }
      let stocks = this.findStocks();
      for (let stock of stocks) {
        equationCheck(stock, stock.initial);
      }
      let flows = this.findFlows();
      for (let flow of flows) {
        equationCheck(flow, flow.rate);
      }
      let variables = this.findVariables();
      for (let variable of variables) {
        equationCheck(variable, variable.value);
      }
      let states = this.findStates();
      for (let state of states) {
        equationCheck(state, "" + state.startActive);
      }
      let transitions = this.findTransitions();
      for (let transition2 of transitions) {
        equationCheck(transition2, "" + transition2.value);
      }
      let populations = this.findPopulations();
      for (let population of populations) {
        equationCheck(population, "" + population.networkFunction);
        equationCheck(population, "" + population.geoPlacementFunction);
        equationCheck(population, "" + population.populationSize);
      }
      return errors;
    }
    /**
     * Async simulation mode. Allows for pausing the simulation and adjusting
     * values. Returns a promise that resolves with the results or rejects
     * with an error.
     * 
     * @param {object} options
     * @param {function({ results: Results, time: number, setValue: function(Primitive, any) })=} options.onStep - async function that will be awaited each time step prior to simulation resuming, use setValue() to adjust values.
     * 
     * @returns {Promise<Results, { error: string, errorCode: number, errorPrimitive: Primitive, errorPrimitiveName: string, errorPrimitiveId: string}|Error>}
     */
    async simulateAsync(options = {}) {
      if ("onPause" in options) {
        throw new Error("onPause has been replaced by onStep which is called each time step.");
      }
      return new Promise((resolve, reject) => {
        let config = {
          silent: true,
          model: this
        };
        if (options.onStep) {
          config.pauseEachTimeStep = true;
          config.onPause = async (results) => {
            let items = this.find();
            let nameIdMapping = {};
            for (let item of items) {
              nameIdMapping[item.id] = item.name;
            }
            try {
              await options.onStep({
                results: new Results(results, nameIdMapping),
                time: results.times.at(-1),
                setValue: (primitive, value) => {
                  results.setValue(primitive._node, value);
                }
              });
            } catch (e2) {
              reject(e2);
              return;
            }
            results.resume();
          };
        }
        config.onSuccess = (results) => {
          let items = this.find();
          let nameIdMapping = {};
          for (let item of items) {
            nameIdMapping[item.id] = item.name;
          }
          resolve(new Results(results, nameIdMapping));
        };
        config.onError = (results) => {
          let ep = results.errorPrimitive ? this.get((p2) => p2.id === results.errorPrimitive.id) : null;
          let e2 = {
            error: results.error,
            errorCode: results.errorCode
          };
          if (ep) {
            e2.errorPrimitiveName = ep.name;
            e2.errorPrimitiveId = ep.id;
            Object.defineProperty(e2, "errorPrimitive", {
              value: ep,
              enumerable: false
              // so we don't get massive errors
            });
          }
          reject(e2);
        };
        runSimulation(config);
      });
    }
    simulate() {
      let config = {
        silent: true,
        model: this
      };
      let results = runSimulation(config);
      if (results.error) {
        let config2 = {
          code: results.errorCode
        };
        if (results.errorPrimitive) {
          config2.primitive = this.get((p2) => p2.id === results.errorPrimitive.id);
        }
        config2.line = results.errorLine;
        config2.source = results.errorSource;
        throw new SimulationError(results.error, config2);
      }
      let items = this.find();
      let nameIdMapping = {};
      for (let item of items) {
        nameIdMapping[item.id] = item.name;
      }
      return new Results(results, nameIdMapping);
    }
    /**
     * @param {import("./Blocks.js").PrimitiveConfig & import("./Blocks.js").ValuedConfig & import("./Blocks.js").StockConfig} config
     *
     * @return {Stock}
     */
    Stock(config = {}) {
      let stock = (
        /** @type {Stock} */
        this._createNode("stock").primitive(this, excludeKeys(config, ["name"]))
      );
      stock.name = config.name || "New Stock";
      stock.model = this;
      return stock;
    }
    /**
     * @param {import("./Blocks.js").PrimitiveConfig & import("./Blocks.js").ValuedConfig & import("./Blocks.js").VariableConfig} config
     *
     * @return {Variable}
     */
    Variable(config = {}) {
      let variable = this._createNode("variable").primitive(this, excludeKeys(config, ["name"]));
      variable.name = config.name || "New Variable";
      variable.model = this;
      return (
        /** @type {Variable} */
        variable
      );
    }
    /**
     * @param {import("./Blocks.js").PrimitiveConfig & import("./Blocks.js").ValuedConfig & import("./Blocks.js").ConverterConfig} config
     *
     * @return {Converter}
     */
    Converter(config = {}) {
      let converter = this._createNode("converter").primitive(this, excludeKeys(config, ["name"]));
      converter.name = config.name || "New Converter";
      converter.model = this;
      return (
        /** @type {Converter} */
        converter
      );
    }
    /**
     * @param {import("./Blocks.js").PrimitiveConfig & import("./Blocks.js").StateConfig} config
     *
     * @return {State}
     */
    State(config = {}) {
      let state = this._createNode("state").primitive(this, excludeKeys(config, ["name"]));
      state.name = config.name || "New State";
      state.model = this;
      return (
        /** @type {State} */
        state
      );
    }
    /**
     * @param {import("./Blocks.js").PrimitiveConfig & import("./Blocks.js").ActionConfig} config
     *
     * @return {Action}
     */
    Action(config = {}) {
      let action = this._createNode("action").primitive(this, excludeKeys(config, ["name"]));
      action.name = config.name || "New Action";
      action.model = this;
      return (
        /** @type {Action} */
        action
      );
    }
    /**
     * @param {import("./Blocks.js").PrimitiveConfig & import("./Blocks.js").PopulationConfig} config
     *
     * @return {Population}
     */
    Population(config = {}) {
      let population = this._createNode("agents").primitive(this, excludeKeys(config, ["name"]));
      population.name = config.name || "New Population";
      population.model = this;
      return (
        /** @type {Population} */
        population
      );
    }
    /**
     * @param {Stock|null} start
     * @param {Stock|null} end
     * @param {(import("./Blocks.js").PrimitiveConfig & import("./Blocks.js").ValuedConfig & import("./Blocks.js").FlowConfig)=} config
     *
     * @return {Flow}
     */
    Flow(start2, end, config = {}) {
      let flow = this._createConnector("flow", start2 || config.start || null, end || config.end || null).primitive(this, excludeKeys(config, ["name", "start", "end"]));
      flow.name = config.name || "New Flow";
      flow.model = this;
      return (
        /** @type {Flow} */
        flow
      );
    }
    /**
     * @param {State|null} start
     * @param {State|null} end
     * @param {(import("./Blocks.js").PrimitiveConfig & import("./Blocks.js").TransitionConfig)=} config
     *
     * @return {Transition}
     */
    Transition(start2, end, config = {}) {
      let transition2 = this._createConnector("transition", start2 || config.start || null, end || config.end || null).primitive(this, excludeKeys(config, ["name", "start", "end"]));
      transition2.name = config.name || "New Transition";
      transition2.model = this;
      return (
        /** @type {Transition} */
        transition2
      );
    }
    /**
     * @param {Primitive|null} start
     * @param {Primitive|null} end
     * @param {(import("./Blocks.js").PrimitiveConfig & import("./Blocks.js").LinkConfig)=} config
     *
     * @return {Link}
     */
    Link(start2, end, config = {}) {
      let link = this._createConnector("link", start2 || config.start || null, end || config.end || null).primitive(this, excludeKeys(config, ["name", "start", "end"]));
      link.name = config.name || "Link";
      link.model = this;
      return (
        /** @type {Link} */
        link
      );
    }
    /**
     * @param {import("./Blocks.js").PrimitiveConfig & import("./Blocks.js").ContainerConfig & import("./Blocks.js").AgentConfig} config
     *
     * @return {Agent}
     */
    Agent(config = {}) {
      let agentCell = this._createNode("folder");
      agentCell.setAttribute("Type", "Agent");
      let agent2 = agentCell.primitive(this, excludeKeys(config, ["name"]));
      agent2.name = config.name || "New Agent";
      agent2.model = this;
      return (
        /** @type {Agent} */
        agent2
      );
    }
    /**
     * @param {import("./Blocks.js").PrimitiveConfig & import("./Blocks.js").ContainerConfig & import("./Blocks.js").FolderConfig} config
     *
     * @return {Folder}
     */
    Folder(config = {}) {
      let folder = this._createNode("folder").primitive(this, excludeKeys(config, ["name"]));
      folder.name = config.name || "New Folder";
      folder.model = this;
      folder._node.setAttribute("Type", "None");
      return (
        /** @type {Folder} */
        folder
      );
    }
    /**
     * @param {string} id
     *
     * @return {Primitive}
     */
    getId(id2) {
      return this.get((item) => item.id === id2, "getId");
    }
    /**
     * @param {function(Primitive):boolean} selector
     * @param {string} fn
     *
     * @return {Primitive}
     */
    get(selector3, fn2 = "get") {
      let items = this.p(this._graph);
      let found = items.find((x2) => x2.primitive() && selector3(x2.primitive()));
      if (!found) {
        throw new Error(`No matching primitive found for ${fn2}()`);
      }
      return found.primitive();
    }
    /**
     * @param {function(Link):boolean} selector
     *
     * @return {Link}
     */
    getLink(selector3) {
      let items = this.p(this._graph, "Link");
      let found = items.find((x2) => selector3(x2.primitive()));
      if (!found) {
        throw new Error("No matching primitive found for getLink()");
      }
      return found.primitive();
    }
    /**
     * @param {function(Flow):boolean} selector
     *
     * @return {Flow}
     */
    getFlow(selector3) {
      let items = this.p(this._graph, "Flow");
      let found = items.find((x2) => selector3(x2.primitive()));
      if (!found) {
        throw new Error("No matching primitive found for getFlow()");
      }
      return found.primitive();
    }
    /**
     * @param {function(Transition):boolean} selector
     *
     * @return {Transition}
     */
    getTransition(selector3) {
      let items = this.p(this._graph, "Transition");
      let found = items.find((x2) => selector3(x2.primitive()));
      if (!found) {
        throw new Error("No matching primitive found for getTransition()");
      }
      return found.primitive();
    }
    /**
     * @param {function(Stock):boolean} selector
     *
     * @return {Stock}
     */
    getStock(selector3) {
      let items = this.p(this._graph, "Stock");
      let found = items.find((x2) => selector3(x2.primitive()));
      if (!found) {
        throw new Error("No matching primitive found for getStock()");
      }
      return found.primitive();
    }
    /**
     * @param {function(Variable):boolean} selector
     *
     * @return {Variable}
     */
    getVariable(selector3) {
      let items = this.p(this._graph, "Variable");
      let found = items.find((x2) => selector3(x2.primitive()));
      if (!found) {
        throw new Error("No matching primitive found for getVariable()");
      }
      return found.primitive();
    }
    /**
     * @param {function(Converter):boolean} selector
     *
     * @return {Converter}
     */
    getConverter(selector3) {
      let items = this.p(this._graph, "Converter");
      let found = items.find((x2) => selector3(x2.primitive()));
      if (!found) {
        throw new Error("No matching primitive found for getConverter()");
      }
      return found.primitive();
    }
    /**
     * @param {function(State):boolean} selector
     *
     * @return {State}
     */
    getState(selector3) {
      let items = this.p(this._graph, "State");
      let found = items.find((x2) => selector3(x2.primitive()));
      if (!found) {
        throw new Error("No matching primitive found for getState()");
      }
      return found.primitive();
    }
    /**
     * @param {function(Action):boolean} selector
     *
     * @return {Action}
     */
    getAction(selector3) {
      let items = this.p(this._graph, "Action");
      let found = items.find((x2) => selector3(x2.primitive()));
      if (!found) {
        throw new Error("No matching primitive found for getAction()");
      }
      return found.primitive();
    }
    /**
     * @param {function(Population):boolean} selector
     *
     * @return {Population}
     */
    getPopulation(selector3) {
      let items = this.p(this._graph, "Agents");
      let found = items.find((x2) => selector3(x2.primitive()));
      if (!found) {
        throw new Error("No matching primitive found for getPopulation()");
      }
      return found.primitive();
    }
    /**
     * @param {function(Folder):boolean} selector
     *
     * @return {Folder}
     */
    getFolder(selector3) {
      let items = this.p(this._graph, "Folder").filter((x2) => x2.getAttribute("Type") !== "Agent");
      let found = items.find((x2) => selector3(x2.primitive()));
      if (!found) {
        throw new Error("No matching primitive found for getFolder()");
      }
      return found.primitive();
    }
    /**
     * @param {function(Agent):boolean} selector
     *
     * @return {Agent}
     */
    getAgent(selector3) {
      let items = this.p(this._graph, "Folder").filter((x2) => x2.getAttribute("Type") === "Agent");
      let found = items.find((x2) => selector3(x2.primitive()));
      if (!found) {
        throw new Error("No matching primitive found for getAgent()");
      }
      return found.primitive();
    }
    /**
     * @param {function(Primitive):boolean=} selector
     *
     * @return {Primitive[]}
     */
    find(selector3 = (() => true)) {
      let items = this.p(this._graph);
      return items.filter((x2) => x2.primitive() && selector3(x2.primitive())).map((x2) => x2.primitive());
    }
    /**
     * @param {function(Link):boolean=} selector
     *
     * @return {Link[]}
     */
    findLinks(selector3 = (() => true)) {
      let items = this.p(this._graph, "Link");
      return items.filter((x2) => selector3(x2.primitive())).map((x2) => x2.primitive());
    }
    /**
     * @param {function(Flow):boolean=} selector
     *
     * @return {Flow[]}
     */
    findFlows(selector3 = (() => true)) {
      let items = this.p(this._graph, "Flow");
      return items.filter((x2) => selector3(x2.primitive())).map((x2) => x2.primitive());
    }
    /**
     * @param {function(Transition):boolean=} selector
     *
     * @return {Transition[]}
     */
    findTransitions(selector3 = (() => true)) {
      let items = this.p(this._graph, "Transition");
      return items.filter((x2) => selector3(x2.primitive())).map((x2) => x2.primitive());
    }
    /**
     * @param {function(Stock):boolean=} selector
     *
     * @return {Stock[]}
     */
    findStocks(selector3 = (() => true)) {
      let items = this.p(this._graph, "Stock");
      return items.filter((x2) => selector3(x2.primitive())).map((x2) => x2.primitive());
    }
    /**
     * @param {function(Variable):boolean=} selector
     *
     * @return {Variable[]}
     */
    findVariables(selector3 = (() => true)) {
      let items = this.p(this._graph, "Variable");
      return items.filter((x2) => selector3(x2.primitive())).map((x2) => x2.primitive());
    }
    /**
     * @param {function(Converter):boolean=} selector
     *
     * @return {Converter[]}
     */
    findConverters(selector3 = (() => true)) {
      let items = this.p(this._graph, "Converter");
      return items.filter((x2) => selector3(x2.primitive())).map((x2) => x2.primitive());
    }
    /**
     * @param {function(State):boolean=} selector
     *
     * @return {State[]}
     */
    findStates(selector3 = (() => true)) {
      let items = this.p(this._graph, "State");
      return items.filter((x2) => selector3(x2.primitive())).map((x2) => x2.primitive());
    }
    /**
     * @param {function(Action):boolean=} selector
     *
     * @return {Action[]}
     */
    findActions(selector3 = (() => true)) {
      let items = this.p(this._graph, "Action");
      return items.filter((x2) => selector3(x2.primitive())).map((x2) => x2.primitive());
    }
    /**
     * @param {function(Population):boolean=} selector
     *
     * @return {Population[]}
     */
    findPopulations(selector3 = (() => true)) {
      let items = this.p(this._graph, "Agents");
      return items.filter((x2) => selector3(x2.primitive())).map((x2) => x2.primitive());
    }
    /**
     * @param {function(Folder):boolean=} selector
     *
     * @return {Folder[]}
     */
    findFolders(selector3 = (() => true)) {
      let items = this.p(this._graph, "Folder");
      return items.filter((x2) => x2.getAttribute("Type") !== "Agent").filter((x2) => selector3(x2.primitive())).map((x2) => x2.primitive());
    }
    /**
     * @param {function(Agent):boolean=} selector
     *
     * @return {Agent[]}
     */
    findAgents(selector3 = (() => true)) {
      let items = this.p(this._graph, "Folder");
      return items.filter((x2) => x2.getAttribute("Type") === "Agent").filter((x2) => selector3(x2.primitive())).map((x2) => x2.primitive());
    }
    /**
     * @return {ModelConfig["timeStart"]}
     */
    get timeStart() {
      return +this.settings.getAttribute("TimeStart");
    }
    /**
     * @param {ModelConfig["timeStart"]} value
     */
    set timeStart(value) {
      this.settings.setAttribute("TimeStart", value);
    }
    /**
     * @return {ModelConfig["timeLength"]}
     */
    get timeLength() {
      return +this.settings.getAttribute("TimeLength");
    }
    /**
     * @param {ModelConfig["timeLength"]} value
     */
    set timeLength(value) {
      this.settings.setAttribute("TimeLength", value);
    }
    /**
     * @return {ModelConfig["timePause"]}
     */
    get timePause() {
      return +this.settings.getAttribute("TimePause");
    }
    /**
     * @param {ModelConfig["timePause"]} value
     */
    set timePause(value) {
      this.settings.setAttribute("TimePause", value);
    }
    /**
     * @return {ModelConfig["timeStep"]}
     */
    get timeStep() {
      return +this.settings.getAttribute("TimeStep");
    }
    /**
     * @param {ModelConfig["timeStep"]} value
     */
    set timeStep(value) {
      this.settings.setAttribute("TimeStep", value);
    }
    /**
     * @return {ModelConfig["timeUnits"]}
     */
    get timeUnits() {
      return (
        /** @type {any} */
        this.settings.getAttribute("TimeUnits")
      );
    }
    /**
     * @param {ModelConfig["timeUnits"]} value
     */
    set timeUnits(value) {
      this.settings.setAttribute("TimeUnits", value);
    }
    /**
     * @return {ModelConfig["algorithm"]}
     */
    get algorithm() {
      let value = (
        /** @type {any} */
        this.settings.getAttribute("SolutionAlgorithm")
      );
      if (value === "RK1") {
        return "Euler";
      }
      return value;
    }
    /**
     * @param {ModelConfig["algorithm"]} value
     */
    set algorithm(value) {
      let usedValue;
      if (value === "Euler") {
        usedValue = "RK1";
      } else {
        usedValue = value;
      }
      this.settings.setAttribute("SolutionAlgorithm", usedValue);
    }
    /**
     * @return {string}
     */
    get globals() {
      return this.settings.getAttribute("Macros") || "";
    }
    /**
     * @param {string} value
     */
    set globals(value) {
      this.settings.setAttribute("Macros", value);
    }
    /**
     * @return {CustomUnitsType}
     */
    get customUnits() {
      return (this.settings.getAttribute("Units") || "").split("\n").filter((x2) => !!x2).map((unit) => {
        let parts = unit.split("<>");
        return {
          name: parts[0],
          scale: +parts[1],
          target: parts[2]
        };
      });
    }
    /**
     * @param {CustomUnitsType} value
     */
    set customUnits(value) {
      this.settings.setAttribute("Units", value.map((unit) => unit.name + "<>" + unit.scale + "<>" + unit.target).join("\n"));
    }
  };
  function excludeKeys(obj, keys) {
    let newObj = {};
    for (let key in obj) {
      if (!keys.includes(key)) {
        newObj[key] = obj[key];
      }
    }
    return newObj;
  }

  // components/ModelFileInput.tsx
  var import_react6 = __toESM(require_react(), 1);
  var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
  function ModelFileInput({
    onFileUpload,
    loading
  }) {
    const fileInputRef = (0, import_react6.useRef)(null);
    const handleFileSelect = async (event) => {
      const file = event.target.files?.[0];
      if (!file) return;
      try {
        const content = await file.text();
        onFileUpload(content);
      } catch (error) {
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", { className: "flex gap-3 items-center swiss-card p-3", children: [
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "input",
        {
          ref: fileInputRef,
          type: "file",
          accept: ".InsightMaker",
          onChange: handleFileSelect,
          disabled: loading,
          className: "hidden",
          id: "model-file-input"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
        "label",
        {
          htmlFor: "model-file-input",
          className: "px-4 py-2 bg-gray-700 hover:bg-gray-800 text-white font-medium rounded-lg cursor-pointer transition-all shadow-sm hover:shadow-md flex items-center gap-2 disabled:opacity-50 swiss-btn",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" }) }),
            loading ? "Loading..." : "Load Different Model"
          ]
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", { className: "text-gray-500 text-sm flex items-center gap-1", children: [
        /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" }) }),
        "Upload .InsightMaker model file"
      ] })
    ] });
  }

  // components/SimulationResultsModal.tsx
  var import_react7 = __toESM(require_react(), 1);

  // lib/scenarioColors.ts
  var SCENARIO_COLORS = [
    "#3b82f6",
    // blue
    "#ef4444",
    // red
    "#22c55e",
    // green
    "#f59e0b",
    // amber
    "#8b5cf6",
    // violet
    "#ec4899",
    // pink
    "#06b6d4",
    // cyan
    "#f97316",
    // orange
    "#84cc16",
    // lime
    "#14b8a6"
    // teal
  ];
  var scenarioColorCache = /* @__PURE__ */ new Map();
  function getScenarioColor(scenarioName) {
    if (scenarioColorCache.has(scenarioName)) {
      return scenarioColorCache.get(scenarioName);
    }
    let hash = 0;
    for (let i2 = 0; i2 < scenarioName.length; i2++) {
      const char = scenarioName.charCodeAt(i2);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    const colorIndex = Math.abs(hash) % SCENARIO_COLORS.length;
    const color2 = SCENARIO_COLORS[colorIndex];
    scenarioColorCache.set(scenarioName, color2);
    return color2;
  }
  function getScenarioColorByIndex(index) {
    return SCENARIO_COLORS[index % SCENARIO_COLORS.length];
  }

  // components/TimeSeriesGraph.tsx
  var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
  var LINE_PATTERNS = [
    { dashArray: void 0, name: "solid" },
    // Solid line 
    { dashArray: "8 4", name: "dashed" },
    // Dashed   
    { dashArray: "2 4", name: "dotted" },
    // Dotted    
    { dashArray: "12 4 2 4", name: "dash-dot" },
    // Dash-dot 
    { dashArray: "12 4 2 4 2 4", name: "dash-dot-dot" },
    // Dash-dot-dot 
    { dashArray: "16 4", name: "long-dash" },
    // Long dash  
    { dashArray: "4 4", name: "short-dash" },
    // Short dash   
    { dashArray: "1 3", name: "fine-dot" }
    // Fine dots 
  ];
  var MARKER_SHAPES = [
    { type: "circle", render: (x2, y2, size, color2) => `<circle cx="${x2}" cy="${y2}" r="${size / 2}" fill="${color2}" />` },
    { type: "square", render: (x2, y2, size, color2) => `<rect x="${x2 - size / 2}" y="${y2 - size / 2}" width="${size}" height="${size}" fill="${color2}" />` },
    { type: "diamond", render: (x2, y2, size, color2) => `<polygon points="${x2},${y2 - size / 2} ${x2 + size / 2},${y2} ${x2},${y2 + size / 2} ${x2 - size / 2},${y2}" fill="${color2}" />` },
    { type: "triangle", render: (x2, y2, size, color2) => `<polygon points="${x2},${y2 - size / 2} ${x2 + size / 2},${y2 + size / 2} ${x2 - size / 2},${y2 + size / 2}" fill="${color2}" />` },
    { type: "triangle-down", render: (x2, y2, size, color2) => `<polygon points="${x2 - size / 2},${y2 - size / 2} ${x2 + size / 2},${y2 - size / 2} ${x2},${y2 + size / 2}" fill="${color2}" />` },
    { type: "cross", render: (x2, y2, size, color2) => `<path d="M${x2 - size / 2},${y2} L${x2 + size / 2},${y2} M${x2},${y2 - size / 2} L${x2},${y2 + size / 2}" stroke="${color2}" stroke-width="2" fill="none" />` },
    { type: "star", render: (x2, y2, size, color2) => {
      const r2 = size / 2;
      const points = [];
      for (let i2 = 0; i2 < 5; i2++) {
        const angle = (i2 * 72 - 90) * Math.PI / 180;
        const innerAngle = (i2 * 72 + 36 - 90) * Math.PI / 180;
        points.push(`${x2 + r2 * Math.cos(angle)},${y2 + r2 * Math.sin(angle)}`);
        points.push(`${x2 + r2 * 0.4 * Math.cos(innerAngle)},${y2 + r2 * 0.4 * Math.sin(innerAngle)}`);
      }
      return `<polygon points="${points.join(" ")}" fill="${color2}" />`;
    } },
    { type: "hexagon", render: (x2, y2, size, color2) => {
      const r2 = size / 2;
      const points = [];
      for (let i2 = 0; i2 < 6; i2++) {
        const angle = (i2 * 60 - 90) * Math.PI / 180;
        points.push(`${x2 + r2 * Math.cos(angle)},${y2 + r2 * Math.sin(angle)}`);
      }
      return `<polygon points="${points.join(" ")}" fill="${color2}" />`;
    } }
  ];
  var DEFAULT_COLORS = ["#3b82f6", "#10b981", "#f59e0b", "#ef4444", "#8b5cf6", "#06b6d4", "#ec4899", "#84cc16", "#f97316", "#6366f1"];
  function TimeSeriesGraph({ data, isMultiScenario = false }) {
    const { series, times } = data;
    const uniqueVariables = [...new Set(series.map((s2) => s2.variableName || s2.name.split(" (")[0]))];
    const uniqueScenarios = [...new Set(series.map((s2) => s2.scenarioName).filter(Boolean))];
    const variableIndex = new Map(uniqueVariables.map((v2, i2) => [v2, i2]));
    const stats = series.map((s2) => ({
      name: s2.name,
      min: Math.min(...s2.values),
      max: Math.max(...s2.values),
      start: s2.values[0],
      end: s2.values[s2.values.length - 1]
    }));
    const margin = { top: 30, right: 50, bottom: 70, left: 80 };
    const graphWidth = 1e3;
    const graphHeight = 500;
    const innerWidth = graphWidth - margin.left - margin.right;
    const innerHeight = graphHeight - margin.top - margin.bottom;
    const allValues = series.flatMap((s2) => s2.values);
    const globalMin = Math.min(...allValues);
    const globalMax = Math.max(...allValues);
    const valueRange = globalMax - globalMin || 1;
    const timeStart = times[0];
    const timeEnd = times[times.length - 1];
    const timeRange = timeEnd - timeStart || 1;
    const yTicks = [0, 0.25, 0.5, 0.75, 1].map((fraction) => ({
      fraction,
      value: globalMin + fraction * valueRange,
      y: margin.top + innerHeight * (1 - fraction)
    }));
    const xTicks = [0, 0.2, 0.4, 0.6, 0.8, 1].map((fraction) => ({
      fraction,
      value: timeStart + fraction * timeRange,
      x: margin.left + innerWidth * fraction
    }));
    const getSeriesStyle = (s2, idx) => {
      if (isMultiScenario && s2.variableName && s2.scenarioName) {
        const varIdx = variableIndex.get(s2.variableName) || 0;
        return {
          color: getScenarioColor(s2.scenarioName),
          pattern: LINE_PATTERNS[varIdx % LINE_PATTERNS.length],
          markerShape: MARKER_SHAPES[varIdx % MARKER_SHAPES.length]
        };
      }
      return {
        color: s2.color || DEFAULT_COLORS[idx % DEFAULT_COLORS.length],
        pattern: LINE_PATTERNS[0],
        markerShape: MARKER_SHAPES[idx % MARKER_SHAPES.length]
      };
    };
    const generateMarkers = (values, color2, markerIdx, seriesIdx) => {
      if (!isMultiScenario) return null;
      const interval2 = Math.max(1, Math.floor(values.length / 10));
      const markers = [];
      values.forEach((val, idx) => {
        if (idx % interval2 === 0 || idx === values.length - 1) {
          const x2 = margin.left + idx / (values.length - 1) * innerWidth;
          const normalizedY = (val - globalMin) / valueRange;
          const y2 = margin.top + innerHeight * (1 - normalizedY);
          const shape = MARKER_SHAPES[markerIdx % MARKER_SHAPES.length];
          markers.push(
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("g", { dangerouslySetInnerHTML: {
              __html: shape.render(x2, y2, 6, color2)
            } }, `marker-${seriesIdx}-${idx}`)
          );
        }
      });
      return markers;
    };
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "space-y-4", children: [
      /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "p-4 rounded-lg", children: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h3", { className: "text-gray-900 font-semibold mb-6 text-lg swiss-header", children: "Time Series" }),
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "overflow-x-auto", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("svg", { width: graphWidth, height: graphHeight, className: "bg-white", children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            "rect",
            {
              x: margin.left,
              y: margin.top,
              width: innerWidth,
              height: innerHeight,
              fill: "#f9fafb",
              stroke: "#e5e7eb",
              strokeWidth: 1
            }
          ),
          yTicks.map((tick) => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            "line",
            {
              x1: margin.left,
              y1: tick.y,
              x2: margin.left + innerWidth,
              y2: tick.y,
              stroke: "#e5e7eb",
              strokeWidth: 1
            },
            `grid-h-${tick.fraction}`
          )),
          xTicks.map((tick) => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            "line",
            {
              x1: tick.x,
              y1: margin.top,
              x2: tick.x,
              y2: margin.top + innerHeight,
              stroke: "#e5e7eb",
              strokeWidth: 1
            },
            `grid-v-${tick.fraction}`
          )),
          series.map((s2, seriesIdx) => {
            const style2 = getSeriesStyle(s2, seriesIdx);
            const varIdx = s2.variableName ? variableIndex.get(s2.variableName) || 0 : seriesIdx;
            const points = s2.values.map((val, idx) => {
              const x2 = margin.left + idx / (s2.values.length - 1) * innerWidth;
              const normalizedY = (val - globalMin) / valueRange;
              const y2 = margin.top + innerHeight * (1 - normalizedY);
              return `${x2},${y2}`;
            }).join(" ");
            return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("g", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                "polyline",
                {
                  points,
                  fill: "none",
                  stroke: style2.color,
                  strokeWidth: 2.5,
                  strokeDasharray: style2.pattern.dashArray
                }
              ),
              isMultiScenario && generateMarkers(s2.values, style2.color, varIdx, seriesIdx)
            ] }, seriesIdx);
          }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            "line",
            {
              x1: margin.left,
              y1: margin.top,
              x2: margin.left,
              y2: margin.top + innerHeight,
              stroke: "#374151",
              strokeWidth: 2
            }
          ),
          yTicks.map((tick) => /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("g", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "line",
              {
                x1: margin.left - 6,
                y1: tick.y,
                x2: margin.left,
                y2: tick.y,
                stroke: "#374151",
                strokeWidth: 2
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "text",
              {
                x: margin.left - 10,
                y: tick.y,
                textAnchor: "end",
                alignmentBaseline: "middle",
                fontSize: "12",
                fill: "#4b5563",
                fontFamily: "system-ui, -apple-system, sans-serif",
                children: tick.value.toFixed(2)
              }
            )
          ] }, `y-tick-${tick.fraction}`)),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            "text",
            {
              x: -graphHeight / 2,
              y: 20,
              transform: `rotate(-90, 20, ${graphHeight / 2})`,
              textAnchor: "middle",
              fontSize: "14",
              fontWeight: "600",
              fill: "#1f2937",
              fontFamily: "system-ui, -apple-system, sans-serif",
              children: "Value"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            "line",
            {
              x1: margin.left,
              y1: margin.top + innerHeight,
              x2: margin.left + innerWidth,
              y2: margin.top + innerHeight,
              stroke: "#374151",
              strokeWidth: 2
            }
          ),
          xTicks.map((tick) => /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("g", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "line",
              {
                x1: tick.x,
                y1: margin.top + innerHeight,
                x2: tick.x,
                y2: margin.top + innerHeight + 6,
                stroke: "#374151",
                strokeWidth: 2
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
              "text",
              {
                x: tick.x,
                y: margin.top + innerHeight + 20,
                textAnchor: "middle",
                fontSize: "12",
                fill: "#4b5563",
                fontFamily: "system-ui, -apple-system, sans-serif",
                children: tick.value.toFixed(1)
              }
            )
          ] }, `x-tick-${tick.fraction}`)),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
            "text",
            {
              x: margin.left + innerWidth / 2,
              y: graphHeight - 15,
              textAnchor: "middle",
              fontSize: "14",
              fontWeight: "600",
              fill: "#1f2937",
              fontFamily: "system-ui, -apple-system, sans-serif",
              children: "Time"
            }
          )
        ] }) }),
        isMultiScenario && uniqueScenarios.length > 0 ? /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "mt-6 space-y-4", children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h4", { className: "text-sm font-medium text-gray-700 mb-2", children: "Scenarios (by color):" }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-wrap gap-4", children: uniqueScenarios.map((scenario) => {
              const color2 = getScenarioColor(scenario);
              return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                  "div",
                  {
                    className: "w-4 h-4 rounded flex-shrink-0",
                    style: { backgroundColor: color2 }
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-gray-700 text-sm", children: scenario })
              ] }, scenario);
            }) })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h4", { className: "text-sm font-medium text-gray-700 mb-2", children: "Variables (by line style):" }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "flex flex-wrap gap-4", children: uniqueVariables.map((variable, idx) => {
              const pattern = LINE_PATTERNS[idx % LINE_PATTERNS.length];
              const marker = MARKER_SHAPES[idx % MARKER_SHAPES.length];
              return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("svg", { width: "32", height: "16", className: "flex-shrink-0", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                    "line",
                    {
                      x1: "0",
                      y1: "8",
                      x2: "24",
                      y2: "8",
                      stroke: "#374151",
                      strokeWidth: "2.5",
                      strokeDasharray: pattern.dashArray
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("g", { dangerouslySetInnerHTML: {
                    __html: marker.render(28, 8, 6, "#374151")
                  } })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-gray-700 text-sm", children: variable })
              ] }, variable);
            }) })
          ] })
        ] }) : (
          /* Single scenario legend */
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "mt-4 flex flex-wrap gap-4", children: series.map((s2, idx) => {
            const style2 = getSeriesStyle(s2, idx);
            return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center gap-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("svg", { width: "20", height: "16", className: "flex-shrink-0", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                "line",
                {
                  x1: "0",
                  y1: "8",
                  x2: "20",
                  y2: "8",
                  stroke: style2.color,
                  strokeWidth: "2.5",
                  strokeDasharray: style2.pattern.dashArray
                }
              ) }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-gray-700 text-sm", children: s2.name })
            ] }, idx);
          }) })
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "p-6 rounded-lg", children: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h3", { className: "text-gray-900 font-semibold mb-4 text-lg", children: "Statistics" }),
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "overflow-x-auto", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("table", { className: "w-full text-sm", children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("thead", { children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("tr", { className: "border-b border-gray-300", children: [
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("th", { className: "text-left py-2 px-2 text-gray-600", children: "Series" }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("th", { className: "text-right py-2 px-2 text-gray-600", children: "Min" }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("th", { className: "text-right py-2 px-2 text-gray-600", children: "Max" }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("th", { className: "text-right py-2 px-2 text-gray-600", children: "Start" }),
            /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("th", { className: "text-right py-2 px-2 text-gray-600", children: "End" })
          ] }) }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("tbody", { children: stats.map((stat, idx) => {
            const style2 = getSeriesStyle(series[idx], idx);
            return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("tr", { className: "border-b border-gray-200", children: [
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("td", { className: "py-2 px-2", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("svg", { width: "20", height: "12", className: "flex-shrink-0", children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
                  "line",
                  {
                    x1: "0",
                    y1: "6",
                    x2: "20",
                    y2: "6",
                    stroke: style2.color,
                    strokeWidth: "2",
                    strokeDasharray: style2.pattern.dashArray
                  }
                ) }),
                /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: "text-gray-900", children: stat.name })
              ] }) }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("td", { className: "text-right py-2 px-2 text-gray-700", children: stat.min.toFixed(4) }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("td", { className: "text-right py-2 px-2 text-gray-700", children: stat.max.toFixed(4) }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("td", { className: "text-right py-2 px-2 text-gray-700", children: stat.start.toFixed(4) }),
              /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("td", { className: "text-right py-2 px-2 text-gray-700", children: stat.end.toFixed(4) })
            ] }, idx);
          }) })
        ] }) })
      ] })
    ] });
  }

  // components/DataTable.tsx
  var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
  function DataTable({ times, series }) {
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "p-4", children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("h3", { className: "text-gray-900 font-semibold mb-4 text-lg swiss-header", children: "Tabular Data" }),
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "overflow-x-auto", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("table", { className: "w-full text-sm font-mono", children: [
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("thead", { children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("tr", { className: "border-b border-gray-300", children: [
          /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("th", { className: "text-left py-2 px-2 text-gray-600 swiss-table", children: "Time" }),
          series.map((s2, idx) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("th", { className: "text-right py-2 px-2 text-gray-600", children: s2.name }, idx))
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("tbody", { children: times.map((time, timeIdx) => /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("tr", { className: "border-b border-gray-200", children: [
          /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("td", { className: "py-1 px-2 text-gray-900", children: time.toFixed(2) }),
          series.map((s2, seriesIdx) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("td", { className: "text-right py-1 px-2 text-gray-700", children: s2.values[timeIdx]?.toFixed(4) || "N/A" }, seriesIdx))
        ] }, timeIdx)) })
      ] }) })
    ] });
  }

  // components/SimulationResultsModal.tsx
  var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
  function SimulationResultsModal({
    isOpen,
    onClose,
    selectedElement,
    simulationResults,
    modelData,
    convertedData,
    scenarioHistory = []
  }) {
    const [activeTab, setActiveTab] = (0, import_react7.useState)("");
    const [selectedScenarios, setSelectedScenarios] = (0, import_react7.useState)(/* @__PURE__ */ new Set());
    const [showScenarioSelector, setShowScenarioSelector] = (0, import_react7.useState)(false);
    (0, import_react7.useEffect)(() => {
      if (scenarioHistory.length > 0) {
        const latestScenario = scenarioHistory[scenarioHistory.length - 1];
        setSelectedScenarios(/* @__PURE__ */ new Set([latestScenario.scenarioName]));
      } else {
        setSelectedScenarios(/* @__PURE__ */ new Set(["__current__"]));
      }
    }, [scenarioHistory, isOpen]);
    const { timeSeriesViz, tabularViz } = (0, import_react7.useMemo)(() => {
      if (convertedData?.displays) {
        const timeSeries2 = [];
        const tabular2 = [];
        convertedData.displays.forEach((display) => {
          const vizType = display.type?.toUpperCase().replace(/\s+/g, "_");
          if (vizType === "TABLE" || vizType === "TABULAR") {
            tabular2.push({
              name: display.name,
              type: display.type,
              primitives: display.primitiveIds,
              primitives2: display.primitiveIds2
            });
          } else {
            timeSeries2.push({
              name: display.name,
              type: display.type,
              primitives: display.primitiveIds,
              primitives2: display.primitiveIds2
            });
          }
        });
        return { timeSeriesViz: timeSeries2, tabularViz: tabular2 };
      }
      if (!modelData) return { timeSeriesViz: [], tabularViz: [] };
      const timeSeries = [];
      const tabular = [];
      modelData.visualizations.forEach((viz) => {
        const vizType = viz.type?.toUpperCase().replace(/\s+/g, "_");
        if (vizType === "TABLE" || vizType === "TABULAR") {
          tabular.push(viz);
        } else {
          timeSeries.push(viz);
        }
      });
      return { timeSeriesViz: timeSeries, tabularViz: tabular };
    }, [modelData, convertedData]);
    (0, import_react7.useMemo)(() => {
      if (selectedElement && timeSeriesViz.length > 0) {
        setActiveTab(timeSeriesViz[0].name || "viz-0");
      } else if (selectedElement) {
        setActiveTab("selected");
      } else if (timeSeriesViz.length > 0) {
        setActiveTab(timeSeriesViz[0].name || "viz-0");
      } else if (tabularViz.length > 0) {
        setActiveTab(tabularViz[0].name || "tab-0");
      }
    }, [selectedElement, timeSeriesViz, tabularViz, isOpen]);
    const toggleScenario = (scenarioName) => {
      const newSelected = new Set(selectedScenarios);
      if (newSelected.has(scenarioName)) {
        if (newSelected.size > 1) {
          newSelected.delete(scenarioName);
        }
      } else {
        newSelected.add(scenarioName);
      }
      setSelectedScenarios(newSelected);
    };
    const getColorForScenario = (scenarioName) => {
      return getScenarioColor(scenarioName);
    };
    const availableScenarios = (0, import_react7.useMemo)(() => {
      const scenarios = [];
      if (simulationResults && scenarioHistory.length === 0) {
        scenarios.push({ name: "__current__", isCurrent: true });
      }
      scenarioHistory.forEach((result) => {
        scenarios.push({
          name: result.scenarioName,
          timestamp: result.timestamp,
          isCurrent: false
        });
      });
      return scenarios;
    }, [simulationResults, scenarioHistory]);
    const activeVizData = (0, import_react7.useMemo)(() => {
      if (!modelData) return null;
      const resultsToInclude = [];
      if (selectedScenarios.has("__current__") && simulationResults) {
        resultsToInclude.push({
          name: "Current",
          results: simulationResults,
          color: getScenarioColor("Current")
        });
      }
      scenarioHistory.forEach((scenario) => {
        if (selectedScenarios.has(scenario.scenarioName)) {
          resultsToInclude.push({
            name: scenario.scenarioName,
            results: scenario.simulationResults,
            color: getScenarioColor(scenario.scenarioName)
          });
        }
      });
      if (resultsToInclude.length === 0) return null;
      const firstResult = resultsToInclude[0].results;
      const times = firstResult.times();
      if (selectedElement && activeTab === "selected") {
        const series = [];
        resultsToInclude.forEach(({ name: scenarioName, results, color: color2 }) => {
          try {
            const primitive = modelData.find((p2) => p2.name === selectedElement)[0];
            if (primitive) {
              const values = results.series(primitive);
              const displayName = resultsToInclude.length > 1 ? `${selectedElement} (${scenarioName})` : selectedElement;
              series.push({
                name: displayName,
                values,
                color: color2,
                variableName: selectedElement,
                scenarioName
              });
            }
          } catch (error) {
          }
        });
        return { times, series, type: "TIME_SERIES", isMultiScenario: resultsToInclude.length > 1 };
      }
      const allViz = [...timeSeriesViz, ...tabularViz];
      const viz = allViz.find((v2) => v2.name === activeTab);
      if (!viz) return null;
      const primitiveIds = viz.primitives || viz.elements;
      if (!primitiveIds || primitiveIds.length === 0) return null;
      try {
        const series = [];
        resultsToInclude.forEach(({ name: scenarioName, results, color: color2 }, scenarioIdx) => {
          primitiveIds.forEach((id2, primIdx) => {
            try {
              let elementName = id2;
              if (convertedData?.idToName && convertedData.idToName[id2]) {
                elementName = convertedData.idToName[id2];
              }
              const primitives2 = modelData.find((p2) => p2.name === elementName);
              if (primitives2 && primitives2.length > 0) {
                const primitive = primitives2[0];
                const values = results.series(primitive);
                const displayName = resultsToInclude.length > 1 ? `${primitive.name} (${scenarioName})` : primitive.name;
                const seriesColor = resultsToInclude.length > 1 ? color2 : getScenarioColorByIndex(primIdx);
                series.push({
                  name: displayName,
                  values,
                  color: seriesColor,
                  variableName: primitive.name,
                  scenarioName
                });
                return;
              }
              try {
                const primitive = modelData.getId(id2);
                if (primitive) {
                  const values = results.series(primitive);
                  const displayName = resultsToInclude.length > 1 ? `${primitive.name} (${scenarioName})` : primitive.name;
                  const seriesColor = resultsToInclude.length > 1 ? color2 : getScenarioColorByIndex(primIdx);
                  series.push({
                    name: displayName,
                    values,
                    color: seriesColor,
                    variableName: primitive.name,
                    scenarioName
                  });
                }
              } catch (e2) {
              }
            } catch (error) {
            }
          });
        });
        const vizType = viz.type?.toUpperCase().replace(/\s+/g, "_") || "TIME_SERIES";
        return { times, series, type: vizType, isMultiScenario: resultsToInclude.length > 1 };
      } catch (error) {
        return null;
      }
    }, [simulationResults, modelData, selectedElement, activeTab, timeSeriesViz, tabularViz, convertedData, selectedScenarios, scenarioHistory]);
    const handleDownload = () => {
      if (!activeVizData || !activeVizData.series || activeVizData.series.length === 0) return;
      const activeTabInfo = tabs.find((t2) => t2.name === activeTab);
      const tabLabel = activeTabInfo?.label || activeTab;
      const scenarioData = {};
      const selectedScenariosList = Array.from(selectedScenarios);
      selectedScenariosList.forEach((scenarioName) => {
        const displayName = scenarioName === "__current__" ? "Current" : scenarioName;
        scenarioData[displayName] = {
          times: activeVizData.times,
          variables: []
        };
      });
      activeVizData.series.forEach((s2) => {
        const scenarioName = s2.scenarioName || "Current";
        if (scenarioData[scenarioName]) {
          scenarioData[scenarioName].variables.push({
            name: s2.variableName || s2.name,
            values: s2.values
          });
        }
      });
      const data = {
        visualization: tabLabel,
        type: activeVizData.type,
        exportedAt: (/* @__PURE__ */ new Date()).toISOString(),
        scenarios: Object.entries(scenarioData).map(([name, data2]) => ({
          scenarioName: name,
          times: data2.times,
          variables: data2.variables
        }))
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a2 = document.createElement("a");
      a2.href = url;
      const safeTabName = tabLabel.replace(/[^a-zA-Z0-9]/g, "-");
      const scenarioCount = Object.keys(scenarioData).length;
      a2.download = scenarioCount > 1 ? `${safeTabName}-${scenarioCount}-scenarios.json` : `${safeTabName}.json`;
      document.body.appendChild(a2);
      a2.click();
      document.body.removeChild(a2);
      URL.revokeObjectURL(url);
    };
    if (!isOpen) return null;
    const tabs = [];
    if (selectedElement) {
      tabs.push({ name: "selected", label: selectedElement, type: "TIME_SERIES" });
    }
    timeSeriesViz.forEach((viz, idx) => {
      tabs.push({ name: viz.name || `viz-${idx}`, label: viz.name || `Chart ${idx + 1}`, type: "TIME_SERIES" });
    });
    tabularViz.forEach((viz, idx) => {
      tabs.push({ name: viz.name || `tab-${idx}`, label: viz.name || `Table ${idx + 1}`, type: "TABLE" });
    });
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "fixed inset-0 bg-black bg-opacity-30 flex items-center justify-center z-50 p-2", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "bg-white rounded-lg shadow-2xl w-[98vw] h-[96vh] overflow-hidden flex flex-col swiss-modal-inner", children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "p-4 border-b border-gray-200 flex justify-between items-center flex-shrink-0 swiss-header", children: [
        /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "flex items-center gap-4", children: [
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("h2", { className: "text-xl font-bold text-gray-900", children: "Simulation Results" }),
          availableScenarios.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "relative", children: [
            /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
              "button",
              {
                onClick: () => setShowScenarioSelector(!showScenarioSelector),
                className: "flex items-center gap-2 px-3 py-1.5 bg-indigo-50 hover:bg-indigo-100 text-indigo-700 rounded-lg text-sm font-medium transition-colors",
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" }) }),
                  "Scenarios (",
                  selectedScenarios.size,
                  ")",
                  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("svg", { className: `w-4 h-4 transition-transform ${showScenarioSelector ? "rotate-180" : ""}`, fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" }) })
                ]
              }
            ),
            showScenarioSelector && /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "absolute top-full left-0 mt-1 w-72 z-10 swiss-card p-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "text-xs font-medium text-gray-500 uppercase tracking-wide px-2 py-1 mb-1", children: "Compare Scenarios" }),
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "max-h-64 overflow-y-auto", children: availableScenarios.map((scenario, idx) => /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
                "label",
                {
                  className: "flex items-center gap-3 px-2 py-2 hover:bg-gray-50 rounded cursor-pointer swiss-checkbox-label",
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
                      "input",
                      {
                        type: "checkbox",
                        checked: selectedScenarios.has(scenario.name),
                        onChange: () => toggleScenario(scenario.name),
                        className: "swiss-checkbox"
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
                      "div",
                      {
                        className: "w-3 h-3 rounded-full flex-shrink-0",
                        style: { backgroundColor: getScenarioColor(scenario.name) }
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "flex-1 min-w-0", children: [
                      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("p", { className: "text-sm font-medium text-gray-800 truncate", children: scenario.isCurrent ? "Current Run" : scenario.name }),
                      scenario.timestamp && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("p", { className: "text-xs text-gray-500", children: scenario.timestamp.toLocaleString() })
                    ] })
                  ]
                },
                scenario.name
              )) }),
              availableScenarios.length > 1 && /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "pt-2 mt-2 flex gap-2", children: [
                /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
                  "button",
                  {
                    onClick: () => setSelectedScenarios(new Set(availableScenarios.map((s2) => s2.name))),
                    className: "flex-1 text-xs py-1 swiss-btn swiss-btn--secondary",
                    children: "Select All"
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
                  "button",
                  {
                    onClick: () => {
                      const latest = availableScenarios[availableScenarios.length - 1];
                      setSelectedScenarios(/* @__PURE__ */ new Set([latest.name]));
                    },
                    className: "flex-1 text-xs py-1 swiss-btn swiss-btn--secondary",
                    children: "Latest Only"
                  }
                )
              ] })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
          "button",
          {
            onClick: onClose,
            className: "text-gray-500 hover:text-gray-700 transition-colors",
            children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) })
          }
        )
      ] }),
      selectedScenarios.size > 1 && /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "px-6 py-2 bg-indigo-50 border-b border-indigo-100 flex items-center gap-2 flex-wrap", children: [
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: "text-xs font-medium text-indigo-600", children: "Comparing:" }),
        Array.from(selectedScenarios).map((name, idx) => {
          const scenario = availableScenarios.find((s2) => s2.name === name);
          const colorIdx = availableScenarios.findIndex((s2) => s2.name === name);
          return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
            "span",
            {
              className: "inline-flex items-center gap-1.5 px-2 py-0.5 bg-white rounded-full text-xs font-medium text-gray-700 border border-gray-200",
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
                  "span",
                  {
                    className: "w-2 h-2 rounded-full",
                    style: { backgroundColor: getScenarioColor(name) }
                  }
                ),
                scenario?.isCurrent ? "Current" : name
              ]
            },
            name
          );
        })
      ] }),
      tabs.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "border-b border-gray-200 overflow-x-auto flex-shrink-0 bg-gray-50", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "flex px-6 gap-2", children: tabs.map((tab) => /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
        "button",
        {
          onClick: () => setActiveTab(tab.name),
          className: `px-6 py-4 font-medium text-base whitespace-nowrap transition-colors rounded-t-lg ${activeTab === tab.name ? "text-[color:var(--swiss-red)] bg-white border-b-3 border-[color:var(--swiss-red)] shadow-sm" : "text-gray-600 hover:text-gray-900 hover:bg-gray-100"}`,
          children: tab.label
        },
        tab.name
      )) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "flex-1 overflow-y-auto p-6", children: activeVizData ? activeVizData.type === "TABLE" || activeVizData.type === "TABULAR" ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(DataTable, { times: activeVizData.times, series: activeVizData.series }) : /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
        TimeSeriesGraph,
        {
          data: activeVizData,
          isMultiScenario: activeVizData.isMultiScenario
        }
      ) : /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "swiss-card text-center", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("p", { className: "text-gray-600 py-4", children: "No data available. Run simulation first." }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "p-4 border-t border-gray-200 flex justify-between items-center flex-shrink-0", children: [
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { className: "text-sm text-gray-500", children: activeVizData && activeVizData.series && activeVizData.series.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("span", { children: [
          activeVizData.series.length,
          " series \xB7 ",
          activeVizData.times?.length || 0,
          " time points",
          selectedScenarios.size > 1 && ` \xB7 ${selectedScenarios.size} scenarios`
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "flex gap-2", children: [
          activeVizData && activeVizData.series && activeVizData.series.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
            "button",
            {
              onClick: handleDownload,
              className: "px-4 py-2 swiss-btn swiss-btn--accent flex items-center gap-2",
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" }) }),
                selectedScenarios.size > 1 ? `Download ${selectedScenarios.size} Scenarios` : "Download Data"
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            "button",
            {
              onClick: onClose,
              className: "px-4 py-2 swiss-btn swiss-btn--secondary",
              children: "Close"
            }
          )
        ] })
      ] })
    ] }) });
  }

  // components/ElementDetailModal.tsx
  var import_react8 = __toESM(require_react(), 1);
  var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
  function ElementDetailModal({
    isOpen,
    onClose,
    elementId,
    simulationResults: _simulationResults,
    // kept for backwards compatibility
    modelData,
    scenarioHistory = [],
    selectedDisplayScenarios: initialSelectedScenarios = /* @__PURE__ */ new Set()
  }) {
    const [localSelectedScenarios, setLocalSelectedScenarios] = (0, import_react8.useState)(/* @__PURE__ */ new Set());
    const [showScenarioDropdown, setShowScenarioDropdown] = (0, import_react8.useState)(false);
    (0, import_react8.useEffect)(() => {
      if (isOpen) {
        setLocalSelectedScenarios(new Set(initialSelectedScenarios));
      }
    }, [isOpen, initialSelectedScenarios]);
    const elementInfo = (0, import_react8.useMemo)(() => {
      if (!isOpen || !elementId || !modelData) return null;
      try {
        const primitive = modelData.find((p2) => p2.name === elementId)[0];
        if (primitive) {
          return {
            name: primitive.name,
            type: primitive.constructor.name,
            doc: primitive.doc,
            units: primitive.units,
            primitive
          };
        }
      } catch (error) {
      }
      return null;
    }, [isOpen, elementId, modelData]);
    const scenariosToDisplay = (0, import_react8.useMemo)(() => {
      if (scenarioHistory.length === 0) return [];
      if (localSelectedScenarios.size > 0) {
        return scenarioHistory.filter((s2) => localSelectedScenarios.has(s2.scenarioName));
      }
      return [scenarioHistory[scenarioHistory.length - 1]];
    }, [scenarioHistory, localSelectedScenarios]);
    const multiScenarioData = (0, import_react8.useMemo)(() => {
      if (!elementInfo?.primitive || scenariosToDisplay.length === 0) return null;
      const scenarioData = [];
      scenariosToDisplay.forEach((scenario, idx) => {
        try {
          const times = scenario.simulationResults.times();
          const values = scenario.simulationResults.series(elementInfo.primitive);
          if (times && values) {
            scenarioData.push({
              scenarioName: scenario.scenarioName,
              times,
              values,
              color: getScenarioColorByIndex(idx)
            });
          }
        } catch {
        }
      });
      return scenarioData.length > 0 ? scenarioData : null;
    }, [elementInfo?.primitive, scenariosToDisplay]);
    const graphBounds = (0, import_react8.useMemo)(() => {
      if (!multiScenarioData) return null;
      let globalMinVal = Infinity;
      let globalMaxVal = -Infinity;
      let globalMinTime = Infinity;
      let globalMaxTime = -Infinity;
      multiScenarioData.forEach((s2) => {
        const minVal = Math.min(...s2.values);
        const maxVal = Math.max(...s2.values);
        globalMinVal = Math.min(globalMinVal, minVal);
        globalMaxVal = Math.max(globalMaxVal, maxVal);
        globalMinTime = Math.min(globalMinTime, s2.times[0]);
        globalMaxTime = Math.max(globalMaxTime, s2.times[s2.times.length - 1]);
      });
      return {
        minVal: globalMinVal,
        maxVal: globalMaxVal,
        minTime: globalMinTime,
        maxTime: globalMaxTime,
        valRange: globalMaxVal - globalMinVal || 1,
        timeRange: globalMaxTime - globalMinTime || 1
      };
    }, [multiScenarioData]);
    const stats = (0, import_react8.useMemo)(() => {
      if (!multiScenarioData || multiScenarioData.length === 0) return null;
      const firstScenario = multiScenarioData[0];
      const values = firstScenario.values;
      const min = Math.min(...values);
      const max = Math.max(...values);
      const mean = values.reduce((sum, v2) => sum + v2, 0) / values.length;
      const start2 = values[0];
      const end = values[values.length - 1];
      if (typeof start2 !== "number" || typeof end !== "number" || isNaN(start2) || isNaN(end)) {
        return null;
      }
      return { min, max, mean, start: start2, end, count: values.length };
    }, [multiScenarioData]);
    const graphMargin = { top: 20, right: 30, bottom: 50, left: 60 };
    const graphWidth = 700;
    const graphHeight = 300;
    const graphInnerWidth = graphWidth - graphMargin.left - graphMargin.right;
    const graphInnerHeight = graphHeight - graphMargin.top - graphMargin.bottom;
    const graphData = (0, import_react8.useMemo)(() => {
      if (!multiScenarioData || !graphBounds) return null;
      const { minVal, minTime, valRange, timeRange } = graphBounds;
      const yTicks = [0, 0.25, 0.5, 0.75, 1].map((fraction) => ({
        fraction,
        value: minVal + fraction * valRange,
        y: graphMargin.top + graphInnerHeight * (1 - fraction)
      }));
      const xTicks = [0, 0.2, 0.4, 0.6, 0.8, 1].map((fraction) => ({
        fraction,
        value: minTime + fraction * timeRange,
        x: graphMargin.left + graphInnerWidth * fraction
      }));
      const scenarioPaths = multiScenarioData.map((scenario, idx) => {
        const points = scenario.values.map((val, i2) => {
          const timeFraction = (scenario.times[i2] - minTime) / timeRange;
          const valFraction = (val - minVal) / valRange;
          const x2 = graphMargin.left + timeFraction * graphInnerWidth;
          const y2 = graphMargin.top + graphInnerHeight * (1 - valFraction);
          return `${x2},${y2}`;
        }).join(" ");
        return {
          scenarioName: scenario.scenarioName,
          points,
          color: getScenarioColorByIndex(idx)
        };
      });
      return { yTicks, xTicks, scenarioPaths };
    }, [multiScenarioData, graphBounds, graphMargin.left, graphMargin.top, graphInnerWidth, graphInnerHeight]);
    if (!isOpen || !elementId || !modelData || !elementInfo) return null;
    const getScenariosToDownload = () => {
      return scenariosToDisplay;
    };
    const handleDownload = () => {
      const scenariosToDownload = getScenariosToDownload();
      if (!elementInfo?.primitive) return;
      if (scenariosToDownload.length > 1) {
        const data = {
          element: elementId,
          type: elementInfo.type || "Unknown",
          units: elementInfo.units,
          scenarios: []
        };
        scenariosToDownload.forEach((scenario) => {
          try {
            const times = scenario.simulationResults.times();
            const values = scenario.simulationResults.series(elementInfo.primitive);
            if (times && values) {
              data.scenarios.push({
                scenarioName: scenario.scenarioName,
                timestamp: scenario.timestamp.toISOString(),
                timeUnits: scenario.simulationResults.timeUnits || "Years",
                times,
                values
              });
            }
          } catch {
          }
        });
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a2 = document.createElement("a");
        a2.href = url;
        a2.download = `${elementId}-${data.scenarios.length}-scenarios.json`;
        document.body.appendChild(a2);
        a2.click();
        document.body.removeChild(a2);
        URL.revokeObjectURL(url);
      } else if (multiScenarioData && multiScenarioData.length > 0) {
        const firstScenario = multiScenarioData[0];
        const scenarioEntry = scenariosToDownload[0];
        const data = {
          element: elementId,
          type: elementInfo.type,
          units: elementInfo.units,
          times: firstScenario.times,
          values: firstScenario.values,
          timeUnits: scenarioEntry?.simulationResults?.timeUnits,
          ...scenarioEntry && { scenario: scenarioEntry.scenarioName }
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a2 = document.createElement("a");
        a2.href = url;
        const filename = scenarioEntry?.scenarioName ? `${elementId}-${scenarioEntry.scenarioName.replace(/[^a-zA-Z0-9]/g, "-")}.json` : `${elementId}-data.json`;
        a2.download = filename;
        document.body.appendChild(a2);
        a2.click();
        document.body.removeChild(a2);
        URL.revokeObjectURL(url);
      }
    };
    const getTypeColor = (type) => {
      switch (type) {
        case "Stock":
          return { bg: "bg-blue-50", text: "text-blue-700", border: "border-blue-200" };
        case "Flow":
          return { bg: "bg-red-50", text: "text-red-700", border: "border-red-200" };
        case "Variable":
          return { bg: "bg-green-50", text: "text-green-700", border: "border-green-200" };
        case "Converter":
          return { bg: "bg-orange-50", text: "text-orange-700", border: "border-orange-200" };
        default:
          return { bg: "bg-gray-50", text: "text-gray-700", border: "border-gray-200" };
      }
    };
    const typeColors = getTypeColor(elementInfo.type);
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50 p-4", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "bg-white rounded-lg shadow-2xl w-full max-w-4xl max-h-[90vh] overflow-hidden flex flex-col swiss-modal-inner", children: [
      /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "px-6 py-4 border-b border-gray-200 flex justify-between items-start flex-shrink-0 swiss-header", children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex-1", children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("h2", { className: "text-xl font-bold text-gray-900", children: elementInfo.name }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { className: `inline-block mt-1.5 px-2.5 py-1 ${typeColors.bg} ${typeColors.text} text-xs font-medium rounded border ${typeColors.border}`, children: elementInfo.type })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
          "button",
          {
            onClick: onClose,
            className: "text-gray-400 hover:text-gray-600 transition-colors ml-4",
            children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) })
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex-1 overflow-y-auto p-6 space-y-5", children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("h3", { className: "text-sm font-semibold text-gray-900 mb-3", children: "Element Information" }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "grid grid-cols-2 gap-3 text-sm", children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { className: "text-gray-600", children: "Type" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("p", { className: "font-medium text-gray-900 mt-0.5", children: elementInfo.type })
            ] }),
            elementInfo.units && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { className: "text-gray-600", children: "Units" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("p", { className: "font-medium text-gray-900 mt-0.5", children: elementInfo.units })
            ] })
          ] }),
          elementInfo.doc && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "mt-3", children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { className: "text-gray-600 text-sm", children: "Description" }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("p", { className: "text-gray-900 mt-0.5", children: elementInfo.doc })
          ] })
        ] }),
        scenarioHistory.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("h3", { className: "text-sm font-semibold text-gray-900 mb-3", children: "Scenarios to Display" }),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "relative inline-block", children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
              "button",
              {
                onClick: () => setShowScenarioDropdown(!showScenarioDropdown),
                className: "flex items-center gap-2 px-3 py-2 border border-gray-300 rounded-lg text-sm bg-white hover:border-gray-400 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none transition-colors",
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("svg", { className: "w-4 h-4 text-gray-500", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" }) }),
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { className: "font-medium text-gray-700", children: localSelectedScenarios.size === 0 ? scenarioHistory[scenarioHistory.length - 1]?.scenarioName : localSelectedScenarios.size === 1 ? Array.from(localSelectedScenarios)[0] : `${localSelectedScenarios.size} scenarios` }),
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("svg", { className: `w-4 h-4 text-gray-400 transition-transform ${showScenarioDropdown ? "rotate-180" : ""}`, fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" }) })
                ]
              }
            ),
            showScenarioDropdown && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "absolute top-full left-0 mt-1 w-72 bg-white rounded-lg shadow-xl border border-gray-200 z-50 py-2", children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "px-3 py-1 text-xs font-medium text-gray-500 uppercase tracking-wide border-b border-gray-100 mb-1", children: "Select scenarios to display" }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "max-h-64 overflow-y-auto", children: scenarioHistory.map((scenario, idx) => {
                const isSelected = localSelectedScenarios.has(scenario.scenarioName);
                const isLatest = idx === scenarioHistory.length - 1;
                const colorIdx = Array.from(localSelectedScenarios).indexOf(scenario.scenarioName);
                const color2 = isSelected ? getScenarioColorByIndex(colorIdx) : void 0;
                return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
                  "label",
                  {
                    className: "flex items-center gap-3 px-3 py-2 hover:bg-gray-50 cursor-pointer swiss-checkbox-label",
                    children: [
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                        "input",
                        {
                          type: "checkbox",
                          checked: isSelected || localSelectedScenarios.size === 0 && isLatest,
                          onChange: () => {
                            const newSelected = new Set(localSelectedScenarios);
                            if (isSelected) {
                              newSelected.delete(scenario.scenarioName);
                            } else {
                              newSelected.add(scenario.scenarioName);
                            }
                            setLocalSelectedScenarios(newSelected);
                          },
                          className: "swiss-checkbox"
                        }
                      ),
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                        "div",
                        {
                          className: "w-3 h-3 rounded-full flex-shrink-0",
                          style: { backgroundColor: color2 || "#d1d5db" }
                        }
                      ),
                      /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "flex-1 min-w-0", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("p", { className: "text-sm font-medium text-gray-800 truncate", children: [
                        scenario.scenarioName,
                        isLatest && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { className: "ml-1 text-xs text-gray-400", children: "(latest)" })
                      ] }) })
                    ]
                  },
                  scenario.scenarioName
                );
              }) }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "border-t border-gray-100 px-3 py-2 flex gap-2", children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  "button",
                  {
                    onClick: () => setLocalSelectedScenarios(new Set(scenarioHistory.map((s2) => s2.scenarioName))),
                    className: "flex-1 text-xs py-1 swiss-btn swiss-btn--secondary",
                    children: "Select All"
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  "button",
                  {
                    onClick: () => setLocalSelectedScenarios(/* @__PURE__ */ new Set()),
                    className: "flex-1 text-xs py-1 swiss-btn swiss-btn--secondary",
                    children: "Latest Only"
                  }
                )
              ] })
            ] })
          ] })
        ] }),
        multiScenarioData && stats ? /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("h3", { className: "text-sm font-semibold text-gray-900 mb-3", children: [
              "Statistics",
              scenariosToDisplay.length === 1 && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("span", { className: "font-normal text-gray-500 ml-2", children: [
                "(",
                scenariosToDisplay[0].scenarioName,
                ")"
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "swiss-card", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("table", { className: "w-full text-sm", children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("thead", { children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("tr", { className: "border-b border-gray-200 bg-gray-50", children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("th", { className: "text-left py-2 px-3 text-gray-600 font-medium", children: "Metric" }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("th", { className: "text-right py-2 px-3 text-gray-600 font-medium", children: "Value" })
              ] }) }),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("tbody", { children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("tr", { className: "border-b border-gray-100", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("td", { className: "py-2 px-3 text-gray-700", children: "Minimum" }),
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("td", { className: "text-right py-2 px-3 text-gray-900 font-mono", children: stats.min.toFixed(4) })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("tr", { className: "border-b border-gray-100", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("td", { className: "py-2 px-3 text-gray-700", children: "Mean" }),
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("td", { className: "text-right py-2 px-3 text-gray-900 font-mono", children: stats.mean.toFixed(4) })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("tr", { className: "border-b border-gray-100", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("td", { className: "py-2 px-3 text-gray-700", children: "Maximum" }),
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("td", { className: "text-right py-2 px-3 text-gray-900 font-mono", children: stats.max.toFixed(4) })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("tr", { className: "border-b border-gray-100", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("td", { className: "py-2 px-3 text-gray-700", children: "Start Value" }),
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("td", { className: "text-right py-2 px-3 text-gray-900 font-mono", children: stats.start.toFixed(4) })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("tr", { className: "border-b border-gray-100", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("td", { className: "py-2 px-3 text-gray-700", children: "End Value" }),
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("td", { className: "text-right py-2 px-3 text-gray-900 font-mono", children: stats.end.toFixed(4) })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("tr", { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("td", { className: "py-2 px-3 text-gray-700", children: "Data Points" }),
                  /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("td", { className: "text-right py-2 px-3 text-gray-900 font-mono", children: stats.count })
                ] })
              ] })
            ] }) })
          ] }),
          graphData && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("h3", { className: "text-sm font-semibold text-gray-900 mb-3", children: "Time Series" }),
            graphData.scenarioPaths.length > 1 && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "flex flex-wrap gap-3 mb-3", children: graphData.scenarioPaths.map((sp) => /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex items-center gap-1.5 text-xs", children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                "div",
                {
                  className: "w-3 h-3 rounded-full",
                  style: { backgroundColor: sp.color }
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { className: "text-gray-700", children: sp.scenarioName })
            ] }, sp.scenarioName)) }),
            /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "swiss-card", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("svg", { width: graphWidth, height: graphHeight, className: "w-full", children: [
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                "rect",
                {
                  x: graphMargin.left,
                  y: graphMargin.top,
                  width: graphInnerWidth,
                  height: graphInnerHeight,
                  fill: "#f9fafb",
                  stroke: "#e5e7eb",
                  strokeWidth: 1
                }
              ),
              graphData.yTicks.map((tick) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                "line",
                {
                  x1: graphMargin.left,
                  y1: tick.y,
                  x2: graphMargin.left + graphInnerWidth,
                  y2: tick.y,
                  stroke: "#e5e7eb",
                  strokeWidth: 1
                },
                `grid-h-${tick.fraction}`
              )),
              graphData.xTicks.map((tick) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                "line",
                {
                  x1: tick.x,
                  y1: graphMargin.top,
                  x2: tick.x,
                  y2: graphMargin.top + graphInnerHeight,
                  stroke: "#e5e7eb",
                  strokeWidth: 1
                },
                `grid-v-${tick.fraction}`
              )),
              graphData.scenarioPaths.map((sp) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                "polyline",
                {
                  points: sp.points,
                  fill: "none",
                  stroke: sp.color,
                  strokeWidth: "2"
                },
                sp.scenarioName
              )),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                "line",
                {
                  x1: graphMargin.left,
                  y1: graphMargin.top,
                  x2: graphMargin.left,
                  y2: graphMargin.top + graphInnerHeight,
                  stroke: "#374151",
                  strokeWidth: 2
                }
              ),
              graphData.yTicks.map((tick) => /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("g", { children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  "line",
                  {
                    x1: graphMargin.left - 5,
                    y1: tick.y,
                    x2: graphMargin.left,
                    y2: tick.y,
                    stroke: "#374151",
                    strokeWidth: 2
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  "text",
                  {
                    x: graphMargin.left - 8,
                    y: tick.y,
                    textAnchor: "end",
                    alignmentBaseline: "middle",
                    fontSize: "11",
                    fill: "#4b5563",
                    fontFamily: "system-ui, -apple-system, sans-serif",
                    children: tick.value.toFixed(2)
                  }
                )
              ] }, `y-tick-${tick.fraction}`)),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                "text",
                {
                  x: -graphHeight / 2,
                  y: 15,
                  transform: `rotate(-90, 15, ${graphHeight / 2})`,
                  textAnchor: "middle",
                  fontSize: "12",
                  fontWeight: "600",
                  fill: "#1f2937",
                  fontFamily: "system-ui, -apple-system, sans-serif",
                  children: "Value"
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                "line",
                {
                  x1: graphMargin.left,
                  y1: graphMargin.top + graphInnerHeight,
                  x2: graphMargin.left + graphInnerWidth,
                  y2: graphMargin.top + graphInnerHeight,
                  stroke: "#374151",
                  strokeWidth: 2
                }
              ),
              graphData.xTicks.map((tick) => /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("g", { children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  "line",
                  {
                    x1: tick.x,
                    y1: graphMargin.top + graphInnerHeight,
                    x2: tick.x,
                    y2: graphMargin.top + graphInnerHeight + 5,
                    stroke: "#374151",
                    strokeWidth: 2
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                  "text",
                  {
                    x: tick.x,
                    y: graphMargin.top + graphInnerHeight + 18,
                    textAnchor: "middle",
                    fontSize: "11",
                    fill: "#4b5563",
                    fontFamily: "system-ui, -apple-system, sans-serif",
                    children: tick.value.toFixed(1)
                  }
                )
              ] }, `x-tick-${tick.fraction}`)),
              /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
                "text",
                {
                  x: graphMargin.left + graphInnerWidth / 2,
                  y: graphHeight - 10,
                  textAnchor: "middle",
                  fontSize: "12",
                  fontWeight: "600",
                  fill: "#1f2937",
                  fontFamily: "system-ui, -apple-system, sans-serif",
                  children: "Time"
                }
              )
            ] }) })
          ] })
        ] }) : /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "swiss-card", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("p", { className: "text-sm text-gray-700", children: "No simulation data available. Run a simulation to see time series data and statistics." }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "px-6 py-3 border-t border-gray-200 flex justify-between items-center flex-shrink-0 bg-gray-50", children: [
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { className: "text-xs text-gray-600", children: graphBounds && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("span", { children: [
          "Time range: ",
          graphBounds.minTime.toFixed(2),
          " - ",
          graphBounds.maxTime.toFixed(2),
          scenariosToDisplay[0]?.simulationResults?.timeUnits && ` ${scenariosToDisplay[0].simulationResults.timeUnits}`
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)("div", { className: "flex gap-2", children: [
          (multiScenarioData || getScenariosToDownload().length > 0) && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
            "button",
            {
              onClick: handleDownload,
              className: "px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white text-sm rounded font-medium transition-colors flex items-center gap-1.5",
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" }) }),
                getScenariosToDownload().length > 1 ? `Download ${getScenariosToDownload().length} Scenarios` : "Download Data"
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
            "button",
            {
              onClick: onClose,
              className: "px-3 py-1.5 bg-gray-200 hover:bg-gray-300 text-gray-900 text-sm rounded font-medium transition-colors",
              children: "Close"
            }
          )
        ] })
      ] })
    ] }) });
  }

  // components/ScenarioPanel.tsx
  var import_react9 = __toESM(require_react(), 1);

  // lib/buttonParser.ts
  var import_xml2js = __toESM(require_xml2js(), 1);
  function decodeHtmlEntities(text) {
    return text.replace(/&quot;/g, '"').replace(/&#xa;/g, "\n").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
  }
  function parseFunctionCode(functionCode) {
    const decoded = decodeHtmlEntities(functionCode);
    const setValues = [];
    let parentButton;
    let runsModel = false;
    const pressButtonMatch = decoded.match(/pressButton\s*\(\s*findName\s*\(\s*["']([^"']+)["']\s*\)\s*\)/);
    if (pressButtonMatch) {
      parentButton = pressButtonMatch[1];
    }
    const setValueRegex = /setValue\s*\(\s*findName\s*\(\s*["']([^"']+)["']\s*\)\s*,\s*([^)]+)\)/g;
    let match;
    while ((match = setValueRegex.exec(decoded)) !== null) {
      const variableName = match[1];
      let valueStr = match[2].trim();
      let value;
      if (/^-?\d+\.?\d*$/.test(valueStr)) {
        value = parseFloat(valueStr);
      } else {
        value = valueStr;
      }
      setValues.push({
        variableName,
        value
      });
    }
    runsModel = /runModel\s*\(\s*\)/.test(decoded);
    return { parentButton, setValues, runsModel };
  }
  function resolveButtonInheritance(buttons) {
    const buttonsByName = /* @__PURE__ */ new Map();
    buttons.forEach((b2) => buttonsByName.set(b2.name, b2));
    const resolved = /* @__PURE__ */ new Map();
    const resolving = /* @__PURE__ */ new Set();
    function resolveButton(buttonName) {
      if (resolved.has(buttonName)) {
        return resolved.get(buttonName);
      }
      const button = buttonsByName.get(buttonName);
      if (!button) {
        return [];
      }
      if (resolving.has(buttonName)) {
        return button.setValues;
      }
      resolving.add(buttonName);
      let allValues = [];
      if (button.parentButton) {
        const parentValues = resolveButton(button.parentButton);
        allValues = [...parentValues];
      }
      const valueMap = /* @__PURE__ */ new Map();
      allValues.forEach((v2) => valueMap.set(v2.variableName, v2));
      button.setValues.forEach((v2) => valueMap.set(v2.variableName, v2));
      const finalValues = Array.from(valueMap.values());
      resolved.set(buttonName, finalValues);
      resolving.delete(buttonName);
      return finalValues;
    }
    buttons.forEach((b2) => resolveButton(b2.name));
    return resolved;
  }
  async function parseButtonsFromXml(xmlContent) {
    const parsed = await (0, import_xml2js.parseStringPromise)(xmlContent, {
      explicitArray: true,
      mergeAttrs: false,
      attrkey: "$",
      charkey: "_"
    });
    const insightMaker = parsed.InsightMakerModel;
    if (!insightMaker?.root?.[0]) {
      throw new Error("Invalid InsightMaker file: missing root element");
    }
    const root2 = insightMaker.root[0];
    const buttons = [];
    const buttonsByName = /* @__PURE__ */ new Map();
    const buttonElements = root2.Button;
    if (!buttonElements) {
      return { buttons, buttonsByName };
    }
    for (const buttonEl of buttonElements) {
      const attrs = buttonEl.$;
      if (!attrs) continue;
      const id2 = attrs.id || "";
      const name = attrs.name || "";
      const note = attrs.Note || "";
      const functionCode = attrs.Function || "";
      const { parentButton, setValues, runsModel } = parseFunctionCode(functionCode);
      const mxCell = buttonEl.mxCell?.[0];
      let display;
      if (mxCell?.mxGeometry?.[0]?.$) {
        const geom = mxCell.mxGeometry[0].$;
        display = {
          coordinates: [parseFloat(geom.x) || 0, parseFloat(geom.y) || 0],
          size: [parseFloat(geom.width) || 120, parseFloat(geom.height) || 24]
        };
      }
      const button = {
        id: id2,
        name,
        note: note || void 0,
        parentButton,
        setValues,
        runsModel,
        display
      };
      buttons.push(button);
      buttonsByName.set(name, button);
    }
    return { buttons, buttonsByName };
  }
  function createButtonSummary(button) {
    const parts = [];
    if (button.parentButton) {
      parts.push(`Inherits from: "${button.parentButton}"`);
    }
    if (button.setValues.length > 0) {
      parts.push(`Sets ${button.setValues.length} variable(s)`);
    }
    if (button.runsModel) {
      parts.push("Runs simulation");
    }
    return parts.join(" | ") || "No operations";
  }

  // components/ScenarioPanel.tsx
  var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
  function ScenarioPanel({
    buttons,
    onRunScenario,
    isRunning,
    currentScenario,
    scenarioHistory,
    cachedScenarios = /* @__PURE__ */ new Set()
  }) {
    const [expandedButton, setExpandedButton] = (0, import_react9.useState)(null);
    const [showVariables, setShowVariables] = (0, import_react9.useState)(false);
    const resolvedValues = (0, import_react9.useMemo)(() => {
      return resolveButtonInheritance(buttons);
    }, [buttons]);
    const allVariables = (0, import_react9.useMemo)(() => {
      const vars = /* @__PURE__ */ new Set();
      resolvedValues.forEach((values) => {
        values.forEach((v2) => vars.add(v2.variableName));
      });
      return Array.from(vars).sort();
    }, [resolvedValues]);
    const scenarioButtons = (0, import_react9.useMemo)(() => {
      return buttons.filter((b2) => b2.runsModel);
    }, [buttons]);
    const baseButtons = (0, import_react9.useMemo)(() => {
      return buttons.filter((b2) => !b2.runsModel);
    }, [buttons]);
    const alreadyRunScenarios = (0, import_react9.useMemo)(() => {
      return new Set(scenarioHistory.map((s2) => s2.scenarioName));
    }, [scenarioHistory]);
    const handleRunScenario = async (button) => {
      const values = resolvedValues.get(button.name) || button.setValues;
      await onRunScenario(values, button.name);
    };
    const toggleExpanded = (buttonName) => {
      setExpandedButton(expandedButton === buttonName ? null : buttonName);
    };
    const comparisonData = (0, import_react9.useMemo)(() => {
      const data = [];
      allVariables.forEach((variable) => {
        const valuesByScenario = /* @__PURE__ */ new Map();
        scenarioButtons.forEach((button) => {
          const resolved = resolvedValues.get(button.name) || [];
          const match = resolved.find((v2) => v2.variableName === variable);
          if (match) {
            valuesByScenario.set(button.name, match.value);
          }
        });
        if (valuesByScenario.size > 0) {
          data.push({ variable, values: valuesByScenario });
        }
      });
      return data;
    }, [allVariables, scenarioButtons, resolvedValues]);
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "h-full flex flex-col bg-white swiss-card", children: [
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "p-4 border-b border-gray-200 bg-gradient-to-r from-indigo-50 to-purple-50 swiss-header", children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("h2", { className: "text-lg font-semibold text-gray-800 flex items-center gap-2", children: [
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("svg", { className: "w-5 h-5 text-indigo-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" }) }),
          "Scenarios (",
          scenarioButtons.length,
          ")"
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("p", { className: "text-sm text-gray-500 mt-1", children: "Run pre-configured scenarios from the model" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "flex-1 overflow-y-auto", children: [
        baseButtons.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "p-3 border-b border-gray-100", children: [
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("h3", { className: "text-xs font-medium text-gray-500 uppercase tracking-wide mb-2", children: "Base Parameters" }),
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "space-y-1", children: baseButtons.map((button) => /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
            "div",
            {
              className: "text-sm text-gray-600 bg-gray-50 px-3 py-2 rounded-md",
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "font-medium", children: button.name }),
                /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("span", { className: "text-gray-400 ml-2", children: [
                  "(",
                  button.setValues.length,
                  " params)"
                ] })
              ]
            },
            button.id
          )) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "p-3", children: [
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("h3", { className: "text-xs font-medium text-gray-500 uppercase tracking-wide mb-2", children: "Run Scenarios" }),
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "space-y-2", children: scenarioButtons.map((button) => {
            const isExpanded = expandedButton === button.name;
            const isCurrentlyRunning = isRunning && currentScenario === button.name;
            const hasAlreadyRun = alreadyRunScenarios.has(button.name);
            const isCached = cachedScenarios.has(button.name);
            const resolved = resolvedValues.get(button.name) || [];
            const canLoadFromCache = isCached && !hasAlreadyRun;
            return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
              "div",
              {
                className: `border rounded-lg overflow-hidden transition-all ${isCurrentlyRunning ? "border-indigo-400 bg-indigo-50" : hasAlreadyRun ? "border-green-200 bg-green-50" : canLoadFromCache ? "border-blue-200 bg-blue-50" : "border-gray-200 bg-white hover:border-gray-300"}`,
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "flex items-center gap-2 p-3", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                      "button",
                      {
                        onClick: () => handleRunScenario(button),
                        disabled: isRunning || hasAlreadyRun,
                        title: hasAlreadyRun ? "This scenario has already been run" : canLoadFromCache ? "Load from cache (instant)" : void 0,
                        className: `flex-shrink-0 px-3 py-1.5 rounded-md text-sm font-medium transition-all swiss-btn ${isRunning || hasAlreadyRun ? " swiss-btn--secondary" : ""} ${canLoadFromCache ? " swiss-btn--accent" : " swiss-btn--accent"}`,
                        children: isCurrentlyRunning ? /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("span", { className: "flex items-center gap-1.5", children: [
                          /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("svg", { className: "w-4 h-4 animate-spin", fill: "none", viewBox: "0 0 24 24", children: [
                            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }),
                            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })
                          ] }),
                          "Running"
                        ] }) : hasAlreadyRun ? /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("span", { className: "flex items-center gap-1.5", children: [
                          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M5 13l4 4L19 7" }) }),
                          "Done"
                        ] }) : canLoadFromCache ? /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("span", { className: "flex items-center gap-1.5", children: [
                          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" }) }),
                          "Load"
                        ] }) : "Run"
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "flex-1 min-w-0", children: [
                      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "flex items-center gap-1.5", children: [
                        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("p", { className: `font-medium truncate ${hasAlreadyRun ? "text-green-700" : canLoadFromCache ? "text-blue-700" : "text-gray-800"}`, children: button.name }),
                        canLoadFromCache && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "flex-shrink-0 px-1.5 py-0.5 text-[10px] font-medium bg-blue-100 text-blue-600 rounded", children: "CACHED" })
                      ] }),
                      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("p", { className: "text-xs text-gray-500", children: createButtonSummary(button) })
                    ] }),
                    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                      "button",
                      {
                        onClick: () => toggleExpanded(button.name),
                        className: "flex-shrink-0 p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded",
                        children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                          "svg",
                          {
                            className: `w-4 h-4 transition-transform ${isExpanded ? "rotate-180" : ""}`,
                            fill: "none",
                            stroke: "currentColor",
                            viewBox: "0 0 24 24",
                            children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" })
                          }
                        )
                      }
                    )
                  ] }),
                  isExpanded && /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "border-t border-gray-100 bg-gray-50 p-3", children: [
                    button.parentButton && /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("p", { className: "text-xs text-indigo-600 mb-2", children: [
                      "Inherits from: ",
                      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "font-medium", children: button.parentButton })
                    ] }),
                    /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("p", { className: "text-xs font-medium text-gray-500 mb-2", children: [
                      "Variables (",
                      resolved.length,
                      "):"
                    ] }),
                    /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "max-h-48 overflow-y-auto", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("table", { className: "w-full text-xs", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("tbody", { children: resolved.map((sv, i2) => /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("tr", { className: i2 % 2 === 0 ? "bg-white" : "bg-gray-50", children: [
                      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("td", { className: "py-1 px-2 text-gray-600 truncate max-w-[150px]", title: sv.variableName, children: sv.variableName }),
                      /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("td", { className: "py-1 px-2 text-right font-mono text-gray-800", children: typeof sv.value === "number" ? sv.value.toFixed(4).replace(/\.?0+$/, "") : sv.value })
                    ] }, i2)) }) }) })
                  ] })
                ]
              },
              button.id
            );
          }) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "p-3 border-t border-gray-100", children: [
          /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
            "button",
            {
              onClick: () => setShowVariables(!showVariables),
              className: "w-full flex items-center justify-between text-sm text-gray-600 hover:text-gray-800 py-2",
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "font-medium", children: "Compare Variables Across Scenarios" }),
                /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
                  "svg",
                  {
                    className: `w-4 h-4 transition-transform ${showVariables ? "rotate-180" : ""}`,
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24",
                    children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" })
                  }
                )
              ]
            }
          ),
          showVariables && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "mt-2 max-h-64 overflow-auto border rounded-lg", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("table", { className: "w-full text-xs", children: [
            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("thead", { className: "bg-gray-100 sticky top-0", children: /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("tr", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("th", { className: "py-2 px-2 text-left text-gray-600 font-medium", children: "Variable" }),
              scenarioButtons.map((b2) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("th", { className: "py-2 px-2 text-right text-gray-600 font-medium whitespace-nowrap", children: b2.name.length > 15 ? b2.name.slice(0, 15) + "..." : b2.name }, b2.id))
            ] }) }),
            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("tbody", { children: comparisonData.map((row2, i2) => /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("tr", { className: i2 % 2 === 0 ? "bg-white" : "bg-gray-50", children: [
              /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("td", { className: "py-1 px-2 text-gray-700 truncate max-w-[120px]", title: row2.variable, children: row2.variable }),
              scenarioButtons.map((b2) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("td", { className: "py-1 px-2 text-right font-mono text-gray-600", children: row2.values.has(b2.name) ? typeof row2.values.get(b2.name) === "number" ? row2.values.get(b2.name).toFixed(4).replace(/\.?0+$/, "") : row2.values.get(b2.name) : /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "text-gray-300", children: "-" }) }, b2.id))
            ] }, row2.variable)) })
          ] }) })
        ] })
      ] }),
      scenarioHistory.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "border-t border-gray-200 p-3 bg-gray-50", children: [
        /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("h3", { className: "text-xs font-medium text-gray-500 uppercase tracking-wide mb-2", children: [
          "Recent Runs (",
          scenarioHistory.length,
          ")"
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "space-y-1 max-h-24 overflow-y-auto", children: scenarioHistory.slice(-5).reverse().map((result, i2) => /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("div", { className: "flex items-center justify-between text-xs text-gray-600 bg-white px-2 py-1 rounded", children: [
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "font-medium", children: result.scenarioName }),
          /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("span", { className: "text-gray-400", children: result.timestamp.toLocaleTimeString() })
        ] }, i2)) })
      ] })
    ] });
  }

  // components/visualizer/VisualizerHeader.tsx
  var import_react11 = __toESM(require_react(), 1);

  // components/ClearCacheButton.tsx
  var import_react10 = __toESM(require_react(), 1);

  // lib/simulationCache.ts
  var DB_NAME = "InsightMakerSimulationCache";
  var DB_VERSION = 2;
  var STORE_NAME = "simulations";
  var DB_OPEN_TIMEOUT = 15e3;
  var dbPromise = null;
  var dbInitialized = false;
  var cacheDisabled = false;
  function hashString(str) {
    let hash = 0;
    for (let i2 = 0; i2 < str.length; i2++) {
      const char = str.charCodeAt(i2);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(36);
  }
  function generateFingerprint(modelXml, scenarioName, parameters) {
    const modelHash = hashString(modelXml.slice(0, 1e4) + modelXml.length.toString());
    const sortedParams = [...parameters].sort((a2, b2) => a2.variableName.localeCompare(b2.variableName));
    const paramString = sortedParams.map((p2) => `${p2.variableName}=${p2.value}`).join("|");
    const paramHash = hashString(paramString);
    return `${modelHash}_${scenarioName}_${paramHash}`;
  }
  function generateModelHash(modelXml) {
    return hashString(modelXml.slice(0, 1e4) + modelXml.length.toString());
  }
  function openDatabase() {
    if (cacheDisabled) {
      return Promise.reject(new Error("Cache disabled due to previous failures"));
    }
    if (dbPromise && dbInitialized) {
      return dbPromise;
    }
    if (typeof indexedDB === "undefined") {
      cacheDisabled = true;
      return Promise.reject(new Error("IndexedDB not available"));
    }
    dbPromise = new Promise((resolve, reject) => {
      try {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        const timeout2 = setTimeout(() => {
          cacheDisabled = true;
          dbInitialized = false;
          dbPromise = null;
          reject(new Error("IndexedDB timeout"));
        }, DB_OPEN_TIMEOUT);
        request.onerror = () => {
          clearTimeout(timeout2);
          cacheDisabled = true;
          dbInitialized = false;
          dbPromise = null;
          reject(request.error);
        };
        request.onsuccess = () => {
          clearTimeout(timeout2);
          try {
            const db = request.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
              throw new Error(`Object store '${STORE_NAME}' not found`);
            }
            dbInitialized = true;
            resolve(db);
          } catch (error) {
            cacheDisabled = true;
            dbInitialized = false;
            dbPromise = null;
            reject(error);
          }
        };
        request.onupgradeneeded = (event) => {
          try {
            const db = event.target.result;
            while (db.objectStoreNames.length > 0) {
              const storeName = db.objectStoreNames[0];
              db.deleteObjectStore(storeName);
            }
            const store = db.createObjectStore(STORE_NAME, { keyPath: "fingerprint" });
            store.createIndex("modelHash", "modelHash", { unique: false });
            store.createIndex("scenarioName", "scenarioName", { unique: false });
            store.createIndex("timestamp", "timestamp", { unique: false });
          } catch (error) {
            cacheDisabled = true;
          }
        };
      } catch (error) {
        cacheDisabled = true;
        dbInitialized = false;
        dbPromise = null;
        reject(error);
      }
    });
    return dbPromise;
  }
  async function cacheSimulationResult(fingerprint, modelHash, scenarioName, parameters, times, series, timeUnits) {
    try {
      if (cacheDisabled) return;
      const db = await openDatabase();
      const result = {
        fingerprint,
        modelHash,
        scenarioName,
        parameters,
        timestamp: /* @__PURE__ */ new Date(),
        times,
        series,
        timeUnits
      };
      return new Promise((resolve) => {
        try {
          const transaction = db.transaction([STORE_NAME], "readwrite");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.put(result);
          request.onsuccess = () => {
            resolve();
          };
          request.onerror = () => {
            resolve();
          };
          transaction.onerror = () => {
            resolve();
          };
        } catch (error) {
          resolve();
        }
      });
    } catch (error) {
    }
  }
  async function getCachedResult(fingerprint) {
    try {
      if (cacheDisabled) return null;
      const db = await openDatabase();
      return new Promise((resolve) => {
        try {
          const transaction = db.transaction([STORE_NAME], "readonly");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.get(fingerprint);
          request.onsuccess = () => {
            if (request.result) {
              resolve(request.result);
            } else {
              resolve(null);
            }
          };
          request.onerror = () => {
            resolve(null);
          };
          transaction.onerror = () => {
            resolve(null);
          };
        } catch (error) {
          resolve(null);
        }
      });
    } catch (error) {
      return null;
    }
  }
  async function getCachedResultsForModel(modelHash) {
    try {
      if (cacheDisabled) return [];
      const db = await openDatabase();
      return new Promise((resolve) => {
        try {
          const transaction = db.transaction([STORE_NAME], "readonly");
          const store = transaction.objectStore(STORE_NAME);
          const index = store.index("modelHash");
          const request = index.getAll(modelHash);
          request.onsuccess = () => {
            resolve(request.result || []);
          };
          request.onerror = () => {
            resolve([]);
          };
          transaction.onerror = () => {
            resolve([]);
          };
        } catch (error) {
          resolve([]);
        }
      });
    } catch (error) {
      return [];
    }
  }
  async function getCachedScenarioNames(modelHash) {
    const results = await getCachedResultsForModel(modelHash);
    return new Set(results.map((r2) => r2.scenarioName));
  }
  async function clearAllCache() {
    try {
      if (cacheDisabled) return;
      const db = await openDatabase();
      return new Promise((resolve) => {
        try {
          const transaction = db.transaction([STORE_NAME], "readwrite");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.clear();
          request.onsuccess = () => {
            resolve();
          };
          request.onerror = () => {
            resolve();
          };
          transaction.onerror = () => {
            resolve();
          };
        } catch (error) {
          resolve();
        }
      });
    } catch (error) {
    }
  }
  async function getCacheStats() {
    try {
      if (cacheDisabled) return { count: 0 };
      const db = await openDatabase();
      return new Promise((resolve) => {
        try {
          const transaction = db.transaction([STORE_NAME], "readonly");
          const store = transaction.objectStore(STORE_NAME);
          const allRequest = store.getAll();
          allRequest.onsuccess = () => {
            try {
              const results = allRequest.result;
              if (results.length === 0) {
                resolve({ count: 0 });
                return;
              }
              const timestamps = results.map((r2) => new Date(r2.timestamp).getTime());
              resolve({
                count: results.length,
                oldestTimestamp: new Date(Math.min(...timestamps)),
                newestTimestamp: new Date(Math.max(...timestamps))
              });
            } catch (error) {
              resolve({ count: 0 });
            }
          };
          allRequest.onerror = () => {
            resolve({ count: 0 });
          };
          transaction.onerror = () => {
            resolve({ count: 0 });
          };
        } catch (error) {
          resolve({ count: 0 });
        }
      });
    } catch (error) {
      return { count: 0 };
    }
  }

  // components/ClearCacheButton.tsx
  var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
  function ClearCacheButton({ onCleared }) {
    const [isClearing, setIsClearing] = (0, import_react10.useState)(false);
    const [showConfirm, setShowConfirm] = (0, import_react10.useState)(false);
    const [cacheStats, setCacheStats] = (0, import_react10.useState)(null);
    const handleShowConfirm = async () => {
      const stats = await getCacheStats();
      setCacheStats(stats);
      setShowConfirm(true);
    };
    const handleClear = async () => {
      setIsClearing(true);
      try {
        await clearAllCache();
        setCacheStats({ count: 0 });
        setShowConfirm(false);
        onCleared?.();
      } catch (error) {
      } finally {
        setIsClearing(false);
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        "button",
        {
          onClick: handleShowConfirm,
          disabled: isClearing,
          title: "Clear all cached simulation results",
          className: "px-3 py-2 text-sm text-gray-600 hover:text-gray-900 border border-gray-300 rounded-lg bg-white hover:bg-gray-50 transition-colors disabled:opacity-50 disabled:cursor-not-allowed swiss-btn swiss-btn--secondary",
          children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" }) }),
            /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("span", { children: "Clear Cache" })
          ] })
        }
      ),
      showConfirm && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: "fixed inset-0 bg-black/50 z-50 flex items-center justify-center", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "bg-white rounded-lg shadow-xl border border-gray-200 max-w-sm p-6", children: [
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("h3", { className: "text-lg font-semibold text-gray-900 mb-2", children: "Clear Cache?" }),
        /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("p", { className: "text-gray-600 mb-4", children: cacheStats && cacheStats.count > 0 ? `This will delete ${cacheStats.count} cached simulation result${cacheStats.count !== 1 ? "s" : ""}. You can re-run simulations to rebuild the cache.` : "The cache is currently empty." }),
        /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "flex gap-3 justify-end", children: [
          /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
            "button",
            {
              onClick: () => setShowConfirm(false),
              disabled: isClearing,
              className: "px-4 py-2 text-gray-700 border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors disabled:opacity-50 swiss-btn swiss-btn--secondary",
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
            "button",
            {
              onClick: handleClear,
              disabled: isClearing,
              className: "px-4 py-2 text-white bg-red-600 hover:bg-red-700 rounded-lg transition-colors disabled:opacity-50 font-medium swiss-btn swiss-btn--danger",
              children: isClearing ? "Clearing..." : "Clear Cache"
            }
          )
        ] })
      ] }) })
    ] });
  }

  // components/SimulationButton.tsx
  var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
  function SimulationButton({ modelData, onRunSimulation, running }) {
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
      "button",
      {
        onClick: onRunSimulation,
        disabled: !modelData || running,
        className: "px-5 py-2.5 text-white font-medium rounded-lg disabled:cursor-not-allowed transition-all shadow-md hover:shadow-lg disabled:shadow-none flex items-center gap-2 swiss-btn swiss-btn--accent",
        children: running ? /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("svg", { className: "animate-spin h-5 w-5", viewBox: "0 0 24 24", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4", fill: "none" }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })
          ] }),
          "Running Simulation..."
        ] }) : /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M21 12a9 9 0 11-18 0 9 9 0 0118 0z" })
          ] }),
          "Run Simulation"
        ] })
      }
    );
  }

  // components/visualizer/VisualizerHeader.tsx
  var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
  function VisualizerHeader({
    modelData,
    elementCount,
    simulationResults,
    hasRunSimulation,
    isRunningSimulation,
    scenarioHistory,
    selectedDisplayScenarios,
    setSelectedDisplayScenarios,
    showScenarioDropdown,
    setShowScenarioDropdown,
    onShowResultsModal,
    onRunSimulation
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "bg-white shadow-md border-b border-gray-200 flex-shrink-0 swiss-header", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "max-w-[98%] mx-auto px-6 py-4", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex justify-between items-center mb-3", children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("h1", { className: "text-3xl font-bold text-gray-900 tracking-tight", children: modelData?.name || "InsightMaker Model Visualizer" }),
        modelData && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("p", { className: "text-sm text-gray-500 mt-1", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("span", { className: "inline-flex items-center gap-1", children: [
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
            "path",
            {
              strokeLinecap: "round",
              strokeLinejoin: "round",
              strokeWidth: 2,
              d: "M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"
            }
          ) }),
          elementCount,
          " elements loaded"
        ] }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "flex gap-3 items-center", children: [
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(ClearCacheButton, {}),
        scenarioHistory.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
          ScenarioDisplayDropdown,
          {
            scenarioHistory,
            selectedDisplayScenarios,
            setSelectedDisplayScenarios,
            showScenarioDropdown,
            setShowScenarioDropdown
          }
        ),
        hasRunSimulation && simulationResults && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
          "button",
          {
            onClick: onShowResultsModal,
            className: "px-5 py-2.5 text-white rounded-lg font-medium transition-all shadow-md hover:shadow-lg flex items-center gap-2 swiss-btn swiss-btn--accent",
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                "path",
                {
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  strokeWidth: 2,
                  d: "M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"
                }
              ) }),
              "View Results"
            ]
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(SimulationButton, { modelData, onRunSimulation, running: isRunningSimulation })
      ] })
    ] }) }) });
  }
  function ScenarioDisplayDropdown({
    scenarioHistory,
    selectedDisplayScenarios,
    setSelectedDisplayScenarios,
    showScenarioDropdown,
    setShowScenarioDropdown
  }) {
    const displayLabel = selectedDisplayScenarios.size === 0 ? scenarioHistory[scenarioHistory.length - 1]?.scenarioName : selectedDisplayScenarios.size === 1 ? Array.from(selectedDisplayScenarios)[0] : `${selectedDisplayScenarios.size} scenarios`;
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "relative", children: [
      /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
        "button",
        {
          onClick: () => setShowScenarioDropdown(!showScenarioDropdown),
          className: "flex items-center gap-2 px-3 py-2 border border-gray-300 rounded-lg text-sm bg-white hover:border-gray-400 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 outline-none transition-colors swiss-btn swiss-btn--secondary",
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("svg", { className: "w-4 h-4 text-gray-500", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
              "path",
              {
                strokeLinecap: "round",
                strokeLinejoin: "round",
                strokeWidth: 2,
                d: "M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("span", { className: "font-medium text-gray-700", children: [
              "Display: ",
              displayLabel
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
              "svg",
              {
                className: `w-4 h-4 text-gray-400 transition-transform ${showScenarioDropdown ? "rotate-180" : ""}`,
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24",
                children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" })
              }
            )
          ]
        }
      ),
      showScenarioDropdown && /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "absolute top-full left-0 mt-1 w-72 bg-white rounded-lg shadow-xl border border-gray-200 z-50 py-2", children: [
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "px-3 py-1 text-xs font-medium text-gray-500 uppercase tracking-wide border-b border-gray-100 mb-1", children: "Select scenarios to display" }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "max-h-64 overflow-y-auto", children: scenarioHistory.map((scenario, idx) => {
          const isSelected = selectedDisplayScenarios.has(scenario.scenarioName);
          const isLatest = idx === scenarioHistory.length - 1;
          return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
            "label",
            {
              className: "flex items-center gap-3 px-3 py-2 hover:bg-gray-50 cursor-pointer",
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
                  "input",
                  {
                    type: "checkbox",
                    checked: isSelected || selectedDisplayScenarios.size === 0 && isLatest,
                    onChange: () => {
                      const newSelected = new Set(selectedDisplayScenarios);
                      if (isSelected) {
                        newSelected.delete(scenario.scenarioName);
                      } else {
                        newSelected.add(scenario.scenarioName);
                      }
                      setSelectedDisplayScenarios(newSelected);
                    },
                    className: "swiss-checkbox"
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "flex-1 min-w-0", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("p", { className: "text-sm font-medium text-gray-800 truncate", children: [
                  scenario.scenarioName,
                  isLatest && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { className: "ml-1 text-xs text-gray-400", children: "(latest)" })
                ] }) })
              ]
            },
            scenario.scenarioName
          );
        }) }),
        /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("div", { className: "border-t border-gray-100 px-3 py-2 flex gap-2", children: [
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
            "button",
            {
              onClick: () => setSelectedDisplayScenarios(new Set(scenarioHistory.map((s2) => s2.scenarioName))),
              className: "flex-1 text-xs py-1 swiss-btn swiss-btn--secondary",
              children: "Select All"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
            "button",
            {
              onClick: () => setSelectedDisplayScenarios(/* @__PURE__ */ new Set()),
              className: "flex-1 text-xs py-1 swiss-btn swiss-btn--secondary",
              children: "Latest Only"
            }
          )
        ] })
      ] })
    ] });
  }
  var VisualizerHeader_default = (0, import_react11.memo)(VisualizerHeader);

  // components/visualizer/VisualizerCanvas.tsx
  var import_react18 = __toESM(require_react(), 1);

  // components/nodes/StockNode.tsx
  var import_react12 = __toESM(require_react(), 1);

  // lib/nodeTypes.ts
  var DEFAULT_COLORS2 = {
    STOCK: { border: "#3b82f6", fill: "#dbeafe" },
    // Blue
    FLOW: { border: "#ef4444", fill: "#fee2e2" },
    // Red
    VARIABLE: { border: "#10b981", fill: "#dcfce7" },
    // Green
    CONVERTER: { border: "#f59e0b", fill: "#fed7aa" },
    // Orange
    FOLDER: { border: "#8b5cf6", fill: "#ede9fe" },
    // Purple
    GHOST: { border: "#9ca3af", fill: "#f3f4f6" },
    // Gray (transparent)
    LINK: { border: "#64748b", fill: "#f1f5f9" },
    // Slate
    MISSING: { border: "#999999", fill: "#e5e5e5" }
    // Gray
  };
  var NODE_DIMENSIONS = {
    STOCK: { width: 120, height: 70 },
    FLOW: { width: 100, height: 50 },
    VARIABLE: { width: 100, height: 100 },
    CONVERTER: { width: 100, height: 100 },
    FOLDER: { width: 300, height: 200 },
    GHOST: { width: 100, height: 100 },
    LINK: { width: 50, height: 30 },
    MISSING: { width: 80, height: 50 }
  };
  var MIN_NODE_DIMENSIONS = {
    STOCK: { width: 60, height: 40 },
    // Minimum readable stock
    FLOW: { width: 50, height: 30 },
    VARIABLE: { width: 50, height: 50 },
    // Minimum readable circle
    CONVERTER: { width: 50, height: 50 },
    // Minimum readable diamond
    FOLDER: { width: 100, height: 60 },
    GHOST: { width: 50, height: 50 },
    // Minimum readable circle
    LINK: { width: 30, height: 20 },
    MISSING: { width: 40, height: 30 }
  };
  function calculateMinNodeSize(_label, elementType, _fontSize = 11, _hasMiniGraph = true) {
    const minDims = MIN_NODE_DIMENSIONS[elementType] || MIN_NODE_DIMENSIONS.VARIABLE;
    return { width: minDims.width, height: minDims.height };
  }
  function ensureMinNodeSize(requestedWidth, requestedHeight, label, elementType, fontSize = 11) {
    const minSize = calculateMinNodeSize(label, elementType, fontSize, true);
    const defaultDims = NODE_DIMENSIONS[elementType] || NODE_DIMENSIONS.VARIABLE;
    const width = requestedWidth || defaultDims.width;
    const height2 = requestedHeight || defaultDims.height;
    return {
      width: Math.max(width, minSize.width),
      height: Math.max(height2, minSize.height)
    };
  }
  function isGhostNode(style2) {
    if (!style2) return false;
    return style2.opacity !== void 0 && style2.opacity < 100 && style2.opacity > 0;
  }
  function generateMiniGraph(elementId, simulationResults, modelData) {
    if (!simulationResults || !modelData) return null;
    try {
      const primitives2 = modelData.find((p2) => p2.name === elementId);
      const primitive = primitives2 && primitives2.length > 0 ? primitives2[0] : null;
      if (!primitive) return null;
      try {
        const values = simulationResults.series(primitive);
        if (!values || values.length === 0) return null;
        const min = Math.min(...values);
        const max = Math.max(...values);
        const range = max - min;
        if (range < 1e-4) {
          return {
            path: "",
            isConstant: true,
            value: values[0],
            unit: primitive.units || ""
          };
        }
        const width = 80;
        const height2 = 30;
        const points = values.map((val, idx) => {
          const x2 = idx / (values.length - 1) * width;
          const y2 = height2 - (val - min) / range * height2;
          return `${x2},${y2}`;
        }).join(" ");
        return { path: points, isConstant: false };
      } catch {
        return null;
      }
    } catch (error) {
      return null;
    }
  }
  function generateMultiScenarioMiniGraph(elementId, scenarioResults, modelData) {
    if (!scenarioResults || scenarioResults.length === 0 || !modelData) return null;
    try {
      const primitives2 = modelData.find((p2) => p2.name === elementId);
      const primitive = primitives2 && primitives2.length > 0 ? primitives2[0] : null;
      if (!primitive) return null;
      const allSeriesData = [];
      let globalMin = Infinity;
      let globalMax = -Infinity;
      scenarioResults.forEach((scenario) => {
        try {
          const values = scenario.results.series(primitive);
          if (values && values.length > 0) {
            const min = Math.min(...values);
            const max = Math.max(...values);
            globalMin = Math.min(globalMin, min);
            globalMax = Math.max(globalMax, max);
            allSeriesData.push({
              values,
              scenarioName: scenario.scenarioName,
              color: getScenarioColor(scenario.scenarioName)
            });
          }
        } catch {
        }
      });
      if (allSeriesData.length === 0) return null;
      const range = globalMax - globalMin;
      if (range < 1e-4) {
        return {
          paths: [],
          isConstant: true,
          values: allSeriesData.map((s2) => ({
            value: s2.values[0],
            scenarioName: s2.scenarioName,
            color: s2.color
          })),
          unit: primitive.units || ""
        };
      }
      const width = 80;
      const height2 = 30;
      const paths = allSeriesData.map(({ values, scenarioName, color: color2 }) => {
        const points = values.map((val, idx) => {
          const x2 = idx / (values.length - 1) * width;
          const y2 = height2 - (val - globalMin) / range * height2;
          return `${x2},${y2}`;
        }).join(" ");
        return { path: points, color: color2, scenarioName };
      });
      return { paths, isConstant: false };
    } catch (error) {
      return null;
    }
  }
  var FOLDER_COLORS = [
    "#8b5cf6",
    // Purple
    "#3b82f6",
    // Blue
    "#06b6d4",
    // Cyan
    "#10b981",
    // Emerald
    "#84cc16",
    // Lime
    "#eab308",
    // Yellow
    "#f97316",
    // Orange
    "#ef4444",
    // Red
    "#ec4899",
    // Pink
    "#a855f7",
    // Violet
    "#6366f1",
    // Indigo
    "#14b8a6",
    // Teal
    "#22c55e",
    // Green
    "#facc15",
    // Amber
    "#fb923c",
    // Light Orange
    "#f43f5e",
    // Rose
    "#d946ef",
    // Fuchsia
    "#0ea5e9",
    // Sky
    "#2dd4bf",
    // Aqua
    "#a3e635"
    // Yellow-green
  ];
  function getFolderColor(index) {
    return FOLDER_COLORS[index % FOLDER_COLORS.length];
  }

  // components/nodes/StockNode.tsx
  var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
  function StockNode({ data, id: id2 }) {
    const {
      label,
      simulationResults,
      modelData,
      scenarioResults,
      highlighted,
      style: style2,
      borderColor,
      fillColor,
      fontSize = 11,
      fontColor = "#1f2937",
      opacity = 100,
      width,
      height: height2
    } = data;
    const multiScenarioGraph = scenarioResults && scenarioResults.length > 0 ? generateMultiScenarioMiniGraph(id2, scenarioResults, modelData) : null;
    const singleGraph = !multiScenarioGraph ? generateMiniGraph(id2, simulationResults, modelData) : null;
    const hasData = !!multiScenarioGraph || !!singleGraph;
    let { width: nodeWidth, height: nodeHeight } = ensureMinNodeSize(
      width,
      height2,
      label,
      "STOCK",
      fontSize
    );
    if (hasData) {
      nodeWidth = Math.max(nodeWidth, 80);
      nodeHeight = Math.max(nodeHeight, 60);
    }
    const minDim = Math.min(nodeWidth, nodeHeight);
    const scaledFontSize = Math.max(8, Math.min(fontSize, minDim / 5));
    const miniGraphWidth = Math.min(nodeWidth * 0.85, 100);
    const miniGraphHeight = Math.min(minDim * 0.45, 28);
    const labelMaxWidth = Math.max(40, nodeWidth - 24);
    const defaults = DEFAULT_COLORS2.STOCK;
    const finalBorderColor = highlighted ? "#ec4899" : borderColor || style2?.strokeColor || defaults.border;
    const finalFillColor = fillColor || style2?.fillColor || defaults.fill;
    const finalOpacity = (style2?.opacity ?? opacity) / 100;
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(
      "div",
      {
        style: {
          background: finalFillColor,
          border: `3px solid ${finalBorderColor}`,
          borderRadius: "4px",
          padding: "6px",
          width: `${nodeWidth}px`,
          height: `${nodeHeight}px`,
          display: "flex",
          flexDirection: "column",
          justifyContent: "space-between",
          boxShadow: highlighted ? "0 0 16px rgba(236, 72, 153, 0.7)" : "0 2px 4px rgba(0,0,0,0.15)",
          opacity: finalOpacity,
          boxSizing: "border-box",
          overflow: "hidden"
        },
        className: "swiss-card",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Handle$1, { type: "target", position: Position.Top, style: { background: finalBorderColor } }),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                top: "4px",
                right: "4px",
                width: "14px",
                height: "14px",
                opacity: 0.5
              },
              children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("svg", { viewBox: "0 0 24 24", fill: finalBorderColor, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("rect", { x: "3", y: "6", width: "18", height: "12", rx: "1", strokeWidth: "2", stroke: finalBorderColor, fill: "none" }) })
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
            "div",
            {
              style: {
                fontSize: `${scaledFontSize}px`,
                fontWeight: "600",
                color: fontColor,
                textAlign: "center",
                overflow: "hidden",
                maxWidth: `${labelMaxWidth}px`,
                lineHeight: "1.2",
                wordWrap: "break-word",
                overflowWrap: "break-word",
                display: "-webkit-box",
                WebkitLineClamp: 3,
                WebkitBoxOrient: "vertical"
              },
              title: label,
              children: label
            }
          ),
          multiScenarioGraph && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { style: { height: `${miniGraphHeight}px`, display: "flex", alignItems: "center", justifyContent: "center" }, children: multiScenarioGraph.isConstant ? /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
            "div",
            {
              style: {
                fontSize: `${Math.max(7, scaledFontSize - 2)}px`,
                fontWeight: "bold",
                color: "#1f2937",
                padding: "2px 4px",
                background: "rgba(255,255,255,0.7)",
                borderRadius: "2px",
                fontFamily: "monospace",
                display: "flex",
                flexDirection: "column",
                gap: "1px"
              },
              children: multiScenarioGraph.values?.map((v2, i2) => /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("span", { style: { color: v2.color }, children: v2.value.toFixed(1) }, i2))
            }
          ) : /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
            "svg",
            {
              width: miniGraphWidth,
              height: miniGraphHeight,
              style: { background: "rgba(255,255,255,0.5)", borderRadius: "2px" },
              children: multiScenarioGraph.paths.map((p2, i2) => /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
                "polyline",
                {
                  points: p2.path,
                  fill: "none",
                  stroke: p2.color,
                  strokeWidth: "1.5",
                  transform: `scale(${miniGraphWidth / 80}, ${miniGraphHeight / 30})`
                },
                i2
              ))
            }
          ) }),
          singleGraph && !multiScenarioGraph && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { style: { height: `${miniGraphHeight}px`, display: "flex", alignItems: "center", justifyContent: "center" }, children: singleGraph.isConstant ? /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(
            "div",
            {
              style: {
                fontSize: `${Math.max(8, scaledFontSize - 1)}px`,
                fontWeight: "bold",
                color: "#1f2937",
                padding: "2px 4px",
                background: "rgba(255,255,255,0.7)",
                borderRadius: "2px",
                fontFamily: "monospace"
              },
              children: [
                singleGraph.value?.toFixed(2),
                singleGraph.unit && ` ${singleGraph.unit}`
              ]
            }
          ) : singleGraph.path ? /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
            "svg",
            {
              width: miniGraphWidth,
              height: miniGraphHeight,
              style: { background: "rgba(255,255,255,0.5)", borderRadius: "2px" },
              children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
                "polyline",
                {
                  points: singleGraph.path,
                  fill: "none",
                  stroke: finalBorderColor,
                  strokeWidth: "1.5",
                  transform: `scale(${miniGraphWidth / 80}, ${miniGraphHeight / 30})`
                }
              )
            }
          ) : null }),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Handle$1, { type: "source", position: Position.Bottom, style: { background: finalBorderColor } })
        ]
      }
    );
  }
  var StockNode_default = (0, import_react12.memo)(StockNode);

  // components/nodes/VariableNode.tsx
  var import_react13 = __toESM(require_react(), 1);
  var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
  function VariableNode({ data, id: id2 }) {
    const {
      label,
      simulationResults,
      modelData,
      scenarioResults,
      highlighted,
      style: style2,
      borderColor,
      fillColor,
      fontSize = 11,
      fontColor = "#1f2937",
      opacity = 100,
      width,
      height: height2
    } = data;
    const multiScenarioGraph = scenarioResults && scenarioResults.length > 0 ? generateMultiScenarioMiniGraph(id2, scenarioResults, modelData) : null;
    const singleGraph = !multiScenarioGraph ? generateMiniGraph(id2, simulationResults, modelData) : null;
    const hasData = !!multiScenarioGraph || !!singleGraph;
    let { width: nodeWidth, height: nodeHeight } = ensureMinNodeSize(
      width,
      height2,
      label,
      "VARIABLE",
      fontSize
    );
    if (hasData) {
      const minWithData = 70;
      nodeWidth = Math.max(nodeWidth, minWithData);
      nodeHeight = Math.max(nodeHeight, minWithData);
    }
    const defaults = DEFAULT_COLORS2.VARIABLE;
    const finalBorderColor = highlighted ? "#ec4899" : borderColor || style2?.strokeColor || defaults.border;
    const finalFillColor = fillColor || style2?.fillColor || defaults.fill;
    const finalOpacity = (style2?.opacity ?? opacity) / 100;
    const minDim = Math.min(nodeWidth, nodeHeight);
    const scaledFontSize = Math.max(8, Math.min(fontSize, minDim / 8));
    const miniGraphSize = Math.min(minDim * 0.5, 60);
    const labelMaxWidth = Math.max(40, nodeWidth * 0.8);
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(
      "div",
      {
        style: {
          background: finalFillColor,
          border: `2px solid ${finalBorderColor}`,
          borderRadius: "50%",
          width: `${nodeWidth}px`,
          height: `${nodeHeight}px`,
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          gap: "2px",
          boxShadow: highlighted ? "0 0 16px rgba(236, 72, 153, 0.7)" : "0 1px 3px rgba(0,0,0,0.1)",
          opacity: finalOpacity,
          boxSizing: "border-box",
          overflow: "hidden",
          position: "relative"
        },
        className: "swiss-card",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Handle$1, { type: "target", position: Position.Top, style: { background: finalBorderColor } }),
          /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
            "div",
            {
              style: {
                fontSize: `${scaledFontSize}px`,
                fontWeight: "500",
                color: fontColor,
                textAlign: "center",
                overflow: "hidden",
                maxWidth: `${labelMaxWidth}px`,
                lineHeight: "1.2",
                padding: "0 4px",
                wordWrap: "break-word",
                overflowWrap: "break-word",
                display: "-webkit-box",
                WebkitLineClamp: 3,
                WebkitBoxOrient: "vertical"
              },
              title: label,
              children: label
            }
          ),
          multiScenarioGraph && /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { style: { height: `${miniGraphSize * 0.5}px`, display: "flex", alignItems: "center", justifyContent: "center" }, children: multiScenarioGraph.isConstant ? /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
            "div",
            {
              style: {
                fontSize: `${Math.max(7, scaledFontSize - 2)}px`,
                fontWeight: "bold",
                color: "#1f2937",
                padding: "1px 3px",
                background: "rgba(255,255,255,0.7)",
                borderRadius: "2px",
                fontFamily: "monospace",
                display: "flex",
                flexDirection: "column",
                gap: "1px"
              },
              children: multiScenarioGraph.values?.map((v2, i2) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("span", { style: { color: v2.color }, children: v2.value.toFixed(1) }, i2))
            }
          ) : /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
            "svg",
            {
              width: miniGraphSize,
              height: miniGraphSize * 0.4,
              style: { background: "rgba(255,255,255,0.5)", borderRadius: "2px" },
              children: multiScenarioGraph.paths.map((p2, i2) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
                "polyline",
                {
                  points: p2.path,
                  fill: "none",
                  stroke: p2.color,
                  strokeWidth: "1.5",
                  transform: `scale(${miniGraphSize / 80}, ${miniGraphSize * 0.4 / 30})`
                },
                i2
              ))
            }
          ) }),
          singleGraph && !multiScenarioGraph && /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("div", { style: { height: `${miniGraphSize * 0.5}px`, display: "flex", alignItems: "center", justifyContent: "center" }, children: singleGraph.isConstant ? /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)(
            "div",
            {
              style: {
                fontSize: `${Math.max(8, scaledFontSize - 1)}px`,
                fontWeight: "bold",
                color: "#1f2937",
                padding: "1px 3px",
                background: "rgba(255,255,255,0.7)",
                borderRadius: "2px",
                fontFamily: "monospace"
              },
              children: [
                singleGraph.value?.toFixed(2),
                singleGraph.unit && ` ${singleGraph.unit}`
              ]
            }
          ) : singleGraph.path ? /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
            "svg",
            {
              width: miniGraphSize,
              height: miniGraphSize * 0.4,
              style: { background: "rgba(255,255,255,0.5)", borderRadius: "2px" },
              children: /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
                "polyline",
                {
                  points: singleGraph.path,
                  fill: "none",
                  stroke: finalBorderColor,
                  strokeWidth: "1.5",
                  transform: `scale(${miniGraphSize / 80}, ${miniGraphSize * 0.4 / 30})`
                }
              )
            }
          ) : null }),
          /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Handle$1, { type: "source", position: Position.Bottom, style: { background: finalBorderColor } })
        ]
      }
    );
  }
  var VariableNode_default = (0, import_react13.memo)(VariableNode);

  // components/nodes/GhostNode.tsx
  var import_react14 = __toESM(require_react(), 1);
  var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
  function GhostNode({ data, id: id2 }) {
    const {
      label,
      simulationResults,
      modelData,
      highlighted,
      style: style2,
      borderColor,
      fillColor,
      fontSize = 10,
      fontColor = "#6b7280",
      opacity = 30,
      source,
      // Reference to the original element this ghost represents
      width,
      height: height2
    } = data;
    const dataElementId = source || id2;
    const miniGraph = generateMiniGraph(dataElementId, simulationResults, modelData);
    const hasData = !!miniGraph;
    let { width: nodeWidth, height: nodeHeight } = ensureMinNodeSize(
      width,
      height2,
      label,
      "GHOST",
      fontSize
    );
    if (hasData) {
      const minWithData = 70;
      nodeWidth = Math.max(nodeWidth, minWithData);
      nodeHeight = Math.max(nodeHeight, minWithData);
    }
    const minDim = Math.min(nodeWidth, nodeHeight);
    const scaledFontSize = Math.max(8, Math.min(fontSize, minDim / 8));
    const miniGraphSize = Math.min(minDim * 0.5, 60);
    const labelMaxWidth = Math.max(40, nodeWidth * 0.8);
    const defaults = DEFAULT_COLORS2.GHOST;
    const finalBorderColor = highlighted ? "#ec4899" : borderColor || style2?.strokeColor || defaults.border;
    const finalFillColor = fillColor || style2?.fillColor || defaults.fill;
    const finalOpacity = Math.min(style2?.opacity ?? opacity, 60) / 100;
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(
      "div",
      {
        style: {
          background: finalFillColor,
          border: `2px dashed ${finalBorderColor}`,
          borderRadius: "50%",
          width: `${nodeWidth}px`,
          height: `${nodeHeight}px`,
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          gap: "2px",
          boxShadow: highlighted ? "0 0 12px rgba(236, 72, 153, 0.5)" : "none",
          opacity: finalOpacity,
          position: "relative",
          boxSizing: "border-box",
          overflow: "hidden"
        },
        className: "swiss-card swiss-muted",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Handle$1, { type: "target", position: Position.Top, style: { background: finalBorderColor, opacity: 0.6 } }),
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                top: "4px",
                right: "8px",
                width: "12px",
                height: "12px",
                opacity: 0.5
              },
              children: /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("svg", { viewBox: "0 0 24 24", fill: finalBorderColor, children: [
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("path", { d: "M12 2C6.48 2 2 6.48 2 12v8c0 1.1.9 2 2 2h2v-2H4v-8c0-4.41 3.59-8 8-8s8 3.59 8 8v8h-2v2h2c1.1 0 2-.9 2-2v-8c0-5.52-4.48-10-10-10z" }),
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("circle", { cx: "9", cy: "13", r: "1.5" }),
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("circle", { cx: "15", cy: "13", r: "1.5" })
              ] })
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
            "div",
            {
              style: {
                fontSize: `${scaledFontSize}px`,
                fontWeight: "400",
                fontStyle: "italic",
                color: fontColor,
                textAlign: "center",
                overflow: "hidden",
                maxWidth: `${labelMaxWidth}px`,
                lineHeight: "1.2",
                wordWrap: "break-word",
                overflowWrap: "break-word",
                display: "-webkit-box",
                WebkitLineClamp: 3,
                WebkitBoxOrient: "vertical"
              },
              title: label,
              children: label
            }
          ),
          miniGraph && /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { style: { height: `${miniGraphSize * 0.5}px`, display: "flex", alignItems: "center", justifyContent: "center" }, children: miniGraph.isConstant ? /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(
            "div",
            {
              style: {
                fontSize: `${Math.max(8, scaledFontSize - 1)}px`,
                fontWeight: "bold",
                color: "#6b7280",
                padding: "2px 4px",
                background: "rgba(255,255,255,0.5)",
                borderRadius: "2px",
                fontFamily: "monospace"
              },
              children: [
                miniGraph.value?.toFixed(2),
                miniGraph.unit && ` ${miniGraph.unit}`
              ]
            }
          ) : miniGraph.path ? /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
            "svg",
            {
              width: miniGraphSize,
              height: miniGraphSize * 0.4,
              style: { background: "rgba(255,255,255,0.3)", borderRadius: "2px" },
              children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
                "polyline",
                {
                  points: miniGraph.path,
                  fill: "none",
                  stroke: finalBorderColor,
                  strokeWidth: "1",
                  strokeDasharray: "2 1",
                  transform: `scale(${miniGraphSize / 80}, ${miniGraphSize * 0.4 / 30})`
                }
              )
            }
          ) : null }),
          /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Handle$1, { type: "source", position: Position.Bottom, style: { background: finalBorderColor, opacity: 0.6 } })
        ]
      }
    );
  }
  var GhostNode_default = (0, import_react14.memo)(GhostNode);

  // components/nodes/ConverterNode.tsx
  var import_react15 = __toESM(require_react(), 1);
  var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
  function ConverterNode({ data, id: id2 }) {
    const {
      label,
      simulationResults,
      modelData,
      scenarioResults,
      highlighted,
      style: style2,
      borderColor,
      fillColor,
      fontSize = 10,
      fontColor = "#1f2937",
      opacity = 100,
      width,
      height: height2
    } = data;
    const multiScenarioGraph = scenarioResults && scenarioResults.length > 0 ? generateMultiScenarioMiniGraph(id2, scenarioResults, modelData) : null;
    const singleGraph = !multiScenarioGraph ? generateMiniGraph(id2, simulationResults, modelData) : null;
    const hasData = !!multiScenarioGraph || !!singleGraph;
    let { width: nodeWidth, height: nodeHeight } = ensureMinNodeSize(
      width,
      height2,
      label,
      "CONVERTER",
      fontSize
    );
    if (hasData) {
      const minWithData = 70;
      nodeWidth = Math.max(nodeWidth, minWithData);
      nodeHeight = Math.max(nodeHeight, minWithData);
    }
    const diamondSize = Math.min(nodeWidth, nodeHeight) * 0.7;
    const minDim = Math.min(nodeWidth, nodeHeight);
    const scaledFontSize = Math.max(8, Math.min(fontSize, minDim / 8));
    const miniGraphSize = Math.min(minDim * 0.4, 40);
    const labelMaxWidth = Math.max(40, diamondSize * 0.8);
    const defaults = DEFAULT_COLORS2.CONVERTER;
    const finalBorderColor = highlighted ? "#ec4899" : borderColor || style2?.strokeColor || defaults.border;
    const finalFillColor = fillColor || style2?.fillColor || defaults.fill;
    const finalOpacity = (style2?.opacity ?? opacity) / 100;
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(
      "div",
      {
        style: {
          position: "relative",
          width: `${nodeWidth}px`,
          height: `${nodeHeight}px`,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: finalOpacity,
          boxSizing: "border-box"
        },
        className: "swiss-card",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                width: `${diamondSize}px`,
                height: `${diamondSize}px`,
                background: finalFillColor,
                border: `2px solid ${finalBorderColor}`,
                borderRadius: "4px",
                transform: "rotate(45deg)",
                boxShadow: highlighted ? "0 0 16px rgba(236, 72, 153, 0.7)" : "0 1px 3px rgba(0,0,0,0.1)"
              }
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(
            "div",
            {
              style: {
                position: "relative",
                zIndex: 1,
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                gap: "2px",
                padding: "4px",
                overflow: "hidden"
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
                  "div",
                  {
                    style: {
                      fontSize: `${scaledFontSize}px`,
                      fontWeight: "500",
                      color: fontColor,
                      textAlign: "center",
                      overflow: "hidden",
                      maxWidth: `${labelMaxWidth}px`,
                      lineHeight: "1.2",
                      wordWrap: "break-word",
                      overflowWrap: "break-word",
                      display: "-webkit-box",
                      WebkitLineClamp: 2,
                      WebkitBoxOrient: "vertical"
                    },
                    title: label,
                    children: label
                  }
                ),
                multiScenarioGraph && /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("div", { style: { height: `${miniGraphSize * 0.5}px`, display: "flex", alignItems: "center", justifyContent: "center" }, children: multiScenarioGraph.isConstant ? /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
                  "div",
                  {
                    style: {
                      fontSize: `${Math.max(7, scaledFontSize - 2)}px`,
                      fontWeight: "bold",
                      color: "#1f2937",
                      padding: "1px 3px",
                      background: "rgba(255,255,255,0.7)",
                      borderRadius: "2px",
                      fontFamily: "monospace",
                      display: "flex",
                      flexDirection: "column",
                      gap: "1px"
                    },
                    children: multiScenarioGraph.values?.map((v2, i2) => /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("span", { style: { color: v2.color }, children: v2.value.toFixed(1) }, i2))
                  }
                ) : /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
                  "svg",
                  {
                    width: miniGraphSize,
                    height: miniGraphSize * 0.4,
                    style: { background: "rgba(255,255,255,0.5)", borderRadius: "2px" },
                    children: multiScenarioGraph.paths.map((p2, i2) => /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
                      "polyline",
                      {
                        points: p2.path,
                        fill: "none",
                        stroke: p2.color,
                        strokeWidth: "1",
                        transform: `scale(${miniGraphSize / 80}, ${miniGraphSize * 0.4 / 30})`
                      },
                      i2
                    ))
                  }
                ) }),
                singleGraph && !multiScenarioGraph && /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("div", { style: { height: `${miniGraphSize * 0.5}px`, display: "flex", alignItems: "center", justifyContent: "center" }, children: singleGraph.isConstant ? /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(
                  "div",
                  {
                    style: {
                      fontSize: `${Math.max(8, scaledFontSize - 1)}px`,
                      fontWeight: "bold",
                      color: "#1f2937",
                      padding: "1px 3px",
                      background: "rgba(255,255,255,0.7)",
                      borderRadius: "2px",
                      fontFamily: "monospace"
                    },
                    children: [
                      singleGraph.value?.toFixed(1),
                      singleGraph.unit && ` ${singleGraph.unit}`
                    ]
                  }
                ) : singleGraph.path ? /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
                  "svg",
                  {
                    width: miniGraphSize,
                    height: miniGraphSize * 0.4,
                    style: { background: "rgba(255,255,255,0.5)", borderRadius: "2px" },
                    children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
                      "polyline",
                      {
                        points: singleGraph.path,
                        fill: "none",
                        stroke: finalBorderColor,
                        strokeWidth: "1",
                        transform: `scale(${miniGraphSize / 80}, ${miniGraphSize * 0.4 / 30})`
                      }
                    )
                  }
                ) : null })
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Handle$1, { type: "target", position: Position.Top, style: { background: finalBorderColor, top: "5px" } }),
          /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Handle$1, { type: "source", position: Position.Bottom, style: { background: finalBorderColor, bottom: "5px" } })
        ]
      }
    );
  }
  var ConverterNode_default = (0, import_react15.memo)(ConverterNode);

  // components/nodes/FolderNode.tsx
  var import_react16 = __toESM(require_react(), 1);
  var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
  function FolderNode({ data, selected }) {
    const {
      label,
      doc: doc2,
      childCount = 0,
      borderColor = "#8b5cf6",
      fontSize = 12,
      fontColor = "#1f2937",
      highlighted = false
    } = data;
    const finalBorderColor = highlighted ? "#ec4899" : borderColor;
    return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(
      "div",
      {
        style: {
          width: "100%",
          height: "100%",
          background: "transparent",
          // Fully transparent background
          border: `2px ${highlighted || selected ? "solid" : "dashed"} ${finalBorderColor}`,
          borderRadius: "12px",
          boxSizing: "border-box",
          display: "flex",
          flexDirection: "column",
          justifyContent: "flex-start",
          boxShadow: selected || highlighted ? `0 0 16px ${finalBorderColor}60` : "none",
          transition: "all 0.2s ease",
          position: "relative",
          overflow: "visible",
          pointerEvents: "none"
          // Make folder transparent to clicks - clicks pass through to edges/elements
        },
        className: "swiss-card",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(
            "div",
            {
              style: {
                background: `${finalBorderColor}15`,
                // Very light tint
                borderBottom: `1px solid ${finalBorderColor}30`,
                borderRadius: "10px 10px 0 0",
                padding: "8px 12px",
                display: "flex",
                alignItems: "center",
                gap: "8px",
                minHeight: "36px"
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { style: { width: "20px", height: "20px", flexShrink: 0 }, children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("svg", { viewBox: "0 0 24 24", fill: finalBorderColor, children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("path", { d: "M10 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z" }) }) }),
                /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
                  "div",
                  {
                    style: {
                      fontSize: `${fontSize}px`,
                      fontWeight: "700",
                      color: fontColor,
                      flex: 1,
                      overflow: "hidden",
                      textOverflow: "ellipsis",
                      whiteSpace: "nowrap"
                    },
                    children: label
                  }
                ),
                childCount > 0 && /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
                  "div",
                  {
                    style: {
                      fontSize: "10px",
                      fontWeight: "600",
                      color: "white",
                      background: finalBorderColor,
                      padding: "2px 8px",
                      borderRadius: "10px",
                      flexShrink: 0
                    },
                    children: childCount
                  }
                )
              ]
            }
          ),
          doc2 && /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
            "div",
            {
              style: {
                fontSize: `${Math.max(9, fontSize - 3)}px`,
                color: fontColor,
                opacity: 0.7,
                padding: "4px 12px",
                maxHeight: "24px",
                overflow: "hidden",
                textOverflow: "ellipsis",
                whiteSpace: "nowrap",
                background: `${finalBorderColor}08`
                // Very subtle tint
              },
              children: doc2
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
            "div",
            {
              style: {
                flex: 1,
                position: "relative",
                padding: "10px"
              }
            }
          )
        ]
      }
    );
  }
  var FolderNode_default = (0, import_react16.memo)(FolderNode);

  // components/FlowEdge.tsx
  var import_react17 = __toESM(require_react(), 1);
  var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
  function getContrastTextColor(hexColor) {
    if (!hexColor || !hexColor.startsWith("#")) return "#ffffff";
    let hex2 = hexColor.slice(1);
    if (hex2.length === 3) {
      hex2 = hex2.split("").map((c2) => c2 + c2).join("");
    }
    const r2 = parseInt(hex2.substring(0, 2), 16) / 255;
    const g2 = parseInt(hex2.substring(2, 4), 16) / 255;
    const b2 = parseInt(hex2.substring(4, 6), 16) / 255;
    const luminance = 0.2126 * r2 + 0.7152 * g2 + 0.0722 * b2;
    return luminance > 0.5 ? "#1f2937" : "#ffffff";
  }
  function FlowEdge({
    id: id2,
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition,
    data,
    selected
  }) {
    const [edgePath, labelX, labelY] = getBezierPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition
    });
    const handleFlowClick = (e2) => {
      e2.stopPropagation();
      if (data?.onFlowClick && data?.flowName) {
        data.onFlowClick(data.flowName);
      }
    };
    const strokeColor = selected ? "#ec4899" : data?.strokeColor || "#ef4444";
    const textColor = getContrastTextColor(strokeColor);
    const markerId = `flowArrow-${id2}`;
    const glowMarkerId = `flowGlow-${id2}`;
    return /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("defs", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("filter", { id: glowMarkerId, x: "-50%", y: "-50%", width: "200%", height: "200%", children: [
          /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("feGaussianBlur", { stdDeviation: "2", result: "coloredBlur" }),
          /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("feMerge", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("feMergeNode", { in: "coloredBlur" }),
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("feMergeNode", { in: "SourceGraphic" })
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
          "marker",
          {
            id: markerId,
            markerWidth: "25",
            markerHeight: "25",
            markerUnits: "strokeWidth",
            orient: "auto",
            refX: "20",
            refY: "10",
            children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("path", { d: "M0,0 L0,20 L25,10 Z", fill: strokeColor })
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
        "path",
        {
          d: edgePath,
          strokeWidth: selected ? 6 : 5,
          stroke: strokeColor,
          fill: "none",
          opacity: "0.15",
          filter: `url(#${glowMarkerId})`
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
        "path",
        {
          id: id2,
          className: "react-flow__edge-path",
          d: edgePath,
          strokeWidth: selected ? 4 : 3,
          stroke: strokeColor,
          fill: "none",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          markerEnd: `url(#${markerId})`,
          style: {
            filter: selected ? `drop-shadow(0 0 6px ${strokeColor})` : "none",
            transition: "all 0.2s ease"
          }
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(EdgeLabelRenderer, { children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
        "button",
        {
          onClick: handleFlowClick,
          className: "nodrag nopan swiss-btn swiss-flow-btn",
          style: {
            position: "absolute",
            transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
            pointerEvents: "all",
            zIndex: 10,
            background: strokeColor,
            color: textColor,
            padding: "6px 12px",
            borderRadius: "6px",
            fontSize: "11px",
            fontWeight: "600",
            whiteSpace: "nowrap",
            boxShadow: "0 2px 8px rgba(0,0,0,0.3)",
            border: "2px solid white",
            cursor: "pointer",
            transition: "all 0.15s ease"
          },
          onMouseEnter: (e2) => {
            e2.currentTarget.style.transform = `translate(-50%, -50%) translate(${labelX}px,${labelY}px) scale(1.1)`;
            e2.currentTarget.style.boxShadow = "0 4px 12px rgba(0,0,0,0.4)";
          },
          onMouseLeave: (e2) => {
            e2.currentTarget.style.transform = `translate(-50%, -50%) translate(${labelX}px,${labelY}px) scale(1)`;
            e2.currentTarget.style.boxShadow = "0 2px 8px rgba(0,0,0,0.3)";
          },
          title: `Click to view details for "${data?.flowName || "Flow"}"`,
          children: data?.flowName || "FLOW"
        }
      ) })
    ] });
  }
  var FlowEdge_default = (0, import_react17.memo)(FlowEdge);

  // components/LoadingOverlay.tsx
  var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
  function LoadingOverlay({ isVisible, title, subtitle, type }) {
    if (!isVisible) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "absolute inset-0 bg-white/90 backdrop-blur-sm z-50 flex items-center justify-center", children: [
      /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "flex flex-col items-center gap-6", children: [
        type === "layout" ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(LayoutAnimation, {}) : /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(SimulationAnimation, {}),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "text-center", children: [
          /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("h3", { className: "text-xl font-semibold text-gray-800", children: title }),
          subtitle && /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("p", { className: "text-sm text-gray-500 mt-1", children: subtitle })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(ProgressBar, { type })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(AnimationStyles, {})
    ] });
  }
  function LayoutAnimation() {
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "relative w-32 h-32", children: [
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: "absolute inset-0", children: [...Array(9)].map((_2, i2) => {
        const row2 = Math.floor(i2 / 3);
        const col = i2 % 3;
        const delay = (row2 + col) * 0.1;
        return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
          "div",
          {
            className: "absolute w-6 h-6 rounded-md",
            style: {
              left: `${col * 40 + 16}px`,
              top: `${row2 * 40 + 16}px`,
              backgroundColor: i2 % 3 === 0 ? "#3b82f6" : i2 % 3 === 1 ? "#10b981" : "#f59e0b",
              animation: `layoutPulse 1.5s ease-in-out ${delay}s infinite`
            }
          },
          i2
        );
      }) }),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("svg", { className: "absolute inset-0 w-32 h-32", style: { animation: "fadeInOut 2s ease-in-out infinite" }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("line", { x1: "28", y1: "28", x2: "68", y2: "28", stroke: "#94a3b8", strokeWidth: "2", strokeDasharray: "4 2" }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("line", { x1: "68", y1: "28", x2: "108", y2: "28", stroke: "#94a3b8", strokeWidth: "2", strokeDasharray: "4 2" }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("line", { x1: "28", y1: "68", x2: "68", y2: "68", stroke: "#94a3b8", strokeWidth: "2", strokeDasharray: "4 2" }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("line", { x1: "68", y1: "68", x2: "108", y2: "68", stroke: "#94a3b8", strokeWidth: "2", strokeDasharray: "4 2" }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("line", { x1: "28", y1: "28", x2: "28", y2: "68", stroke: "#94a3b8", strokeWidth: "2", strokeDasharray: "4 2" }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("line", { x1: "68", y1: "28", x2: "68", y2: "68", stroke: "#94a3b8", strokeWidth: "2", strokeDasharray: "4 2" }),
        /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("line", { x1: "108", y1: "28", x2: "108", y2: "68", stroke: "#94a3b8", strokeWidth: "2", strokeDasharray: "4 2" })
      ] })
    ] });
  }
  function SimulationAnimation() {
    const orbitColors = ["#3b82f6", "#10b981", "#f59e0b", "#ef4444", "#8b5cf6", "#06b6d4"];
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("div", { className: "relative w-32 h-32", children: [
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        "div",
        {
          className: "absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-12 h-12 rounded-full bg-gradient-to-br from-purple-500 to-pink-500",
          style: { animation: "simulationCore 1s ease-in-out infinite" }
        }
      ),
      orbitColors.map((color2, i2) => /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        "div",
        {
          className: "absolute left-1/2 top-1/2 w-3 h-3 rounded-full",
          style: {
            backgroundColor: color2,
            animation: `orbit${i2 % 2 === 0 ? "" : "Reverse"} ${2 + i2 * 0.3}s linear infinite`,
            transformOrigin: `${24 + i2 * 4}px 0`
          }
        },
        i2
      )),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        "div",
        {
          className: "absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-24 h-24 rounded-full border-2 border-purple-300",
          style: { animation: "pulseRing 2s ease-out infinite" }
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        "div",
        {
          className: "absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-24 h-24 rounded-full border-2 border-pink-300",
          style: { animation: "pulseRing 2s ease-out 0.5s infinite" }
        }
      )
    ] });
  }
  function ProgressBar({ type }) {
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: "w-48 h-1.5 bg-gray-200 rounded-full overflow-hidden", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
      "div",
      {
        className: "h-full rounded-full",
        style: {
          background: type === "layout" ? "linear-gradient(90deg, #3b82f6, #10b981, #f59e0b)" : "linear-gradient(90deg, #8b5cf6, #ec4899, #ef4444)",
          animation: type === "layout" ? "progressTimed1s 1s ease-out forwards" : "progressTimed2s 2s ease-out forwards"
        }
      }
    ) });
  }
  function AnimationStyles() {
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
      "style",
      {
        dangerouslySetInnerHTML: {
          __html: `
        @keyframes layoutPulse {
          0%, 100% { transform: scale(1); opacity: 0.7; }
          50% { transform: scale(1.2); opacity: 1; }
        }
        @keyframes fadeInOut {
          0%, 100% { opacity: 0.3; }
          50% { opacity: 0.8; }
        }
        @keyframes simulationCore {
          0%, 100% { transform: translate(-50%, -50%) scale(1); }
          50% { transform: translate(-50%, -50%) scale(1.15); }
        }
        @keyframes orbit {
          from { transform: rotate(0deg) translateX(28px) rotate(0deg); }
          to { transform: rotate(360deg) translateX(28px) rotate(-360deg); }
        }
        @keyframes orbitReverse {
          from { transform: rotate(360deg) translateX(36px) rotate(-360deg); }
          to { transform: rotate(0deg) translateX(36px) rotate(0deg); }
        }
        @keyframes pulseRing {
          0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
          100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }
        @keyframes progressTimed1s {
          0% { width: 0%; }
          30% { width: 40%; }
          60% { width: 70%; }
          90% { width: 90%; }
          100% { width: 99%; }
        }
        @keyframes progressTimed2s {
          0% { width: 0%; }
          50% { width: 60%; }
          100% { width: 99%; }
        }
      `
        }
      }
    );
  }

  // components/visualizer/VisualizerCanvas.tsx
  var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
  function VisualizerCanvas({
    nodes,
    edges,
    onNodesChange,
    onEdgesChange,
    onNodeClick,
    onEdgeClick,
    onPaneClick,
    isCalculatingLayout,
    isRunningSimulation,
    currentScenario
  }) {
    const nodeTypes = (0, import_react18.useMemo)(
      () => ({
        stockNode: StockNode_default,
        variableNode: VariableNode_default,
        ghostNode: GhostNode_default,
        converterNode: ConverterNode_default,
        folderNode: FolderNode_default
      }),
      []
    );
    const edgeTypes = (0, import_react18.useMemo)(() => ({ flowEdge: FlowEdge_default }), []);
    return /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { className: "flex-1 h-full bg-white rounded-2xl shadow-xl border border-gray-200 overflow-hidden relative", children: [
      /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
        LoadingOverlay,
        {
          isVisible: isCalculatingLayout,
          title: "Calculating Layout",
          subtitle: "Positioning nodes within folders...",
          type: "layout"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
        LoadingOverlay,
        {
          isVisible: isRunningSimulation,
          title: "Running Simulation",
          subtitle: currentScenario ? `Running: ${currentScenario}` : "Results incoming...",
          type: "simulation"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)(
        ReactFlow,
        {
          nodes,
          edges,
          nodeTypes,
          edgeTypes,
          onNodesChange,
          onEdgesChange,
          onNodeClick,
          onEdgeClick,
          onPaneClick,
          fitView: true,
          fitViewOptions: {
            padding: 0.2,
            includeHiddenNodes: false
          },
          minZoom: 0.1,
          maxZoom: 2,
          defaultEdgeOptions: {
            type: "smoothstep"
          },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(Background$1, { color: "#d1d5db", gap: 20, size: 1 }),
            /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(Controls$1, { className: "bg-white shadow-lg rounded-lg border border-gray-200" })
          ]
        }
      )
    ] });
  }
  var VisualizerCanvas_default = (0, import_react18.memo)(VisualizerCanvas);

  // components/hooks/useSidebarResize.ts
  var import_react19 = __toESM(require_react(), 1);
  var COLLAPSED_WIDTH = 48;
  var MIN_SIDEBAR = 220;
  var MAX_SIDEBAR = 1200;
  function useSidebarResize({ containerRef }) {
    const [sidebarWidth, setSidebarWidth] = (0, import_react19.useState)(0);
    const [isResizing, setIsResizing] = (0, import_react19.useState)(false);
    const [showScenarioPanel, setShowScenarioPanel] = (0, import_react19.useState)(true);
    const savedWidthRef = (0, import_react19.useRef)(null);
    (0, import_react19.useEffect)(() => {
      const init2 = () => {
        if (!containerRef.current) return;
        const parent = containerRef.current;
        const width = parent.clientWidth || window.innerWidth;
        const defaultWidth = Math.max(MIN_SIDEBAR, Math.floor(width * 0.33));
        setSidebarWidth(defaultWidth);
        savedWidthRef.current = defaultWidth;
      };
      init2();
      window.addEventListener("resize", init2);
      return () => window.removeEventListener("resize", init2);
    }, [containerRef]);
    const startResizing = (0, import_react19.useCallback)(
      (e2) => {
        e2.preventDefault();
        setIsResizing(true);
        const onMouseMove = (moveEvent) => {
          if (!containerRef.current) return;
          const rect = containerRef.current.getBoundingClientRect();
          const newWidth = Math.max(MIN_SIDEBAR, Math.min(MAX_SIDEBAR, moveEvent.clientX - rect.left));
          setSidebarWidth(newWidth);
          savedWidthRef.current = newWidth;
        };
        const onMouseUp = () => {
          setIsResizing(false);
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        };
        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", onMouseUp);
      },
      [containerRef]
    );
    return {
      sidebarWidth,
      isResizing,
      showScenarioPanel,
      setShowScenarioPanel,
      startResizing,
      COLLAPSED_WIDTH
    };
  }

  // components/hooks/useHighlighting.ts
  var import_react20 = __toESM(require_react(), 1);
  function useHighlighting({ setNodes, setEdges }) {
    const [highlightedEdge, setHighlightedEdge] = (0, import_react20.useState)(null);
    const [highlightedNodes, setHighlightedNodes] = (0, import_react20.useState)(/* @__PURE__ */ new Set());
    const handleEdgeClick = (0, import_react20.useCallback)(
      (event, edge) => {
        event.stopPropagation();
        if (highlightedEdge === edge.id) {
          setHighlightedEdge(null);
          setHighlightedNodes(/* @__PURE__ */ new Set());
        } else {
          setHighlightedEdge(edge.id);
          setHighlightedNodes(/* @__PURE__ */ new Set([edge.source, edge.target]));
        }
      },
      [highlightedEdge]
    );
    const handlePaneClick = (0, import_react20.useCallback)(() => {
      if (highlightedEdge) {
        setHighlightedEdge(null);
        setHighlightedNodes(/* @__PURE__ */ new Set());
      }
    }, [highlightedEdge]);
    (0, import_react20.useEffect)(() => {
      if (highlightedNodes.size > 0) {
        setNodes(
          (nds) => nds.map((node) => ({
            ...node,
            data: {
              ...node.data,
              highlighted: highlightedNodes.has(node.id)
            }
          }))
        );
        setEdges(
          (eds) => eds.map((edge) => ({
            ...edge,
            animated: edge.id === highlightedEdge,
            style: {
              ...edge.style,
              stroke: edge.id === highlightedEdge ? "#ec4899" : edge.style?.stroke || "#64748b",
              strokeWidth: edge.id === highlightedEdge ? 4 : edge.style?.strokeWidth || 1
            }
          }))
        );
      } else {
        setNodes(
          (nds) => nds.map((node) => ({
            ...node,
            data: {
              ...node.data,
              highlighted: false
            }
          }))
        );
        setEdges(
          (eds) => eds.map((edge) => ({
            ...edge,
            animated: false
          }))
        );
      }
    }, [highlightedEdge, highlightedNodes, setNodes, setEdges]);
    return {
      highlightedEdge,
      highlightedNodes,
      handleEdgeClick,
      handlePaneClick
    };
  }

  // components/hooks/useSimulation.ts
  var import_react21 = __toESM(require_react(), 1);
  function useSimulation({
    modelData,
    convertedData,
    setNodes,
    setPendingLayoutRecalc
  }) {
    const [simulationResults, setSimulationResults] = (0, import_react21.useState)(null);
    const [isRunningSimulation, setIsRunningSimulation] = (0, import_react21.useState)(false);
    const [hasRunSimulation, setHasRunSimulation] = (0, import_react21.useState)(false);
    const [error, setError] = (0, import_react21.useState)(null);
    const createResultsFromCache = (0, import_react21.useCallback)((cached) => {
      return {
        times: () => cached.times,
        timeUnits: cached.timeUnits || "Years",
        series: (primitive) => {
          const elementName = primitive.name;
          return cached.series[elementName] || [];
        }
      };
    }, []);
    const downloadAllResults = (0, import_react21.useCallback)(
      (results, scenarioName) => {
        try {
          if (!modelData) return;
          const allElements = modelData.find();
          const times = results.times();
          const resultsData = {
            timeUnits: results.timeUnits,
            times,
            visualizations: [],
            elements: {},
            ...scenarioName && { scenario: scenarioName }
          };
          allElements.forEach((element) => {
            try {
              const values = results.series(element);
              if (values && values.length > 0) {
                resultsData.elements[element.name] = {
                  type: element.constructor.name,
                  units: element.units,
                  values
                };
              }
            } catch {
            }
          });
          if (convertedData?.displays && convertedData?.idToName) {
            const idToName = convertedData.idToName;
            convertedData.displays.forEach((display) => {
              const visualization = {
                name: display.name,
                type: display.type,
                elements: display.primitiveIds.map((id2) => idToName[id2]).filter((name) => name && resultsData.elements[name])
              };
              if (display.primitiveIds2 && display.primitiveIds2.length > 0) {
                visualization.elements2 = display.primitiveIds2.map((id2) => idToName[id2]).filter((name) => name && resultsData.elements[name]);
              }
              resultsData.visualizations.push(visualization);
            });
          }
          const blob = new Blob([JSON.stringify(resultsData, null, 2)], {
            type: "application/json"
          });
          const url = URL.createObjectURL(blob);
          const a2 = document.createElement("a");
          a2.href = url;
          const dateStr = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
          const filename = scenarioName ? `simulation-${scenarioName.replace(/[^a-zA-Z0-9]/g, "-")}-${dateStr}.json` : `simulation-results-${dateStr}.json`;
          a2.download = filename;
          document.body.appendChild(a2);
          a2.click();
          document.body.removeChild(a2);
          URL.revokeObjectURL(url);
        } catch (err) {
          console.error("Error downloading results:", err);
        }
      },
      [modelData, convertedData]
    );
    const handleRunSimulation = (0, import_react21.useCallback)(
      async (scenarioName) => {
        if (!modelData) return;
        setIsRunningSimulation(true);
        setError(null);
        setTimeout(() => {
          try {
            const results = modelData.simulate();
            setSimulationResults(results);
            setNodes(
              (currentNodes) => currentNodes.map((node) => ({
                ...node,
                data: {
                  ...node.data,
                  simulationResults: results,
                  modelData
                }
              }))
            );
            setHasRunSimulation(true);
            setIsRunningSimulation(false);
            setPendingLayoutRecalc(true);
            setTimeout(() => {
              downloadAllResults(results, scenarioName);
            }, 500);
          } catch (err) {
            console.error("Simulation error:", err);
            setError(err instanceof Error ? err.message : "Simulation failed");
            setIsRunningSimulation(false);
          }
        }, 100);
      },
      [modelData, setNodes, downloadAllResults, setPendingLayoutRecalc]
    );
    return {
      simulationResults,
      isRunningSimulation,
      hasRunSimulation,
      setHasRunSimulation,
      handleRunSimulation,
      downloadAllResults,
      createResultsFromCache,
      setSimulationResults,
      setIsRunningSimulation,
      error,
      setError
    };
  }

  // components/hooks/useScenarios.ts
  var import_react22 = __toESM(require_react(), 1);
  function useScenarios({
    modelData,
    setModelData,
    xmlContent,
    setNodes,
    setPendingLayoutRecalc,
    setHasRunSimulation,
    downloadAllResults,
    createResultsFromCache,
    setSimulationResults,
    setIsRunningSimulation,
    setError
  }) {
    const [buttons, setButtons] = (0, import_react22.useState)([]);
    const [currentScenario, setCurrentScenario] = (0, import_react22.useState)();
    const [scenarioHistory, setScenarioHistory] = (0, import_react22.useState)([]);
    const [cachedScenarios, setCachedScenarios] = (0, import_react22.useState)(/* @__PURE__ */ new Set());
    const [selectedDisplayScenarios, setSelectedDisplayScenarios] = (0, import_react22.useState)(/* @__PURE__ */ new Set());
    const [showScenarioDropdown, setShowScenarioDropdown] = (0, import_react22.useState)(false);
    const handleRunScenario = (0, import_react22.useCallback)(
      async (values, scenarioName) => {
        if (!modelData || !xmlContent) return;
        const fingerprint = generateFingerprint(xmlContent, scenarioName, values);
        const currentModelHash = generateModelHash(xmlContent);
        const cachedResult = await getCachedResult(fingerprint);
        if (cachedResult) {
          const mockResults = createResultsFromCache(cachedResult);
          setSimulationResults(mockResults);
          setNodes(
            (currentNodes) => currentNodes.map((node) => ({
              ...node,
              data: {
                ...node.data,
                simulationResults: mockResults,
                modelData
              }
            }))
          );
          setScenarioHistory((prev) => [
            ...prev,
            { scenarioName, timestamp: new Date(cachedResult.timestamp), values, simulationResults: mockResults }
          ]);
          setCachedScenarios((prev) => /* @__PURE__ */ new Set([...prev, scenarioName]));
          setHasRunSimulation(true);
          return;
        }
        setIsRunningSimulation(true);
        setCurrentScenario(scenarioName);
        setError(null);
        try {
          const freshModel = loadInsightMaker(xmlContent);
          const allElements = freshModel.find();
          const elementsByName = /* @__PURE__ */ new Map();
          allElements.forEach((el) => {
            elementsByName.set(el.name, el);
          });
          for (const { variableName, value } of values) {
            const element = elementsByName.get(variableName);
            if (element && element._node && element._node.attributes) {
              try {
                element._node.attributes.set("InitialValue", String(value));
                element._node.attributes.set("Equation", String(value));
              } catch {
                console.warn(`Could not set value for ${variableName}`);
              }
            }
          }
          setModelData(freshModel);
          setTimeout(async () => {
            try {
              const results = freshModel.simulate();
              const times = results.times();
              const series = {};
              const elementsForCache = freshModel.find();
              elementsForCache.forEach((el) => {
                try {
                  const elementValues = results.series(el);
                  if (elementValues && elementValues.length > 0) {
                    series[el.name] = elementValues;
                  }
                } catch {
                }
              });
              await cacheSimulationResult(
                fingerprint,
                currentModelHash,
                scenarioName,
                values,
                times,
                series,
                results.timeUnits
              );
              setCachedScenarios((prev) => /* @__PURE__ */ new Set([...prev, scenarioName]));
              setSimulationResults(results);
              setNodes(
                (currentNodes) => currentNodes.map((node) => ({
                  ...node,
                  data: {
                    ...node.data,
                    simulationResults: results,
                    modelData: freshModel
                  }
                }))
              );
              setScenarioHistory((prev) => [
                ...prev,
                { scenarioName, timestamp: /* @__PURE__ */ new Date(), values, simulationResults: results }
              ]);
              setHasRunSimulation(true);
              setIsRunningSimulation(false);
              setCurrentScenario(void 0);
              setPendingLayoutRecalc(true);
              setTimeout(() => {
                downloadAllResults(results, scenarioName);
              }, 500);
            } catch (err) {
              console.error("Scenario simulation error:", err);
              setError(err instanceof Error ? err.message : "Scenario simulation failed");
              setIsRunningSimulation(false);
              setCurrentScenario(void 0);
            }
          }, 100);
        } catch (err) {
          console.error("Error applying scenario:", err);
          setError(err instanceof Error ? err.message : "Failed to apply scenario");
          setIsRunningSimulation(false);
          setCurrentScenario(void 0);
        }
      },
      [
        modelData,
        xmlContent,
        setNodes,
        setModelData,
        createResultsFromCache,
        setSimulationResults,
        setHasRunSimulation,
        setIsRunningSimulation,
        setError,
        setPendingLayoutRecalc,
        downloadAllResults
      ]
    );
    (0, import_react22.useEffect)(() => {
      if (!modelData || scenarioHistory.length === 0) return;
      const scenariosToShow = selectedDisplayScenarios.size > 0 ? scenarioHistory.filter((s2) => selectedDisplayScenarios.has(s2.scenarioName)) : [scenarioHistory[scenarioHistory.length - 1]];
      if (scenariosToShow.length > 0) {
        const allResults = scenariosToShow.map((s2) => ({
          scenarioName: s2.scenarioName,
          results: s2.simulationResults
        }));
        setNodes(
          (currentNodes) => currentNodes.map((node) => ({
            ...node,
            data: {
              ...node.data,
              // Keep primary simulationResults for backward compatibility
              simulationResults: scenariosToShow[0].simulationResults,
              // Add all selected scenario results for multi-scenario minigraphs
              scenarioResults: allResults,
              modelData
            }
          }))
        );
      }
    }, [selectedDisplayScenarios, scenarioHistory, modelData, setNodes]);
    return {
      buttons,
      setButtons,
      currentScenario,
      setCurrentScenario,
      scenarioHistory,
      setScenarioHistory,
      cachedScenarios,
      setCachedScenarios,
      selectedDisplayScenarios,
      setSelectedDisplayScenarios,
      showScenarioDropdown,
      setShowScenarioDropdown,
      handleRunScenario
    };
  }

  // lib/defaultModel.ts
  var defaultModelXML = `<InsightMakerModel>
  <root>
    <mxCell id="0" />
    <mxCell id="1" parent="0" />
    <Folder name="Recycling" Note="" Type="None" Solver="{&quot;enabled&quot;:false,&quot;algorithm&quot;:&quot;RK1&quot;,&quot;timeStep&quot;:1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="2675" id="2675">
      <mxCell style="folder" vertex="1" parent="1">
        <mxGeometry x="359.9999999999999" y="1749.9999999999998" width="746.46" height="277.9100000000003" as="geometry" />
      </mxCell>
    </Folder>
    <Stock name="Al new sec production capacity" Note="Gt/a capacity&lt;br&gt;" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1571" id="1571">
      <mxCell style="stock;fontSize=10;fillColor=#B3E2CD;" parent="2675" vertex="1">
        <mxGeometry x="415.50000000000057" y="105.06000000000017" width="67.31" height="52.57" as="geometry" />
      </mxCell>
    </Stock>
    <Stock name="Al sec production capacity in construction" Note="" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1572" id="1572">
      <mxCell style="stock;fontSize=10;fillColor=#B3E2CD;" parent="2675" vertex="1">
        <mxGeometry x="279.00000000000057" y="105.06000000000017" width="70" height="60" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al sec cap constructed" Note="" FlowRate="Delay3([Al sec cap constructing],[Al recycling construction time],0)" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1573" id="1573">
      <mxCell style="flow;fontSize=6;" parent="2675" source="1572" target="1571" edge="1">
        <mxGeometry x="-1216.06" y="-1187.7299999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1010.9999999999998" y="-735.0799999999999" as="sourcePoint" />
          <mxPoint x="-911" y="-835.0799999999999" as="targetPoint" />
          <Array as="points">
            <mxPoint x="359.00000000000057" y="134.92000000000007" />
          </Array>
          <mxPoint x="2" y="7" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="Al sec cap constructing" Note="" FlowRate="[Al additional recycling capacity constructing]/({1 Gt/a}*{1 Years})" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1574" id="1574">
      <mxCell style="flow;fontSize=6;" parent="2675" target="1572" edge="1">
        <mxGeometry x="-1010.9999999999998" y="-804.9399999999998" width="100" height="100" as="geometry">
          <mxPoint x="189.00000000000057" y="135.05999999999995" as="sourcePoint" />
          <mxPoint x="-1010.9999999999998" y="-704.9399999999998" as="targetPoint" />
          <Array as="points">
            <mxPoint x="229.00000000000057" y="135.05999999999995" />
          </Array>
          <mxPoint x="-5" y="10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="Al sec cap 2" Note="" FlowRate="Delay([Al sec cap constructed],[Al sec cap min lifetime],0)" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1575" id="1575">
      <mxCell style="flow;fontSize=6;" parent="2675" source="1571" target="1655" edge="1">
        <mxGeometry x="-974.5" y="-804.9399999999998" width="100" height="100" as="geometry">
          <mxPoint x="-974.5" y="-704.9399999999998" as="sourcePoint" />
          <mxPoint x="585.5000000000005" y="135.05999999999995" as="targetPoint" />
          <Array as="points" />
          <mxPoint x="-10" y="10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="Al sec production 2026" Note="47Mt/a / 56 Mt/a manufacturing + post consumer recycling flow per total waste flow&lt;br&gt;" Equation="0.046" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1595" id="1595">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2675" vertex="1">
        <mxGeometry x="147.59000000000015" y="53.79000000000019" width="38.77" height="35.8" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1596" id="1596">
      <mxCell style="link" parent="2675" source="1595" target="1624" edge="1">
        <mxGeometry x="-1269.85" y="-837.7499999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1269.85" y="-737.7499999999998" as="sourcePoint" />
          <mxPoint x="-1169.85" y="-837.7499999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al recycling 1" Note="" Equation="If 0.95*[Al max recycling]&gt;[Al eff recycling capacity] Then&#xa;  [Al EOL]*[Al max RR]&#xa;Else &#xa;  [Al max recycling]&#xa;End If" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1602" LiveGraph="{&quot;active&quot;:false}" id="1602">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2675" vertex="1">
        <mxGeometry x="254.75000000000057" y="56" width="58.5" height="15" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al eff recycling capacity" Note="" Equation="[Al recycling capacity]*[max capacity utilization factor]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1603" id="1603">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2675" vertex="1">
        <mxGeometry x="414.9400000000004" y="65.43999999999983" width="48.75" height="27.43" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1604" id="1604">
      <mxCell style="link" parent="2675" source="1571" target="1965" edge="1">
        <mxGeometry x="-1134.2499999999998" y="-944.9399999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1134.2499999999998" y="-844.9399999999998" as="sourcePoint" />
          <mxPoint x="-1034.2499999999998" y="-944.9399999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al recycling construction time" Note="" Equation="2" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1605" id="1605">
      <mxCell style="variable;fontSize=8;fillColor=#99CC00;" parent="2675" vertex="1">
        <mxGeometry x="356.36000000000024" y="161.79999999999995" width="51.75" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1606" id="1606">
      <mxCell style="link" parent="2675" source="1574" target="1573" edge="1">
        <mxGeometry x="-1252.7499999999998" y="-822.3699999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1252.7499999999998" y="-722.3699999999999" as="sourcePoint" />
          <mxPoint x="-1152.7499999999998" y="-822.3699999999999" as="targetPoint" />
          <Array as="points">
            <mxPoint x="317.25000000000057" y="107.63000000000011" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1607" id="1607">
      <mxCell style="link" parent="2675" source="1605" target="1573" edge="1">
        <mxGeometry x="-1254.8399999999997" y="-835.6699999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1254.8399999999997" y="-735.6700000000001" as="sourcePoint" />
          <mxPoint x="-1154.8399999999997" y="-835.6699999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1611" id="1611">
      <mxCell style="link" parent="2675" source="1603" target="1602" edge="1">
        <mxGeometry x="-1236.3799999999999" y="-863.9999999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1236.3799999999999" y="-763.9999999999998" as="sourcePoint" />
          <mxPoint x="-1136.3799999999999" y="-863.9999999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al additional recycling capacity ordered" Note="" Equation="[Al sec cap building function]*[Al eff recycling capacity]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1613" id="1613">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2675" vertex="1">
        <mxGeometry x="205.06000000000006" y="80.57999999999993" width="60" height="38.96" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1614" id="1614">
      <mxCell style="link" parent="2675" source="1603" target="1613" edge="1">
        <mxGeometry x="-1252.7499999999998" y="-822.3699999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1252.7499999999998" y="-722.3699999999999" as="sourcePoint" />
          <mxPoint x="-1152.7499999999998" y="-822.3699999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1616" id="1616">
      <mxCell style="link" parent="2675" source="1632" target="1602" edge="1">
        <mxGeometry x="-1184.6299999999999" y="-863.9999999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1184.6299999999999" y="-763.9999999999998" as="sourcePoint" />
          <mxPoint x="-1084.6299999999999" y="-863.9999999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1618" id="1618">
      <mxCell style="link" parent="2675" source="1613" target="1904" edge="1">
        <mxGeometry x="-1252.7499999999998" y="-822.3699999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1252.7499999999998" y="-722.3699999999999" as="sourcePoint" />
          <mxPoint x="-1152.7499999999998" y="-822.3699999999999" as="targetPoint" />
          <Array as="points">
            <mxPoint x="223.94000000000017" y="132.26999999999998" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al recycling permitting factor" Note="" Equation="0.2" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1619" id="1619">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2675" vertex="1">
        <mxGeometry x="286.50000000000057" y="165.05999999999995" width="55" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1620" id="1620">
      <mxCell style="link" parent="2675" source="1619" target="1904" edge="1">
        <mxGeometry x="-1252.7499999999998" y="-822.3699999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1252.7499999999998" y="-722.3699999999999" as="sourcePoint" />
          <mxPoint x="-1152.7499999999998" y="-822.3699999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1621" id="1621">
      <mxCell style="link" parent="2675" source="1602" target="1739" edge="1">
        <mxGeometry x="-1184.6299999999999" y="-863.9999999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1184.6299999999999" y="-763.9999999999998" as="sourcePoint" />
          <mxPoint x="-1084.6299999999999" y="-863.9999999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="AL max recycling 2" Note="" InitialValue="[Al sec production 2026] / {1 Gt/a}#*[Al EOL] / {1 Gt/a}" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1624" id="1624">
      <mxCell style="stock;fontSize=6;" parent="2675" vertex="1">
        <mxGeometry x="104.03000000000031" y="60.819999999999936" width="37.62" height="20" as="geometry" />
      </mxCell>
    </Stock>
    <Variable name="Al recycling increase limit" Note="" Equation="1" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1626" id="1626">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2675" vertex="1">
        <mxGeometry x="47.61000000000024" y="20" width="40" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="d Al max recycling" Note="&lt;div&gt;https://alucycle.international-aluminium.org/public-access/public-global-cycle/&lt;/div&gt;&lt;div&gt;Flow to in-use&lt;br&gt;&lt;/div&gt;" Equation="([Al max recycling 1]/{1 Gt/a}-[AL max recycling 2])/TimeStep()" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1628" id="1628">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2675" vertex="1">
        <mxGeometry x="104.9600000000006" y="26.289999999999964" width="38.06" height="26.05" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1630" id="1630">
      <mxCell style="link" parent="2675" source="1624" target="1628" edge="1">
        <mxGeometry x="-1213.35" y="-803.3899999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1213.35" y="-703.3899999999999" as="sourcePoint" />
          <mxPoint x="-1113.35" y="-803.3899999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al max recycling" Note="&lt;div&gt;https://alucycle.international-aluminium.org/public-access/public-global-cycle/&lt;/div&gt;&lt;div&gt;Flow to in-use&lt;br&gt;&lt;/div&gt;" Equation="If [AL max recycling 2]&lt;=0 Then&#xa;  {0 Gt/a}&#xa;Else&#xa;  [AL max recycling 2] * {1 Gt/a}&#xa;End If" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1632" id="1632">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2675" vertex="1">
        <mxGeometry x="105.9000000000002" y="87.98000000000002" width="36.19" height="27.68" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1634" id="1634">
      <mxCell style="link" parent="2675" source="1624" target="1632" edge="1">
        <mxGeometry x="-1218.35" y="-849.1799999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1218.35" y="-749.1799999999998" as="sourcePoint" />
          <mxPoint x="-1118.35" y="-849.1799999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al recycling CF" Note="25Mt/a / 33.5 Mt/a post consumer recycling flow per post consumer waste flow&lt;br&gt;" Equation="[Al recycling 2]/[Al eff recycling capacity]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1635" id="1635">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2675" vertex="1">
        <mxGeometry x="365.00000000000034" y="26.29000000000019" width="58" height="20.63" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1636" id="1636">
      <mxCell style="link" parent="2675" source="1739" target="1635" edge="1">
        <mxGeometry x="-1240.6599999999999" y="-856.28" width="100" height="100" as="geometry">
          <mxPoint x="-1240.6599999999999" y="-756.2799999999997" as="sourcePoint" />
          <mxPoint x="-1140.6599999999999" y="-856.28" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1637" id="1637">
      <mxCell style="link" parent="2675" source="1603" target="1635" edge="1">
        <mxGeometry x="-1236.3799999999999" y="-863.9999999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1236.3799999999999" y="-763.9999999999998" as="sourcePoint" />
          <mxPoint x="-1136.3799999999999" y="-863.9999999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al recycling decrease limit" Note="" Equation="-1" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0" SliderMin="-5" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1638" id="1638">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2675" vertex="1">
        <mxGeometry x="47.61000000000024" y="83.82000000000016" width="40" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al RR" Note="25Mt/a / 33.5 Mt/a post consumer recycling flow per post consumer waste flow&lt;br&gt;" Equation="[Al recycling 1]/[Al EOL]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1640" id="1640">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2675" vertex="1">
        <mxGeometry x="192.6400000000001" y="53.50000000000023" width="30" height="20" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1641" id="1641">
      <mxCell style="link" parent="2675" source="1602" target="1640" edge="1">
        <mxGeometry x="-1184.6299999999999" y="-863.9999999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1184.6299999999999" y="-763.9999999999998" as="sourcePoint" />
          <mxPoint x="-1084.6299999999999" y="-863.9999999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1642" id="1642">
      <mxCell style="link" parent="2675" source="1693" target="1640" edge="1">
        <mxGeometry x="-1184.6299999999999" y="-863.9999999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1184.6299999999999" y="-763.9999999999998" as="sourcePoint" />
          <mxPoint x="-1084.6299999999999" y="-863.9999999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1643" id="1643">
      <mxCell style="link" parent="2675" source="1603" target="1739" edge="1">
        <mxGeometry x="-1184.6299999999999" y="-863.9999999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1184.6299999999999" y="-763.9999999999998" as="sourcePoint" />
          <mxPoint x="-1084.6299999999999" y="-863.9999999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="Al old sec production capacity" Note="&lt;div&gt;Gt/a capacity&lt;/div&gt;&lt;div&gt;2026 secondary production = 47 Mt/a&lt;/div&gt;&lt;div&gt;+ some overcapacity&lt;br&gt;&lt;/div&gt;" InitialValue="1" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1648" id="1648">
      <mxCell style="stock;fontSize=10;fillColor=#B3E2CD;" parent="2675" vertex="1">
        <mxGeometry x="415.50000000000057" y="156.2199999999998" width="67.31" height="50" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al old sec cap retiring" Note="" FlowRate="[Al old sec capacity retirement normalized L=20a]+([Al old sec capacity retirement normalized L=30a]-[Al old sec capacity retirement normalized L=20a])/({30 a}-{20 a})*([Al old sec cap lifetime]-{20 a})" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1649" LiveGraph="{&quot;active&quot;:false}" id="1649">
      <mxCell style="flow;fontSize=6;" parent="2675" source="1648" edge="1">
        <mxGeometry x="-910.4299999999998" y="-736.2599999999998" width="100" height="100" as="geometry">
          <mxPoint x="549.5700000000003" y="203.74" as="sourcePoint" />
          <mxPoint x="713.94" y="192.26999999999998" as="targetPoint" />
          <Array as="points">
            <mxPoint x="493.94000000000017" y="192.26999999999998" />
            <mxPoint x="490.94000000000017" y="190.26999999999998" />
          </Array>
          <mxPoint x="-10" y="10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="Al sec cap min lifetime" Note="" Equation="10" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1651" id="1651">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2675" vertex="1">
        <mxGeometry x="581.0600000000004" y="159.07999999999993" width="51.75" height="23.95" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1652" id="1652">
      <mxCell style="link" parent="2675" source="1651" target="1575" edge="1">
        <mxGeometry x="-1200.9999999999998" y="-822.3699999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1200.9999999999998" y="-722.3699999999999" as="sourcePoint" />
          <mxPoint x="-1100.9999999999998" y="-822.3699999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1653" id="1653">
      <mxCell style="link" parent="2675" source="1573" target="1575" edge="1">
        <mxGeometry x="-1200.9999999999998" y="-822.3699999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1200.9999999999998" y="-722.3699999999999" as="sourcePoint" />
          <mxPoint x="-1100.9999999999998" y="-822.3699999999999" as="targetPoint" />
          <Array as="points">
            <mxPoint x="459.00000000000057" y="117.63000000000011" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="Al new sec production capacity 2" Note="Gt/a capacity&lt;br&gt;" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1655" id="1655">
      <mxCell style="stock;fontSize=10;fillColor=#B3E2CD;" parent="2675" vertex="1">
        <mxGeometry x="581.0600000000004" y="105.06000000000017" width="53.81" height="52.57" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al sec cap retiring" Note="" FlowRate="Delay3([Al sec cap 2],[Al sec cap lifetime]-[Al sec cap min lifetime],0)" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1656" id="1656">
      <mxCell style="flow;fontSize=6;" parent="2675" source="1655" edge="1">
        <mxGeometry x="-777.35" y="-788.6299999999999" width="100" height="100" as="geometry">
          <mxPoint x="682.6500000000005" y="147.65499999999997" as="sourcePoint" />
          <mxPoint x="726.46" y="130.37000000000012" as="targetPoint" />
          <Array as="points" />
          <mxPoint x="-10" y="10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="Al sec cap lifetime" Note="&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; width=&quot;369&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;369&quot;&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr height=&quot;20&quot;&gt;&#xa;  &lt;td height=&quot;20&quot; class=&quot;xl64&quot; width=&quot;369&quot; style=&quot;height:15.0pt;width:277pt&quot;&gt;average&#xa;  lifetime of newly added recycling capacity&lt;/td&gt;&#xa;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;" Equation="25" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1657" id="1657">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2675" vertex="1">
        <mxGeometry x="665.0000000000005" y="146.73000000000002" width="51.75" height="23.64" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1658" id="1658">
      <mxCell style="link" parent="2675" source="1575" target="1656" edge="1">
        <mxGeometry x="-1200.9999999999998" y="-822.3699999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1200.9999999999998" y="-722.3699999999999" as="sourcePoint" />
          <mxPoint x="-1100.9999999999998" y="-822.3699999999999" as="targetPoint" />
          <Array as="points">
            <mxPoint x="603.94" y="92.26999999999998" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1659" id="1659">
      <mxCell style="link" parent="2675" source="1657" target="1656" edge="1">
        <mxGeometry x="-1200.9999999999998" y="-822.3699999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1200.9999999999998" y="-722.3699999999999" as="sourcePoint" />
          <mxPoint x="-1100.9999999999998" y="-822.3699999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1660" id="1660">
      <mxCell style="link" parent="2675" source="1651" target="1656" edge="1">
        <mxGeometry x="-1200.9999999999998" y="-822.3699999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1200.9999999999998" y="-722.3699999999999" as="sourcePoint" />
          <mxPoint x="-1100.9999999999998" y="-822.3699999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1661" id="1661">
      <mxCell style="link" parent="2675" source="1655" target="1965" edge="1">
        <mxGeometry x="-1200.9999999999998" y="-822.3699999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1200.9999999999998" y="-722.3699999999999" as="sourcePoint" />
          <mxPoint x="-1100.9999999999998" y="-822.3699999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al old sec cap lifetime" Note="" Equation="25" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1662" id="1662">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2675" vertex="1">
        <mxGeometry x="634.8699999999999" y="170.3699999999999" width="77.31" height="22.71" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1663" id="1663">
      <mxCell style="link" parent="2675" source="1662" target="1649" edge="1">
        <mxGeometry x="-1200.9999999999998" y="-822.3699999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1200.9999999999998" y="-722.3699999999999" as="sourcePoint" />
          <mxPoint x="-1100.9999999999998" y="-822.3699999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al recycling CF building threshold" Note="Factor describing from what CF onwards construction of new recycling facilities starts&lt;br&gt;" Equation="0.7" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1664" id="1664">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2675" vertex="1">
        <mxGeometry x="144.99000000000046" y="170.37000000000012" width="55" height="36.89" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="1578" oldId="1693" name="Al EOL" id="1693">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2675" vertex="1">
        <mxGeometry x="147.59000000000026" y="29.15000000000009" width="30" height="20.93" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1610" id="1610">
      <mxCell style="link" parent="2675" source="1632" target="1613" edge="1">
        <mxGeometry x="-1183.6799999999998" y="-865.1999999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1183.6799999999998" y="-765.1999999999998" as="sourcePoint" />
          <mxPoint x="416.3200000000003" y="24.800000000000182" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1594" id="1594">
      <mxCell style="link" parent="2675" source="1693" target="1602" edge="1">
        <mxGeometry x="-1184.6299999999999" y="-863.9999999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1184.6299999999999" y="-763.9999999999998" as="sourcePoint" />
          <mxPoint x="-1084.6299999999999" y="-863.9999999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1609" id="1609">
      <mxCell style="link" parent="2675" source="1693" target="1624" edge="1">
        <mxGeometry x="-1198.35" y="-919.4999999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1198.35" y="-819.4999999999998" as="sourcePoint" />
          <mxPoint x="-1098.35" y="-919.4999999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al recycling 2" Note="" Equation="If [Al recycling 1]&gt;[Al eff recycling capacity] Then&#xa;  [Al eff recycling capacity]&#xa;Else&#xa;  [Al recycling 1]&#xa;End If" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1739" LiveGraph="{&quot;active&quot;:false}" id="1739">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2675" vertex="1">
        <mxGeometry x="254.75000000000057" y="26.289999999999736" width="58.5" height="15" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al additional recycling capacity constructing" Note="" Equation="[Al additional recycling capacity ordered]*[Al recycling permitting factor]/[max capacity utilization factor]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1904" id="1904">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2675" vertex="1">
        <mxGeometry x="203.94000000000017" y="153.5999999999999" width="63.68" height="44.2" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1905" id="1905">
      <mxCell style="link" parent="2675" source="1904" target="1574" edge="1">
        <mxGeometry x="-1154.6299999999999" y="-1169.4199999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1154.6299999999999" y="-1069.4199999999998" as="sourcePoint" />
          <mxPoint x="-1054.6299999999999" y="-1169.4199999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al old recycling capacity" Note="&lt;div&gt;https://alucycle.international-aluminium.org/public-access/public-global-cycle/&lt;/div&gt;&lt;div&gt;Flow to in-use&lt;br&gt;&lt;/div&gt;" Equation="[Al old sec production capacity]*[Al old recycling capacity 0 ]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1907" id="1907">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2675" vertex="1">
        <mxGeometry x="499.00000000000034" y="153.5999999999999" width="48.57" height="34.24" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1908" id="1908">
      <mxCell style="link" parent="2675" source="1648" target="1907" edge="1">
        <mxGeometry x="-1154.6299999999999" y="-1169.4199999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1154.6299999999999" y="-1069.4199999999998" as="sourcePoint" />
          <mxPoint x="-1054.6299999999999" y="-1169.4199999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1939" oldId="1964" name="max capacity utilization factor" id="1964">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2675" vertex="1">
        <mxGeometry x="468.8599999999999" y="37.25999999999999" width="64.04" height="33.74" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="Al recycling capacity" Note="" Equation="([Al new sec production capacity]+[Al new sec production capacity 2])*{1 Gt/a}+[Al old recycling capacity]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1965" id="1965">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2675" vertex="1">
        <mxGeometry x="500.62" y="93.14999999999986" width="48.75" height="27.43" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1966" id="1966">
      <mxCell style="link" parent="2675" source="1965" target="1603" edge="1">
        <mxGeometry x="-1154.6299999999999" y="-1169.4199999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1154.6299999999999" y="-1069.4199999999998" as="sourcePoint" />
          <mxPoint x="-1054.6299999999999" y="-1169.4199999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1967" id="1967">
      <mxCell style="link" parent="2675" source="1964" target="1603" edge="1">
        <mxGeometry x="-1154.6299999999999" y="-1169.4199999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1154.6299999999999" y="-1069.4199999999998" as="sourcePoint" />
          <mxPoint x="-1054.6299999999999" y="-1169.4199999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al sec building function raw" Note="" Equation="If [Al recycling CF]&gt;[Al recycling CF building threshold] Then&#xa;  (([Al recycling CF]-[Al recycling CF building threshold])/(1-[Al recycling CF building threshold]))^[Al sec capacity building exponent]&#xa;Else&#xa;  0&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2376" id="2376">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2675" vertex="1">
        <mxGeometry x="92.12000000000035" y="140.0500000000004" width="46.63" height="37" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2377" id="2377">
      <mxCell style="link" parent="2675" source="1664" target="2376" edge="1">
        <mxGeometry x="-453.6399999999999" y="-1510.4099999999999" width="100" height="100" as="geometry">
          <mxPoint x="-453.6399999999999" y="-1410.4099999999999" as="sourcePoint" />
          <mxPoint x="-353.6399999999999" y="-1510.4099999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2378" id="2378">
      <mxCell style="link" parent="2675" source="1635" target="2376" edge="1">
        <mxGeometry x="-453.6399999999999" y="-1510.4099999999999" width="100" height="100" as="geometry">
          <mxPoint x="-453.6399999999999" y="-1410.4099999999999" as="sourcePoint" />
          <mxPoint x="-353.6399999999999" y="-1510.4099999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al sec cap building function" Note="" Equation="Min(1,Max(0,[Al sec building function raw]))" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2379" id="2379">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2675" vertex="1">
        <mxGeometry x="20" y="128.05999999999995" width="46.63" height="37" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2381" id="2381">
      <mxCell style="link" parent="2675" source="2376" target="2379" edge="1">
        <mxGeometry x="-453.6399999999999" y="-1510.4099999999999" width="100" height="100" as="geometry">
          <mxPoint x="-453.6399999999999" y="-1410.4099999999999" as="sourcePoint" />
          <mxPoint x="-353.6399999999999" y="-1510.4099999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2382" id="2382">
      <mxCell style="link" parent="2675" source="2379" target="1613" edge="1">
        <mxGeometry x="-453.6399999999999" y="-1510.4099999999999" width="100" height="100" as="geometry">
          <mxPoint x="-453.6399999999999" y="-1410.4099999999999" as="sourcePoint" />
          <mxPoint x="-353.6399999999999" y="-1510.4099999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al sec capacity building exponent" Note="" Equation="2" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="10" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2445" id="2445">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2675" vertex="1">
        <mxGeometry x="29.990000000000464" y="170.22000000000003" width="55" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2446" id="2446">
      <mxCell style="link" parent="2675" source="2445" target="2376" edge="1">
        <mxGeometry x="-453.6399999999999" y="-1510.4099999999999" width="100" height="100" as="geometry">
          <mxPoint x="-453.6399999999999" y="-1410.4099999999999" as="sourcePoint" />
          <mxPoint x="-353.6399999999999" y="-1510.4099999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al old recycling capacity 0 " Note="secondary production in 2026= 47Mt/a; capacity factor = 0.84&lt;br&gt;" Equation="0.055" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2552" id="2552">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2675" vertex="1">
        <mxGeometry x="500.8000000000003" y="201.05999999999995" width="48.57" height="34.24" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2553" id="2553">
      <mxCell style="link" parent="2675" source="2552" target="1907" edge="1">
        <mxGeometry x="-453.6399999999999" y="-1510.4099999999999" width="100" height="100" as="geometry">
          <mxPoint x="-453.6399999999999" y="-1410.4099999999999" as="sourcePoint" />
          <mxPoint x="-353.6399999999999" y="-1510.4099999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Converter name="Al old sec capacity retirement normalized L=20a" Note="Langhorst" Source="Time" Data="0,0.033482491; 1,0.035146797; 2,0.036810179; 3,0.038447208; 4,0.040027406; 5,0.041515318; 6,0.04287094; 7,0.044050587; 8,0.045008253; 9,0.045697465; 10,0.046073603; 11,0.046096593; 12,0.0457338; 13,0.044962899; 14,0.043774458; 15,0.042173931; 16,0.040182799; 17,0.037838619; 18,0.035193887; 19,0.032313695; 20,0.029272339; 21,0.026149143; 22,0.02302388; 23,0.019972217; 24,0.017061612; 25,0.014348032; 26,0.011873761; 27,0.009666407; 28,0.007739115; 29,0.006091805; 30,0.004713228; 31,0.003583495; 32,0.002676812; 33,0.001964112; 34,0.001415383; 35,0.001001542; 36,0.000695804; 37,0.000474533; 38,0.000317653; 39,0.000208687; 40,0.000134539; 41,0.000085108; 42,0.0000528226; 43,0.0000321634; 44,0.0000192116; 45,0.0000112563; 46,0.00000646886; 47,0.00000364615; 48,0.00000201555; 49,0.00000109265; 50,5.80865e-7; 51,3.02802e-7; 52,1.5478e-7; 53,7.75753e-8; 54,3.81217e-8; 55,1.83673e-8; 56,8.67624e-9; 57,4.01805e-9; 58,1.82426e-9; 59,8.1196e-10; 60,3.54281e-10; 61,1.51537e-10; 62,6.35382e-11; 63,2.6115e-11; 64,1.05215e-11; 65,4.15514e-12; 66,1.60846e-12; 67,6.10301e-13; 68,2.26977e-13; 69,8.27397e-14; 70,2.95623e-14; 71,1.03526e-14; 72,3.55335e-15; 73,1.19537e-15; 74,1.19537e-15" Interpolation="Linear" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2554" id="2554">
      <mxCell style="converter;fontSize=8;" parent="2675" vertex="1">
        <mxGeometry x="582.8600000000004" y="212.08000000000015" width="61.01" height="44.92" as="geometry" />
      </mxCell>
    </Converter>
    <Converter name="Al old sec capacity retirement normalized L=30a" Note="Langhorst" Source="Time" Data="0,0.01744327; 1,0.018339252; 2,0.019266119; 3,0.020220854; 4,0.021199299; 5,0.022196039; 6,0.023204307; 7,0.024215918; 8,0.025221251; 9,0.026209267; 10,0.027167596; 11,0.028082674; 12,0.028939954; 13,0.029724182; 14,0.030419739; 15,0.031011039; 16,0.031482983; 17,0.031821444; 18,0.032013766; 19,0.032049267; 20,0.031919707; 21,0.031619704; 22,0.031147075; 23,0.030503079; 24,0.029692541; 25,0.028723847; 26,0.027608806; 27,0.026362371; 28,0.025002244; 29,0.023548362; 30,0.022022298; 31,0.020446609; 32,0.018844144; 33,0.017237368; 34,0.015647709; 35,0.014094988; 36,0.012596917; 37,0.011168725; 38,0.009822889; 39,0.008569001; 40,0.007413744; 41,0.00636099; 42,0.005411987; 43,0.004565631; 44,0.003818792; 45,0.003166669; 46,0.002603173; 47,0.002121294; 48,0.001713449; 49,0.001371799; 50,0.00108852; 51,0.000856027; 52,0.000667151; 53,0.000515262; 54,0.000394348; 55,0.000299064; 56,0.000224731; 57,0.000167325; 58,0.000123438; 59,0.0000902203; 60,0.0000653312; 61,0.0000468688; 62,0.0000333105; 63,0.0000234533; 64,0.0000163583; 65,0.0000113025; 66,0.00000773584; 67,0.00000524474; 68,0.00000352222; 69,0.00000234302; 70,0.00000154382; 71,0.00000100755; 72,6.51307e-7; 73,4.17006e-7; 74,4.17006e-7" Interpolation="Linear" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2555" id="2555">
      <mxCell style="converter;fontSize=8;" parent="2675" vertex="1">
        <mxGeometry x="651.7300000000002" y="212.99000000000024" width="61.01" height="44.92" as="geometry" />
      </mxCell>
    </Converter>
    <Link name="Link" Note="" BiDirectional="false" oldId="2556" id="2556">
      <mxCell style="link" parent="2675" source="2554" target="1649" edge="1">
        <mxGeometry x="-453.6399999999999" y="-1510.4099999999999" width="100" height="100" as="geometry">
          <mxPoint x="-453.6399999999999" y="-1410.4099999999999" as="sourcePoint" />
          <mxPoint x="-353.6399999999999" y="-1510.4099999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2557" id="2557">
      <mxCell style="link" parent="2675" source="2555" target="1649" edge="1">
        <mxGeometry x="-453.6399999999999" y="-1510.4099999999999" width="100" height="100" as="geometry">
          <mxPoint x="-453.6399999999999" y="-1410.4099999999999" as="sourcePoint" />
          <mxPoint x="-353.6399999999999" y="-1510.4099999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1650" id="1650">
      <mxCell style="link" parent="2675" source="1907" target="1965" edge="1">
        <mxGeometry x="-1200.9999999999998" y="-822.3699999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1200.9999999999998" y="-722.3699999999999" as="sourcePoint" />
          <mxPoint x="-1100.9999999999998" y="-822.3699999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2597" id="2597">
      <mxCell style="link" parent="2675" source="1964" target="1904" edge="1">
        <mxGeometry x="-453.6399999999999" y="-1510.4099999999999" width="100" height="100" as="geometry">
          <mxPoint x="-453.6399999999999" y="-1410.4099999999999" as="sourcePoint" />
          <mxPoint x="-353.6399999999999" y="-1510.4099999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="Aluminium" Note="" Type="None" Solver="{&quot;enabled&quot;:false,&quot;algorithm&quot;:&quot;RK1&quot;,&quot;timeStep&quot;:1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="2672" id="2672">
      <mxCell style="folder" vertex="1" parent="1">
        <mxGeometry x="520.27" y="890" width="867.3399999999999" height="521.53" as="geometry" />
      </mxCell>
    </Folder>
    <Stock name="Al in ground" Note="" InitialValue="75" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1492" id="1492">
      <mxCell style="stock;fontSize=12;" parent="2672" vertex="1">
        <mxGeometry x="65.02000000000027" y="44.69999999999982" width="70" height="60" as="geometry" />
      </mxCell>
    </Stock>
    <Stock name="Al in use" Note="" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1493" id="1493">
      <mxCell style="stock;fontSize=12;" parent="2672" vertex="1">
        <mxGeometry x="331.1200000000002" y="318.0999999999999" width="70" height="20" as="geometry" />
      </mxCell>
    </Stock>
    <Stock name="Al market" Note="" InitialValue="[Al market stock 0]" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1494" LiveGraph="{&quot;active&quot;:false}" id="1494">
      <mxCell style="stock;fontSize=12;" parent="2672" vertex="1">
        <mxGeometry x="198.25000000000006" y="44.700000000000045" width="40" height="455.3" as="geometry" />
      </mxCell>
    </Stock>
    <Stock name="Al in fossil" Note="" InitialValue="[Al in fossil 2026]" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1495" id="1495">
      <mxCell style="stock;fontSize=12;" parent="2672" vertex="1">
        <mxGeometry x="331.1200000000002" y="381.79999999999995" width="70" height="26.3" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al primary" Note="" FlowRate="[Al primary 1]" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1497" id="1497">
      <mxCell style="flow;fontSize=8;" parent="2672" source="1492" target="1494" edge="1">
        <mxGeometry x="-1177.69" y="-619.49" width="100" height="100" as="geometry">
          <mxPoint x="-1211.75" y="-463.4200000000001" as="sourcePoint" />
          <mxPoint x="-1111.75" y="-563.4200000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="180.31000000000023" y="74.50999999999976" />
          </Array>
          <mxPoint x="-1" y="-4" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="Al supply to society" Note="" FlowRate="[Al demand by society]" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1498" id="1498">
      <mxCell style="flow;fontSize=8;" parent="2672" source="1494" target="1493" edge="1">
        <mxGeometry x="-1178.88" y="-401.9000000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1181.16" y="-235.93000000000006" as="sourcePoint" />
          <mxPoint x="-1081.16" y="-335.93000000000006" as="targetPoint" />
          <Array as="points">
            <mxPoint x="291.1200000000002" y="328.0999999999999" />
          </Array>
          <mxPoint x="-3" y="-10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="Al supply to PV flow" Note="" FlowRate="[Al supply to PV]" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1499" id="1499">
      <mxCell style="flow;fontSize=8;" parent="2672" source="1494" target="2051" edge="1">
        <mxGeometry x="-1175.82" y="-420.01" width="100" height="100" as="geometry">
          <mxPoint x="-1175.82" y="-330.29999999999995" as="sourcePoint" />
          <mxPoint x="-1075.82" y="-430.3000000000002" as="targetPoint" />
          <Array as="points">
            <mxPoint x="327.4199999999999" y="213.67000000000007" />
          </Array>
          <mxPoint x="-4" y="-10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="Al waste market" Note="" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1500" id="1500">
      <mxCell style="stock;fontSize=12;" parent="2672" vertex="1">
        <mxGeometry x="569.6099999999999" y="46.23000000000002" width="40" height="455.3" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al society eol" Note="" FlowRate="Delay3([Al supply to society], [Al lifetime], {0 Gt/a})" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1501" id="1501">
      <mxCell style="flow;fontSize=8;" parent="2672" source="1493" target="1500" edge="1">
        <mxGeometry x="-1205.64" y="-690.0200000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1177.57" y="-246.5999999999999" as="sourcePoint" />
          <mxPoint x="-1077.57" y="-346.60000000000014" as="targetPoint" />
          <Array as="points">
            <mxPoint x="432.4300000000001" y="327.98" />
          </Array>
          <mxPoint x="-41" y="-8" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="Al fC eol" Note="" FlowRate="[P_EoL fC total]*[fossil Al intensity]" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1502" id="1502">
      <mxCell style="flow;fontSize=8;" parent="2672" source="1495" target="1500" edge="1">
        <mxGeometry x="-1148.88" y="-621.9000000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1176.88" y="-181.22000000000003" as="sourcePoint" />
          <mxPoint x="-1076.88" y="-281.22" as="targetPoint" />
          <Array as="points">
            <mxPoint x="436.1200000000002" y="394.78" />
          </Array>
          <mxPoint x="-7" y="-7" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="Al PV eol" Note="" FlowRate="Delay3([Al PV 2], ([T_resPV]-[T_resPV_min])/{1 Years})" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1503" id="1503">
      <mxCell style="flow;fontSize=8;" parent="2672" source="2054" target="1500" edge="1">
        <mxGeometry x="-1145.82" y="-650.4100000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1172.82" y="-352.73" as="sourcePoint" />
          <mxPoint x="-1072.82" y="-452.73" as="targetPoint" />
          <Array as="points">
            <mxPoint x="483.4199999999999" y="212.8900000000001" />
          </Array>
          <mxPoint x="2" y="-4" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="Al waste" Note="" InitialValue="0.5" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1504" id="1504">
      <mxCell style="stock;fontSize=12;" parent="2672" vertex="1">
        <mxGeometry x="675.6100000000004" y="441.52999999999975" width="70" height="60" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al waste stream" Note="" FlowRate="[Al EOL]-[Al recycling]" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1505" id="1505">
      <mxCell style="flow;fontSize=8;" parent="2672" source="1500" target="1504" edge="1">
        <mxGeometry x="-1124.39" y="-281.2800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1080.39" y="-125.21000000000026" as="sourcePoint" />
          <mxPoint x="-980.3900000000001" y="-225.21000000000004" as="targetPoint" />
          <Array as="points">
            <mxPoint x="634.55" y="491.6899999999998" />
            <mxPoint x="645.6100000000004" y="438.7199999999998" />
            <mxPoint x="652.55" y="493.6899999999998" />
            <mxPoint x="662.55" y="493.6899999999998" />
            <mxPoint x="652.55" y="493.6899999999998" />
          </Array>
          <mxPoint x="-3" y="-10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="Al recycling" Note="" FlowRate="[Al recycling 2]" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1506" LiveGraph="{&quot;active&quot;:false}" id="1506">
      <mxCell style="flow;fontSize=8;" parent="2672" source="1500" target="1494" edge="1">
        <mxGeometry x="-1176.38" y="-373.38" width="100" height="100" as="geometry">
          <mxPoint x="-1176.38" y="-218.31000000000017" as="sourcePoint" />
          <mxPoint x="-1076.38" y="-318.31000000000006" as="targetPoint" />
          <Array as="points">
            <mxPoint x="373.6200000000002" y="491.69000000000005" />
          </Array>
          <mxPoint x="-75" y="-5" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Ghost Source="1202" oldId="1507" name="P_EoL fC total" id="1507">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="370.92999999999967" y="409.6700000000001" width="40" height="27.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="fossil Al intensity" Note="0.163 Gt Alu in 26.63 TWa energy embodied in fossil stock&lt;br&gt;" Equation="0.006121" Units="Gt/(TW*a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1508" id="1508">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="330.92999999999967" y="409.6700000000001" width="40" height="26" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1509" id="1509">
      <mxCell style="link" parent="2672" source="1508" target="1502" edge="1">
        <mxGeometry x="-1178.88" y="-329.20000000000005" width="100" height="100" as="geometry">
          <mxPoint x="-1178.88" y="-229.20000000000005" as="sourcePoint" />
          <mxPoint x="-1078.88" y="-329.20000000000005" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1510" id="1510">
      <mxCell style="link" parent="2672" source="1507" target="1502" edge="1">
        <mxGeometry x="-1178.88" y="-329.20000000000005" width="100" height="100" as="geometry">
          <mxPoint x="-1178.88" y="-229.20000000000005" as="sourcePoint" />
          <mxPoint x="-1078.88" y="-329.20000000000005" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1360" oldId="1518" name="P_supply to society curtailled" id="1518">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="654.4800000000005" y="401.4899999999998" width="50" height="29.93" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="560" oldId="1519" name="P_demand_0" id="1519">
      <mxCell style="variable;fontSize=12;fillColor=#FDCDAC;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="643.4200000000005" y="291.3599999999999" width="70" height="24" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="Al demand 0" Note="&lt;div&gt;https://alucycle.international-aluminium.org/public-access/public-global-cycle/&lt;/div&gt;&lt;div&gt;Flow to in-usein 2026&lt;br&gt;&lt;/div&gt;" Equation="0.0987" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1520" id="1520">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="659.4800000000005" y="249.05999999999972" width="40" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1521" id="1521">
      <mxCell style="link" parent="2672" source="1518" target="2064" edge="1">
        <mxGeometry x="-1298.95" y="-356.47" width="100" height="100" as="geometry">
          <mxPoint x="-1298.95" y="-256.47" as="sourcePoint" />
          <mxPoint x="-1198.95" y="-356.47" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="Al in use old" Note="" InitialValue="[Al in-use 2026]-[Al in fossil 2026]" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1534" id="1534">
      <mxCell style="stock;fontSize=12;" parent="2672" vertex="1">
        <mxGeometry x="330.92999999999967" y="297.02999999999975" width="70" height="21.07" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al eol old" Note="" FlowRate="If [Al in use old]&gt;{0 Gt} Then&#xa;  [Al eol outflow normalized]*([Al in-use 2026]-[Al in fossil 2026])&#xa;Else&#xa;  {0 Gt/a}&#xa;End If" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1536" id="1536">
      <mxCell style="flow;fontSize=8;" parent="2672" source="1534" target="1500" edge="1">
        <mxGeometry x="-1205.45" y="-685.5200000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1178.88" y="-251.42000000000007" as="sourcePoint" />
          <mxPoint x="-1078.88" y="-351.4200000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="441.1200000000002" y="312.5799999999997" />
          </Array>
          <mxPoint x="-41" y="-8" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Converter name="Al eol outflow normalized" Note="Langhorst et al. 2024&lt;br&gt;" Source="Time" Data="0,0.026738406; 1,0.017925098; 2,0.018787237; 3,0.019670355; 4,0.020561425; 5,0.021441347; 6,0.022284543; 7,0.02306014; 8,0.023735271; 9,0.024280256; 10,0.024674332; 11,0.024909875; 12,0.024993181; 13,0.024941188; 14,0.024775339; 15,0.024515162; 16,0.02417422; 17,0.023759751; 18,0.023275504; 19,0.02272592; 20,0.022119582; 21,0.021470601; 22,0.020797743; 23,0.020121973; 24,0.019463445; 25,0.018838831; 26,0.018259552; 27,0.017731072; 28,0.01725316; 29,0.01682087; 30,0.016425921; 31,0.016058196; 32,0.015707117; 33,0.015362757; 34,0.015016591; 35,0.014661919; 36,0.014293976; 37,0.013909824; 38,0.013508113; 39,0.013088768; 40,0.012652678; 41,0.012201409; 42,0.011736979; 43,0.011261672; 44,0.010777916; 45,0.010288193; 46,0.009794979; 47,0.009300712; 48,0.008807759; 49,0.0083184; 50,0.007834807; 51,0.00735903; 52,0.006892978; 53,0.006438405; 54,0.005996894; 55,0.005569846; 56,0.005158475; 57,0.004763796; 58,0.00438663; 59,0.004027601; 60,0.003687148; 61,0.00336553; 62,0.003062837; 63,0.002779006; 64,0.002513834; 65,0.002266993; 66,0.002038045; 67,0.001826459; 68,0.001631624; 69,0.001452862; 70,0.001289444; 71,0.0011406; 72,0.001005533; 73,0.000883424; 74,0.000883424" Interpolation="Linear" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1537" id="1537">
      <mxCell style="converter;fontSize=8;" parent="2672" vertex="1">
        <mxGeometry x="493.4199999999997" y="272.0699999999997" width="48" height="38.93" as="geometry" />
      </mxCell>
    </Converter>
    <Variable name="Al in-use 2026" Note="https://alucycle.international-aluminium.org/public-access/public-global-cycle/" Equation="1.485" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1538" id="1538">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="425.02000000000027" y="272.0699999999997" width="40" height="28.93" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1539" id="1539">
      <mxCell style="link" parent="2672" source="1538" target="1534" edge="1">
        <mxGeometry x="-1178.88" y="-346.83000000000015" width="100" height="100" as="geometry">
          <mxPoint x="-1178.88" y="-246.83000000000015" as="sourcePoint" />
          <mxPoint x="-1078.88" y="-346.83000000000015" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1541" id="1541">
      <mxCell style="link" parent="2672" source="1537" target="1536" edge="1">
        <mxGeometry x="-1178.88" y="-346.83000000000015" width="100" height="100" as="geometry">
          <mxPoint x="-1178.88" y="-246.83000000000015" as="sourcePoint" />
          <mxPoint x="-1078.88" y="-346.83000000000015" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al lifetime" Note="" Equation="23" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1542" id="1542">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="497.4199999999999" y="328.3399999999999" width="40" height="26.83" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1543" id="1543">
      <mxCell style="link" parent="2672" source="1542" target="1501" edge="1">
        <mxGeometry x="-1178.88" y="-346.83000000000015" width="100" height="100" as="geometry">
          <mxPoint x="-1178.88" y="-246.83000000000015" as="sourcePoint" />
          <mxPoint x="-1078.88" y="-346.83000000000015" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1544" id="1544">
      <mxCell style="link" parent="2672" source="1498" target="1501" edge="1">
        <mxGeometry x="-1182.5500000000002" y="-346.93000000000006" width="100" height="100" as="geometry">
          <mxPoint x="-1182.5500000000002" y="-246.93000000000006" as="sourcePoint" />
          <mxPoint x="-1082.5500000000002" y="-346.93000000000006" as="targetPoint" />
          <Array as="points">
            <mxPoint x="354.55" y="359.9999999999998" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al min dilution ratio" Note="" Equation="[Al dilution ratio inf]+([Al dilution ratio 0]-[Al dilution ratio inf])*Exp(-time()/[Al dilution tau])" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1545" id="1545">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="120.02000000000027" y="251.70000000000005" width="40" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al dilution ratio" Note="" Equation="If [Al recycling 2]={0 Gt/a} Then&#xa;  5&#xa;Else&#xa;  [Al primary 1]/[Al recycling 2]&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1546" LiveGraph="{&quot;active&quot;:false}" id="1546">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="62.7300000000003" y="134" width="40" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1547" id="1547">
      <mxCell style="link" parent="2672" source="1921" target="1546" edge="1">
        <mxGeometry x="-1211.75" y="-424.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1211.75" y="-324.29999999999995" as="sourcePoint" />
          <mxPoint x="-1111.75" y="-424.29999999999995" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1548" id="1548">
      <mxCell style="link" parent="2672" source="1750" target="1546" edge="1">
        <mxGeometry x="-1177.69" y="-425.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1077.69" y="-425.29999999999995" as="sourcePoint" />
          <mxPoint x="-1177.69" y="-325.29999999999995" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al max RR" Note="" Equation="[manufacturing scrap / EoL]*[Al max RR manufacturing scrap] + (1-[manufacturing scrap / EoL])*[Al max RR EoL scrap]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1549" id="1549">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="110.71999999999986" y="398.8799999999999" width="40" height="32.54" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al EOL" Note="&lt;div&gt;https://alucycle.international-aluminium.org/public-access/public-global-cycle/&lt;/div&gt;&lt;div&gt;Flow to in-use&lt;br&gt;&lt;/div&gt;" Equation="[Al PV eol]+[Al eol old]+[Al society eol]+[Al fC eol]+[Al storage eol]+[Al DAC eol]+[Al manufacturing scrap]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1578" id="1578">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="555.7300000000002" y="448.50999999999976" width="30" height="20.93" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1579" id="1579">
      <mxCell style="link" parent="2672" source="1503" target="1578" edge="1">
        <mxGeometry x="-1177.69" y="-425.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1177.69" y="-325.29999999999995" as="sourcePoint" />
          <mxPoint x="-1077.69" y="-425.29999999999995" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1580" id="1580">
      <mxCell style="link" parent="2672" source="1536" target="1578" edge="1">
        <mxGeometry x="-1177.69" y="-425.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1177.69" y="-325.29999999999995" as="sourcePoint" />
          <mxPoint x="-1077.69" y="-425.29999999999995" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1581" id="1581">
      <mxCell style="link" parent="2672" source="1501" target="1578" edge="1">
        <mxGeometry x="-1177.69" y="-425.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1177.69" y="-325.29999999999995" as="sourcePoint" />
          <mxPoint x="-1077.69" y="-425.29999999999995" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1582" id="1582">
      <mxCell style="link" parent="2672" source="1502" target="1578" edge="1">
        <mxGeometry x="-1177.69" y="-425.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1177.69" y="-325.29999999999995" as="sourcePoint" />
          <mxPoint x="-1077.69" y="-425.29999999999995" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al in-use stock" Note="" Equation="[Al in PV]+[Al in use old]+[Al in use]+[Al in fossil]+[Al in storage]+[Al in DAC]" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1587" id="1587">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="410.59999999999974" y="440.78" width="41.5" height="21.07" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1588" id="1588">
      <mxCell style="link" parent="2672" source="2053" target="1587" edge="1">
        <mxGeometry x="-1177.69" y="-425.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1177.69" y="-325.29999999999995" as="sourcePoint" />
          <mxPoint x="-1077.69" y="-425.29999999999995" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1589" id="1589">
      <mxCell style="link" parent="2672" source="1534" target="1587" edge="1">
        <mxGeometry x="-1177.69" y="-425.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1177.69" y="-325.29999999999995" as="sourcePoint" />
          <mxPoint x="-1077.69" y="-425.29999999999995" as="targetPoint" />
          <Array as="points">
            <mxPoint x="412.31000000000023" y="294.6999999999998" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1590" id="1590">
      <mxCell style="link" parent="2672" source="1493" target="1587" edge="1">
        <mxGeometry x="-1177.69" y="-425.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1177.69" y="-325.29999999999995" as="sourcePoint" />
          <mxPoint x="-1077.69" y="-425.29999999999995" as="targetPoint" />
          <Array as="points">
            <mxPoint x="412.31000000000023" y="314.6999999999998" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1591" id="1591">
      <mxCell style="link" parent="2672" source="1495" target="1587" edge="1">
        <mxGeometry x="-1177.69" y="-425.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1177.69" y="-325.29999999999995" as="sourcePoint" />
          <mxPoint x="-1077.69" y="-425.29999999999995" as="targetPoint" />
          <Array as="points">
            <mxPoint x="412.31000000000023" y="384.6999999999998" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1600" id="1600">
      <mxCell style="link" parent="2672" source="1545" target="1644" edge="1">
        <mxGeometry x="-1193.23" y="-324.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1193.23" y="-224.29999999999995" as="sourcePoint" />
          <mxPoint x="-1093.23" y="-324.29999999999995" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1601" id="1601">
      <mxCell style="link" parent="2672" source="1549" target="1645" edge="1">
        <mxGeometry x="-1193.23" y="-324.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1193.23" y="-224.29999999999995" as="sourcePoint" />
          <mxPoint x="-1093.23" y="-324.29999999999995" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al max recycling 1" Note="&lt;div&gt;https://alucycle.international-aluminium.org/public-access/public-global-cycle/&lt;/div&gt;&lt;div&gt;Flow to in-use&lt;br&gt;&lt;/div&gt;" Equation="Min([Al dilution requirement],[Al recycling max RR])&#xa;&#xa;#If [Al dilution requirement]&lt;[Al recycling max RR] Then&#xa;#  [Al dilution requirement]&#xa;#Else&#xa;#  [Al recycling max RR]&#xa;#End If" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1608" LiveGraph="{&quot;active&quot;:false}" id="1608">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="65.9800000000003" y="455.6899999999998" width="36.75" height="29.5" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al dilution requirement" Note="&lt;div&gt;https://alucycle.international-aluminium.org/public-access/public-global-cycle/&lt;/div&gt;&lt;div&gt;Flow to in-use&lt;br&gt;&lt;/div&gt;" Equation="Max({0 Gt/a},[Al primary 1]/[Al min dilution ratio])" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1644" id="1644">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="120.01999999999981" y="302.5799999999999" width="40" height="28.32" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al recycling max RR" Note="&lt;div&gt;https://alucycle.international-aluminium.org/public-access/public-global-cycle/&lt;/div&gt;&lt;div&gt;Flow to in-use&lt;br&gt;&lt;/div&gt;" Equation="[Al EOL]*[Al max RR]&#xa;" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1645" id="1645">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="129.4199999999999" y="455.6899999999998" width="45" height="29.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1646" id="1646">
      <mxCell style="link" parent="2672" source="1644" target="1608" edge="1">
        <mxGeometry x="-1193.23" y="-324.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1193.23" y="-224.29999999999995" as="sourcePoint" />
          <mxPoint x="-1093.23" y="-324.29999999999995" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1647" id="1647">
      <mxCell style="link" parent="2672" source="1645" target="1608" edge="1">
        <mxGeometry x="-1193.23" y="-324.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1193.23" y="-224.29999999999995" as="sourcePoint" />
          <mxPoint x="-1093.23" y="-324.29999999999995" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1694" id="1694">
      <mxCell style="link" parent="2672" source="1578" target="1505" edge="1">
        <mxGeometry x="-1177.69" y="-425.29999999999995" width="100" height="100" as="geometry">
          <mxPoint x="-1177.69" y="-325.29999999999995" as="sourcePoint" />
          <mxPoint x="-1077.69" y="-425.29999999999995" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="Al supply to fossil" Note="" FlowRate="[P_build_fC1]*[fossil Al intensity]" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1695" id="1695">
      <mxCell style="flow;fontSize=8;" parent="2672" source="1494" target="1495" edge="1">
        <mxGeometry x="-1165.5700000000002" y="-311.4200000000001" width="100" height="100" as="geometry">
          <mxPoint x="250.37000000000018" y="418.5799999999999" as="sourcePoint" />
          <mxPoint x="344.42999999999967" y="418.5799999999999" as="targetPoint" />
          <Array as="points">
            <mxPoint x="293.1200000000002" y="394.0999999999999" />
          </Array>
          <mxPoint x="-3" y="-10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Ghost Source="1055" name="P_build_fC1" oldId="1696" id="1696">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="238.80999999999977" y="405.91999999999985" width="86" height="20.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1697" id="1697">
      <mxCell style="link" parent="2672" source="1696" target="1695" edge="1">
        <mxGeometry x="-1178.88" y="-401.9000000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1178.88" y="-301.9000000000001" as="sourcePoint" />
          <mxPoint x="-1078.88" y="-401.9000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1698" id="1698">
      <mxCell style="link" parent="2672" source="1508" target="1695" edge="1">
        <mxGeometry x="-1178.88" y="-401.9000000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1178.88" y="-301.9000000000001" as="sourcePoint" />
          <mxPoint x="-1078.88" y="-401.9000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="Al supply to storage" Note="" FlowRate="[Al to storage]" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1700" id="1700">
      <mxCell style="flow;fontSize=8;" parent="2672" source="1494" target="2038" edge="1">
        <mxGeometry x="-1177.25" y="-464.48" width="100" height="100" as="geometry">
          <mxPoint x="238.69000000000034" y="135.2299999999998" as="sourcePoint" />
          <mxPoint x="-1077.25" y="-474.7700000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="304.55" y="138.70000000000005" />
          </Array>
          <mxPoint x="-4" y="-10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="Al storage eol" Note="" FlowRate="Delay3([Al storage 2], ([T_res storage]-[T_res storage_min])/{1 Years})" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1701" id="1701">
      <mxCell style="flow;fontSize=8;" parent="2672" source="2040" target="1500" edge="1">
        <mxGeometry x="-1147.69" y="-640.6" width="100" height="100" as="geometry">
          <mxPoint x="-1174.25" y="-400.4200000000001" as="sourcePoint" />
          <mxPoint x="516.7499999999998" y="135.58000000000015" as="targetPoint" />
          <Array as="points">
            <mxPoint x="455.55" y="138.70000000000005" />
          </Array>
          <mxPoint x="2" y="-7" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="Al in DAC 1" Note="" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1715" id="1715">
      <mxCell style="stock;fontSize=8;" parent="2672" vertex="1">
        <mxGeometry x="330.8999999999999" y="46.42000000000007" width="35.19" height="30" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al supply to DAC flow" Note="" FlowRate="[Al supply to DAC]" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1716" id="1716">
      <mxCell style="flow;fontSize=8;" parent="2672" source="1494" target="1715" edge="1">
        <mxGeometry x="-1177.25" y="-540.1800000000001" width="100" height="100" as="geometry">
          <mxPoint x="238.24999999999983" y="60.690000000000055" as="sourcePoint" />
          <mxPoint x="-1077.25" y="-550.47" as="targetPoint" />
          <Array as="points">
            <mxPoint x="300.31000000000023" y="58.69999999999982" />
          </Array>
          <mxPoint x="-4" y="-10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="Al DAC eol" Note="" FlowRate="Delay3([Al DAC 2], ([T_resCCS]-[T_resCCS_min])/{1 Years})" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1717" id="1717">
      <mxCell style="flow;fontSize=8;" parent="2672" source="2026" target="1500" edge="1">
        <mxGeometry x="-1147.69" y="-645.3" width="100" height="100" as="geometry">
          <mxPoint x="-1174.25" y="-476.1200000000001" as="sourcePoint" />
          <mxPoint x="516.3100000000002" y="60.690000000000055" as="targetPoint" />
          <Array as="points">
            <mxPoint x="459.31000000000023" y="59.5" />
          </Array>
          <mxPoint x="2" y="-4" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="1729" id="1729">
      <mxCell style="link" parent="2672" source="1701" target="1578" edge="1">
        <mxGeometry x="-1147.69" y="-645.3" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-545.3" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-645.3" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1730" id="1730">
      <mxCell style="link" parent="2672" source="1717" target="1578" edge="1">
        <mxGeometry x="-1147.69" y="-645.3" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-545.3" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-645.3" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al supply" Note="&lt;div&gt;https://alucycle.international-aluminium.org/public-access/public-global-cycle/&lt;/div&gt;&lt;div&gt;Flow to in-use&lt;br&gt;&lt;/div&gt;" Equation="([Al supply to fossil]+[Al supply to society]+[Al supply to PV flow]+[Al supply to storage]+[Al supply to DAC flow])*(1+[manufacturing scarp fraction])" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1731" id="1731">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="224.56000000000023" y="448.51" width="30" height="20.93" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1732" id="1732">
      <mxCell style="link" parent="2672" source="2041" target="1587" edge="1">
        <mxGeometry x="-1147.69" y="-645.3" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-545.3" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-645.3" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1733" id="1733">
      <mxCell style="link" parent="2672" source="2035" target="1587" edge="1">
        <mxGeometry x="-1147.69" y="-645.3" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-545.3" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-645.3" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1734" id="1734">
      <mxCell style="link" parent="2672" source="1695" target="1731" edge="1">
        <mxGeometry x="-1147.69" y="-645.3" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-545.3" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-645.3" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1735" id="1735">
      <mxCell style="link" parent="2672" source="1498" target="1731" edge="1">
        <mxGeometry x="-1147.69" y="-645.3" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-545.3" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-645.3" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1736" id="1736">
      <mxCell style="link" parent="2672" source="1499" target="1731" edge="1">
        <mxGeometry x="-1147.69" y="-645.3" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-545.3" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-645.3" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1737" id="1737">
      <mxCell style="link" parent="2672" source="1700" target="1731" edge="1">
        <mxGeometry x="-1147.69" y="-645.3" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-545.3" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-645.3" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1738" id="1738">
      <mxCell style="link" parent="2672" source="1716" target="1731" edge="1">
        <mxGeometry x="-1147.69" y="-645.3" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-545.3" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-645.3" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al dilution ratio 0" Note="" Equation="1.54" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1744" LiveGraph="{&quot;active&quot;:false}" id="1744">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="62.31000000000023" y="294.70000000000005" width="40" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al dilution ratio inf" Note="" Equation="0.5" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1745" id="1745">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="62.31000000000023" y="251.70000000000027" width="40" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al dilution tau" Note="" Equation="50" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1746" id="1746">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="62.31000000000023" y="204.42000000000007" width="40" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1747" id="1747">
      <mxCell style="link" parent="2672" source="1744" target="1545" edge="1">
        <mxGeometry x="-1147.69" y="-645.3" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-545.3" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-645.3" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1748" id="1748">
      <mxCell style="link" parent="2672" source="1745" target="1545" edge="1">
        <mxGeometry x="-1147.69" y="-645.3" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-545.3" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-645.3" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1749" id="1749">
      <mxCell style="link" parent="2672" source="1746" target="1545" edge="1">
        <mxGeometry x="-1147.69" y="-645.3" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-545.3" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-645.3" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1739" oldId="1750" name="Al recycling 2" id="1750">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="65.01999999999981" y="179.99999999999977" width="58.5" height="15" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="Al prim required" Note="" Equation="[Al supply]-[Al recycling 2]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1820" LiveGraph="{&quot;active&quot;:false}" id="1820">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="123.5200000000005" y="207.67000000000007" width="36.75" height="29.5" as="geometry" />
      </mxCell>
    </Variable>
    <Flow name="Al manufacturing scrap" Note="" FlowRate="[Al supply]*[manufacturing scarp fraction]" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1832" LiveGraph="{&quot;active&quot;:false}" id="1832">
      <mxCell style="flow;fontSize=8;" parent="2672" source="1494" target="1500" edge="1">
        <mxGeometry x="-1146" y="-379.51" width="100" height="100" as="geometry">
          <mxPoint x="484.06000000000023" y="529.9999999999998" as="sourcePoint" />
          <mxPoint x="269.94000000000034" y="485.55999999999995" as="targetPoint" />
          <Array as="points">
            <mxPoint x="454.06000000000023" y="479.9999999999998" />
          </Array>
          <mxPoint x="-75" y="-5" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="manufacturing scarp fraction" Note="&lt;div&gt;https://alucycle.international-aluminium.org/public-access/public-global-cycle/&lt;/div&gt;&lt;div&gt;manufacturing scrap / final products&lt;br&gt;&lt;/div&gt;" Equation="0.178" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1833" id="1833">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="324.55" y="448.36999999999966" width="70.72" height="20.93" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1834" id="1834">
      <mxCell style="link" parent="2672" source="1731" target="1832" edge="1">
        <mxGeometry x="-1147.69" y="-730.72" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-630.72" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-730.72" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1835" id="1835">
      <mxCell style="link" parent="2672" source="1833" target="1832" edge="1">
        <mxGeometry x="-1147.69" y="-730.72" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-630.72" as="sourcePoint" />
          <mxPoint x="372.31000000000023" y="429.27999999999975" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1528" id="1528">
      <mxCell style="link" parent="2672" source="1750" target="1820" edge="1">
        <mxGeometry x="-1177.69" y="-370.23" width="100" height="100" as="geometry">
          <mxPoint x="-1077.69" y="-370.23" as="sourcePoint" />
          <mxPoint x="-1177.69" y="-270.23" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1836" id="1836">
      <mxCell style="link" parent="2672" source="1832" target="1578" edge="1">
        <mxGeometry x="-1147.69" y="-730.72" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-630.72" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-730.72" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1918" id="1918">
      <mxCell style="link" parent="2672" source="1833" target="1731" edge="1">
        <mxGeometry x="-1147.69" y="-730.72" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-630.72" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-730.72" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1872" oldId="1921" name="Al primary 1" id="1921">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="106.47000000000008" y="114.48000000000002" width="53.97" height="14.51" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1922" id="1922">
      <mxCell style="link" parent="2672" source="1921" target="1497" edge="1">
        <mxGeometry x="-1147.69" y="-730.72" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-630.72" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-730.72" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al market stock" Note="" Equation="[Al market]" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1958" LiveGraph="{&quot;active&quot;:false}" id="1958">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="161.50000000000028" y="207.67000000000007" width="36.75" height="29.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1959" id="1959">
      <mxCell style="link" parent="2672" source="1494" target="1958" edge="1">
        <mxGeometry x="-1147.69" y="-730.72" width="100" height="100" as="geometry">
          <mxPoint x="-1147.69" y="-630.72" as="sourcePoint" />
          <mxPoint x="-1047.69" y="-730.72" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="Al in DAC 2" Note="" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="2026" id="2026">
      <mxCell style="stock;fontSize=8;" parent="2672" vertex="1">
        <mxGeometry x="434.83" y="46.42000000000007" width="30.19" height="30" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al DAC 2" Note="" FlowRate="Delay([Al supply to DAC flow], [T_resCCS_min]/{1 Years}, 0)" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2027" id="2027">
      <mxCell style="flow;fontSize=6;" parent="2672" source="1715" target="2026" edge="1">
        <mxGeometry x="22.31000000000023" y="-174.5" width="100" height="100" as="geometry">
          <mxPoint x="22.31000000000023" y="-74.5" as="sourcePoint" />
          <mxPoint x="122.31000000000023" y="-174.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Ghost Source="169" oldId="2029" name="T_resCCS" id="2029">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="509.60999999999996" y="78.7199999999998" width="60" height="12.83" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="577" oldId="2028" name="T_resCCS_min" id="2028">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="447.9800000000001" y="78.53999999999996" width="60" height="13.01" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2030" id="2030">
      <mxCell style="link" parent="2672" source="2028" target="2027" edge="1">
        <mxGeometry x="22.31000000000023" y="-174.5" width="100" height="100" as="geometry">
          <mxPoint x="22.31000000000023" y="-74.5" as="sourcePoint" />
          <mxPoint x="122.31000000000023" y="-174.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2031" id="2031">
      <mxCell style="link" parent="2672" source="2029" target="1717" edge="1">
        <mxGeometry x="22.31000000000023" y="-174.5" width="100" height="100" as="geometry">
          <mxPoint x="22.31000000000023" y="-74.5" as="sourcePoint" />
          <mxPoint x="122.31000000000023" y="-174.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2032" id="2032">
      <mxCell style="link" parent="2672" source="2028" target="1717" edge="1">
        <mxGeometry x="22.31000000000023" y="-174.5" width="100" height="100" as="geometry">
          <mxPoint x="22.31000000000023" y="-74.5" as="sourcePoint" />
          <mxPoint x="122.31000000000023" y="-174.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2033" id="2033">
      <mxCell style="link" parent="2672" source="1716" target="2027" edge="1">
        <mxGeometry x="22.31000000000023" y="-174.5" width="100" height="100" as="geometry">
          <mxPoint x="22.31000000000023" y="-74.5" as="sourcePoint" />
          <mxPoint x="122.31000000000023" y="-174.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="354.55" y="20" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2034" id="2034">
      <mxCell style="link" parent="2672" source="2027" target="1717" edge="1">
        <mxGeometry x="22.31000000000023" y="-174.5" width="100" height="100" as="geometry">
          <mxPoint x="22.31000000000023" y="-74.5" as="sourcePoint" />
          <mxPoint x="122.31000000000023" y="-174.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="444.55" y="20" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al in DAC" Note="" Equation="[Al in DAC 1]+[Al in DAC 2]" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2035" id="2035">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="364.83" y="78.04999999999995" width="70" height="14" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2036" id="2036">
      <mxCell style="link" parent="2672" source="1715" target="2035" edge="1">
        <mxGeometry x="22.31000000000023" y="-174.5" width="100" height="100" as="geometry">
          <mxPoint x="22.31000000000023" y="-74.5" as="sourcePoint" />
          <mxPoint x="122.31000000000023" y="-174.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2037" id="2037">
      <mxCell style="link" parent="2672" source="2026" target="2035" edge="1">
        <mxGeometry x="22.31000000000023" y="-174.5" width="100" height="100" as="geometry">
          <mxPoint x="22.31000000000023" y="-74.5" as="sourcePoint" />
          <mxPoint x="122.31000000000023" y="-174.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="Al in storage 1" Note="" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="2038" id="2038">
      <mxCell style="stock;fontSize=8;" parent="2672" vertex="1">
        <mxGeometry x="330.90000000000015" y="125.15000000000009" width="35.19" height="30" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al storage 2" Note="" FlowRate="Delay([Al supply to storage], [T_res storage_min]/{1 Years}, 0)" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2039" id="2039">
      <mxCell style="flow;fontSize=6;" parent="2672" source="2038" target="2040" edge="1">
        <mxGeometry x="-1183.94" y="-605.1700000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1183.94" y="-505.1700000000002" as="sourcePoint" />
          <mxPoint x="-1083.9400000000003" y="-605.1700000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="Al in storage 2" Note="" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="2040" id="2040">
      <mxCell style="stock;fontSize=8;" parent="2672" vertex="1">
        <mxGeometry x="433.6100000000002" y="124.21000000000004" width="30.19" height="30" as="geometry" />
      </mxCell>
    </Stock>
    <Variable name="Al in storage" Note="" Equation="[Al in storage 1]+[Al in storage 2]" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2041" id="2041">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="366.1800000000001" y="154.70000000000005" width="68.37" height="14.07" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2042" id="2042">
      <mxCell style="link" parent="2672" source="2038" target="2041" edge="1">
        <mxGeometry x="-100.08999999999963" y="-63.75" width="100" height="100" as="geometry">
          <mxPoint x="-100.08999999999963" y="36.25" as="sourcePoint" />
          <mxPoint x="-0.08999999999963393" y="-63.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2043" id="2043">
      <mxCell style="link" parent="2672" source="2040" target="2041" edge="1">
        <mxGeometry x="-100.08999999999963" y="-63.75" width="100" height="100" as="geometry">
          <mxPoint x="-100.08999999999963" y="36.25" as="sourcePoint" />
          <mxPoint x="-0.08999999999963393" y="-63.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1104" oldId="2044" name="T_res storage_min" id="2044">
      <mxCell style="variable;fontSize=6;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="452.7300000000001" y="154.9000000000001" width="58.5" height="13.87" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1100" oldId="2045" name="T_res storage" id="2045">
      <mxCell style="variable;fontSize=6;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="514.55" y="154.21000000000004" width="54.27" height="15.25" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2046" id="2046">
      <mxCell style="link" parent="2672" source="2045" target="1701" edge="1">
        <mxGeometry x="-1205.45" y="-685.3000000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-585.3000000000001" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-685.3000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2047" id="2047">
      <mxCell style="link" parent="2672" source="2044" target="2039" edge="1">
        <mxGeometry x="-1205.45" y="-685.3000000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-585.3000000000001" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-685.3000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2048" id="2048">
      <mxCell style="link" parent="2672" source="2044" target="1701" edge="1">
        <mxGeometry x="-1205.45" y="-685.3000000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-585.3000000000001" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-685.3000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2049" id="2049">
      <mxCell style="link" parent="2672" source="1700" target="2039" edge="1">
        <mxGeometry x="-1205.45" y="-685.3000000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-585.3000000000001" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-685.3000000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="344.55" y="100" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2050" id="2050">
      <mxCell style="link" parent="2672" source="2039" target="1701" edge="1">
        <mxGeometry x="-1205.45" y="-685.3000000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-585.3000000000001" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-685.3000000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="444.55" y="100" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="Al in PV 1" Note="" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="2051" id="2051">
      <mxCell style="stock;fontSize=8;" parent="2672" vertex="1">
        <mxGeometry x="335.78000000000003" y="199.7800000000002" width="35.19" height="30" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al PV 2" Note="" FlowRate="Delay([Al supply to PV flow], [T_resPV_min]/{1 Years}, 0)" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2052" id="2052">
      <mxCell style="flow;fontSize=6;" parent="2672" source="2051" target="2054" edge="1">
        <mxGeometry x="-1179.06" y="-530.54" width="100" height="100" as="geometry">
          <mxPoint x="-1179.06" y="-430.5400000000002" as="sourcePoint" />
          <mxPoint x="-1079.0600000000002" y="-530.54" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="Al in PV" Note="" Equation="[Al in PV 1]+[Al in PV 2]" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2053" id="2053">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="371.06" y="229.33000000000015" width="68.37" height="14.07" as="geometry" />
      </mxCell>
    </Variable>
    <Stock name="Al in PV 2" Note="" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="2054" id="2054">
      <mxCell style="stock;fontSize=8;" parent="2672" vertex="1">
        <mxGeometry x="438.49000000000007" y="198.84000000000015" width="30.19" height="30" as="geometry" />
      </mxCell>
    </Stock>
    <Link name="Link" Note="" BiDirectional="false" oldId="2055" id="2055">
      <mxCell style="link" parent="2672" source="2051" target="2053" edge="1">
        <mxGeometry x="-1203.58" y="-671.45" width="100" height="100" as="geometry">
          <mxPoint x="-1203.58" y="-571.45" as="sourcePoint" />
          <mxPoint x="-1103.58" y="-671.45" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2056" id="2056">
      <mxCell style="link" parent="2672" source="2054" target="2053" edge="1">
        <mxGeometry x="-1203.58" y="-671.45" width="100" height="100" as="geometry">
          <mxPoint x="-1203.58" y="-571.45" as="sourcePoint" />
          <mxPoint x="-1103.58" y="-671.45" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="571" oldId="2057" name="T_resPV_min" id="2057">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="454.59999999999974" y="231.36000000000013" width="62.97" height="10" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="183" oldId="2058" name="T_resPV" id="2058">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="516.4199999999998" y="230.70000000000005" width="54.27" height="11.33" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2059" id="2059">
      <mxCell style="link" parent="2672" source="2057" target="2052" edge="1">
        <mxGeometry x="-1203.58" y="-671.45" width="100" height="100" as="geometry">
          <mxPoint x="-1203.58" y="-571.45" as="sourcePoint" />
          <mxPoint x="-1103.58" y="-671.45" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2060" id="2060">
      <mxCell style="link" parent="2672" source="2058" target="1503" edge="1">
        <mxGeometry x="-1203.58" y="-671.45" width="100" height="100" as="geometry">
          <mxPoint x="-1203.58" y="-571.45" as="sourcePoint" />
          <mxPoint x="-1103.58" y="-671.45" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2061" id="2061">
      <mxCell style="link" parent="2672" source="2057" target="1503" edge="1">
        <mxGeometry x="-1203.58" y="-671.45" width="100" height="100" as="geometry">
          <mxPoint x="-1203.58" y="-571.45" as="sourcePoint" />
          <mxPoint x="-1103.58" y="-671.45" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2062" id="2062">
      <mxCell style="link" parent="2672" source="1499" target="2052" edge="1">
        <mxGeometry x="-1205.45" y="-690" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-590" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-690" as="targetPoint" />
          <Array as="points">
            <mxPoint x="354.55" y="170" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2063" id="2063">
      <mxCell style="link" parent="2672" source="2052" target="1503" edge="1">
        <mxGeometry x="-1205.45" y="-690" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-590" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-690" as="targetPoint" />
          <Array as="points">
            <mxPoint x="454.55" y="170" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al demand by society" Note="&lt;div&gt;https://alucycle.international-aluminium.org/public-access/public-global-cycle/&lt;/div&gt;&lt;div&gt;Flow to in-use&lt;br&gt;&lt;/div&gt;" Equation="[societal Al intensity]*[P_supply to society curtailled]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2064" id="2064">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="723.3499999999999" y="398.45999999999935" width="41.13" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2065" id="2065">
      <mxCell style="link" parent="2672" source="2066" target="1498" edge="1">
        <mxGeometry x="-1205.45" y="-690" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-590" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-690" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2064" oldId="2066" name="Al demand by society" id="2066">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="282.00000000000006" y="283.2399999999998" width="46.32" height="26.76" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2068" id="2068">
      <mxCell style="link" parent="2672" source="1520" target="2079" edge="1">
        <mxGeometry x="-1325.52" y="-699.6400000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1325.52" y="-599.6400000000001" as="sourcePoint" />
          <mxPoint x="641.8110018334746" y="290.4030259406825" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2069" id="2069">
      <mxCell style="link" parent="2672" source="1519" target="2079" edge="1">
        <mxGeometry x="-1325.52" y="-699.6400000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1325.52" y="-599.6400000000001" as="sourcePoint" />
          <mxPoint x="621.495370496692" y="319.52086118962416" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="societal Al intensity inf factor" Note="factor to which societal Al intensity converges compared to at start of simulation&lt;br&gt;" Equation="0.9478" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2070" id="2070">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="653.4200000000001" y="357.11999999999966" width="51.06" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="societal Al intensity tau" Note="time constant&lt;br&gt;" Equation="12" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2071" id="2071">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="653.4200000000001" y="318.6999999999996" width="50" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2074" id="2074">
      <mxCell style="link" parent="2672" source="2070" target="2080" edge="1">
        <mxGeometry x="-1325.52" y="-699.6400000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1325.52" y="-599.6400000000001" as="sourcePoint" />
          <mxPoint x="-1225.52" y="-699.6400000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2075" id="2075">
      <mxCell style="link" parent="2672" source="2071" target="2080" edge="1">
        <mxGeometry x="-1325.52" y="-699.6400000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1325.52" y="-599.6400000000001" as="sourcePoint" />
          <mxPoint x="-1225.52" y="-699.6400000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2076" id="2076">
      <mxCell style="link" parent="2672" source="2080" target="2064" edge="1">
        <mxGeometry x="-1325.52" y="-699.6400000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1325.52" y="-599.6400000000001" as="sourcePoint" />
          <mxPoint x="-1225.52" y="-699.6400000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="societal Al intensity 0" Note="Al consumption per average power demand at start of simulation&lt;br&gt;" Equation="[Al demand 0]/[P_demand_0]" Units="(Gt/a)/TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2079" id="2079">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="717.8600000000001" y="268.2699999999995" width="51.06" height="34.54" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1585" id="1585">
      <mxCell style="link" parent="2672" source="1506" target="1505" edge="1">
        <mxGeometry x="-584.66" y="632.31" width="100" height="100" as="geometry">
          <mxPoint x="-484.65999999999997" y="632.31" as="sourcePoint" />
          <mxPoint x="-584.66" y="732.31" as="targetPoint" />
          <Array as="points">
            <mxPoint x="1057.58" y="1532.6799999999998" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="societal Al intensity" Note="Al consumption per average power demand&lt;br&gt;" Equation="[societal Al intensity 0]*(1+([societal Al intensity increase factor]-1)*(1-exp(-Time()/[societal Al intensity tau]))-([societal Al intensity increase factor]-[societal Al intensity inf factor])/(2100-2026)*Time()/{1 a})&#xa;&#xa;#[societal Al intensity 0]*([societal Al intensity inf factor]+(1-[societal Al intensity inf factor])*exp(-Time()/[societal Al intensity tau]))" Units="(Gt/a)/TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2080" id="2080">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="718.9200000000001" y="340.12999999999965" width="50" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="2094" oldId="2098" name="Al supply to PV" id="2098">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="288.32" y="225.08999999999992" width="40" height="22.53" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2099" id="2099">
      <mxCell style="link" parent="2672" source="2098" target="1499" edge="1">
        <mxGeometry x="-1205.45" y="-690" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-590" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-690" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2108" id="2108">
      <mxCell style="link" parent="2672" source="1731" target="1820" edge="1">
        <mxGeometry x="-1205.45" y="-690" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-590" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-690" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2127" oldId="2131" name="Al to storage" id="2131">
      <mxCell style="variable;fontSize=6;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="287.6900000000001" y="147.3599999999999" width="40.63" height="24.36" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2132" id="2132">
      <mxCell style="link" parent="2672" source="2131" target="1700" edge="1">
        <mxGeometry x="-1205.45" y="-690" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-590" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-690" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al in-use in society" Note="" Equation="[Al in use]+[Al in use old]" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2181" id="2181">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="329.76000000000005" y="271.1399999999999" width="71.17" height="24.7" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2182" id="2182">
      <mxCell style="link" parent="2672" source="1493" target="2181" edge="1">
        <mxGeometry x="-1205.45" y="-690" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-590" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-690" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2183" id="2183">
      <mxCell style="link" parent="2672" source="1534" target="2181" edge="1">
        <mxGeometry x="-1205.45" y="-690" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-590" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-690" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2299" oldId="2300" name="Al supply to DAC" id="2300">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="285.1599999999999" y="62.34999999999991" width="40" height="27.65" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2301" id="2301">
      <mxCell style="link" parent="2672" source="2300" target="1716" edge="1">
        <mxGeometry x="-1205.45" y="-690" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-590" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-690" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2327" id="2327">
      <mxCell style="link" parent="2672" source="1921" target="1644" edge="1">
        <mxGeometry x="-1205.45" y="-690" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-590" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-690" as="targetPoint" />
          <Array as="points">
            <mxPoint x="84.55000000000001" y="259.9999999999998" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al CO2 intensity" Note="direct process emissions; kg CO2 per kg primary Al; see EI391&lt;br&gt;" Equation="3" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2328" id="2328">
      <mxCell style="variable;fontSize=8;fillColor=#CCFFFF;" parent="2672" vertex="1">
        <mxGeometry x="129.42000000000013" y="173.3599999999999" width="66.06" height="17.02" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al prim CO2 emissions" Note="direct process emissions; kg CO2 per kg primary Al; see EI391&lt;br&gt;" Equation="[Al CO2 intensity]*[Al primary]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2329" id="2329">
      <mxCell style="variable;fontSize=8;fillColor=#CCFFFF;" parent="2672" vertex="1">
        <mxGeometry x="129.4199999999999" y="133.46000000000004" width="66.06" height="26.54" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2330" id="2330">
      <mxCell style="link" parent="2672" source="2328" target="2329" edge="1">
        <mxGeometry x="-1205.45" y="-690" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-590" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-690" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2331" id="2331">
      <mxCell style="link" parent="2672" source="1497" target="2329" edge="1">
        <mxGeometry x="-1205.45" y="-690" width="100" height="100" as="geometry">
          <mxPoint x="-1205.45" y="-590" as="sourcePoint" />
          <mxPoint x="-1105.45" y="-690" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al market stock 0" Note="" Equation="0.01" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2397" LiveGraph="{&quot;active&quot;:false}" id="2397">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="161.52000000000027" y="253.74" width="36.75" height="29.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2398" id="2398">
      <mxCell style="link" parent="2672" source="2397" target="1494" edge="1">
        <mxGeometry x="-443.03000000000003" y="-1012.6800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-443.03000000000003" y="-912.6800000000001" as="sourcePoint" />
          <mxPoint x="-343.03000000000003" y="-1012.6800000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al in fossil 2026" Note="Schlesier et al. 2024&lt;br&gt;" Equation="0.163" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2461" id="2461">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="423.80000000000024" y="357.9999999999998" width="40" height="28.93" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2462" id="2462">
      <mxCell style="link" parent="2672" source="2461" target="1495" edge="1">
        <mxGeometry x="-443.03000000000003" y="-1012.6800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-443.03000000000003" y="-912.6800000000001" as="sourcePoint" />
          <mxPoint x="-343.03000000000003" y="-1012.6800000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2463" id="2463">
      <mxCell style="link" parent="2672" source="2461" target="1534" edge="1">
        <mxGeometry x="-443.03000000000003" y="-1012.6800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-443.03000000000003" y="-912.6800000000001" as="sourcePoint" />
          <mxPoint x="-343.03000000000003" y="-1012.6800000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="426.96999999999997" y="317.31999999999994" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2495" id="2495">
      <mxCell style="link" parent="2672" source="1731" target="1608" edge="1">
        <mxGeometry x="-443.03000000000003" y="-1012.6800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-443.03000000000003" y="-912.6800000000001" as="sourcePoint" />
          <mxPoint x="-343.03000000000003" y="-1012.6800000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="146.96999999999997" y="417.31999999999994" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="manufacturing scrap / EoL" Note="&lt;div&gt;manufacturing scrap flow / end of life material flow&lt;br&gt;&lt;/div&gt;" Equation="[Al manufacturing scrap]/[Al EOL]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2531" id="2531">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2672" vertex="1">
        <mxGeometry x="470.7" y="440.9199999999996" width="70.72" height="20.93" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2532" id="2532">
      <mxCell style="link" parent="2672" source="1832" target="2531" edge="1">
        <mxGeometry x="-446.13000000000005" y="-1021.0600000000001" width="100" height="100" as="geometry">
          <mxPoint x="-446.13000000000005" y="-921.0600000000001" as="sourcePoint" />
          <mxPoint x="-346.13" y="-1021.0600000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2533" id="2533">
      <mxCell style="link" parent="2672" source="1578" target="2531" edge="1">
        <mxGeometry x="-443.03000000000003" y="-1012.6800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-443.03000000000003" y="-912.6800000000001" as="sourcePoint" />
          <mxPoint x="-343.03000000000003" y="-1012.6800000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al max RR manufacturing scrap" Note="" Equation="0.99" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2534" id="2534">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="36.96999999999997" y="365.91999999999985" width="60" height="32.54" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al max RR EoL scrap" Note="" Equation="0.8" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2535" id="2535">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="150.71999999999986" y="366.3399999999997" width="40" height="32.54" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2536" id="2536">
      <mxCell style="link" parent="2672" source="2535" target="1549" edge="1">
        <mxGeometry x="-443.03000000000003" y="-1012.6800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-443.03000000000003" y="-912.6800000000001" as="sourcePoint" />
          <mxPoint x="-343.03000000000003" y="-1012.6800000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2537" id="2537">
      <mxCell style="link" parent="2672" source="2534" target="1549" edge="1">
        <mxGeometry x="-443.03000000000003" y="-1012.6800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-443.03000000000003" y="-912.6800000000001" as="sourcePoint" />
          <mxPoint x="-343.03000000000003" y="-1012.6800000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2538" id="2538">
      <mxCell style="link" parent="2672" source="2539" target="1549" edge="1">
        <mxGeometry x="-443.03000000000003" y="-1012.6800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-443.03000000000003" y="-912.6800000000001" as="sourcePoint" />
          <mxPoint x="-343.03000000000003" y="-1012.6800000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2531" oldId="2539" name="manufacturing scrap / EoL" id="2539">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2672" vertex="1">
        <mxGeometry x="20" y="409.6699999999996" width="70.72" height="20.93" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2591" id="2591">
      <mxCell style="link" parent="2672" source="1538" target="1536" edge="1">
        <mxGeometry x="-443.03000000000003" y="-1012.6800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-443.03000000000003" y="-912.6800000000001" as="sourcePoint" />
          <mxPoint x="-343.03000000000003" y="-1012.6800000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2592" id="2592">
      <mxCell style="link" parent="2672" source="2461" target="1536" edge="1">
        <mxGeometry x="-443.03000000000003" y="-1012.6800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-443.03000000000003" y="-912.6800000000001" as="sourcePoint" />
          <mxPoint x="-343.03000000000003" y="-1012.6800000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="societal Al intensity increase factor" Note="factor to which societal Al intensity aim to in the beginning&lt;br&gt;" Equation="1.404" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2595" id="2595">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2672" vertex="1">
        <mxGeometry x="796.28" y="340.8299999999997" width="51.06" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2596" id="2596">
      <mxCell style="link" parent="2672" source="2595" target="2080" edge="1">
        <mxGeometry x="-443.03000000000003" y="-1012.6800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-443.03000000000003" y="-912.6800000000001" as="sourcePoint" />
          <mxPoint x="-343.03000000000003" y="-1012.6800000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2073" id="2073">
      <mxCell style="link" parent="2672" source="2079" target="2080" edge="1">
        <mxGeometry x="-1325.52" y="-699.6400000000001" width="100" height="100" as="geometry">
          <mxPoint x="665.5008618100328" y="306.6740926821233" as="sourcePoint" />
          <mxPoint x="-1225.52" y="-699.6400000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="PV Switch" Note="" Type="None" Solver="{&quot;enabled&quot;:false,&quot;algorithm&quot;:&quot;RK1&quot;,&quot;timeStep&quot;:1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="2669" id="2669">
      <mxCell style="folder" vertex="1" parent="1">
        <mxGeometry x="1556.91" y="1590.9899999999998" width="286.50000000000045" height="253.3699999999999" as="geometry" />
      </mxCell>
    </Folder>
    <Variable name="PV Al intensity" Note="" Equation="If [PV material intensity switch]=0 Then&#xa;  [PV Al intensity framed]&#xa;Else If [PV material intensity switch]=2 Then&#xa;  [PV Al intensity frameless]&#xa;Else&#xa;  [PV Al intensity frameless]+([PV Al intensity framed]-[PV Al intensity frameless])*exp(-Time()/[PV Al intensity tau])&#xa;End If" Units="(Gt/a)/(TW/a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1511" id="1511">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2669" vertex="1">
        <mxGeometry x="139.94000000000005" y="92.10000000000014" width="40" height="40.39" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="2085" oldId="2086" name="PV cap building" id="2086">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="2669" vertex="1">
        <mxGeometry x="229.00000000000045" y="56.5" width="37.5" height="23.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="PV Al intensity frameless" Note="" Equation="0.00700202764976959" Units="(Gt/a)/(TW/a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2088" id="2088">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2669" vertex="1">
        <mxGeometry x="75.87000000000057" y="92.09999999999991" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="PV material intensity switch" Note="&lt;div&gt;0 = framed, no learning&lt;/div&gt;&lt;div&gt;1 = gradual switch from framed to frameless&lt;/div&gt;&lt;div&gt;2 = frameless, no further learning&lt;br&gt;&lt;/div&gt;" Equation="0" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="2" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2089" LiveGraph="{&quot;active&quot;:false}" id="2089">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="2669" vertex="1">
        <mxGeometry x="157.20000000000027" y="20" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="PV Al intensity tau" Note="time constant&lt;br&gt;" Equation="60" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2090" id="2090">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2669" vertex="1">
        <mxGeometry x="75.87000000000012" y="39.99999999999977" width="40" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2092" id="2092">
      <mxCell style="link" parent="2669" source="2090" target="1511" edge="1">
        <mxGeometry x="-2134.83" y="-1260.6399999999999" width="100" height="100" as="geometry">
          <mxPoint x="-2134.83" y="-1160.6399999999999" as="sourcePoint" />
          <mxPoint x="-2034.83" y="-1260.6399999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2093" id="2093">
      <mxCell style="link" parent="2669" source="2088" target="1511" edge="1">
        <mxGeometry x="-2134.83" y="-1260.6399999999999" width="100" height="100" as="geometry">
          <mxPoint x="-2134.83" y="-1160.6399999999999" as="sourcePoint" />
          <mxPoint x="-2034.83" y="-1260.6399999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al supply to PV" Note="" Equation="[PV cap building]*[PV Al intensity]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2094" id="2094">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2669" vertex="1">
        <mxGeometry x="194.39000000000033" y="91.9699999999998" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2095" id="2095">
      <mxCell style="link" parent="2669" source="2089" target="1511" edge="1">
        <mxGeometry x="-2134.83" y="-1260.6399999999999" width="100" height="100" as="geometry">
          <mxPoint x="-2134.83" y="-1160.6399999999999" as="sourcePoint" />
          <mxPoint x="-2034.83" y="-1260.6399999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2096" id="2096">
      <mxCell style="link" parent="2669" source="2086" target="2094" edge="1">
        <mxGeometry x="-2134.83" y="-1260.6399999999999" width="100" height="100" as="geometry">
          <mxPoint x="-2134.83" y="-1160.6399999999999" as="sourcePoint" />
          <mxPoint x="-2034.83" y="-1260.6399999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2097" id="2097">
      <mxCell style="link" parent="2669" source="1511" target="2094" edge="1">
        <mxGeometry x="-2134.83" y="-1260.6399999999999" width="100" height="100" as="geometry">
          <mxPoint x="-2134.83" y="-1160.6399999999999" as="sourcePoint" />
          <mxPoint x="-2034.83" y="-1260.6399999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="PV Al intensity framed" Note="" Equation="0.164740013166557" Units="(Gt/a)/(TW/a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2298" id="2298">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2669" vertex="1">
        <mxGeometry x="20" y="91.97000000000025" width="40" height="38.77" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="PV steel intensity frameless" Note="" Equation="0.0873329822251481" Units="(Gt/a)/(TW/a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2481" id="2481">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2669" vertex="1">
        <mxGeometry x="75.87000000000057" y="143.9599999999998" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="PV steel intensity framed" Note="" Equation="0.060709888084266" Units="(Gt/a)/(TW/a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2482" id="2482">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2669" vertex="1">
        <mxGeometry x="20.000000000000682" y="143.95999999999935" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="PV steel intensity" Note="" Equation="If [PV material intensity switch]=0 Then&#xa;  [PV steel intensity framed]&#xa;Else If [PV material intensity switch]=2 Then&#xa;  [PV steel intensity frameless]&#xa;Else&#xa;  [PV steel intensity frameless]+([PV steel intensity framed]-[PV steel intensity frameless])*exp(-Time()/[PV Al intensity tau])&#xa;End If" Units="(Gt/a)/(TW/a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2483" id="2483">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2669" vertex="1">
        <mxGeometry x="139.9400000000005" y="143.9599999999998" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2484" id="2484">
      <mxCell style="link" parent="2669" source="2481" target="2483" edge="1">
        <mxGeometry x="-1261" y="-1567.5099999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1261" y="-1467.5099999999998" as="sourcePoint" />
          <mxPoint x="-1161" y="-1567.5099999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2485" id="2485">
      <mxCell style="link" parent="2669" source="2482" target="2483" edge="1">
        <mxGeometry x="-1261" y="-1567.5099999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1261" y="-1467.5099999999998" as="sourcePoint" />
          <mxPoint x="-1161" y="-1567.5099999999998" as="targetPoint" />
          <Array as="points">
            <mxPoint x="79" y="132.49000000000024" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2486" id="2486">
      <mxCell style="link" parent="2669" source="2090" target="2483" edge="1">
        <mxGeometry x="-1261" y="-1567.5099999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1261" y="-1467.5099999999998" as="sourcePoint" />
          <mxPoint x="-1161" y="-1567.5099999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2487" id="2487">
      <mxCell style="link" parent="2669" source="2089" target="2483" edge="1">
        <mxGeometry x="-1261" y="-1567.5099999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1261" y="-1467.5099999999998" as="sourcePoint" />
          <mxPoint x="-1161" y="-1567.5099999999998" as="targetPoint" />
          <Array as="points">
            <mxPoint x="179" y="132.49000000000024" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="steel supply to PV" Note="" Equation="[PV cap building]*[PV steel intensity]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2488" id="2488">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2669" vertex="1">
        <mxGeometry x="195.64000000000033" y="143.9599999999998" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2489" id="2489">
      <mxCell style="link" parent="2669" source="2483" target="2488" edge="1">
        <mxGeometry x="-1261" y="-1567.5099999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1261" y="-1467.5099999999998" as="sourcePoint" />
          <mxPoint x="-1161" y="-1567.5099999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2490" id="2490">
      <mxCell style="link" parent="2669" source="2086" target="2488" edge="1">
        <mxGeometry x="-1261" y="-1567.5099999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1261" y="-1467.5099999999998" as="sourcePoint" />
          <mxPoint x="-1161" y="-1567.5099999999998" as="targetPoint" />
          <Array as="points">
            <mxPoint x="239" y="122.49000000000024" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2510" id="2510">
      <mxCell style="link" parent="2669" source="2298" target="1511" edge="1">
        <mxGeometry x="-1261" y="-1567.5099999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1261" y="-1467.5099999999998" as="sourcePoint" />
          <mxPoint x="159" y="122.49000000000024" as="targetPoint" />
          <Array as="points">
            <mxPoint x="79" y="72.49000000000024" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="PV glass intensity frameless" Note="" Equation="0.384726793943384" Units="(Gt/a)/(TW/a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2511" id="2511">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2669" vertex="1">
        <mxGeometry x="75.87000000000057" y="194.7299999999998" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="PV glass intensity framed" Note="" Equation="0.307781435154707" Units="(Gt/a)/(TW/a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2512" id="2512">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2669" vertex="1">
        <mxGeometry x="20.000000000000682" y="194.72999999999934" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="PV glass intensity" Note="" Equation="If [PV material intensity switch]=0 Then&#xa;  [PV glass intensity framed]&#xa;Else If [PV material intensity switch]=2 Then&#xa;  [PV glass intensity frameless]&#xa;Else&#xa;  [PV glass intensity frameless]+([PV glass intensity framed]-[PV glass intensity frameless])*exp(-Time()/[PV Al intensity tau])&#xa;End If" Units="(Gt/a)/(TW/a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2513" id="2513">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2669" vertex="1">
        <mxGeometry x="139.9400000000005" y="194.7299999999998" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2514" id="2514">
      <mxCell style="link" parent="2669" source="2511" target="2513" edge="1">
        <mxGeometry x="-1261" y="-1516.7399999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1261" y="-1416.7399999999998" as="sourcePoint" />
          <mxPoint x="-1161" y="-1516.7399999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="glass supply to PV" Note="" Equation="[PV cap building]*[PV glass intensity]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2515" id="2515">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2669" vertex="1">
        <mxGeometry x="195.64000000000033" y="194.7299999999998" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2516" id="2516">
      <mxCell style="link" parent="2669" source="2513" target="2515" edge="1">
        <mxGeometry x="-1261" y="-1516.7399999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1261" y="-1416.7399999999998" as="sourcePoint" />
          <mxPoint x="-1161" y="-1516.7399999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2520" id="2520">
      <mxCell style="link" parent="2669" source="2512" target="2513" edge="1">
        <mxGeometry x="-1261" y="-1567.5099999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1261" y="-1467.5099999999998" as="sourcePoint" />
          <mxPoint x="-1161" y="-1567.5099999999998" as="targetPoint" />
          <Array as="points">
            <mxPoint x="79" y="182.49000000000024" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2521" id="2521">
      <mxCell style="link" parent="2669" source="2089" target="2513" edge="1">
        <mxGeometry x="-1261" y="-1567.5099999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1261" y="-1467.5099999999998" as="sourcePoint" />
          <mxPoint x="-1161" y="-1567.5099999999998" as="targetPoint" />
          <Array as="points">
            <mxPoint x="189" y="152.49000000000024" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2522" id="2522">
      <mxCell style="link" parent="2669" source="2086" target="2515" edge="1">
        <mxGeometry x="-1261" y="-1567.5099999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1261" y="-1467.5099999999998" as="sourcePoint" />
          <mxPoint x="-1161" y="-1567.5099999999998" as="targetPoint" />
          <Array as="points">
            <mxPoint x="249" y="132.49000000000024" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2527" id="2527">
      <mxCell style="link" parent="2669" source="2090" target="2513" edge="1">
        <mxGeometry x="-1261" y="-1567.5099999999998" width="100" height="100" as="geometry">
          <mxPoint x="-1261" y="-1467.5099999999998" as="sourcePoint" />
          <mxPoint x="-1161" y="-1567.5099999999998" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="DAC" Note="" Type="None" Solver="{&quot;enabled&quot;:false,&quot;algorithm&quot;:&quot;RK1&quot;,&quot;timeStep&quot;:1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="2668" id="2668">
      <mxCell style="folder" vertex="1" parent="1">
        <mxGeometry x="1830" y="1381.05" width="190.35000000000014" height="138.95000000000005" as="geometry" />
      </mxCell>
    </Folder>
    <Variable name="DAC Al intensity 0" Note="0.0016 kg Al / kg/a CO2 removal capacity&lt;br&gt;" Equation="0.010098" Units="Gt/TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1718" id="1718">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2668" vertex="1">
        <mxGeometry x="20" y="20" width="46.63" height="25.07" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al supply to DAC" Note="" Equation="[DAC cap building]*[DAC Al intensity]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2299" id="2299">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2668" vertex="1">
        <mxGeometry x="130.35000000000014" y="79.87000000000012" width="40" height="39.08" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="DAC Al intensity tau" Note="time constant&lt;br&gt;" Equation="50" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2305" id="2305">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2668" vertex="1">
        <mxGeometry x="20" y="44.71999999999957" width="40" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2306" id="2306">
      <mxCell style="link" parent="2668" source="2305" target="2309" edge="1">
        <mxGeometry x="-2015.7" y="-1123.01" width="100" height="100" as="geometry">
          <mxPoint x="-2015.7" y="-1023.01" as="sourcePoint" />
          <mxPoint x="-1915.7" y="-1123.01" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="DAC Al intensity inf" Note="kg Al / kg/a CO2 removal capacity&lt;br&gt;" Equation="0.000316" Units="Gt/TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2307" id="2307">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2668" vertex="1">
        <mxGeometry x="20" y="89.73000000000002" width="46.63" height="25.07" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2308" id="2308">
      <mxCell style="link" parent="2668" source="2307" target="2309" edge="1">
        <mxGeometry x="-2015.7" y="-1123.01" width="100" height="100" as="geometry">
          <mxPoint x="-2015.7" y="-1023.01" as="sourcePoint" />
          <mxPoint x="-1915.7" y="-1123.01" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="DAC Al intensity" Note="0.014kg Al / kg/a CO2 removal capacity&lt;br&gt;" Equation="[DAC Al intensity inf]+([DAC Al intensity 0]-[DAC Al intensity inf])*exp(-Time()/[DAC Al intensity tau])" Units="Gt/TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2309" id="2309">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2668" vertex="1">
        <mxGeometry x="77.20000000000027" y="89.73000000000002" width="46.63" height="25.07" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1722" id="1722">
      <mxCell style="link" parent="2668" source="2309" target="2299" edge="1">
        <mxGeometry x="-1923.8400000000001" y="-807.7199999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1923.8400000000001" y="-707.7199999999999" as="sourcePoint" />
          <mxPoint x="-1823.8400000000001" y="-807.7199999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2310" id="2310">
      <mxCell style="link" parent="2668" source="1718" target="2309" edge="1">
        <mxGeometry x="-2015.7" y="-1123.01" width="100" height="100" as="geometry">
          <mxPoint x="-2015.7" y="-1023.01" as="sourcePoint" />
          <mxPoint x="84.30000000000018" y="86.98999999999978" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="DAC Al intensity rel" Note="" Equation="[DAC Al intensity]/[DAC Al intensity 0]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2358" id="2358">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2668" vertex="1">
        <mxGeometry x="77.04000000000019" y="20.1400000000001" width="46.63" height="25.07" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2359" id="2359">
      <mxCell style="link" parent="2668" source="1718" target="2358" edge="1">
        <mxGeometry x="-1219.31" y="-1441.05" width="100" height="100" as="geometry">
          <mxPoint x="-1219.31" y="-1341.05" as="sourcePoint" />
          <mxPoint x="-1119.31" y="-1441.05" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2360" id="2360">
      <mxCell style="link" parent="2668" source="2309" target="2358" edge="1">
        <mxGeometry x="-1219.31" y="-1441.05" width="100" height="100" as="geometry">
          <mxPoint x="-1219.31" y="-1341.05" as="sourcePoint" />
          <mxPoint x="-1119.31" y="-1441.05" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2173" oldId="2540" name="DAC cap building" id="2540">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="2668" vertex="1">
        <mxGeometry x="127.57999999999993" y="33.480000000000246" width="37.5" height="23.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2541" id="2541">
      <mxCell style="link" parent="2668" source="2540" target="2299" edge="1">
        <mxGeometry x="-1219.31" y="-1441.05" width="100" height="100" as="geometry">
          <mxPoint x="-1219.31" y="-1341.05" as="sourcePoint" />
          <mxPoint x="-1119.31" y="-1441.05" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="Aluminium Energy" Note="" Type="None" Solver="{&quot;enabled&quot;:false,&quot;algorithm&quot;:&quot;RK1&quot;,&quot;timeStep&quot;:1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="2667" id="2667">
      <mxCell style="folder" vertex="1" parent="1">
        <mxGeometry x="2140" y="907.6400000000002" width="820.0000000000005" height="620.7199999999998" as="geometry" />
      </mxCell>
    </Folder>
    <Variable name="CCS_EIT" Note="&lt;div&gt;Time of energy investment necessary to build the infrastructure for CCS&lt;/div&gt;&lt;div&gt;Energy invested 15 MWa for 60 MW nominal power = 15/60a=0.25a&lt;/div&gt;&lt;div&gt;see excel file CCS technology data&lt;/div&gt;&lt;div&gt;Minimum: 0.015a&lt;br&gt;&lt;/div&gt;" Equation="smooth([EIT_DAC unsmoothed],[EIT_DAC smoothing period],[EIT_DAC 0])" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="349" id="349">
      <mxCell style="variable;fontSize=10;" parent="2667" vertex="1">
        <mxGeometry x="90.82999999999993" y="550.7199999999998" width="53.91" height="50" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_Al sec cap construction" Note="Power required for constructing recycling facilities&lt;br&gt;" Equation="[Al additional recycling capacity constructing]*[EI_Al sec cap construction]/{1 Years}" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1666" id="1666">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="112.72999999999911" y="158.93999999999994" width="52.12" height="50" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1667" id="1667">
      <mxCell style="link" parent="2667" source="1906" target="1666" edge="1">
        <mxGeometry x="-1353.02" y="-921.3600000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1353.02" y="-821.3600000000004" as="sourcePoint" />
          <mxPoint x="-1253.02" y="-921.3600000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="EI_Al sec cap construction" Note="&lt;div&gt;Energy intensity of constructing Al recycling facitlites; see EI391&lt;/div&gt;" Equation="0.000614" Units="TW*a/(Gt/a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1668" id="1668">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="192.9399999999987" y="164.7499999999999" width="66.06" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1669" id="1669">
      <mxCell style="link" parent="2667" source="1668" target="1666" edge="1">
        <mxGeometry x="-1353.02" y="-921.3600000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1353.02" y="-821.3600000000004" as="sourcePoint" />
          <mxPoint x="-1253.02" y="-921.3600000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="EI_Al sec prod old" Note="15 MJ/kg&lt;br&gt;" Equation="0.31688087814029" Units="TW*a/Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1670" id="1670">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="191.2899999999986" y="256.52" width="66.06" height="23.68" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="EI_Al sec prod new" Note="8 MJ/kg&lt;br&gt;" Equation="0.31688087814029" Units="TW*a/Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1671" id="1671">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="191.2899999999986" y="229.63999999999987" width="66.06" height="25.27" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_Al sec production" Note="Power required for Al recycling&lt;br&gt;" Equation="[Al recycling 2]*([EI_Al sec prod new]*(1-[Al sec old/total])+[EI_Al sec prod old]*[Al sec old/total])" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1672" LiveGraph="{&quot;active&quot;:false}" id="1672">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="112.39999999999918" y="226.88999999999987" width="52.12" height="50" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1674" id="1674">
      <mxCell style="link" parent="2667" source="1670" target="1672" edge="1">
        <mxGeometry x="-1590.46" y="-614.2500000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1590.46" y="-514.2500000000002" as="sourcePoint" />
          <mxPoint x="-1490.46" y="-614.2500000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1675" id="1675">
      <mxCell style="link" parent="2667" source="1671" target="1672" edge="1">
        <mxGeometry x="-1590.46" y="-614.2500000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1590.46" y="-514.2500000000002" as="sourcePoint" />
          <mxPoint x="-1490.46" y="-614.2500000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1677" id="1677">
      <mxCell style="link" parent="2667" source="1741" target="1672" edge="1">
        <mxGeometry x="-1560.25" y="-940.6700000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1460.25" y="-940.6700000000003" as="sourcePoint" />
          <mxPoint x="-1560.25" y="-840.6700000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1739" oldId="1741" name="Al recycling 2" id="1741">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="25.129999999999654" y="214.63999999999965" width="58.5" height="15" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="P_Al prim cap construction" Note="Power required for constructing recycling facilities&lt;br&gt;" Equation="[Al additional prim capacity constructing]*[EI_Al prim cap construction]/{1 Years}" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1785" id="1785">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="114.37999999999965" y="20" width="52.12" height="50" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1786" id="1786">
      <mxCell style="link" parent="2667" source="1899" target="1785" edge="1">
        <mxGeometry x="-1950.68" y="-1065.4100000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1950.68" y="-965.4100000000003" as="sourcePoint" />
          <mxPoint x="-1850.68" y="-1065.4100000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="EI_Al prim cap construction" Note="Energy intensity of constructing Al smelting furnaces and casting facitlites; see EI391&lt;br&gt;" Equation="0.000978" Units="TW*a/(Gt/a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1787" id="1787">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="192.94000000000005" y="27" width="66.06" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1788" id="1788">
      <mxCell style="link" parent="2667" source="1787" target="1785" edge="1">
        <mxGeometry x="-1904.0499999999997" y="-948.3800000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1904.0499999999997" y="-848.3800000000002" as="sourcePoint" />
          <mxPoint x="-1804.0500000000004" y="-948.3800000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="EI_Al prim prod old" Note="" Equation="2.12310188353994" Units="TW*a/Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1789" id="1789">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="192.93999999999915" y="112.62999999999988" width="66.06" height="23.68" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="EI_Al prim prod new" Note="" Equation="1.73650721220879" Units="TW*a/Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1790" id="1790">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="192.93999999999915" y="85.16999999999962" width="66.06" height="25.27" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_Al prim production" Note="Power required for Al recycling&lt;br&gt;" Equation="[Al primary 1]*([EI_Al prim prod new]*(1-[Al prim old/total])+[EI_Al prim prod old]*[Al prim old/total])*[EI_Al prim CF adjustment function]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1791" id="1791">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="114.37999999999874" y="88.19999999999959" width="52.12" height="50" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1793" id="1793">
      <mxCell style="link" parent="2667" source="1789" target="1791" edge="1">
        <mxGeometry x="-1949.2100000000003" y="-679.8000000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1949.2100000000003" y="-579.8000000000002" as="sourcePoint" />
          <mxPoint x="-1849.2100000000003" y="-679.8000000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1794" id="1794">
      <mxCell style="link" parent="2667" source="1790" target="1791" edge="1">
        <mxGeometry x="-1949.2100000000003" y="-679.8000000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1949.2100000000003" y="-579.8000000000002" as="sourcePoint" />
          <mxPoint x="-1849.2100000000003" y="-679.8000000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_Al for PV" Note="Power required for Al provision for PV&lt;br&gt;" Equation="[Al supply to PV]*(1+[manufacturing scarp fraction])*[Al energy intensity]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1802" id="1802">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="553.7900000000004" y="345.10000000000014" width="52.12" height="38.07" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1831" id="1831">
      <mxCell style="link" parent="2667" source="1890" target="1791" edge="1">
        <mxGeometry x="-1975.99" y="-534.2800000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1975.99" y="-434.2800000000002" as="sourcePoint" />
          <mxPoint x="-1875.9899999999998" y="-534.2800000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1872" oldId="1890" name="Al primary 1" id="1890">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="28.6400000000001" y="72.56999999999971" width="49.74" height="15.63" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1897" oldId="1899" name="Al additional prim capacity constructing" id="1899">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="25.13000000000011" y="28.319999999999823" width="60" height="33.36" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1757" oldId="1900" name="Al prim capacity" id="1900">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="76.98999999999933" y="131.50999999999976" width="48.75" height="27.43" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1901" oldId="1903" name="Al old prim capacity" id="1903">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="28.130000000000337" y="129.13999999999976" width="48.75" height="27.43" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1904" oldId="1906" name="Al additional recycling capacity constructing" id="1906">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="20" y="159.61999999999978" width="60" height="46.26" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1907" oldId="1909" name="Al old recycling capacity" id="1909">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="25.129999999999654" y="278.07000000000016" width="48.75" height="27.43" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1965" oldId="1975" name="Al recycling capacity" id="1975">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="73.87999999999965" y="276.8900000000001" width="48.75" height="29.78" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="P_Al" Note="Power required for Al recycling&lt;br&gt;" Equation="[P_Al prim]+[P_Al sec]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1976" id="1976">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="330.8599999999997" y="126.40999999999963" width="52.12" height="50" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1977" id="1977">
      <mxCell style="link" parent="2667" source="1672" target="1987" edge="1">
        <mxGeometry x="-1861.5799999999997" y="-749.2300000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1861.5799999999997" y="-649.2300000000002" as="sourcePoint" />
          <mxPoint x="-1761.5799999999997" y="-749.2300000000002" as="targetPoint" />
          <Array as="points">
            <mxPoint x="210" y="216.50999999999976" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1978" id="1978">
      <mxCell style="link" parent="2667" source="1666" target="1987" edge="1">
        <mxGeometry x="-1861.5799999999997" y="-749.2300000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1861.5799999999997" y="-649.2300000000002" as="sourcePoint" />
          <mxPoint x="-1761.5799999999997" y="-749.2300000000002" as="targetPoint" />
          <Array as="points">
            <mxPoint x="210" y="206.50999999999976" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1979" id="1979">
      <mxCell style="link" parent="2667" source="1791" target="1986" edge="1">
        <mxGeometry x="-1861.5799999999997" y="-749.2300000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1861.5799999999997" y="-649.2300000000002" as="sourcePoint" />
          <mxPoint x="-1761.5799999999997" y="-749.2300000000002" as="targetPoint" />
          <Array as="points">
            <mxPoint x="200" y="76.50999999999976" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1980" id="1980">
      <mxCell style="link" parent="2667" source="1785" target="1986" edge="1">
        <mxGeometry x="-1861.5799999999997" y="-749.2300000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1861.5799999999997" y="-649.2300000000002" as="sourcePoint" />
          <mxPoint x="-1761.5799999999997" y="-749.2300000000002" as="targetPoint" />
          <Array as="points">
            <mxPoint x="210" y="66.50999999999976" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="EPBT_PV unsmoothed" Note="energy payback time for PV systems (Brockway et al. 2019, Raugei et al. 2017)&lt;br&gt;" Equation="If [material supply constrain switch]=1 Then&#xa;  [EPBT_PV2]&#xa;Else&#xa;  [EPBT_PV 0]&#xa;End If" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="743" id="743">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="559.0000000000005" y="481.66999999999985" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="EPBT_PV 0" Note="at time zero&lt;br&gt;" Equation="1.5" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1984" id="1984">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="633.7200000000012" y="476.19000000000005" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_Al prim" Note="Power required for Al recycling&lt;br&gt;" Equation="[P_Al prim production]+[P_Al prim cap construction]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1986" id="1986">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="258.9999999999991" y="51.22999999999956" width="52.12" height="50" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_Al sec" Note="Power required for Al recycling&lt;br&gt;" Equation="[P_Al sec production]+[P_Al sec cap construction]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1987" id="1987">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="258.99999999999955" y="189.57999999999947" width="52.12" height="50" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1988" id="1988">
      <mxCell style="link" parent="2667" source="1986" target="1976" edge="1">
        <mxGeometry x="-1861.5799999999997" y="-749.2300000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1861.5799999999997" y="-649.2300000000002" as="sourcePoint" />
          <mxPoint x="-1761.5799999999997" y="-749.2300000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1989" id="1989">
      <mxCell style="link" parent="2667" source="1987" target="1976" edge="1">
        <mxGeometry x="-1861.5799999999997" y="-749.2300000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1861.5799999999997" y="-649.2300000000002" as="sourcePoint" />
          <mxPoint x="-1761.5799999999997" y="-749.2300000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1997" id="1997">
      <mxCell style="link" parent="2667" source="1984" target="2001" edge="1">
        <mxGeometry x="-1480.9899999999998" y="-776.2600000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1480.9899999999998" y="-676.2600000000002" as="sourcePoint" />
          <mxPoint x="-1380.9899999999998" y="-776.2600000000002" as="targetPoint" />
          <Array as="points">
            <mxPoint x="590" y="456.50999999999976" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="d EPBT_PV" Note="" Equation="([EPBT_PV adjusted]-[EPBT_PV2])/TimeStep()" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1999" id="1999">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2667" vertex="1">
        <mxGeometry x="509.00000000000045" y="455.44000000000005" width="50" height="26.05" as="geometry" />
      </mxCell>
    </Variable>
    <Flow name="EPBT flow" Note="" FlowRate="[d EPBT_PV]" OnlyPositive="false" TimeIndependent="false" Units="Years/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2000" id="2000">
      <mxCell style="flow;startFill=0;fontSize=6;startArrow=block;" parent="2667" target="2001" edge="1">
        <mxGeometry x="-840.1600000000001" y="-491.0000000000002" width="100" height="100" as="geometry">
          <mxPoint x="491.25000000000045" y="442.65999999999985" as="sourcePoint" />
          <mxPoint x="-840.1600000000001" y="-391.0000000000002" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="EPBT_PV2" Note="" InitialValue="[EPBT_PV 0]" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2001" id="2001">
      <mxCell style="stock;fontSize=6;" parent="2667" vertex="1">
        <mxGeometry x="481.25000000000045" y="501.65999999999985" width="56.69" height="15.53" as="geometry" />
      </mxCell>
    </Stock>
    <Link name="Link" Note="" BiDirectional="false" oldId="2003" id="2003">
      <mxCell style="link" parent="2667" source="1999" target="2000" edge="1">
        <mxGeometry x="-1478.7499999999995" y="-834.5600000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1478.7499999999995" y="-734.5600000000003" as="sourcePoint" />
          <mxPoint x="-1378.75" y="-834.5600000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2005" id="2005">
      <mxCell style="link" parent="2667" source="2618" target="1999" edge="1">
        <mxGeometry x="-1480.9899999999998" y="-776.2600000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1480.9899999999998" y="-676.2600000000002" as="sourcePoint" />
          <mxPoint x="-1380.9899999999998" y="-776.2600000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2006" id="2006">
      <mxCell style="link" parent="2667" source="2001" target="1999" edge="1">
        <mxGeometry x="-1478.7499999999995" y="-834.5600000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1478.7499999999995" y="-734.5600000000003" as="sourcePoint" />
          <mxPoint x="-1378.75" y="-834.5600000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2007" id="2007">
      <mxCell style="link" parent="2667" source="2001" target="743" edge="1">
        <mxGeometry x="-1478.7499999999995" y="-834.5600000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1478.7499999999995" y="-734.5600000000003" as="sourcePoint" />
          <mxPoint x="-1378.75" y="-834.5600000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2008" id="2008">
      <mxCell style="link" parent="2667" source="1984" target="743" edge="1">
        <mxGeometry x="-1480.9899999999998" y="-776.2600000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1480.9899999999998" y="-676.2600000000002" as="sourcePoint" />
          <mxPoint x="-1380.9899999999998" y="-776.2600000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1853" oldId="2009" name="material supply constrain switch" id="2009">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="479.60000000000036" y="539.0199999999995" width="60" height="57.02" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2010" id="2010">
      <mxCell style="link" parent="2667" source="2009" target="743" edge="1">
        <mxGeometry x="-1478.7499999999995" y="-834.5600000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1478.7499999999995" y="-734.5600000000003" as="sourcePoint" />
          <mxPoint x="-1378.75" y="-834.5600000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="EPBT_PV" Note="energy payback time for PV systems (Brockway et al. 2019, Raugei et al. 2017)&lt;br&gt;" Equation="smooth([EPBT_PV unsmoothed],[EPBT_PV smoothing period])" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2100" id="2100">
      <mxCell style="variable;fontSize=10;fillColor=#FDCDAC;" parent="2667" vertex="1">
        <mxGeometry x="554.3800000000006" y="545.1999999999996" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2101" id="2101">
      <mxCell style="link" parent="2667" source="743" target="2100" edge="1">
        <mxGeometry x="-1986.51" y="-790.8300000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1986.51" y="-690.8300000000002" as="sourcePoint" />
          <mxPoint x="-1886.51" y="-790.8300000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="EPBT_PV smoothing period" Note="" Equation="10*TimeStep()" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2103" id="2103">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="633.7200000000007" y="543.1799999999998" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2104" id="2104">
      <mxCell style="link" parent="2667" source="2103" target="2100" edge="1">
        <mxGeometry x="-1986.51" y="-790.8300000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1986.51" y="-690.8300000000002" as="sourcePoint" />
          <mxPoint x="-1886.51" y="-790.8300000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2094" oldId="2140" name="Al supply to PV" id="2140">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="562.0900000000001" y="296.4899999999998" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1683" id="1683">
      <mxCell style="link" parent="2667" source="2140" target="1802" edge="1">
        <mxGeometry x="-1961.58" y="-409.9400000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1861.58" y="-409.9400000000002" as="sourcePoint" />
          <mxPoint x="507.8250000000003" y="398.14999999999986" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al energy intensity" Note="" Equation="If [Al primary 1]+[Al recycling 2]={0 Gt/a} Then&#xa;  [Al energy intensity 0]&#xa;Else&#xa;  [P_Al]/([Al recycling 2]+[Al primary 1])&#xa;End If" Units="TW*a/Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2151" id="2151">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="332.23" y="230.69999999999982" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2152" id="2152">
      <mxCell style="link" parent="2667" source="1976" target="2151" edge="1">
        <mxGeometry x="-2240.4" y="-675.5100000000002" width="100" height="100" as="geometry">
          <mxPoint x="-2240.4" y="-575.5100000000002" as="sourcePoint" />
          <mxPoint x="-2140.4" y="-675.5100000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1739" oldId="2154" name="Al recycling 2" id="2154">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="389.5999999999999" y="203.9099999999994" width="58.5" height="15" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1872" oldId="2155" name="Al primary 1" id="2155">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="400.75" y="65.52999999999963" width="36.19" height="27.68" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2156" id="2156">
      <mxCell style="link" parent="2667" source="2154" target="2151" edge="1">
        <mxGeometry x="-2240.4" y="-675.5100000000002" width="100" height="100" as="geometry">
          <mxPoint x="-2240.4" y="-575.5100000000002" as="sourcePoint" />
          <mxPoint x="-2140.4" y="-675.5100000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2157" id="2157">
      <mxCell style="link" parent="2667" source="2155" target="2151" edge="1">
        <mxGeometry x="-2240.4" y="-675.5100000000002" width="100" height="100" as="geometry">
          <mxPoint x="-2240.4" y="-575.5100000000002" as="sourcePoint" />
          <mxPoint x="-2140.4" y="-675.5100000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2161" id="2161">
      <mxCell style="link" parent="2667" source="2295" target="1802" edge="1">
        <mxGeometry x="-1871.08" y="-641.2600000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1871.08" y="-541.2600000000002" as="sourcePoint" />
          <mxPoint x="494.2553299752276" y="346.63151725631883" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al sec/supply" Note="" Equation="[Al recycling 2]/([Al primary 1]+[Al recycling 2])" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2162" id="2162">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="397.3499999999997" y="126.40999999999963" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2163" id="2163">
      <mxCell style="link" parent="2667" source="2155" target="2162" edge="1">
        <mxGeometry x="-2240.4" y="-675.5100000000002" width="100" height="100" as="geometry">
          <mxPoint x="-2240.4" y="-575.5100000000002" as="sourcePoint" />
          <mxPoint x="-2140.4" y="-675.5100000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2164" id="2164">
      <mxCell style="link" parent="2667" source="2154" target="2162" edge="1">
        <mxGeometry x="-2240.4" y="-675.5100000000002" width="100" height="100" as="geometry">
          <mxPoint x="-2240.4" y="-575.5100000000002" as="sourcePoint" />
          <mxPoint x="-2140.4" y="-675.5100000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_Al for storage" Note="Power required for Al provision for storage&lt;br&gt;" Equation="[Al to storage]*[Al energy intensity]*(1+[manufacturing scarp fraction])" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2208" id="2208">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="325.60000000000014" y="342.82000000000016" width="52.12" height="38.07" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="EI storage unsmoothed" Note="" Equation="If [material supply constrain switch]=1 Then&#xa;  [EI storage 2]&#xa;Else&#xa;  [EI storage 0]&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2210" id="2210">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="326.97000000000025" y="480.15999999999985" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="d EI storage" Note="" Equation="([EI storage adjusted]-[EI storage 2])/TimeStep()" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2214" id="2214">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2667" vertex="1">
        <mxGeometry x="283.8800000000001" y="452.44000000000005" width="50" height="26.05" as="geometry" />
      </mxCell>
    </Variable>
    <Flow name="EI flow" Note="" FlowRate="[d EI storage]" OnlyPositive="false" TimeIndependent="false" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2215" id="2215">
      <mxCell style="flow;startFill=0;fontSize=6;startArrow=block;" parent="2667" target="2216" edge="1">
        <mxGeometry x="-1065.2800000000002" y="-494.0000000000002" width="100" height="100" as="geometry">
          <mxPoint x="266.1300000000001" y="439.65999999999985" as="sourcePoint" />
          <mxPoint x="-1065.2800000000002" y="-394.0000000000002" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="EI storage 2" Note="" InitialValue="[EI storage 0]" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2216" id="2216">
      <mxCell style="stock;fontSize=6;" parent="2667" vertex="1">
        <mxGeometry x="256.1300000000001" y="498.65999999999985" width="56.69" height="15.53" as="geometry" />
      </mxCell>
    </Stock>
    <Link name="Link" Note="" BiDirectional="false" oldId="2217" id="2217">
      <mxCell style="link" parent="2667" source="2214" target="2215" edge="1">
        <mxGeometry x="-1703.87" y="-837.5600000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1703.87" y="-737.5600000000003" as="sourcePoint" />
          <mxPoint x="-1603.87" y="-837.5600000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2218" id="2218">
      <mxCell style="link" parent="2667" source="2231" target="2214" edge="1">
        <mxGeometry x="-1706.11" y="-779.2600000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1706.11" y="-679.2600000000002" as="sourcePoint" />
          <mxPoint x="-1606.11" y="-779.2600000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2219" id="2219">
      <mxCell style="link" parent="2667" source="2216" target="2214" edge="1">
        <mxGeometry x="-1703.87" y="-837.5600000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1703.87" y="-737.5600000000003" as="sourcePoint" />
          <mxPoint x="-1603.87" y="-837.5600000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2220" id="2220">
      <mxCell style="link" parent="2667" source="2216" target="2210" edge="1">
        <mxGeometry x="-1703.87" y="-837.5600000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1703.87" y="-737.5600000000003" as="sourcePoint" />
          <mxPoint x="-1603.87" y="-837.5600000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2221" id="2221">
      <mxCell style="link" parent="2667" source="2259" target="2210" edge="1">
        <mxGeometry x="-1706.11" y="-779.2600000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1706.11" y="-679.2600000000002" as="sourcePoint" />
          <mxPoint x="-1606.11" y="-779.2600000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1853" oldId="2222" name="material supply constrain switch" id="2222">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="254.48000000000002" y="536.0199999999995" width="60" height="57.02" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2223" id="2223">
      <mxCell style="link" parent="2667" source="2222" target="2210" edge="1">
        <mxGeometry x="-1703.87" y="-837.5600000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1703.87" y="-737.5600000000003" as="sourcePoint" />
          <mxPoint x="-1603.87" y="-837.5600000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2225" id="2225">
      <mxCell style="link" parent="2667" source="2210" target="1072" edge="1">
        <mxGeometry x="-2211.63" y="-793.8300000000003" width="100" height="100" as="geometry">
          <mxPoint x="-2211.63" y="-693.8300000000002" as="sourcePoint" />
          <mxPoint x="-2111.63" y="-793.8300000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="EI storage smoothing period" Note="" Equation="10*TimeStep()" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2226" id="2226">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="408.60000000000036" y="546.04" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2227" id="2227">
      <mxCell style="link" parent="2667" source="2226" target="1072" edge="1">
        <mxGeometry x="-2211.63" y="-793.8300000000003" width="100" height="100" as="geometry">
          <mxPoint x="-2211.63" y="-693.8300000000002" as="sourcePoint" />
          <mxPoint x="-2111.63" y="-793.8300000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="EI storage adjusted" Note="" Equation="[EI storage rest]+[Al energy intensity]*[storage Al intensity]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2231" id="2231">
      <mxCell style="variable;fontSize=10;fillColor=#FDCDAC;" parent="2667" vertex="1">
        <mxGeometry x="328.6700000000005" y="380.8899999999999" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2238" id="2238">
      <mxCell style="link" parent="2667" source="2295" target="2208" edge="1">
        <mxGeometry x="-1950.83" y="-674.0600000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1950.83" y="-574.0600000000002" as="sourcePoint" />
          <mxPoint x="-1850.83" y="-674.0600000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2211" oldId="2259" name="EI storage 0" id="2259">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="408.6000000000008" y="477.8900000000001" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="2127" oldId="2260" name="Al to storage" id="2260">
      <mxCell style="variable;fontSize=6;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="267.7500000000002" y="344.53" width="40.63" height="35.39" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="storage energy intensity" Note="&lt;div&gt;embodied electric energy / storage capacity&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;" Equation="smooth([EI storage unsmoothed],[EI storage smoothing period])" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="450" SliderMin="60" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1072" id="1072">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2667" vertex="1">
        <mxGeometry x="325.0899999999997" y="546.0399999999997" width="52.63" height="50" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="EIT_DAC unsmoothed" Note="" Equation="If [material supply constrain switch]=1 Then&#xa;  [EIT_DAC2]&#xa;Else&#xa;  [EIT_DAC 0]&#xa;End If" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2268" id="2268">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="93.99000000000024" y="487.3199999999997" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="EIT_DAC 0" Note="&lt;div&gt;Time of energy investment necessary to build the infrastructure for CCS&lt;/div&gt;&lt;div&gt;Energy invested 15 MWa for 60 MW nominal power = 15/60a=0.25a&lt;/div&gt;&lt;div&gt;see excel file CCS technology data&lt;/div&gt;Minimum: 0.015a" Equation="0.116" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2269" id="2269">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="175.6200000000008" y="481.4899999999998" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2271" id="2271">
      <mxCell style="link" parent="2667" source="2269" target="2274" edge="1">
        <mxGeometry x="-1939.09" y="-772.1000000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1939.09" y="-672.1000000000003" as="sourcePoint" />
          <mxPoint x="-1839.09" y="-772.1000000000003" as="targetPoint" />
          <Array as="points">
            <mxPoint x="120" y="466.50999999999976" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="d EIT_DAC" Note="" Equation="([EIT_DAC adjusted]-[EIT_DAC2])/TimeStep()" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2272" id="2272">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2667" vertex="1">
        <mxGeometry x="50.90000000000009" y="459.5999999999999" width="50" height="26.05" as="geometry" />
      </mxCell>
    </Variable>
    <Flow name="EIT flow" Note="" FlowRate="[d EIT_DAC]" OnlyPositive="false" TimeIndependent="false" Units="Years/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2273" id="2273">
      <mxCell style="flow;startFill=0;fontSize=6;startArrow=block;" parent="2667" target="2274" edge="1">
        <mxGeometry x="-1298.26" y="-486.8400000000002" width="100" height="100" as="geometry">
          <mxPoint x="33.15000000000009" y="446.8199999999997" as="sourcePoint" />
          <mxPoint x="-1298.26" y="-386.84000000000026" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="EIT_DAC2" Note="" InitialValue="[EIT_DAC 0]" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2274" id="2274">
      <mxCell style="stock;fontSize=6;" parent="2667" vertex="1">
        <mxGeometry x="23.15000000000009" y="505.8199999999995" width="56.69" height="15.53" as="geometry" />
      </mxCell>
    </Stock>
    <Link name="Link" Note="" BiDirectional="false" oldId="2275" id="2275">
      <mxCell style="link" parent="2667" source="2272" target="2273" edge="1">
        <mxGeometry x="-1936.8499999999997" y="-830.4000000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1936.8499999999997" y="-730.4000000000002" as="sourcePoint" />
          <mxPoint x="-1836.85" y="-830.4000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2276" id="2276">
      <mxCell style="link" parent="2667" source="2289" target="2272" edge="1">
        <mxGeometry x="-1939.09" y="-772.1000000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1939.09" y="-672.1000000000003" as="sourcePoint" />
          <mxPoint x="-1839.09" y="-772.1000000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2277" id="2277">
      <mxCell style="link" parent="2667" source="2274" target="2272" edge="1">
        <mxGeometry x="-1936.8499999999997" y="-830.4000000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1936.8499999999997" y="-730.4000000000002" as="sourcePoint" />
          <mxPoint x="-1836.85" y="-830.4000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2278" id="2278">
      <mxCell style="link" parent="2667" source="2274" target="2268" edge="1">
        <mxGeometry x="-1936.8499999999997" y="-830.4000000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1936.8499999999997" y="-730.4000000000002" as="sourcePoint" />
          <mxPoint x="-1836.85" y="-830.4000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2279" id="2279">
      <mxCell style="link" parent="2667" source="2269" target="2268" edge="1">
        <mxGeometry x="-1939.09" y="-772.1000000000003" width="100" height="100" as="geometry">
          <mxPoint x="-1939.09" y="-672.1000000000003" as="sourcePoint" />
          <mxPoint x="-1839.09" y="-772.1000000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1853" oldId="2280" name="material supply constrain switch" id="2280">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="21.5" y="543.1799999999994" width="60" height="57.02" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2281" id="2281">
      <mxCell style="link" parent="2667" source="2280" target="2268" edge="1">
        <mxGeometry x="-1936.8499999999997" y="-830.4000000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1936.8499999999997" y="-730.4000000000002" as="sourcePoint" />
          <mxPoint x="-1836.85" y="-830.4000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2283" id="2283">
      <mxCell style="link" parent="2667" source="2268" target="349" edge="1">
        <mxGeometry x="-2444.61" y="-786.6700000000002" width="100" height="100" as="geometry">
          <mxPoint x="-2444.61" y="-686.6700000000003" as="sourcePoint" />
          <mxPoint x="120.88790888778203" y="549.3713116309757" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="EIT_DAC smoothing period" Note="" Equation="10*TimeStep()" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2284" id="2284">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="175.62000000000035" y="550.6099999999997" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2285" id="2285">
      <mxCell style="link" parent="2667" source="2284" target="349" edge="1">
        <mxGeometry x="-2444.61" y="-786.6700000000002" width="100" height="100" as="geometry">
          <mxPoint x="-2444.61" y="-686.6700000000003" as="sourcePoint" />
          <mxPoint x="141.634919187999" y="558.8526071655269" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="EIT_DAC adjusted" Note="" Equation="[EIT_DAC rest]+[Al energy intensity]*[DAC Al intensity]" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2289" id="2289">
      <mxCell style="variable;fontSize=10;fillColor=#FDCDAC;" parent="2667" vertex="1">
        <mxGeometry x="95.69000000000051" y="388.0499999999997" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="1833" oldId="2295" name="manufacturing scarp fraction" id="2295">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="186.62999999999988" y="328.6500000000001" width="70.72" height="20.93" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="2299" oldId="2302" name="Al supply to DAC" id="2302">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="27.25" y="349.3899999999999" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2311" id="2311">
      <mxCell style="link" parent="2667" source="2269" target="349" edge="1">
        <mxGeometry x="-2180" y="-518.8500000000003" width="100" height="100" as="geometry">
          <mxPoint x="-2180" y="-418.85000000000025" as="sourcePoint" />
          <mxPoint x="-2080" y="-518.8500000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="EI_Al prim CF adjustment function" Note="" Equation="If [Al prim CF]*[max capacity utilization factor]&gt;[Al prim CF_opt] Then&#xa;  1+([EI_Al prim increase factor at CF=1]-1)*(([Al prim CF]*[max capacity utilization factor]-[Al prim CF_opt])/(1-[Al prim CF_opt]))^2&#xa;Else&#xa;  1+([EI_Al prim increase factor at CF=0]-1)*(([Al prim CF]*[max capacity utilization factor]-[Al prim CF_opt])/(0-[Al prim CF_opt]))^2&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2312" id="2312">
      <mxCell style="variable;fontSize=10;fillColor=#FDCDAC;" parent="2667" vertex="1">
        <mxGeometry x="510" y="71.14999999999975" width="65.73" height="66.8" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="EI_Al prim increase factor at CF=1" Note="at maximum utilization&lt;br&gt;" Equation="1.2" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2313" id="2313">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="592.25" y="36.2199999999998" width="67.16" height="62.43" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="EI_Al prim increase factor at CF=0" Note="at minimum utilization&lt;br&gt;" Equation="1.1" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2314" id="2314">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="592.25" y="99.47999999999968" width="67.16" height="63.73" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al prim CF_opt" Note="optimal CF for minimal energy&lt;br&gt;" Equation="0.8" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2315" id="2315">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="552.0900000000001" y="144.37999999999977" width="50" height="38.61" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2317" id="2317">
      <mxCell style="link" parent="2667" source="2322" target="2312" edge="1">
        <mxGeometry x="-2180" y="-518.8500000000003" width="100" height="100" as="geometry">
          <mxPoint x="508.7668907709467" y="152.53128311474268" as="sourcePoint" />
          <mxPoint x="-2080" y="-518.8500000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2318" id="2318">
      <mxCell style="link" parent="2667" source="2315" target="2312" edge="1">
        <mxGeometry x="-2180" y="-518.8500000000003" width="100" height="100" as="geometry">
          <mxPoint x="-2180" y="-418.85000000000025" as="sourcePoint" />
          <mxPoint x="-2080" y="-518.8500000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2319" id="2319">
      <mxCell style="link" parent="2667" source="2314" target="2312" edge="1">
        <mxGeometry x="-2180" y="-518.8500000000003" width="100" height="100" as="geometry">
          <mxPoint x="-2180" y="-418.85000000000025" as="sourcePoint" />
          <mxPoint x="-2080" y="-518.8500000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2320" id="2320">
      <mxCell style="link" parent="2667" source="2313" target="2312" edge="1">
        <mxGeometry x="-2180" y="-518.8500000000003" width="100" height="100" as="geometry">
          <mxPoint x="-2180" y="-418.85000000000025" as="sourcePoint" />
          <mxPoint x="-2080" y="-518.8500000000003" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2321" id="2321">
      <mxCell style="link" parent="2667" source="2312" target="1791" edge="1">
        <mxGeometry x="-2400" y="-874.6000000000003" width="100" height="100" as="geometry">
          <mxPoint x="-2400" y="-774.6000000000003" as="sourcePoint" />
          <mxPoint x="-2300" y="-874.6000000000003" as="targetPoint" />
          <Array as="points">
            <mxPoint x="380" y="105.39999999999975" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1868" oldId="2322" name="Al prim CF" id="2322">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="509" y="151.58999999999958" width="35.41" height="23.87" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="P_Al for DAC" Note="Power required for Al provision for DAC&lt;br&gt;" Equation="[Al supply to DAC]*(1+[manufacturing scarp fraction])*[Al energy intensity]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2349" id="2349">
      <mxCell style="variable;fontSize=8;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="95" y="345.5799999999999" width="52.12" height="38.07" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2350" id="2350">
      <mxCell style="link" parent="2667" source="2302" target="2349" edge="1">
        <mxGeometry x="-1570.69" y="-797.8000000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570.69" y="-697.8000000000002" as="sourcePoint" />
          <mxPoint x="-1470.69" y="-797.8000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2351" id="2351">
      <mxCell style="link" parent="2667" source="2151" target="2349" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2352" id="2352">
      <mxCell style="link" parent="2667" source="2295" target="2349" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al energy intensity 0" Note="at simulation start&lt;br&gt;" Equation="1.40844364985351" Units="TW*a/Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2353" id="2353">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="420.0000000000002" y="230.69999999999982" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al energy intensity rel" Note="" Equation="[Al energy intensity]/[Al energy intensity 0]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2354" id="2354">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="332.23" y="285.62999999999965" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2355" id="2355">
      <mxCell style="link" parent="2667" source="2151" target="2354" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="390" y="286.50999999999976" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2356" id="2356">
      <mxCell style="link" parent="2667" source="2353" target="2354" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2357" id="2357">
      <mxCell style="link" parent="2667" source="2151" target="2289" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2368" id="2368">
      <mxCell style="link" parent="2667" source="2151" target="2208" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
          <Array as="points">
            <mxPoint x="310" y="306.50999999999976" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2369" id="2369">
      <mxCell style="link" parent="2667" source="2260" target="2208" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2370" id="2370">
      <mxCell style="link" parent="2667" source="2151" target="2231" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
          <Array as="points">
            <mxPoint x="410" y="326.50999999999976" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2213" id="2213">
      <mxCell style="link" parent="2667" source="2259" target="2216" edge="1">
        <mxGeometry x="-1706.11" y="-779.2600000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1706.11" y="-679.2600000000002" as="sourcePoint" />
          <mxPoint x="-1606.11" y="-779.2600000000002" as="targetPoint" />
          <Array as="points">
            <mxPoint x="350" y="456.50999999999976" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2372" id="2372">
      <mxCell style="link" parent="2667" source="2151" target="1802" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
          <Array as="points">
            <mxPoint x="470" y="296.50999999999976" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2373" id="2373">
      <mxCell style="link" parent="2667" source="2353" target="2151" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="energy intensity of solar glass production" Note="" Equation="0.162559890485969" Units="TW*a/Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2480" id="2480">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="690" y="411.4999999999998" width="70" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="1939" oldId="2493" name="max capacity utilization factor" id="2493">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="501.98" y="26.509999999999764" width="64.04" height="38.68" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2494" id="2494">
      <mxCell style="link" parent="2667" source="2493" target="2312" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al sec old/total" Note="" Equation="[Al old recycling capacity]/[Al recycling capacity]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2503" id="2503">
      <mxCell style="variable;fontSize=10;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="26.13000000000011" y="233.89999999999986" width="50.75" height="32.61" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2504" id="2504">
      <mxCell style="link" parent="2667" source="1975" target="2503" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2505" id="2505">
      <mxCell style="link" parent="2667" source="1909" target="2503" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim old/total" Note="fraction of old capacity over total capacity&lt;br&gt;" Equation="[Al old prim capacity]/[Al prim capacity]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2507" id="2507">
      <mxCell style="variable;fontSize=10;fillColor=#FFFF00;" parent="2667" vertex="1">
        <mxGeometry x="28.13000000000011" y="92.40999999999997" width="50.75" height="32.61" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2508" id="2508">
      <mxCell style="link" parent="2667" source="2507" target="1791" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2509" id="2509">
      <mxCell style="link" parent="2667" source="2503" target="1672" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="energy intensity of primary steel production" Note="" Equation="0.333358683803585" Units="TW*a/Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2542" id="2542">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="690" y="361.99999999999955" width="70" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="EPBT_PV rest" Note="energy payback time of PV systems without Al, steel, and glass&lt;br&gt;" Equation="[EPBT_PV 0]-[Al energy intensity 0]*[PV Al intensity framed]-[energy intensity of primary steel production]*[PV steel intensity framed]-[energy intensity of solar glass production]*[PV glass intensity framed]" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2617" id="2617">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="699.6200000000013" y="476.0300000000002" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="EPBT_PV adjusted" Note="" Equation="[EPBT_PV rest]+[Al energy intensity]*[PV Al intensity]+[energy intensity of primary steel production]*[PV steel intensity]+[energy intensity of solar glass production]*[PV glass intensity]&#xa;" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2618" id="2618">
      <mxCell style="variable;fontSize=10;fillColor=#FDCDAC;" parent="2667" vertex="1">
        <mxGeometry x="554.380000000001" y="384.0999999999999" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2619" id="2619">
      <mxCell style="link" parent="2667" source="2617" target="2618" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2620" id="2620">
      <mxCell style="link" parent="2667" source="2151" target="2618" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1511" oldId="2621" name="PV Al intensity" id="2621">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="650" y="349.6599999999996" width="40" height="40" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2622" id="2622">
      <mxCell style="link" parent="2667" source="2621" target="2618" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2483" oldId="2623" name="PV steel intensity" id="2623">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="650.0000000000005" y="390.6799999999989" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="2513" oldId="2624" name="PV glass intensity" id="2624">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="650.0000000000009" y="432.1599999999992" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2625" id="2625">
      <mxCell style="link" parent="2667" source="2542" target="2618" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2626" id="2626">
      <mxCell style="link" parent="2667" source="2480" target="2618" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2627" id="2627">
      <mxCell style="link" parent="2667" source="2623" target="2618" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2628" id="2628">
      <mxCell style="link" parent="2667" source="2624" target="2618" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2298" oldId="2630" name="PV Al intensity framed" id="2630">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="760" y="357.58999999999946" width="40" height="38.77" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="2482" oldId="2631" name="PV steel intensity framed" id="2631">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="760.0000000000005" y="397.86999999999875" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="2512" oldId="2632" name="PV glass intensity framed" id="2632">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="760.0000000000005" y="439.24999999999886" width="40" height="38.64" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2633" id="2633">
      <mxCell style="link" parent="2667" source="2640" target="2617" edge="1">
        <mxGeometry x="-1604.47" y="-846.6500000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1604.47" y="-746.6500000000002" as="sourcePoint" />
          <mxPoint x="-1504.47" y="-846.6500000000002" as="targetPoint" />
          <Array as="points">
            <mxPoint x="780" y="386.50999999999976" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2634" id="2634">
      <mxCell style="link" parent="2667" source="2632" target="2617" edge="1">
        <mxGeometry x="-1604.47" y="-846.6500000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1604.47" y="-746.6500000000002" as="sourcePoint" />
          <mxPoint x="-1504.47" y="-846.6500000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2635" id="2635">
      <mxCell style="link" parent="2667" source="2480" target="2617" edge="1">
        <mxGeometry x="-1604.47" y="-846.6500000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1604.47" y="-746.6500000000002" as="sourcePoint" />
          <mxPoint x="-1504.47" y="-846.6500000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2636" id="2636">
      <mxCell style="link" parent="2667" source="2631" target="2617" edge="1">
        <mxGeometry x="-1604.47" y="-846.6500000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1604.47" y="-746.6500000000002" as="sourcePoint" />
          <mxPoint x="-1504.47" y="-846.6500000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2637" id="2637">
      <mxCell style="link" parent="2667" source="2542" target="2617" edge="1">
        <mxGeometry x="-1604.47" y="-846.6500000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1604.47" y="-746.6500000000002" as="sourcePoint" />
          <mxPoint x="-1504.47" y="-846.6500000000002" as="targetPoint" />
          <Array as="points">
            <mxPoint x="670" y="436.50999999999976" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2638" id="2638">
      <mxCell style="link" parent="2667" source="2630" target="2617" edge="1">
        <mxGeometry x="-1604.47" y="-846.6500000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1604.47" y="-746.6500000000002" as="sourcePoint" />
          <mxPoint x="-1504.47" y="-846.6500000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2639" id="2639">
      <mxCell style="link" parent="2667" source="1984" target="2617" edge="1">
        <mxGeometry x="-1604.47" y="-846.6500000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1604.47" y="-746.6500000000002" as="sourcePoint" />
          <mxPoint x="-1504.47" y="-846.6500000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2353" oldId="2640" name="Al energy intensity 0" id="2640">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="699.6200000000003" y="311.52999999999975" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="EIT_DAC rest" Note="without Aluminium&lt;br&gt;" Equation="[EIT_DAC 0]-[Al energy intensity 0]*[DAC Al intensity 0]" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2641" id="2641">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="175.6200000000008" y="381.75999999999976" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2642" id="2642">
      <mxCell style="link" parent="2667" source="2269" target="2641" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2643" id="2643">
      <mxCell style="link" parent="2667" source="2353" target="2641" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
          <Array as="points">
            <mxPoint x="310" y="286.50999999999976" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2644" id="2644">
      <mxCell style="link" parent="2667" source="2648" target="2641" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2309" oldId="2645" name="DAC Al intensity" id="2645">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="25.130000000000337" y="396.31999999999994" width="46.63" height="25.07" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2646" id="2646">
      <mxCell style="link" parent="2667" source="2645" target="2289" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2647" id="2647">
      <mxCell style="link" parent="2667" source="2641" target="2289" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1718" oldId="2648" name="DAC Al intensity 0" id="2648">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="112.39999999999986" y="444.11999999999966" width="46.63" height="25.07" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1702" oldId="2649" name="storage Al intensity" id="2649">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;opacity=30;" parent="2667" vertex="1">
        <mxGeometry x="358.03999999999996" y="433.5999999999997" width="41.96" height="32.91" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="EI storage rest" Note="without Al&lt;br&gt;" Equation="[EI storage 0]-[Al energy intensity 0]*[storage Al intensity]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2651" id="2651">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="2667" vertex="1">
        <mxGeometry x="408.6000000000008" y="388.52" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2652" id="2652">
      <mxCell style="link" parent="2667" source="2353" target="2651" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2653" id="2653">
      <mxCell style="link" parent="2667" source="2259" target="2651" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2654" id="2654">
      <mxCell style="link" parent="2667" source="2649" target="2651" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2655" id="2655">
      <mxCell style="link" parent="2667" source="2651" target="2231" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2656" id="2656">
      <mxCell style="link" parent="2667" source="2649" target="2231" edge="1">
        <mxGeometry x="-1570" y="-853.4900000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1570" y="-753.4900000000002" as="sourcePoint" />
          <mxPoint x="-1470" y="-853.4900000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1795" id="1795">
      <mxCell style="link" parent="2667" source="1900" target="2507" edge="1">
        <mxGeometry x="-1971.68" y="-940.5200000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1971.68" y="-840.5200000000002" as="sourcePoint" />
          <mxPoint x="-1871.6799999999998" y="-940.5200000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1792" id="1792">
      <mxCell style="link" parent="2667" source="1903" target="2507" edge="1">
        <mxGeometry x="-1971.68" y="-940.5200000000002" width="100" height="100" as="geometry">
          <mxPoint x="-1971.68" y="-840.5200000000002" as="sourcePoint" />
          <mxPoint x="-1871.6799999999998" y="-940.5200000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="Aluminium Market" Note="" Type="None" Solver="{&quot;enabled&quot;:false,&quot;algorithm&quot;:&quot;RK1&quot;,&quot;timeStep&quot;:1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="2666" id="2666">
      <mxCell style="folder" vertex="1" parent="1">
        <mxGeometry x="1483.7799999999993" y="929" width="402.3500000000008" height="366.9200000000001" as="geometry" />
      </mxCell>
    </Folder>
    <Variable name="Al supply gap correction function switched" Note="" Equation="If [material supply constrain switch]=1 Then&#xa;  [Al supply gap correction function]*[Al market shortage correction function]&#xa;Else&#xa;  1&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1843" LiveGraph="{&quot;active&quot;:false}" id="1843">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2666" vertex="1">
        <mxGeometry x="105.63000000000056" y="295.6299999999999" width="57.56" height="47.49" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="1853" oldId="1854" name="material supply constrain switch" id="1854">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;opacity=30;" parent="2666" vertex="1">
        <mxGeometry x="36.6800000000012" y="286.30999999999995" width="60" height="60" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1855" id="1855">
      <mxCell style="link" parent="2666" source="1854" target="1843" edge="1">
        <mxGeometry x="-2111.519999999999" y="-553.08" width="100" height="100" as="geometry">
          <mxPoint x="-2111.519999999999" y="-453.08000000000004" as="sourcePoint" />
          <mxPoint x="-2011.519999999999" y="-553.08" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="AL prim CF 2" Note="" InitialValue="0.88" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1861" id="1861">
      <mxCell style="stock;fontSize=6;" parent="2666" vertex="1">
        <mxGeometry x="46.8100000000004" y="163.11" width="67.67" height="13.7" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al prim CF change" Note="" FlowRate="[delta Al prim CF]&#xa;#If [delta Al prim CF]&gt;[Al prim CF increase limit] Then&#xa;#  [Al prim CF increase limit]&#xa;#Else If [delta Al prim CF]&lt;[Al prim CF decrease limit] Then&#xa;#  [Al prim CF decrease limit]&#xa;#Else&#xa;# # [delta Al prim CF]&#xa;#End If" OnlyPositive="false" TimeIndependent="false" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1862" id="1862">
      <mxCell style="flow;startFill=0;fontSize=6;startArrow=block;" parent="2666" target="1861" edge="1">
        <mxGeometry x="-1226.2699999999993" y="-838.4999999999999" width="100" height="100" as="geometry">
          <mxPoint x="59.67000000000053" y="124.40999999999997" as="sourcePoint" />
          <mxPoint x="-1226.2699999999993" y="-738.5" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="delta Al prim CF" Note="" Equation="If [AL prim CF 2]&gt;=1 And [Al prim CF corr]&gt;=0 Then&#xa;  0&#xa;Else If [AL prim CF 2]&lt;=0 And [Al prim CF corr]&lt;=0 Then&#xa;  0&#xa;Else&#xa;  [Al prim CF corr]&#xa;End If" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1865" id="1865">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2666" vertex="1">
        <mxGeometry x="77.35000000000036" y="118.88999999999999" width="38.06" height="26.05" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1867" id="1867">
      <mxCell style="link" parent="2666" source="1865" target="1862" edge="1">
        <mxGeometry x="-1240.959999999999" y="-704.5" width="100" height="100" as="geometry">
          <mxPoint x="-1240.959999999999" y="-604.5" as="sourcePoint" />
          <mxPoint x="-1140.959999999999" y="-704.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim CF" Note="" Equation="Max(0,Min(1,[AL prim CF 2]))" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1868" id="1868">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2666" vertex="1">
        <mxGeometry x="79.07000000000062" y="186.87" width="35.41" height="20.94" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1869" id="1869">
      <mxCell style="link" parent="2666" source="1861" target="1868" edge="1">
        <mxGeometry x="-1245.959999999999" y="-750.29" width="100" height="100" as="geometry">
          <mxPoint x="-1245.959999999999" y="-650.29" as="sourcePoint" />
          <mxPoint x="-1145.959999999999" y="-750.29" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al primary 1" Note="" Equation="If [material supply constrain switch]=1 Then&#xa;  [Al eff prim capacity]*[Al prim CF]&#xa;Else&#xa;  [Al prim required]&#xa;End If" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1872" id="1872">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2666" vertex="1">
        <mxGeometry x="126.44000000000051" y="189.17999999999995" width="36.19" height="27.68" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1879" id="1879">
      <mxCell style="link" parent="2666" source="1956" target="1872" edge="1">
        <mxGeometry x="-2152.2399999999993" y="-547.2900000000001" width="100" height="100" as="geometry">
          <mxPoint x="-2152.2399999999993" y="-447.2900000000001" as="sourcePoint" />
          <mxPoint x="-2052.2399999999993" y="-547.2900000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1880" id="1880">
      <mxCell style="link" parent="2666" source="1868" target="1872" edge="1">
        <mxGeometry x="-2152.2399999999993" y="-547.2900000000001" width="100" height="100" as="geometry">
          <mxPoint x="-2152.2399999999993" y="-447.2900000000001" as="sourcePoint" />
          <mxPoint x="-2052.2399999999993" y="-547.2900000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim CF correction threshold" Note="From this CF onwards, demand needs to be reduced in order to prevent supply shortage&lt;br&gt;" Equation="0" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.99" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1882" LiveGraph="{&quot;active&quot;:false}" id="1882">
      <mxCell style="variable;fontSize=8;fillColor=#99CC00;" parent="2666" vertex="1">
        <mxGeometry x="39.780000000000655" y="225.24" width="53.81" height="49.94" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al supply gap correction function" Note="" Equation="If [Al prim CF]&lt;[Al prim CF correction threshold] Then&#xa;  1&#xa;Else&#xa;  Max(0,1-(([Al prim CF]-[Al prim CF correction threshold])/(1-[Al prim CF correction threshold]))^[Al prim supply gap correction exponent])&#xa;End If&#xa;&#xa;#Max(0,Min(1, -1/(1-[Al prim CF correction threshold])*[Al prim CF]+1/(1-[Al prim CF correction threshold])))&#xa;" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1883" LiveGraph="{&quot;active&quot;:false}" id="1883">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2666" vertex="1">
        <mxGeometry x="109.58000000000038" y="225.3900000000001" width="51.97" height="49.79" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1884" id="1884">
      <mxCell style="link" parent="2666" source="1882" target="1883" edge="1">
        <mxGeometry x="-2145.8199999999993" y="-551.7500000000001" width="100" height="100" as="geometry">
          <mxPoint x="-2145.8199999999993" y="-451.75" as="sourcePoint" />
          <mxPoint x="-2045.8199999999993" y="-551.7500000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1885" id="1885">
      <mxCell style="link" parent="2666" source="1868" target="1883" edge="1">
        <mxGeometry x="-2152.2399999999993" y="-547.2900000000001" width="100" height="100" as="geometry">
          <mxPoint x="-2152.2399999999993" y="-447.2900000000001" as="sourcePoint" />
          <mxPoint x="-2052.2399999999993" y="-547.2900000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1892" id="1892">
      <mxCell style="link" parent="2666" source="1883" target="1843" edge="1">
        <mxGeometry x="-2113.0599999999995" y="-552.1800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-2113.0599999999995" y="-452.18000000000006" as="sourcePoint" />
          <mxPoint x="-2013.0599999999995" y="-552.1800000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="K_p for Al prim CF" Note="" Equation="0.4" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1.2" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1911" id="1911">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2666" vertex="1">
        <mxGeometry x="20" y="72.13000000000022" width="40" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al prim CF error" Note="" Equation="[Al prim CF error market change]+[Al CF market factor]*[Al prim CF error market]+[Al CF market filling factor]*([Al prim CF market filling]+[Al prim CF market overfilling])&#xa;&#xa;#(-[Al market stock change]/[Al eff prim capacity]-([Al market stock]-[Al market stock 0])/([Al eff prim capacity]*{1 Years})*[Al CF market factor]) + [Al CF market filling factor]*([Al prim CF market filling]+[Al prim CF market overfilling])&#xa;&#xa;#(-[Al prim supply gap]/[Al eff prim capacity]-[Al market stock]/([Al eff prim capacity]*{1 Years})*[Al CF market factor])*[Al CF error multiplier]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1924" LiveGraph="{&quot;active&quot;:false}" id="1924">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2666" vertex="1">
        <mxGeometry x="127.98000000000047" y="107.51000000000022" width="36.75" height="29.5" as="geometry" />
      </mxCell>
    </Variable>
    <Flow name="gap" Note="error" FlowRate="[Al prim CF error]" OnlyPositive="false" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1925" id="1925">
      <mxCell style="flow;startArrow=block;startFill=0;strokeColor=#969696;rounded=0;fontSize=8;fontColor=#FF0000;" parent="2666" target="1926" edge="1">
        <mxGeometry x="-2436.389999999999" y="-200.47000000000014" width="100" height="100" as="geometry">
          <mxPoint x="183.61000000000058" y="37.620000000000005" as="sourcePoint" />
          <mxPoint x="-3331.3899999999994" y="-82.64000000000021" as="targetPoint" />
          <mxPoint y="-12" as="offset" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="integrated gap" Note="integrated error" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1926" id="1926">
      <mxCell style="stock;fillColor=#C0C0C0;fontSize=8;fontColor=#FF0000;" parent="2666" vertex="1">
        <mxGeometry x="64.77000000000044" y="32.609999999999786" width="63.21" height="13" as="geometry" />
      </mxCell>
    </Stock>
    <Link name="Link" Note="" BiDirectional="false" oldId="1930" id="1930">
      <mxCell style="link" parent="2666" source="1924" target="1925" edge="1">
        <mxGeometry x="-1726.3899999999994" y="-742.3799999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1726.3899999999994" y="-642.3799999999999" as="sourcePoint" />
          <mxPoint x="-1626.3899999999992" y="-742.3799999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="K_i for Al prim CF" Note="" Equation="0" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="10" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1931" id="1931">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2666" vertex="1">
        <mxGeometry x="134.23000000000002" y="51.44999999999993" width="40" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al prim CF corr" Note="" Equation="[Al prim CF error]*[K_p for Al prim CF]+[integrated gap]*[K_i for Al prim CF]+([Al prim CF error]-Smooth([Al prim CF error], TimeStep() / {1 Years}, [Al prim CF error]))/TimeStep() * {1 Years}*[K_d for Al prim CF]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1932" LiveGraph="{&quot;active&quot;:false}" id="1932">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2666" vertex="1">
        <mxGeometry x="79.92000000000053" y="70.32999999999981" width="39.58" height="33.09" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1933" id="1933">
      <mxCell style="link" parent="2666" source="1926" target="1932" edge="1">
        <mxGeometry x="-1726.3899999999994" y="-742.3799999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1726.3899999999994" y="-642.3799999999999" as="sourcePoint" />
          <mxPoint x="-1626.3899999999992" y="-742.3799999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1934" id="1934">
      <mxCell style="link" parent="2666" source="1931" target="1932" edge="1">
        <mxGeometry x="-1726.3899999999994" y="-742.3799999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1726.3899999999994" y="-642.3799999999999" as="sourcePoint" />
          <mxPoint x="-1626.3899999999992" y="-742.3799999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1935" id="1935">
      <mxCell style="link" parent="2666" source="1924" target="1932" edge="1">
        <mxGeometry x="-1726.3899999999994" y="-681.8999999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1726.3899999999994" y="-581.9000000000001" as="sourcePoint" />
          <mxPoint x="-1626.3899999999992" y="-681.8999999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1936" id="1936">
      <mxCell style="link" parent="2666" source="1911" target="1932" edge="1">
        <mxGeometry x="-1726.3899999999994" y="-681.8999999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1726.3899999999994" y="-581.9000000000001" as="sourcePoint" />
          <mxPoint x="-1626.3899999999992" y="-681.8999999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1951" id="1951">
      <mxCell style="link" parent="2666" source="1932" target="1865" edge="1">
        <mxGeometry x="-1726.3899999999994" y="-681.8999999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1726.3899999999994" y="-581.9000000000001" as="sourcePoint" />
          <mxPoint x="-1626.3899999999992" y="-681.8999999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="K_d for Al prim CF" Note="" Equation="0" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1.2" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1952" id="1952">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2666" vertex="1">
        <mxGeometry x="21.050000000000182" y="34.33000000000004" width="40" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1953" id="1953">
      <mxCell style="link" parent="2666" source="1952" target="1932" edge="1">
        <mxGeometry x="-1726.3899999999994" y="-742.3799999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1726.3899999999994" y="-642.3799999999999" as="sourcePoint" />
          <mxPoint x="-1626.3899999999992" y="-742.3799999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1938" oldId="1956" name="Al eff prim capacity" id="1956">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2666" vertex="1">
        <mxGeometry x="174.23000000000047" y="189.42999999999972" width="48.75" height="27.43" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1957" id="1957">
      <mxCell style="link" parent="2666" source="1861" target="1865" edge="1">
        <mxGeometry x="-1726.3899999999994" y="-681.8999999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1726.3899999999994" y="-581.9000000000001" as="sourcePoint" />
          <mxPoint x="-1626.3899999999992" y="-681.8999999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1958" oldId="1960" name="Al market stock" id="1960">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2666" vertex="1">
        <mxGeometry x="264.08000000000106" y="168.31999999999982" width="36.75" height="29.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1961" id="1961">
      <mxCell style="link" parent="2666" source="1960" target="1924" edge="1">
        <mxGeometry x="-1726.3899999999994" y="-681.8999999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1726.3899999999994" y="-581.9000000000001" as="sourcePoint" />
          <mxPoint x="-1626.3899999999992" y="-681.8999999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al CF market factor" Note="0 or 1&lt;br&gt;" Equation="0.6" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1962" id="1962">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2666" vertex="1">
        <mxGeometry x="178.6100000000008" y="51.289999999999964" width="40" height="45.46" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1963" id="1963">
      <mxCell style="link" parent="2666" source="1962" target="1924" edge="1">
        <mxGeometry x="-1726.3899999999994" y="-742.3799999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1726.3899999999994" y="-642.3799999999999" as="sourcePoint" />
          <mxPoint x="-1626.3899999999992" y="-742.3799999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim supply gap correction exponent" Note="" Equation="6" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="10" SliderMin="1" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2135" LiveGraph="{&quot;active&quot;:false}" id="2135">
      <mxCell style="variable;fontSize=8;fillColor=#99CC00;" parent="2666" vertex="1">
        <mxGeometry x="174.23000000000093" y="224.03999999999996" width="53.81" height="49.94" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2136" id="2136">
      <mxCell style="link" parent="2666" source="2135" target="1883" edge="1">
        <mxGeometry x="-1912.8099999999993" y="-512.19" width="100" height="100" as="geometry">
          <mxPoint x="-1912.8099999999993" y="-412.19" as="sourcePoint" />
          <mxPoint x="-1812.8099999999993" y="-512.19" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al market stock change" Note="" Equation="([Al market stock]-Smooth([Al market stock],TimeStep(),[Al market stock]))/TimeStep()" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2383" LiveGraph="{&quot;active&quot;:false}" id="2383">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2666" vertex="1">
        <mxGeometry x="191.9800000000007" y="145.26" width="39.75" height="43.92" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2396" id="2396">
      <mxCell style="link" parent="2666" source="1960" target="2383" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2397" oldId="2399" name="Al market stock 0" id="2399">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2666" vertex="1">
        <mxGeometry x="124.75000000000114" y="154.57000000000005" width="36.75" height="29.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2400" id="2400">
      <mxCell style="link" parent="2666" source="2399" target="1924" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al market shortage correction function" Note="" Equation="If [Al market stock]&lt;[Al market stock 0] Then&#xa;  Max(0,Min(1,1-(([Al market stock]-[Al market stock 0])/(-[Al market stock 0]))^[Al market shortage correction exponent]))&#xa;Else&#xa;  1&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2401" LiveGraph="{&quot;active&quot;:false}" id="2401">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2666" vertex="1">
        <mxGeometry x="179.76000000000022" y="297.1300000000001" width="51.97" height="49.79" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2402" id="2402">
      <mxCell style="link" parent="2666" source="1960" target="2401" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2403" id="2403">
      <mxCell style="link" parent="2666" source="2399" target="2401" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al market shortage correction exponent" Note="" Equation="5" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="10" SliderMin="1" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2404" LiveGraph="{&quot;active&quot;:false}" id="2404">
      <mxCell style="variable;fontSize=8;fillColor=#99CC00;" parent="2666" vertex="1">
        <mxGeometry x="229.83000000000084" y="225.21000000000004" width="53.81" height="49.94" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2405" id="2405">
      <mxCell style="link" parent="2666" source="2404" target="2401" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2406" id="2406">
      <mxCell style="link" parent="2666" source="2401" target="1843" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim CF market filling" Note="" Equation="If [Al market stock]&lt;[Al market filling target] Then&#xa;  Min(1,(([Al market stock]-[Al market filling target])/(-[Al market filling target]))^[Al market filling exponent])&#xa;Else&#xa;  0&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2407" LiveGraph="{&quot;active&quot;:false}" id="2407">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2666" vertex="1">
        <mxGeometry x="308.8500000000008" y="97.90999999999997" width="36.75" height="40.26" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2408" id="2408">
      <mxCell style="link" parent="2666" source="1960" target="2407" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al market filling exponent" Note="" Equation="2" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="10" SliderMin="1" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2410" LiveGraph="{&quot;active&quot;:false}" id="2410">
      <mxCell style="variable;fontSize=8;fillColor=#99CC00;" parent="2666" vertex="1">
        <mxGeometry x="328.54000000000065" y="158.10000000000002" width="53.81" height="49.94" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2411" id="2411">
      <mxCell style="link" parent="2666" source="2410" target="2407" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2412" id="2412">
      <mxCell style="link" parent="2666" source="2407" target="1924" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al market filling target" Note="" Equation="0.02" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="0.1" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2413" id="2413">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2666" vertex="1">
        <mxGeometry x="233.4800000000007" y="20" width="40" height="45.46" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2414" id="2414">
      <mxCell style="link" parent="2666" source="2413" target="2407" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al CF market filling factor" Note="" Equation="0.3" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="5" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2415" id="2415">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2666" vertex="1">
        <mxGeometry x="335.44000000000074" y="26.00999999999999" width="40" height="45.46" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al market filling max" Note="" Equation="0.07" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="0.1" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2416" id="2416">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2666" vertex="1">
        <mxGeometry x="283.6400000000008" y="20" width="40" height="45.46" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al prim CF market overfilling" Note="" Equation="If [Al market stock]&lt;[Al market filling target] Then&#xa;  0&#xa;Else&#xa;  Max(-1,-(([Al market stock]-[Al market filling target])/([Al market filling max]-[Al market filling target]))^[Al market filling exponent])&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2418" LiveGraph="{&quot;active&quot;:false}" id="2418">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2666" vertex="1">
        <mxGeometry x="345.6000000000008" y="96.75" width="36.75" height="40.26" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2419" id="2419">
      <mxCell style="link" parent="2666" source="2413" target="2418" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2420" id="2420">
      <mxCell style="link" parent="2666" source="2416" target="2418" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2421" id="2421">
      <mxCell style="link" parent="2666" source="2410" target="2418" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2422" id="2422">
      <mxCell style="link" parent="2666" source="2415" target="1924" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2423" id="2423">
      <mxCell style="link" parent="2666" source="1960" target="2418" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2425" id="2425">
      <mxCell style="link" parent="2666" source="2418" target="1924" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim CF error market" Note="" Equation="-([Al market stock]-[Al market filling target])/([Al eff prim capacity]*{1 Years})" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2426" LiveGraph="{&quot;active&quot;:false}" id="2426">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2666" vertex="1">
        <mxGeometry x="227.33000000000038" y="105.4100000000002" width="36.75" height="29.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2427" id="2427">
      <mxCell style="link" parent="2666" source="1960" target="2426" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2429" id="2429">
      <mxCell style="link" parent="2666" source="2413" target="2426" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim CF error market change" Note="" Equation="-[Al market stock change]/[Al eff prim capacity]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2430" LiveGraph="{&quot;active&quot;:false}" id="2430">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2666" vertex="1">
        <mxGeometry x="182.76000000000045" y="105.4100000000002" width="36.75" height="29.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2431" id="2431">
      <mxCell style="link" parent="2666" source="2383" target="2430" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2432" id="2432">
      <mxCell style="link" parent="2666" source="1956" target="2426" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2433" id="2433">
      <mxCell style="link" parent="2666" source="2426" target="1924" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2434" id="2434">
      <mxCell style="link" parent="2666" source="2430" target="1924" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="constraint mapping" Note="&lt;div&gt;0 = energy constraint&lt;/div&gt;&lt;div&gt;1 = capacity constraint&lt;/div&gt;&lt;div&gt;2 = market shortage&lt;/div&gt;&lt;div&gt;3 = capacity and market constraint&lt;br&gt;&lt;/div&gt;" Equation="If [Al supply gap correction function]&gt;0.95 And [Al market shortage correction function]&gt;0.95 Then&#xa;  0&#xa;Else If [Al supply gap correction function]&lt;0.95 And [Al market shortage correction function]&gt;0.95 Then&#xa;  1&#xa;Else If [Al supply gap correction function]&gt;0.95 And [Al market shortage correction function]&lt;0.95 Then&#xa;  2&#xa;Else&#xa;  3&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="10" SliderMin="1" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2442" LiveGraph="{&quot;active&quot;:false}" id="2442">
      <mxCell style="variable;fontSize=8;fillColor=#99CC00;" parent="2666" vertex="1">
        <mxGeometry x="273.4800000000009" y="294.4000000000001" width="53.81" height="49.94" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2443" id="2443">
      <mxCell style="link" parent="2666" source="1883" target="2442" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2444" id="2444">
      <mxCell style="link" parent="2666" source="2401" target="2442" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1820" oldId="2447" name="Al prim required" id="2447">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2666" vertex="1">
        <mxGeometry x="28.02000000000112" y="186.87000000000012" width="36.75" height="29.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2448" id="2448">
      <mxCell style="link" parent="2666" source="2447" target="1872" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1928" id="1928">
      <mxCell style="link" parent="2666" source="1956" target="2430" edge="1">
        <mxGeometry x="-1726.3899999999994" y="-681.8999999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1726.3899999999994" y="-581.9000000000001" as="sourcePoint" />
          <mxPoint x="-1626.3899999999992" y="-681.8999999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2449" id="2449">
      <mxCell style="link" parent="2666" source="1854" target="1872" edge="1">
        <mxGeometry x="-1154.5599999999993" y="-833.25" width="100" height="100" as="geometry">
          <mxPoint x="-1154.5599999999993" y="-733.25" as="sourcePoint" />
          <mxPoint x="-1054.5599999999993" y="-833.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="Material SupplyChain" Note="" Type="None" Solver="{&quot;enabled&quot;:false,&quot;algorithm&quot;:&quot;RK1&quot;,&quot;timeStep&quot;:1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="2665" id="2665">
      <mxCell style="folder" vertex="1" parent="1">
        <mxGeometry x="344.0500000000003" y="560.33" width="634.4599999999997" height="245.84000000000003" as="geometry" />
      </mxCell>
    </Folder>
    <Stock name="Al new prim production capacity" Note="Gt/a capacity&lt;br&gt;" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1752" id="1752">
      <mxCell style="stock;fontSize=10;fillColor=#B3E2CD;" parent="2665" vertex="1">
        <mxGeometry x="360.14" y="75.89999999999998" width="67.31" height="52.57" as="geometry" />
      </mxCell>
    </Stock>
    <Stock name="Al prim production capacity in construction 1" Note="" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1753" id="1753">
      <mxCell style="stock;fontSize=10;fillColor=#B3E2CD;" parent="2665" vertex="1">
        <mxGeometry x="153.25" y="69.11000000000001" width="70" height="60" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al prim cap constructed" Note="" FlowRate="Delay3([Al prim cap constr 2],([Al prim construction time]-[Al prim min construction time]),0)" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1754" id="1754">
      <mxCell style="flow;fontSize=6;" parent="2665" source="2343" target="1752" edge="1">
        <mxGeometry x="-1136.7500000000002" y="-871.0300000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1136.7500000000002" y="-771.0300000000001" as="sourcePoint" />
          <mxPoint x="-1036.7500000000002" y="-871.0300000000001" as="targetPoint" />
          <Array as="points" />
          <mxPoint x="-5" y="10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="Al prim cap constructing" Note="" FlowRate="[Al additional prim capacity constructing]/({1 Gt/a}*{1 Years})" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1755" id="1755">
      <mxCell style="flow;fontSize=6;" parent="2665" target="1753" edge="1">
        <mxGeometry x="-1136.7500000000002" y="-840.8900000000001" width="100" height="100" as="geometry">
          <mxPoint x="63.25" y="99.11000000000001" as="sourcePoint" />
          <mxPoint x="-1136.7500000000002" y="-740.8900000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="103.25" y="99.11000000000001" />
          </Array>
          <mxPoint x="-5" y="10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="Al prim cap 2" Note="" FlowRate="Delay([Al prim cap constructed],[Al prim cap min lifetime],0)" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1756" id="1756">
      <mxCell style="flow;fontSize=6;" parent="2665" source="1752" target="1774" edge="1">
        <mxGeometry x="-1029.8600000000001" y="-834.1" width="100" height="100" as="geometry">
          <mxPoint x="-1029.8600000000001" y="-734.1" as="sourcePoint" />
          <mxPoint x="530.14" y="105.89999999999998" as="targetPoint" />
          <Array as="points" />
          <mxPoint x="-10" y="10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="Al prim capacity" Note="" Equation="([Al new prim production capacity]+[Al new prim production capacity 2])*{1 Gt/a} + [Al old prim capacity]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1757" id="1757">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2665" vertex="1">
        <mxGeometry x="440.41999999999973" y="58.749999999999886" width="48.75" height="27.43" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1758" id="1758">
      <mxCell style="link" parent="2665" source="1752" target="1757" edge="1">
        <mxGeometry x="-1189.6100000000001" y="-974.1" width="100" height="100" as="geometry">
          <mxPoint x="-1189.6100000000001" y="-874.1" as="sourcePoint" />
          <mxPoint x="-1089.6100000000001" y="-974.1" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim construction time" Note="time needed to build and put in operation primary infrastructure (i.e. mines, refineries, smelters)&lt;br&gt;" Equation="7" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="20" SliderMin="1" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1759" id="1759">
      <mxCell style="variable;fontSize=8;fillColor=#99CC00;" parent="2665" vertex="1">
        <mxGeometry x="267.4299999999997" y="133.93999999999994" width="50.03" height="31.64" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1760" id="1760">
      <mxCell style="link" parent="2665" source="2344" target="1754" edge="1">
        <mxGeometry x="-1378.5000000000002" y="-858.32" width="100" height="100" as="geometry">
          <mxPoint x="-1378.5000000000002" y="-758.3200000000002" as="sourcePoint" />
          <mxPoint x="-1278.5000000000002" y="-858.32" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1761" id="1761">
      <mxCell style="link" parent="2665" source="1759" target="1754" edge="1">
        <mxGeometry x="-1378.5000000000002" y="-858.32" width="100" height="100" as="geometry">
          <mxPoint x="-1378.5000000000002" y="-758.3200000000002" as="sourcePoint" />
          <mxPoint x="-1278.5000000000002" y="-858.32" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al additional prim capacity ordered" Note="" Equation="If [material supply constrain switch]=1 Then&#xa;  [Al eff prim capacity]*[Al prim cap building function]&#xa;Else&#xa;  [Al prim required]-[Al eff prim capacity]&#xa;End If" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1763" id="1763">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2665" vertex="1">
        <mxGeometry x="76.90000000000009" y="50.95999999999992" width="60" height="33.36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1764" id="1764">
      <mxCell style="link" parent="2665" source="1938" target="1763" edge="1">
        <mxGeometry x="-1378.5000000000002" y="-858.32" width="100" height="100" as="geometry">
          <mxPoint x="-1378.5000000000002" y="-758.3200000000002" as="sourcePoint" />
          <mxPoint x="-1278.5000000000002" y="-858.32" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1765" id="1765">
      <mxCell style="link" parent="2665" source="1763" target="1897" edge="1">
        <mxGeometry x="-1378.5000000000002" y="-858.32" width="100" height="100" as="geometry">
          <mxPoint x="-1378.5000000000002" y="-758.3200000000002" as="sourcePoint" />
          <mxPoint x="-1278.5000000000002" y="-858.32" as="targetPoint" />
          <Array as="points">
            <mxPoint x="89.52999999999975" y="108.32000000000005" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim permitting factor" Note="" Equation="0.2" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1766" id="1766">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2665" vertex="1">
        <mxGeometry x="148.94000000000005" y="129.11" width="55" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1767" id="1767">
      <mxCell style="link" parent="2665" source="1766" target="1897" edge="1">
        <mxGeometry x="-1378.5000000000002" y="-858.32" width="100" height="100" as="geometry">
          <mxPoint x="-1378.5000000000002" y="-758.3200000000002" as="sourcePoint" />
          <mxPoint x="-1278.5000000000002" y="-858.32" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="Al old prim production capacity relative" Note="capacity depreciation&lt;br&gt;" InitialValue="1" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1768" id="1768">
      <mxCell style="stock;fontSize=10;fillColor=#B3E2CD;" parent="2665" vertex="1">
        <mxGeometry x="359.66999999999996" y="146.11" width="67.31" height="50" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al old prim cap retiring" Note="" FlowRate="[Al old prim capacity retirement normalized L=40a] + ([Al old prim capacity retirement normalized L=50a]-[Al old prim capacity retirement normalized L=40a])/({50 a}-{40 a})*([Al old prim cap lifetime]-{40 a})" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1769" LiveGraph="{&quot;active&quot;:false}" id="1769">
      <mxCell style="flow;fontSize=6;" parent="2665" source="1768" edge="1">
        <mxGeometry x="-488.5200000000003" y="-806.39" width="100" height="100" as="geometry">
          <mxPoint x="493.7400000000001" y="191.05999999999983" as="sourcePoint" />
          <mxPoint x="627.2099999999999" y="170.87" as="targetPoint" />
          <Array as="points">
            <mxPoint x="497.2099999999999" y="170.87" />
            <mxPoint x="584.2099999999999" y="172.87" />
          </Array>
          <mxPoint x="-16" y="-7" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="1770" id="1770">
      <mxCell style="link" parent="2665" source="1901" target="1757" edge="1">
        <mxGeometry x="-1256.3600000000001" y="-851.53" width="100" height="100" as="geometry">
          <mxPoint x="-1256.3600000000001" y="-751.5300000000001" as="sourcePoint" />
          <mxPoint x="-1156.3600000000001" y="-851.53" as="targetPoint" />
          <Array as="points">
            <mxPoint x="421.9499999999997" y="135.64" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim cap min lifetime" Note="&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; width=&quot;369&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;369&quot;&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr height=&quot;20&quot;&gt;&#xa;  &lt;td height=&quot;20&quot; class=&quot;xl66&quot; width=&quot;369&quot; style=&quot;height:15.0pt;width:277pt&quot;&gt;minimum&#xa;  lifetime of newly added primary capacity&lt;/td&gt;&#xa;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;" Equation="10" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1771" id="1771">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2665" vertex="1">
        <mxGeometry x="442.30000000000007" y="124.46000000000015" width="51.75" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1772" id="1772">
      <mxCell style="link" parent="2665" source="1771" target="1756" edge="1">
        <mxGeometry x="-1256.3600000000001" y="-851.53" width="100" height="100" as="geometry">
          <mxPoint x="-1256.3600000000001" y="-751.5300000000001" as="sourcePoint" />
          <mxPoint x="-1156.3600000000001" y="-851.53" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1773" id="1773">
      <mxCell style="link" parent="2665" source="1754" target="1756" edge="1">
        <mxGeometry x="-1326.7500000000002" y="-858.32" width="100" height="100" as="geometry">
          <mxPoint x="-1326.7500000000002" y="-758.3200000000002" as="sourcePoint" />
          <mxPoint x="-1226.7500000000002" y="-858.32" as="targetPoint" />
          <Array as="points">
            <mxPoint x="333.25" y="81.68000000000018" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="Al new prim production capacity 2" Note="Gt/a capacity&lt;br&gt;" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1774" id="1774">
      <mxCell style="stock;fontSize=10;fillColor=#B3E2CD;" parent="2665" vertex="1">
        <mxGeometry x="489.16999999999973" y="76.5200000000001" width="53.81" height="52.57" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al prim cap retiring" Note="" FlowRate="Delay3([Al prim cap 2],[Al prim cap lifetime]-[Al prim cap min lifetime],0)" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1775" id="1775">
      <mxCell style="flow;fontSize=6;" parent="2665" source="1774" edge="1">
        <mxGeometry x="-835.0100000000001" y="-814.5100000000001" width="100" height="100" as="geometry">
          <mxPoint x="624.9899999999999" y="121.77499999999998" as="sourcePoint" />
          <mxPoint x="629.0299999999999" y="103.69999999999993" as="targetPoint" />
          <Array as="points">
            <mxPoint x="567.68" y="101.90999999999997" />
          </Array>
          <mxPoint x="-10" y="10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="Al prim cap lifetime" Note="&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; width=&quot;369&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;369&quot;&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr height=&quot;20&quot;&gt;&#xa;  &lt;td height=&quot;20&quot; class=&quot;xl66&quot; width=&quot;369&quot; style=&quot;height:15.0pt;width:277pt&quot;&gt;average&#xa;  lifetime of newly added primary capacity&lt;/td&gt;&#xa;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;" Equation="45" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1776" id="1776">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2665" vertex="1">
        <mxGeometry x="562.7099999999997" y="123.45999999999992" width="51.75" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1777" id="1777">
      <mxCell style="link" parent="2665" source="1756" target="1775" edge="1">
        <mxGeometry x="-1256.3600000000001" y="-851.53" width="100" height="100" as="geometry">
          <mxPoint x="-1256.3600000000001" y="-751.5300000000001" as="sourcePoint" />
          <mxPoint x="-1156.3600000000001" y="-851.53" as="targetPoint" />
          <Array as="points">
            <mxPoint x="527.4499999999999" y="85.18000000000018" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1778" id="1778">
      <mxCell style="link" parent="2665" source="1776" target="1775" edge="1">
        <mxGeometry x="-1256.3600000000001" y="-851.53" width="100" height="100" as="geometry">
          <mxPoint x="-1256.3600000000001" y="-751.5300000000001" as="sourcePoint" />
          <mxPoint x="-1156.3600000000001" y="-851.53" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1779" id="1779">
      <mxCell style="link" parent="2665" source="1771" target="1775" edge="1">
        <mxGeometry x="-1256.3600000000001" y="-851.53" width="100" height="100" as="geometry">
          <mxPoint x="-1256.3600000000001" y="-751.5300000000001" as="sourcePoint" />
          <mxPoint x="-1156.3600000000001" y="-851.53" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1780" id="1780">
      <mxCell style="link" parent="2665" source="1774" target="1757" edge="1">
        <mxGeometry x="-1256.3600000000001" y="-851.53" width="100" height="100" as="geometry">
          <mxPoint x="-1256.3600000000001" y="-751.5300000000001" as="sourcePoint" />
          <mxPoint x="-1156.3600000000001" y="-851.53" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim CF building threshold" Note="Factor describing from what CF onwards construction of new recycling facilities starts&lt;br&gt;" Equation="0.7" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1783" id="1783">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2665" vertex="1">
        <mxGeometry x="20" y="174.5100000000001" width="55" height="36.89" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1784" id="1784">
      <mxCell style="link" parent="2665" source="1783" target="1894" edge="1">
        <mxGeometry x="-1333.9500000000003" y="-745.6400000000001" width="100" height="100" as="geometry">
          <mxPoint x="-1333.9500000000003" y="-645.6400000000001" as="sourcePoint" />
          <mxPoint x="-1233.9500000000003" y="-745.6400000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1868" oldId="1886" name="Al prim CF" id="1886">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2665" vertex="1">
        <mxGeometry x="158.34999999999945" y="179.2500000000001" width="36.19" height="27.68" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1887" id="1887">
      <mxCell style="link" parent="2665" source="1886" target="1888" edge="1">
        <mxGeometry x="-1327.2500000000002" y="-492.46999999999997" width="100" height="100" as="geometry">
          <mxPoint x="-1327.2500000000002" y="-392.46999999999997" as="sourcePoint" />
          <mxPoint x="-1227.2500000000002" y="-492.46999999999997" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim cap building function raw" Note="" Equation="If [Al prim CF]&gt;[Al prim CF building threshold] Then&#xa;  (([Al prim CF]-[Al prim CF building threshold])/(1-[Al prim CF building threshold]))^[Al capacity building exponent]&#xa;Else&#xa;  0&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1888" id="1888">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2665" vertex="1">
        <mxGeometry x="88.36999999999989" y="174.5100000000001" width="46.63" height="37" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1893" id="1893">
      <mxCell style="link" parent="2665" source="1783" target="1888" edge="1">
        <mxGeometry x="-1338.2600000000002" y="-316.4999999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1338.2600000000002" y="-216.5000000000001" as="sourcePoint" />
          <mxPoint x="-1238.2600000000002" y="-316.4999999999999" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim cap building function" Note="" Equation="Min(1,Max(0,[Al prim cap building function raw]))" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1894" id="1894">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2665" vertex="1">
        <mxGeometry x="23.6899999999996" y="129.11" width="46.63" height="37" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1896" id="1896">
      <mxCell style="link" parent="2665" source="1894" target="1763" edge="1">
        <mxGeometry x="-1327.2500000000002" y="-492.46999999999997" width="100" height="100" as="geometry">
          <mxPoint x="-1327.2500000000002" y="-392.46999999999997" as="sourcePoint" />
          <mxPoint x="-1227.2500000000002" y="-492.46999999999997" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al additional prim capacity constructing" Note="" Equation="[Al additional prim capacity ordered]*[Al prim permitting factor]/[max capacity utilization factor]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1897" id="1897">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2665" vertex="1">
        <mxGeometry x="75" y="129.11" width="60" height="33.36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1898" id="1898">
      <mxCell style="link" parent="2665" source="1897" target="1755" edge="1">
        <mxGeometry x="-1327.2500000000002" y="-492.46999999999997" width="100" height="100" as="geometry">
          <mxPoint x="-1327.2500000000002" y="-392.46999999999997" as="sourcePoint" />
          <mxPoint x="-1227.2500000000002" y="-492.46999999999997" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al old prim capacity" Note="" Equation="[Al old prim production capacity relative]*[Al old prim capacity 0]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1901" id="1901">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2665" vertex="1">
        <mxGeometry x="432.7299999999998" y="189.45000000000005" width="48.75" height="27.43" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1902" id="1902">
      <mxCell style="link" parent="2665" source="1768" target="1901" edge="1">
        <mxGeometry x="-1257.3300000000004" y="-475.46999999999997" width="100" height="100" as="geometry">
          <mxPoint x="-1257.3300000000004" y="-375.46999999999997" as="sourcePoint" />
          <mxPoint x="-1157.3300000000004" y="-475.46999999999997" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al eff prim capacity" Note="effective primary capacity curtailed by the utilization factor&lt;br&gt;" Equation="[max capacity utilization factor]*[Al prim capacity]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1938" LiveGraph="{&quot;active&quot;:false}" id="1938">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2665" vertex="1">
        <mxGeometry x="373.81000000000006" y="46.76999999999987" width="48.75" height="27.43" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1948" id="1948">
      <mxCell style="link" parent="2665" source="1970" target="1938" edge="1">
        <mxGeometry x="-1122.3200000000002" y="-545.61" width="100" height="100" as="geometry">
          <mxPoint x="-1122.3200000000002" y="-445.61" as="sourcePoint" />
          <mxPoint x="-1022.3200000000003" y="-545.61" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1949" id="1949">
      <mxCell style="link" parent="2665" source="1757" target="1938" edge="1">
        <mxGeometry x="-1122.3200000000002" y="-545.61" width="100" height="100" as="geometry">
          <mxPoint x="-1122.3200000000002" y="-445.61" as="sourcePoint" />
          <mxPoint x="-1022.3200000000003" y="-545.61" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1939" oldId="1970" name="max capacity utilization factor" id="1970">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2665" vertex="1">
        <mxGeometry x="507.4699999999999" y="30.610000000000014" width="48.22" height="43.59" as="geometry" />
      </mxCell>
    </Ghost>
    <Converter name="Al old prim capacity retirement normalized L=40a" Note="Langhorst" Source="Time" Data="0,0.011162538; 1,0.011811972; 2,0.01249593; 3,0.013212366; 4,0.013958782; 5,0.014732223; 6,0.0155293; 7,0.016346207; 8,0.017178764; 9,0.018022461; 10,0.018872521; 11,0.019723973; 12,0.020571726; 13,0.021410659; 14,0.022235704; 15,0.023041927; 16,0.023824597; 17,0.024579239; 18,0.025301667; 19,0.025987989; 20,0.02663458; 21,0.027238027; 22,0.027795051; 23,0.028302397; 24,0.028756716; 25,0.029154443; 26,0.029491681; 27,0.029764121; 28,0.029966984; 29,0.030095033; 30,0.030142639; 31,0.030103919; 32,0.029972945; 33,0.029744012; 34,0.029411972; 35,0.028972588; 36,0.028422907; 37,0.02776162; 38,0.026989372; 39,0.026109017; 40,0.025125766; 41,0.024047235; 42,0.022883374; 43,0.021646274; 44,0.020349856; 45,0.019009472; 46,0.017641421; 47,0.016262429; 48,0.014889096; 49,0.013537377; 50,0.012222092; 51,0.010956508; 52,0.009752016; 53,0.008617899; 54,0.007561205; 55,0.006586733; 56,0.0056971; 57,0.004892896; 58,0.004172904; 59,0.00353436; 60,0.002973242; 61,0.002484571; 62,0.002062695; 63,0.001701565; 64,0.001394968; 65,0.001136734; 66,0.000920902; 67,0.000741839; 68,0.000594337; 69,0.000473659; 70,0.000375569; 71,0.000296336; 72,0.000232714; 73,0.000181917; 74,0.00017062" Interpolation="Linear" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2137" id="2137">
      <mxCell style="converter;fontSize=8;" parent="2665" vertex="1">
        <mxGeometry x="488.6999999999997" y="180.92000000000007" width="61.01" height="44.92" as="geometry" />
      </mxCell>
    </Converter>
    <Link name="Link" Note="" BiDirectional="false" oldId="2138" id="2138">
      <mxCell style="link" parent="2665" source="2137" target="1769" edge="1">
        <mxGeometry x="-1180.5500000000002" y="-494.68" width="100" height="100" as="geometry">
          <mxPoint x="-1180.5500000000002" y="-394.68" as="sourcePoint" />
          <mxPoint x="-1080.5500000000002" y="-494.68" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="Al prim production capacity in construction 2" Note="" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="2343" id="2343">
      <mxCell style="stock;fontSize=10;fillColor=#B3E2CD;" parent="2665" vertex="1">
        <mxGeometry x="249.81000000000006" y="67.52999999999997" width="70" height="60" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="Al prim cap constr 2" Note="" FlowRate="Delay([Al prim cap constructing],[Al prim min construction time],0)" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2344" id="2344">
      <mxCell style="flow;fontSize=6;" parent="2665" source="1753" target="2343" edge="1">
        <mxGeometry x="-488.0500000000003" y="-834.36" width="100" height="100" as="geometry">
          <mxPoint x="-488.0500000000003" y="-734.36" as="sourcePoint" />
          <mxPoint x="-388.0500000000003" y="-834.36" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="2345" id="2345">
      <mxCell style="link" parent="2665" source="1755" target="2344" edge="1">
        <mxGeometry x="-488.0500000000003" y="-834.36" width="100" height="100" as="geometry">
          <mxPoint x="-488.0500000000003" y="-734.36" as="sourcePoint" />
          <mxPoint x="-388.0500000000003" y="-834.36" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim min construction time" Note="time needed to build and put in operation primary infrastructure (i.e. mines, refineries, smelters)&lt;br&gt;" Equation="3" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="20" SliderMin="1" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2346" id="2346">
      <mxCell style="variable;fontSize=8;fillColor=#99CC00;" parent="2665" vertex="1">
        <mxGeometry x="209.54000000000008" y="131.7600000000001" width="51.75" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2347" id="2347">
      <mxCell style="link" parent="2665" source="2346" target="2344" edge="1">
        <mxGeometry x="-488.0500000000003" y="-834.36" width="100" height="100" as="geometry">
          <mxPoint x="-488.0500000000003" y="-734.36" as="sourcePoint" />
          <mxPoint x="-388.0500000000003" y="-834.36" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2348" id="2348">
      <mxCell style="link" parent="2665" source="2346" target="1754" edge="1">
        <mxGeometry x="-488.0500000000003" y="-834.36" width="100" height="100" as="geometry">
          <mxPoint x="-488.0500000000003" y="-734.36" as="sourcePoint" />
          <mxPoint x="-388.0500000000003" y="-834.36" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al capacity building exponent" Note="" Equation="2" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="10" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2385" id="2385">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2665" vertex="1">
        <mxGeometry x="199.20000000000005" y="174.51" width="55" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2386" id="2386">
      <mxCell style="link" parent="2665" source="2385" target="1888" edge="1">
        <mxGeometry x="-488.0500000000003" y="-834.36" width="100" height="100" as="geometry">
          <mxPoint x="-488.0500000000003" y="-734.36" as="sourcePoint" />
          <mxPoint x="-388.0500000000003" y="-834.36" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2391" id="2391">
      <mxCell style="link" parent="2665" source="1888" target="1894" edge="1">
        <mxGeometry x="-488.0500000000003" y="-834.36" width="100" height="100" as="geometry">
          <mxPoint x="-488.0500000000003" y="-734.36" as="sourcePoint" />
          <mxPoint x="-388.0500000000003" y="-834.36" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1820" oldId="2450" name="Al prim required" id="2450">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2665" vertex="1">
        <mxGeometry x="24.700000000000045" y="55.35000000000002" width="36.75" height="29.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1853" oldId="2451" name="material supply constrain switch" id="2451">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;opacity=30;" parent="2665" vertex="1">
        <mxGeometry x="28.479999999999677" y="27.41999999999996" width="183.47" height="18.71" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2452" id="2452">
      <mxCell style="link" parent="2665" source="2451" target="1763" edge="1">
        <mxGeometry x="-488.0500000000003" y="-834.36" width="100" height="100" as="geometry">
          <mxPoint x="-488.0500000000003" y="-734.36" as="sourcePoint" />
          <mxPoint x="-388.0500000000003" y="-834.36" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2453" id="2453">
      <mxCell style="link" parent="2665" source="2450" target="1763" edge="1">
        <mxGeometry x="-488.0500000000003" y="-834.36" width="100" height="100" as="geometry">
          <mxPoint x="-488.0500000000003" y="-734.36" as="sourcePoint" />
          <mxPoint x="-388.0500000000003" y="-834.36" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al prim capacity expansion rate" Note="" Equation="[Al prim cap constructing]/[Al prim capacity]*{1 Gt/a}" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2528" id="2528">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2665" vertex="1">
        <mxGeometry x="220.34000000000003" y="20" width="55" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2529" id="2529">
      <mxCell style="link" parent="2665" source="1755" target="2528" edge="1">
        <mxGeometry x="-488.0500000000003" y="-834.36" width="100" height="100" as="geometry">
          <mxPoint x="-488.0500000000003" y="-734.36" as="sourcePoint" />
          <mxPoint x="-388.0500000000003" y="-834.36" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2530" id="2530">
      <mxCell style="link" parent="2665" source="1757" target="2528" edge="1">
        <mxGeometry x="-488.0500000000003" y="-834.36" width="100" height="100" as="geometry">
          <mxPoint x="-488.0500000000003" y="-734.36" as="sourcePoint" />
          <mxPoint x="-388.0500000000003" y="-834.36" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Al old prim capacity 0" Note="in 2026&lt;br&gt;" Equation="0.0798409090909091" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2545" id="2545">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="2665" vertex="1">
        <mxGeometry x="358.4899999999998" y="195.97000000000003" width="48.75" height="27.43" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2547" id="2547">
      <mxCell style="link" parent="2665" source="2545" target="1901" edge="1">
        <mxGeometry x="-488.5200000000003" y="-824.15" width="100" height="100" as="geometry">
          <mxPoint x="-488.5200000000003" y="-724.1500000000001" as="sourcePoint" />
          <mxPoint x="-388.5200000000003" y="-824.15" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Converter name="Al old prim capacity retirement normalized L=50a" Note="Langhorst" Source="Time" Data="0,0.007573605; 1,0.007895508; 2,0.008236254; 3,0.008596133; 4,0.008975243; 5,0.009373472; 6,0.009790489; 7,0.010225731; 8,0.0106784; 9,0.011147458; 10,0.011631633; 11,0.012129427; 12,0.012639129; 13,0.013158836; 14,0.013686483; 15,0.014219876; 16,0.014756736; 17,0.015294748; 18,0.015831614; 19,0.016365118; 20,0.016893184; 21,0.017413941; 22,0.017925781; 23,0.018427413; 24,0.018917897; 25,0.01939667; 26,0.01986354; 27,0.020318661; 28,0.020762473; 29,0.021195607; 30,0.02161876; 31,0.022032535; 32,0.022437265; 33,0.022832806; 34,0.023218332; 35,0.023592143; 36,0.023951489; 37,0.02429244; 38,0.024609814; 39,0.024897178; 40,0.025146934; 41,0.025350489; 42,0.025498522; 43,0.025581329; 44,0.025589236; 45,0.025513062; 46,0.025344598; 47,0.025077089; 48,0.024705661; 49,0.024227694; 50,0.023643086; 51,0.02295441; 52,0.022166934; 53,0.021288517; 54,0.020329365; 55,0.019301682; 56,0.018219227; 57,0.017096802; 58,0.015949717; 59,0.014793238; 60,0.013642083; 61,0.012509957; 62,0.011409177; 63,0.010350382; 64,0.009342341; 65,0.00839187; 66,0.007503826; 67,0.006681199; 68,0.005925262; 69,0.005235767; 70,0.004611185; 71,0.004048954; 72,0.003545721; 73,0.003097583; 74,0.0029609" Interpolation="Linear" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2548" id="2548">
      <mxCell style="converter;fontSize=8;" parent="2665" vertex="1">
        <mxGeometry x="553.9899999999997" y="182.09000000000003" width="60" height="42.59" as="geometry" />
      </mxCell>
    </Converter>
    <Variable name="Al old prim cap lifetime" Note="&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; width=&quot;369&quot;&gt;&lt;colgroup&gt;&lt;col width=&quot;369&quot;&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&#xa;  &lt;td height=&quot;20&quot; class=&quot;xl66&quot; width=&quot;369&quot; style=&quot;height: 15.0pt ; width: 277pt&quot;&gt;average&#xa;  lifetime of old primary capacity&lt;/td&gt;&#xa;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;" Equation="45" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2549" id="2549">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2665" vertex="1">
        <mxGeometry x="505.7099999999998" y="124.45999999999992" width="51.75" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2550" id="2550">
      <mxCell style="link" parent="2665" source="2549" target="1769" edge="1">
        <mxGeometry x="-488.5200000000003" y="-824.15" width="100" height="100" as="geometry">
          <mxPoint x="-488.5200000000003" y="-724.1500000000001" as="sourcePoint" />
          <mxPoint x="-388.5200000000003" y="-824.15" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2551" id="2551">
      <mxCell style="link" parent="2665" source="2548" target="1769" edge="1">
        <mxGeometry x="-488.5200000000003" y="-824.15" width="100" height="100" as="geometry">
          <mxPoint x="-488.5200000000003" y="-724.1500000000001" as="sourcePoint" />
          <mxPoint x="-388.5200000000003" y="-824.15" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2588" id="2588">
      <mxCell style="link" parent="2665" source="1970" target="1897" edge="1">
        <mxGeometry x="-488.0500000000003" y="-834.36" width="100" height="100" as="geometry">
          <mxPoint x="-488.0500000000003" y="-734.36" as="sourcePoint" />
          <mxPoint x="-388.0500000000003" y="-834.36" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="Al prim cap in pipeline" Note="" FlowRate="[Al prim cap expansion in pipeline normailzed]" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2598" id="2598">
      <mxCell style="flow;fontSize=6;" parent="2665" target="1768" edge="1">
        <mxGeometry x="-488.5200000000003" y="-806.39" width="100" height="100" as="geometry">
          <mxPoint x="311.4799999999997" y="171.11" as="sourcePoint" />
          <mxPoint x="-488.5200000000003" y="-724.1500000000001" as="targetPoint" />
          <mxPoint x="-4" y="-7" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Converter name="Al prim cap expansion in pipeline normailzed" Note="Langhorst" Source="Time" Data="0,0.038838191; 1,0.038766111; 2,0.038744636; 3,0.033161687; 4,0.027458715; 5,0.021733058; 6,0.016053553; 7,0.010501868; 8,0.00513826; 9,0; 10,0; 11,0; 12,0; 13,0; 14,0; 15,0; 16,0; 17,0; 18,0; 19,0; 20,0; 21,0; 22,0; 23,0; 24,0; 25,0; 26,0; 27,0; 28,0; 29,0; 30,0; 31,0; 32,0; 33,0; 34,0; 35,0; 36,0; 37,0; 38,0; 39,0; 40,0; 41,0; 42,0; 43,0; 44,0; 45,0; 46,0; 47,0; 48,0; 49,0; 50,0; 51,0; 52,0; 53,0; 54,0; 55,0; 56,0; 57,0; 58,0; 59,0; 60,0; 61,0; 62,0; 63,0; 64,0; 65,0; 66,0; 67,0; 68,0; 69,0; 70,0; 71,0; 72,0; 73,0; 74,0" Interpolation="Linear" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2599" id="2599">
      <mxCell style="converter;fontSize=8;" parent="2665" vertex="1">
        <mxGeometry x="267.4299999999997" y="182.09000000000003" width="83.93" height="42.59" as="geometry" />
      </mxCell>
    </Converter>
    <Link name="Link" Note="" BiDirectional="false" oldId="2600" id="2600">
      <mxCell style="link" parent="2665" source="2599" target="2598" edge="1">
        <mxGeometry x="-488.5200000000003" y="-824.15" width="100" height="100" as="geometry">
          <mxPoint x="-488.5200000000003" y="-724.1500000000001" as="sourcePoint" />
          <mxPoint x="-388.5200000000003" y="-824.15" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="Biosphere" Note="" Type="None" Solver="{&quot;enabled&quot;:false,&quot;algorithm&quot;:&quot;RK1&quot;,&quot;timeStep&quot;:1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="2664" id="2664">
      <mxCell style="folder" vertex="1" parent="1">
        <mxGeometry x="-11.25" y="26" width="241.25" height="760" as="geometry" />
      </mxCell>
    </Folder>
    <Stock name="C-H_inLitS" Note="Carbon store in lithosphere (i.e. fossil fuels), expressed in m_CO2 in Gt. Initial value corresponds to know reserves and estimated resources (Kausch et al. 2011)&lt;br&gt;" InitialValue="58000" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="55" id="55">
      <mxCell style="stock;fontSize=12;fillColor=#CCFFFF;" parent="2664" vertex="1">
        <mxGeometry x="51.25" y="630" width="70" height="40" as="geometry" />
      </mxCell>
    </Stock>
    <Stock name="CO2_inAtm&amp;UpperOcean" Note="&lt;div&gt;Cumulative CO2 emission since 1850 remaining in atmosphere and upper ocean. Atmosphere and upper ocean are in short term and constant exchange, therefore both stocks are coupled and for simplicity combined.&lt;/div&gt;" InitialValue="2682" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="56" id="56">
      <mxCell style="stock;fontSize=12;fillColor=#CCFFFF;" parent="2664" vertex="1">
        <mxGeometry x="51.25" y="100" width="170" height="40" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="CO2_toAtmS" Note="Release from lithosphere to atmosphere by burning fossil fuels (i.e. fC)&lt;br&gt;" FlowRate="[conv_fC]+[process CO2 emissions from materials]" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="57" id="57">
      <mxCell style="flow;fontSize=12;" parent="2664" source="55" target="56" edge="1">
        <mxGeometry x="31.25" y="-10" width="100" height="100" as="geometry">
          <mxPoint x="121.25" y="450" as="sourcePoint" />
          <mxPoint x="-138.75" y="-20" as="targetPoint" />
          <Array as="points">
            <mxPoint x="81.25" y="340" />
          </Array>
          <mxPoint y="-195" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Text name="AtmS = Atmosphere&#xa;LitS = Lithospere&#xa;TechS = Technosphere&#xa;" LabelPosition="Middle" oldId="101" id="101">
      <mxCell style="text;fontStyle=0;fontSize=12;align=left;labelPosition=middle;verticalLabelPosition=middle;verticalAlign=middle;" parent="2664" vertex="1">
        <mxGeometry x="56.25" y="685" width="160" height="55" as="geometry" />
      </mxCell>
    </Text>
    <Link name="Link" Note="" BiDirectional="false" oldId="130" id="130">
      <mxCell style="link;fontSize=12;" parent="2664" source="196" target="57" edge="1">
        <mxGeometry x="34.25" y="115" width="100" height="100" as="geometry">
          <mxPoint x="34.25" y="215" as="sourcePoint" />
          <mxPoint x="134.25" y="115" as="targetPoint" />
          <Array as="points">
            <mxPoint x="91.25" y="484" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="CO2_fromAtmS" Note="Technical removal from CO2 from atmosphere to lithosphere (i.e. CCS)&lt;br&gt;" FlowRate="[conv_CCS]" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="194" id="194">
      <mxCell style="flow;fontSize=12;" parent="2664" source="56" target="215" edge="1">
        <mxGeometry x="31.25" y="-10" width="100" height="100" as="geometry">
          <mxPoint x="31.25" y="90" as="sourcePoint" />
          <mxPoint x="131.25" y="-10" as="targetPoint" />
          <Array as="points" />
          <mxPoint y="-143" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Ghost Source="134" name="conv_fC" oldId="196" id="196">
      <mxCell style="variable;fontSize=8;fillColor=#CCFFFF;opacity=30;" parent="2664" vertex="1">
        <mxGeometry x="101.16" y="502" width="60" height="60" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="198" name="conv_CCS" oldId="200" id="200">
      <mxCell style="variable;fontSize=8;fillColor=#CCFFFF;opacity=30;" parent="2664" vertex="1">
        <mxGeometry x="101.16" y="280.88" width="60" height="60" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="201" id="201">
      <mxCell style="link;fontSize=12;" parent="2664" source="200" target="194" edge="1">
        <mxGeometry x="31.25" y="-10" width="100" height="100" as="geometry">
          <mxPoint x="31.25" y="90" as="sourcePoint" />
          <mxPoint x="131.25" y="-10" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="CO2_inLitoS" Note="Cumulative CO2 stored in lithosphere&lt;br&gt;" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="215" id="215">
      <mxCell style="stock;fontSize=12;fillColor=#CCFFFF;" parent="2664" vertex="1">
        <mxGeometry x="142.5" y="630" width="72.5" height="40" as="geometry" />
      </mxCell>
    </Stock>
    <Variable name="350 ppm" Note="Cumulative CO2 emissions since 1850 remaining in atmosphere and upper ocean, which correspond to 350ppm CO2 concentration in the atmosphere. 350ppm is considered a save limit for long term climate stability (Hansen et al. 2013, Steffen et al. 2015)&lt;br&gt;" Equation="1332" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="565" id="565">
      <mxCell style="variable;fontSize=12;" parent="2664" vertex="1">
        <mxGeometry x="51.25" y="80" width="170" height="20" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="450 ppm" Note="&lt;div&gt;Cumulative CO2 emissions since 1850 remaining in atmosphere and upper ocean, which correspond to 450ppm CO2 concentration in the atmosphere.&lt;/div&gt;" Equation="3132" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="706" id="706">
      <mxCell style="variable;fontSize=12;" parent="2664" vertex="1">
        <mxGeometry x="51.25" y="40" width="170" height="20" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="2\xB0C - 66% confidence" Note="Cumulative carbon emissions since 1850, which correspond to reach 2\xB0C target with a confidence of 66% Lamboll et al. 2023&lt;br&gt;" Equation="3420" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="707" id="707">
      <mxCell style="variable;fontSize=12;" parent="2664" vertex="1">
        <mxGeometry x="51.25" y="20" width="170" height="20" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="1.5\xB0C - 50% confidence" Note="Cumulative CO2 emissions since 1850, which correspond to reaching 1.5\xB0C target with a confidence of 50%, Lamboll et al. 2023&lt;br&gt;" Equation="2722" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="708" id="708">
      <mxCell style="variable;fontSize=12;" parent="2664" vertex="1">
        <mxGeometry x="51.25" y="60" width="170" height="20" as="geometry" />
      </mxCell>
    </Variable>
    <Flow name="natural leak" Note="CO2 removal from the atmosphere by natural background rate (sedimentation + weathering - volcanism) (Stein 1991, IPCC AR4 2007)&lt;br&gt;" FlowRate="0.8" OnlyPositive="true" TimeIndependent="false" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="876" id="876">
      <mxCell style="flow" parent="2664" source="56" target="215" edge="1">
        <mxGeometry x="11.25" y="-26" width="100" height="100" as="geometry">
          <mxPoint x="65.25" y="90" as="sourcePoint" />
          <mxPoint x="165.25" y="-10" as="targetPoint" />
          <Array as="points">
            <mxPoint x="201.25" y="410" />
          </Array>
          <mxPoint x="10" y="139" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="net CO2 emissions" Note="technically released - technically removed CO2.&lt;br&gt;" Equation="[CO2_toAtmS]-[CO2_fromAtmS]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1016" id="1016">
      <mxCell style="variable;fillColor=#CCFFFF;" parent="2664" vertex="1">
        <mxGeometry x="98.03" y="386" width="66.25" height="50" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1017" id="1017">
      <mxCell style="link" parent="2664" source="57" target="1016" edge="1">
        <mxGeometry x="31.25" y="-10" width="100" height="100" as="geometry">
          <mxPoint x="31.25" y="90" as="sourcePoint" />
          <mxPoint x="131.25" y="-10" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1018" id="1018">
      <mxCell style="link" parent="2664" source="194" target="1016" edge="1">
        <mxGeometry x="31.25" y="-10" width="100" height="100" as="geometry">
          <mxPoint x="31.25" y="90" as="sourcePoint" />
          <mxPoint x="131.25" y="-10" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2333" oldId="2335" name="process CO2 emissions from materials" id="2335">
      <mxCell style="variable;fontSize=8;fillColor=#CCFFFF;opacity=30;" parent="2664" vertex="1">
        <mxGeometry x="98.22000000000045" y="450.0000000000001" width="66.06" height="36" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2336" id="2336">
      <mxCell style="link" parent="2664" source="2335" target="57" edge="1">
        <mxGeometry x="11.25" y="-26" width="100" height="100" as="geometry">
          <mxPoint x="11.25" y="74" as="sourcePoint" />
          <mxPoint x="111.25" y="-26" as="targetPoint" />
          <Array as="points">
            <mxPoint x="101.25" y="444" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="delta T 50%" Note="&lt;div&gt;Temperature increase relative to 1850; 50%tile&lt;br&gt;&lt;/div&gt;" InitialValue="1.446" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Degrees Celsius" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="2464" id="2464">
      <mxCell style="stock;fontSize=12;fillColor=#CCFFFF;" parent="2664" vertex="1">
        <mxGeometry x="20" y="285.38" width="47.5" height="30" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="temperature change" Note="" FlowRate="[net CO2 emissions]*[TCRE 50]" OnlyPositive="false" TimeIndependent="false" Units="Degrees Celsius/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2465" id="2465">
      <mxCell style="flow;startArrow=block;startFill=0;" parent="2664" target="2464" edge="1">
        <mxGeometry x="-76.25" y="59.379999999999995" width="100" height="100" as="geometry">
          <mxPoint x="43.749999999999986" y="359.38" as="sourcePoint" />
          <mxPoint x="-76.25" y="159.38" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="TCRE 50" Note="transient climate response to cumulative emissions&lt;br&gt;" Equation="0.45" Units="Degrees Celsius / Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2466" id="2466">
      <mxCell style="variable;fontSize=8;fillColor=#CCFFFF;" parent="2664" vertex="1">
        <mxGeometry x="20" y="386" width="40" height="37" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2467" id="2467">
      <mxCell style="link" parent="2664" source="2466" target="2465" edge="1">
        <mxGeometry x="11.25" y="-26" width="100" height="100" as="geometry">
          <mxPoint x="11.25" y="74" as="sourcePoint" />
          <mxPoint x="111.25" y="-26" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2468" id="2468">
      <mxCell style="link" parent="2664" source="1016" target="2465" edge="1">
        <mxGeometry x="11.25" y="-26" width="100" height="100" as="geometry">
          <mxPoint x="11.25" y="74" as="sourcePoint" />
          <mxPoint x="111.25" y="-26" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="Technosphere" Note="" Type="None" Solver="{&quot;enabled&quot;:false,&quot;algorithm&quot;:&quot;RK1&quot;,&quot;timeStep&quot;:1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="2663" id="2663">
      <mxCell style="folder" vertex="1" parent="1">
        <mxGeometry x="952.64" y="44" width="915" height="569.5" as="geometry" />
      </mxCell>
    </Folder>
    <Flow name="P_to society" Note="Power supply to society (flow)" FlowRate="[E_Technosphere]/TimeStep()" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="5.77" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="71" id="71">
      <mxCell style="flow;strokeColor=#FFFF00;fontSize=12;" parent="2663" source="143" edge="1">
        <mxGeometry x="-525" y="-40.5" width="100" height="100" as="geometry">
          <mxPoint x="435" y="79.5" as="sourcePoint" />
          <mxPoint x="895" y="139.5" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="E_Technosphere" Note="Technosphere represents the energy grid, collecting and distributing power to where it is needed. It does not have a storing-function, but is used as a summation for all power inputs and outputs&lt;br&gt;" InitialValue="[P_demand_0]*TimeStep()" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1.06" MinConstraint="0.95" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="143" id="143">
      <mxCell style="stock;fillColor=#FFFF00;fontSize=12;" parent="2663" vertex="1">
        <mxGeometry x="77.5" y="119.5" width="690" height="40" as="geometry" />
      </mxCell>
    </Stock>
    <Stock name="E_fC" Note="&lt;div&gt;Embodied energy in fossil conversion engine existing at the beginning of the simulation.&lt;br&gt;&lt;/div&gt;&lt;div&gt;P_output (2026) = 6.24 TW (coal, oil, gas, nuclear; -&amp;gt; Desing et al. (2019); electricity, heat and transport all converted to electricity; each are assumed to be ~1/3)&lt;br&gt;&lt;/div&gt;&lt;div&gt;fC_EPBT = 3a (https://publications.parliament.uk/pa/ld200304/ldselect/ldsctech/126/12620.htm)&lt;br&gt;&lt;/div&gt;&lt;div&gt;LF_fC = 0.5 for electric energy (https://en.wikipedia.org/wiki/Capacity_factor; https://www.eia.gov/todayinenergy/detail.php?id=22832, Desing and Widmer 2021)&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;If all was electricity:&lt;br&gt;&lt;/div&gt;&lt;div&gt;E_fC = P_demand / LF_fC * fC_EPBT = 38.4 TWa&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Considering 1/3 is electricity with a LF = 0.5; 2/3 is with LF=1;&lt;/div&gt;&lt;div&gt;E_fC = P_demand * fC_EPBT *(0.6 + 0.4/LF_fC) = 26.63 TWa&lt;br&gt;&lt;/div&gt;" InitialValue="26.63" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="124" id="124">
      <mxCell style="stock;fillColor=#FFFF00;fontSize=12;" parent="2663" vertex="1">
        <mxGeometry x="70" y="395.5" width="80" height="40" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="P_eolfCnew" Note="power of EoL from newly built fC&lt;br&gt;" FlowRate="Delay3([fC2], ([T_LfC]-[T_LfC_min])/{1 Years})" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="125" id="125">
      <mxCell style="flow;strokeColor=#FFFF00;fontSize=12;" parent="2663" source="897" edge="1">
        <mxGeometry x="-182.5" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="176.65000000000003" y="437.25" as="sourcePoint" />
          <mxPoint x="193.65000000000003" y="547.25" as="targetPoint" />
          <Array as="points" />
          <mxPoint x="4" y="23" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="P_nomfC" Note="&lt;div&gt;Nominal Power of the machine expressed as the embedded energy divided by the energy payback time  i.e. fC_EPBT&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;The nominal power is the maximum supply the machine can provide&lt;/div&gt;" Equation="([E_fC]+[E_fCnew])/[fC_EPBT]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="132" id="132">
      <mxCell style="variable;fontSize=12;" parent="2663" vertex="1">
        <mxGeometry x="117.5" y="314.5" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="conv_fC" Note="Conversion factor from consumed/produced power to the linked flux&lt;br&gt;" Equation="[P_opfC]*[fC emission intensity]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="134" id="134">
      <mxCell style="variable;fontSize=8;fillColor=#CCFFFF;" parent="2663" vertex="1">
        <mxGeometry x="20" y="232.5" width="40" height="37" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="135" id="135">
      <mxCell style="link;fontSize=12;" parent="2663" source="126" target="134" edge="1">
        <mxGeometry x="-55" y="46.5" width="100" height="100" as="geometry">
          <mxPoint x="45" y="46.5" as="sourcePoint" />
          <mxPoint x="-55" y="146.5" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="137" id="137">
      <mxCell style="link;fontSize=12;" parent="2663" source="132" target="126" edge="1">
        <mxGeometry x="-115" y="45.5" width="100" height="100" as="geometry">
          <mxPoint x="-115" y="145.5" as="sourcePoint" />
          <mxPoint x="-15" y="45.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="138" id="138">
      <mxCell style="link;fontSize=12;" parent="2663" source="124" target="132" edge="1">
        <mxGeometry x="-115" y="45.5" width="100" height="100" as="geometry">
          <mxPoint x="152" y="390.5" as="sourcePoint" />
          <mxPoint x="-15" y="45.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="P_buildfC" Note="power demand for building fC" FlowRate="[P_build_fC1]" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="127" id="127">
      <mxCell style="flow;strokeColor=#FFFF00;fontSize=12;" parent="2663" source="143" target="1190" edge="1">
        <mxGeometry x="-182.5" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="849.6399999999999" y="392.88" as="sourcePoint" />
          <mxPoint x="234.64" y="395.88" as="targetPoint" />
          <Array as="points" />
          <mxPoint x="3" y="-25" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="P_opfC" Note="power supply from operating fC" FlowRate="[P_nomfC]*[CF_fC]" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="126" id="126">
      <mxCell style="flow;strokeColor=#FFFF00;fontSize=12;" parent="2663" target="143" edge="1">
        <mxGeometry x="-200" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="92" y="349.5" as="sourcePoint" />
          <mxPoint x="794" y="230.5" as="targetPoint" />
          <Array as="points" />
          <mxPoint x="-2" y="-65" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="E_CCS1" Note="Embodied energy of installed CCS" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="167" id="167">
      <mxCell style="stock;fillColor=#FFFF00;fontSize=12;" parent="2663" vertex="1">
        <mxGeometry x="377.5" y="395.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="P_eolCCS" Note="power reducing embodied energy that reached EoL" FlowRate="Delay3([CCS2], ([T_resCCS]-[T_resCCS_min])/{1 Years})" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="168" id="168">
      <mxCell style="flow;strokeColor=#FFFF00;fontSize=12;" parent="2663" source="578" edge="1">
        <mxGeometry x="-174.5" y="-203" width="100" height="100" as="geometry">
          <mxPoint x="415.5" y="439" as="sourcePoint" />
          <mxPoint x="435.5" y="549" as="targetPoint" />
          <Array as="points">
            <mxPoint x="437.5" y="497" />
          </Array>
          <mxPoint y="41" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="T_resCCS" Note="&lt;div&gt;average lifetime of the embodied energy&lt;br&gt;&lt;/div&gt;" Equation="25" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="35" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="169" id="169">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="347.5" y="502.14" width="60" height="21.36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="170" id="170">
      <mxCell style="link;fontSize=12;" parent="2663" source="169" target="168" edge="1">
        <mxGeometry x="157.5" y="46.5" width="100" height="100" as="geometry">
          <mxPoint x="157.5" y="146.5" as="sourcePoint" />
          <mxPoint x="257.5" y="46.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_nomCCS" Note="nominal power of CCS, i.e. the maximum power the machine can be operated with&lt;br&gt;" Equation="[P nom DAC 1]+[P nom DAC 2]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="171" id="171">
      <mxCell style="variable;fontSize=12;" parent="2663" vertex="1">
        <mxGeometry x="336.13" y="298.25" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="174" id="174">
      <mxCell style="link;fontSize=12;" parent="2663" source="171" target="178" edge="1">
        <mxGeometry x="97.5" y="45.5" width="100" height="100" as="geometry">
          <mxPoint x="97.5" y="145.5" as="sourcePoint" />
          <mxPoint x="197.5" y="45.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="P_opCCS" Note="power for operating CCS" FlowRate="[P_nomCCS]*[CF_CCS]" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="178" id="178">
      <mxCell style="flow;strokeColor=#FFFF00;fontSize=12;" parent="2663" source="143" edge="1">
        <mxGeometry x="-169.5" y="-50.129999999999995" width="100" height="100" as="geometry">
          <mxPoint x="317.5" y="178.87" as="sourcePoint" />
          <mxPoint x="317.5" y="303.87" as="targetPoint" />
          <Array as="points" />
          <mxPoint x="3" y="-55" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="P_buildCCS" Note="power for building CCS" FlowRate="[P_CCS ordered]" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="179" id="179">
      <mxCell style="flow;strokeColor=#FFFF00;fontSize=12;" parent="2663" source="143" target="1183" edge="1">
        <mxGeometry x="-157.7" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="449.29999999999995" y="178.5" as="sourcePoint" />
          <mxPoint x="996.3" y="640.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="437.5" y="203.5" />
          </Array>
          <mxPoint x="5" y="-15" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="E_PV1" Note="embodied energy of installed PV" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="181" id="181">
      <mxCell style="stock;fillColor=#FFFF00;fontSize=12;" parent="2663" vertex="1">
        <mxGeometry x="697.5" y="395.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="P_eolPV" Note="power reducing embodied energy that reached EoL" FlowRate="Delay3([PV2], ([T_resPV]-[T_resPV_min])/{1 Years})" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="182" id="182">
      <mxCell style="flow;strokeColor=#C0C0C0;fontSize=12;" parent="2663" source="569" edge="1">
        <mxGeometry x="-120" y="-202.34" width="100" height="100" as="geometry">
          <mxPoint x="757.5" y="449.65999999999997" as="sourcePoint" />
          <mxPoint x="757.5" y="549.66" as="targetPoint" />
          <Array as="points">
            <mxPoint x="757.7" y="502.15999999999997" />
            <mxPoint x="757.7" y="495.15999999999997" />
          </Array>
          <mxPoint x="3" y="40" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="T_resPV" Note="&lt;div&gt;average lifetime of the embodied energy&lt;br&gt;&lt;/div&gt;" Equation="30" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="35" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="183" id="183">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="667.5" y="503.5" width="52.5" height="27.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="184" id="184">
      <mxCell style="link;fontSize=12;" parent="2663" source="183" target="182" edge="1">
        <mxGeometry x="463" y="46.5" width="100" height="100" as="geometry">
          <mxPoint x="463" y="146.5" as="sourcePoint" />
          <mxPoint x="563" y="46.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_nomPV" Note="&lt;div&gt;Nominal Power of the machine expressed as the embedded energy divided by the energy payback time  i.e. PV_EPBT&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;The nominal power is the maximum output the machine can provide. This is not to be mistaken as peak power of PV, which refers to laboratory conditions. The nominal power is the output that can be generated at specific locations in real installations, i.e. the yearly possible energy yield without curtailment divided by the time of the year.&lt;br&gt;&lt;/div&gt;" Equation="#[E_PV]/[EPBT_PV]&#xa;[P nom PV 2]+[P nom PV 1]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="185" id="185">
      <mxCell style="variable;fontSize=12;" parent="2663" vertex="1">
        <mxGeometry x="647.5" y="298.25" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="186" id="186">
      <mxCell style="link;fontSize=12;" parent="2663" source="185" target="190" edge="1">
        <mxGeometry x="403" y="45.5" width="100" height="100" as="geometry">
          <mxPoint x="403" y="145.5" as="sourcePoint" />
          <mxPoint x="503" y="45.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="P_opPV" Note="power supplied by operating PV" FlowRate="[P_nomPV]*[CF_PV]" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="190" id="190">
      <mxCell style="flow;strokeColor=#99CC00;fontSize=12;" parent="2663" target="143" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="637.5" y="303.5" as="sourcePoint" />
          <mxPoint x="634.84" y="178.5" as="targetPoint" />
          <Array as="points" />
          <mxPoint x="3" y="-21" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="P_buildPV" Note="power for building PV" FlowRate="[P_build_PV2]" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="191" id="191">
      <mxCell style="flow;strokeColor=#FFFF00;fontSize=12;startFill=0;" parent="2663" source="143" target="1174" edge="1">
        <mxGeometry x="-145.73000000000002" y="-204" width="100" height="100" as="geometry">
          <mxPoint x="766.77" y="177" as="sourcePoint" />
          <mxPoint x="1313.77" y="639" as="targetPoint" />
          <Array as="points">
            <mxPoint x="757.5" y="203.5" />
          </Array>
          <mxPoint x="-5" y="-15" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Ghost Source="180" name="CF_CCS" oldId="202" id="202">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="2663" vertex="1">
        <mxGeometry x="337.5" y="249.5" width="50" height="40" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="175" id="175">
      <mxCell style="link;fontSize=12;" parent="2663" source="202" target="178" edge="1">
        <mxGeometry x="97.5" y="45.5" width="100" height="100" as="geometry">
          <mxPoint x="357.5" y="262.5" as="sourcePoint" />
          <mxPoint x="197.5" y="45.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="206" name="P_CCS ordered" oldId="208" id="208">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="2663" vertex="1">
        <mxGeometry x="347.5" y="182.5" width="50" height="30" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="177" id="177">
      <mxCell style="link;fontSize=12;" parent="2663" source="208" target="179" edge="1">
        <mxGeometry x="637.5" y="134.5" width="100" height="100" as="geometry">
          <mxPoint x="456.5" y="273.5" as="sourcePoint" />
          <mxPoint x="737.5" y="134.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="fC_EPBT" Note="https://publications.parliament.uk/pa/ld200304/ldselect/ldsctech/126/12620.htm " Equation="3" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="222" id="222">
      <mxCell style="variable;fontSize=10;" parent="2663" vertex="1">
        <mxGeometry x="60" y="362.25" width="50" height="24.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="223" id="223">
      <mxCell style="link;fontSize=12;" parent="2663" source="222" target="132" edge="1">
        <mxGeometry x="-200" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-200" y="49.5" as="sourcePoint" />
          <mxPoint x="-100" y="-50.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="fC_repair" Note="&lt;div&gt;If 1, fC is repaird on demand, i.e. whenever embodied energy is lost through EoL,  throughout the transition&lt;/div&gt;" Equation="1" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="229" id="229">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="2663" vertex="1">
        <mxGeometry x="148.75" y="39.5" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="T_LfC" Note="&lt;div&gt;average lifetime of the embodied energy&lt;br&gt;&lt;/div&gt;" Equation="30" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="35" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="233" id="233">
      <mxCell style="variable;fontSize=12;" parent="2663" vertex="1">
        <mxGeometry x="210" y="503.5" width="50" height="28.5" as="geometry" />
      </mxCell>
    </Variable>
    <Stock name="E_fCnew1" Note="&lt;div&gt;Embodied energy of newly installed fC&lt;br&gt;&lt;/div&gt;" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="235" id="235">
      <mxCell style="stock;fillColor=#FFFF00;fontSize=12;" parent="2663" vertex="1">
        <mxGeometry x="160" y="395.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Stock>
    <Link name="Link" Note="" BiDirectional="false" oldId="236" id="236">
      <mxCell style="link;fontSize=12;" parent="2663" source="899" target="132" edge="1">
        <mxGeometry x="-200" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-200" y="49.5" as="sourcePoint" />
          <mxPoint x="-100" y="-50.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="P_eolfC" Note="power reducing embodied energy that reached EoL" FlowRate="[E_fC]*[fC_dep]*Exp(Time()/[tau_fC])" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="237" id="237">
      <mxCell style="flow;strokeColor=#FFFF00;fontSize=12;" parent="2663" source="124" edge="1">
        <mxGeometry x="-245.1" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-230.93" y="49.5" as="sourcePoint" />
          <mxPoint x="84.89999999999998" y="549.5" as="targetPoint" />
          <Array as="points" />
          <mxPoint y="-33" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Ghost Source="325" name="CF_PV" oldId="334" id="334">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="2663" vertex="1">
        <mxGeometry x="652.25" y="247.38" width="35.25" height="36" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="324" name="CF_fC" oldId="335" id="335">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="2663" vertex="1">
        <mxGeometry x="110" y="265.5" width="51.5" height="32.75" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="CCS switch" Note="If 1, CCS can be built and operated&lt;br&gt;" Equation="1" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="371" id="371">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="2663" vertex="1">
        <mxGeometry x="331.25" y="39.5" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_supply to society" Note="&lt;div&gt;power supply to society from the energy system&lt;/div&gt;" Equation="[P_to society]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="442" id="442">
      <mxCell style="variable;fontSize=12;" parent="2663" vertex="1">
        <mxGeometry x="792.25" y="73.5" width="78.5" height="46" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="fC switch" Note="&lt;div&gt;If 1, fC is switched off as soon as transition is complete&lt;br&gt;&lt;/div&gt;" Equation="1" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="510" id="510">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="2663" vertex="1">
        <mxGeometry x="78.75" y="39.5" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="fC phase out" Note="If 1, embodied energy of fC is phased out with increased EoL rates&lt;br&gt;" Equation="1" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="523" id="523">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="2663" vertex="1">
        <mxGeometry x="228.75" y="39.5" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Stock name="E_PV2" Note="embodied energy that reached minimum lifetime&lt;br&gt;" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="569" id="569">
      <mxCell style="stock;fillColor=#FFFF00;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="702.87" y="470.5" width="60" height="14" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="PV2" Note="power shifting embodied energy from initial stock to stock, which has already reached minimum lifetime&lt;br&gt;" FlowRate="Delay([P PV constructed], [T_resPV_min]/{1 Years}, 0)" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="570" id="570">
      <mxCell style="flow;fontSize=6;fillColor=none;labelBackgroundColor=none;strokeColor=#FFFF00;" parent="2663" source="181" target="569" edge="1">
        <mxGeometry x="-123.2" y="-37" width="100" height="100" as="geometry">
          <mxPoint x="756.8" y="473" as="sourcePoint" />
          <mxPoint x="-23.19999999999999" y="-37" as="targetPoint" />
          <Array as="points">
            <mxPoint x="757.5" y="453.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="T_resPV_min" Note="&lt;div&gt;minimal lifetime of embodied energy, i.e. all installations reach this lifetime&lt;br&gt;&lt;/div&gt;" Equation="25" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="35" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="571" id="571">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="667.5" y="445.5" width="52.5" height="17" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="573" id="573">
      <mxCell style="link" parent="2663" source="571" target="182" edge="1">
        <mxGeometry x="-165" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-165" y="49.5" as="sourcePoint" />
          <mxPoint x="-65" y="-50.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="574" id="574">
      <mxCell style="link" parent="2663" source="570" target="182" edge="1">
        <mxGeometry x="-142.05" y="-66.67000000000002" width="100" height="100" as="geometry">
          <mxPoint x="-142.05" y="33.329999999999984" as="sourcePoint" />
          <mxPoint x="-42.05000000000001" y="-66.67000000000002" as="targetPoint" />
          <Array as="points">
            <mxPoint x="797.5" y="473.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="T_resCCS_min" Note="&lt;div&gt;minimal lifetime of embodied energy, i.e. all installations reach this lifetime&lt;br&gt;&lt;/div&gt;" Equation="20" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="35" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="577" id="577">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="347.5" y="443.5" width="60" height="19.5" as="geometry" />
      </mxCell>
    </Variable>
    <Stock name="E_CCC2" Note="embodied energy that reached minimum lifetime&lt;br&gt;" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="578" id="578">
      <mxCell style="stock;fillColor=#FFFF00;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="377.5" y="467.5" width="70" height="14" as="geometry" />
      </mxCell>
    </Stock>
    <Link name="Link" Note="" BiDirectional="false" oldId="580" id="580">
      <mxCell style="link" parent="2663" source="583" target="168" edge="1">
        <mxGeometry x="-226.53" y="-44.17" width="100" height="100" as="geometry">
          <mxPoint x="413.47" y="465.83000000000004" as="sourcePoint" />
          <mxPoint x="433.47" y="495.83000000000004" as="targetPoint" />
          <Array as="points">
            <mxPoint x="457.5" y="463.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="581" id="581">
      <mxCell style="link" parent="2663" source="577" target="583" edge="1">
        <mxGeometry x="-232.5" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-232.5" y="49.5" as="sourcePoint" />
          <mxPoint x="-132.5" y="-50.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="582" id="582">
      <mxCell style="link" parent="2663" source="577" target="168" edge="1">
        <mxGeometry x="-232.5" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-232.5" y="49.5" as="sourcePoint" />
          <mxPoint x="-132.5" y="-50.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="407.5" y="503.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="CCS2" Note="power shifting embodied energy from initial stock to stock, which has already reached minimum lifetime&lt;br&gt;" FlowRate="Delay([P CCS constructed], [T_resCCS_min]/{1 Years}, 0)" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="583" id="583">
      <mxCell style="flow;strokeColor=#FFFF00;fontSize=6;fillColor=none;labelBackgroundColor=none;" parent="2663" source="167" target="578" edge="1">
        <mxGeometry x="-232.5" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-214.5" y="62" as="sourcePoint" />
          <mxPoint x="-114.5" y="-38" as="targetPoint" />
          <Array as="points">
            <mxPoint x="437.5" y="443.5" />
            <mxPoint x="408.5" y="448" />
            <mxPoint x="408.5" y="448" />
            <mxPoint x="407.5" y="448" />
          </Array>
          <mxPoint x="-5" y="14" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="584" id="584">
      <mxCell style="link" parent="2663" source="1184" target="583" edge="1">
        <mxGeometry x="-232.5" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-232.5" y="49.5" as="sourcePoint" />
          <mxPoint x="-132.5" y="-50.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="477.5" y="433.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="E_CCS" Note="Embodied energy of CCS&lt;br&gt;" Equation="[E_CCS1]+[E_CCC2]" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="585" id="585">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="447.5" y="444.5" width="30" height="14" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="587" id="587">
      <mxCell style="link" parent="2663" source="578" target="585" edge="1">
        <mxGeometry x="-232.5" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-232.5" y="49.5" as="sourcePoint" />
          <mxPoint x="307.5" y="419.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="E_PV" Note="embodied energy of PV&lt;br&gt;" Equation="[E_PV1]+[E_PV2]" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="588" id="588">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="767.5" y="445.5" width="31.5" height="16" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="589" id="589">
      <mxCell style="link" parent="2663" source="181" target="588" edge="1">
        <mxGeometry x="-165" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-165" y="49.5" as="sourcePoint" />
          <mxPoint x="-65" y="-50.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="777.5" y="433.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="590" id="590">
      <mxCell style="link" parent="2663" source="569" target="588" edge="1">
        <mxGeometry x="-155" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-155" y="49.5" as="sourcePoint" />
          <mxPoint x="-55" y="-50.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="777.5" y="473.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="234">
      <mxCell style="link;fontSize=12;" parent="2663" source="233" target="125" edge="1">
        <mxGeometry x="13.629999999999995" y="123.5" width="100" height="100" as="geometry">
          <mxPoint x="13.629999999999995" y="223.5" as="sourcePoint" />
          <mxPoint x="113.63" y="123.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="895" id="895">
      <mxCell style="link" parent="2663" source="233" target="125" edge="1">
        <mxGeometry x="-182.5" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="49.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-50.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="T_LfC_min" Note="&lt;div&gt;minimal lifetime of embodied energy, i.e. all installations reach this lifetime&lt;br&gt;&lt;/div&gt;" Equation="25" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="35" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="896" id="896">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="207.5" y="443.5" width="50" height="19" as="geometry" />
      </mxCell>
    </Variable>
    <Stock name="E_fCnew2" Note="embodied energy that reached minimum lifetime&lt;br&gt;" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="897" id="897">
      <mxCell style="stock;fillColor=#FFFF00;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="157.5" y="468.5" width="72.5" height="14" as="geometry" />
      </mxCell>
    </Stock>
    <Variable name="E_fCnew" Note="Embodied energy of newly built fC; comprises both initial E_fCnew1 and shifted E_fCnew2 stock values&lt;br&gt;" Equation="[E_fCnew1]+[E_fCnew2]" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="899" id="899">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="148.25" y="445" width="31.5" height="16" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="902" id="902">
      <mxCell style="link" parent="2663" source="896" target="925" edge="1">
        <mxGeometry x="-182.5" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="49.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-50.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="903" id="903">
      <mxCell style="link" parent="2663" source="1191" target="925" edge="1">
        <mxGeometry x="-182.5" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="49.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-50.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="257.5" y="437.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="904" id="904">
      <mxCell style="link" parent="2663" source="896" target="125" edge="1">
        <mxGeometry x="-182.5" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="49.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-50.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="905" id="905">
      <mxCell style="link" parent="2663" source="925" target="125" edge="1">
        <mxGeometry x="-182.5" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="49.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-50.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="fC2" Note="power shifting embodied energy from initial stock to stock, which has already reached minimum lifetime&lt;br&gt;" FlowRate="Delay([P fC constructed], [T_LfC_min]/{1 Years}, 0)" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="925" id="925">
      <mxCell style="flow;fontSize=8;fontColor=#000000;strokeColor=#FFFF00;" parent="2663" source="235" target="897" edge="1">
        <mxGeometry x="-182.5" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-183.45" y="62.5" as="sourcePoint" />
          <mxPoint x="-83.45" y="-37.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="193.55" y="443.5" />
            <mxPoint x="210.55" y="446.5" />
          </Array>
          <mxPoint x="-6" y="-4" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="fC emission intensity" Note="&lt;div&gt;Conversion factor from power output of fC to the linked flux&lt;/div&gt;&lt;div&gt;35.75 Gt/a fossil emissions (2023) / 6.34 TW P_demand_0&lt;br&gt;&lt;/div&gt;" Equation="5.64" Units="(Gt/a)/TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1038" id="1038">
      <mxCell style="variable;fontSize=8;fillColor=#CCFFFF;" parent="2663" vertex="1">
        <mxGeometry x="20" y="182.5" width="40" height="37" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1039" id="1039">
      <mxCell style="link" parent="2663" source="1038" target="134" edge="1">
        <mxGeometry x="-182.5" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="49.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-50.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="187" id="187">
      <mxCell style="link;fontSize=12;" parent="2663" source="334" target="190" edge="1">
        <mxGeometry x="403" y="45.5" width="100" height="100" as="geometry">
          <mxPoint x="647.363832042293" y="267.4863437031417" as="sourcePoint" />
          <mxPoint x="503" y="45.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1057" id="1057">
      <mxCell style="link" parent="2663" source="127" target="125" edge="1">
        <mxGeometry x="-182.5" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="49.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-50.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="317.5" y="463.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="E_storage1" Note="embodied energy of intalled storage" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="1097" id="1097">
      <mxCell style="stock;fillColor=#FFFF00;fontSize=12;" parent="2663" vertex="1">
        <mxGeometry x="531" y="395.5" width="62.5" height="40" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="P_build storage flow" Note="power for building storage capacity" FlowRate="[P_build storage after transition]+[P_build storage during transition]" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1098" id="1098">
      <mxCell style="flow;fontSize=6;strokeColor=#FFFF00;" parent="2663" source="143" target="1097" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-131.79" y="646.5" as="sourcePoint" />
          <mxPoint x="-31.789999999999992" y="546.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="577.5" y="327.5" />
          </Array>
          <mxPoint y="66" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="P_eol storage" Note="power reducing embodied energy that reached EoL" FlowRate="Delay3([storage2], ([T_res storage]-[T_res storage_min])/{1 Years})" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1099" id="1099">
      <mxCell style="flow;strokeColor=#C0C0C0;fontSize=12;" parent="2663" source="1102" edge="1">
        <mxGeometry x="-159.46" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="629.0899999999999" y="601.5" as="sourcePoint" />
          <mxPoint x="586.29" y="537.5" as="targetPoint" />
          <Array as="points" />
          <mxPoint x="4" y="36" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="T_res storage" Note="&lt;div&gt;average lifetime of the embodied energy&lt;br&gt;&lt;/div&gt;" Equation="30" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="35" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1100" id="1100">
      <mxCell style="variable;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="511.62" y="503.5" width="38.5" height="15.25" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1101" id="1101">
      <mxCell style="link;fontSize=12;" parent="2663" source="1100" target="1099" edge="1">
        <mxGeometry x="396.25" y="198.5" width="100" height="100" as="geometry">
          <mxPoint x="396.25" y="298.5" as="sourcePoint" />
          <mxPoint x="496.25" y="198.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="E_storage2" Note="embodied energy that reached minimum lifetime&lt;br&gt;" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="1102" id="1102">
      <mxCell style="stock;fillColor=#FFFF00;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="531" y="467.5" width="62.25" height="16" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="storage2" Note="power shifting embodied energy from initial stock to stock, which has already reached minimum lifetime&lt;br&gt;" FlowRate="Delay([P_build storage flow], [T_res storage_min]/{1 Years}, 0)" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1103" id="1103">
      <mxCell style="flow;fontSize=6;fillColor=none;labelBackgroundColor=none;strokeColor=#FFFF00;" parent="2663" source="1097" target="1102" edge="1">
        <mxGeometry x="-259.18" y="119.25" width="100" height="100" as="geometry">
          <mxPoint x="625.8199999999999" y="589.25" as="sourcePoint" />
          <mxPoint x="-159.18" y="119.25" as="targetPoint" />
          <Array as="points">
            <mxPoint x="577.5" y="443.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="T_res storage_min" Note="&lt;div&gt;minimal lifetime of embodied energy, i.e. all installations reach this lifetime&lt;br&gt;&lt;/div&gt;" Equation="15" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="35" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1104" id="1104">
      <mxCell style="variable;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="511.62" y="439.5" width="38.5" height="22" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1106" id="1106">
      <mxCell style="link" parent="2663" source="1104" target="1099" edge="1">
        <mxGeometry x="-231.75" y="101.5" width="100" height="100" as="geometry">
          <mxPoint x="-231.75" y="201.5" as="sourcePoint" />
          <mxPoint x="-131.75" y="101.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="537.5" y="493.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1107" id="1107">
      <mxCell style="link" parent="2663" source="1103" target="1099" edge="1">
        <mxGeometry x="-232.21" y="131.36" width="100" height="100" as="geometry">
          <mxPoint x="-232.21" y="231.36" as="sourcePoint" />
          <mxPoint x="-132.21" y="131.36" as="targetPoint" />
          <Array as="points">
            <mxPoint x="607.5" y="473.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="E_storage" Note="embodied energy of storage" Equation="[E_storage1]+[E_storage2]" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1108" id="1108">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="584.62" y="443.5" width="37.5" height="16" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1109" id="1109">
      <mxCell style="link" parent="2663" source="1097" target="1108" edge="1">
        <mxGeometry x="-231.75" y="101.5" width="100" height="100" as="geometry">
          <mxPoint x="632.9166666666666" y="587.5" as="sourcePoint" />
          <mxPoint x="-131.75" y="101.5" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1110" id="1110">
      <mxCell style="link" parent="2663" source="1102" target="1108" edge="1">
        <mxGeometry x="-231.75" y="101.5" width="100" height="100" as="geometry">
          <mxPoint x="-231.75" y="201.5" as="sourcePoint" />
          <mxPoint x="-131.75" y="101.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="P_storage loss" Note="power from storage losses, i.e. input power to storage - output power from storage&lt;br&gt;" FlowRate="[P_storage_loss]" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1115" id="1115">
      <mxCell style="flow;strokeColor=#FFFF00;fontSize=8;" parent="2663" source="143" edge="1">
        <mxGeometry x="-172.47" y="155.5" width="100" height="100" as="geometry">
          <mxPoint x="524.3132369942199" y="363.25" as="sourcePoint" />
          <mxPoint x="557.5300000000002" y="265.5" as="targetPoint" />
          <Array as="points" />
          <mxPoint y="-20" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="1125" id="1125">
      <mxCell style="link" parent="2663" source="1098" target="1103" edge="1">
        <mxGeometry x="-113" y="101.5" width="100" height="100" as="geometry">
          <mxPoint x="-113" y="201.5" as="sourcePoint" />
          <mxPoint x="-13" y="101.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="617.5" y="443.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_storage" Note="power demand by storage both for building and induced losses" Equation="[P_storage loss]+[P_build storage]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1129" id="1129">
      <mxCell style="variable;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="586.87" y="259.5" width="35.25" height="17" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1130" id="1130">
      <mxCell style="link" parent="2663" source="1115" target="1129" edge="1">
        <mxGeometry x="-87.75" y="546.5" width="100" height="100" as="geometry">
          <mxPoint x="-87.75" y="646.5" as="sourcePoint" />
          <mxPoint x="12.25" y="546.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1135" id="1135">
      <mxCell style="link" parent="2663" source="1709" target="1129" edge="1">
        <mxGeometry x="-87.75" y="546.5" width="100" height="100" as="geometry">
          <mxPoint x="-87.75" y="646.5" as="sourcePoint" />
          <mxPoint x="12.25" y="546.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1137" id="1137">
      <mxCell style="link" parent="2663" source="71" target="442" edge="1">
        <mxGeometry x="-182.5" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="49.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-50.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1152" id="1152">
      <mxCell style="link" parent="2663" source="571" target="570" edge="1">
        <mxGeometry x="-182.5" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="-102.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-202.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1153" id="1153">
      <mxCell style="link" parent="2663" source="1104" target="1103" edge="1">
        <mxGeometry x="-166.75" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-166.75" y="-102.5" as="sourcePoint" />
          <mxPoint x="-66.75" y="-202.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="E_PV in construction" Note="embodied energy of PV under construction" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="true" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1174" id="1174">
      <mxCell style="stock;fillColor=#FFFF00;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="697.5" y="226.5" width="70" height="14" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="P PV constructed" Note="power for building PV delayed by construction" FlowRate="[E_PV in construction]/[PV construction delay]" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1175" id="1175">
      <mxCell style="flow;strokeColor=#FFFF00;fontSize=6;" parent="2663" source="1174" target="181" edge="1">
        <mxGeometry x="-192.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-158.34" y="-101" as="sourcePoint" />
          <mxPoint x="-58.339999999999975" y="-201" as="targetPoint" />
          <Array as="points">
            <mxPoint x="757.5" y="263.5" />
            <mxPoint x="732.36" y="287.5" />
          </Array>
          <mxPoint x="5" y="-44" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="PV construction delay" Note="delay time for construction" Equation="0.2" Units="a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1176" id="1176">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2663" vertex="1">
        <mxGeometry x="697.5" y="276.5" width="49.5" height="33" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1177" id="1177">
      <mxCell style="link" parent="2663" source="1176" target="1175" edge="1">
        <mxGeometry x="-182.5" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="-102.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-202.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="E_CCS in construction" Note="emnbodied energy under construction" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="true" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1183" id="1183">
      <mxCell style="stock;fillColor=#FFFF00;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="377.5" y="225" width="70" height="14" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="P CCS constructed" Note="power for building CCS delayed by construction time" FlowRate="[E_CCS in construction]/[CCS construction delay]" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1184" id="1184">
      <mxCell style="flow;strokeColor=#FFFF00;fontSize=6;" parent="2663" source="1183" target="167" edge="1">
        <mxGeometry x="-457.85" y="-205" width="100" height="100" as="geometry">
          <mxPoint x="-457.85" y="-105" as="sourcePoint" />
          <mxPoint x="437.9" y="391.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="437.5" y="273.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="CCS construction delay" Note="delay time for construction, i.e. time necessary for construction&lt;br&gt;" Equation="0.2" Units="a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1185" id="1185">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2663" vertex="1">
        <mxGeometry x="394.12" y="264.76" width="39.25" height="35.62" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1186" id="1186">
      <mxCell style="link" parent="2663" source="1185" target="1184" edge="1">
        <mxGeometry x="-182.5" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="-102.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-202.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1187" id="1187">
      <mxCell style="link" parent="2663" source="167" target="585" edge="1">
        <mxGeometry x="-182.5" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="-102.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-202.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1188" id="1188">
      <mxCell style="link" parent="2663" source="897" target="899" edge="1">
        <mxGeometry x="-182.5" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="-102.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-202.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1189" id="1189">
      <mxCell style="link" parent="2663" source="235" target="899" edge="1">
        <mxGeometry x="-182.5" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="-102.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-202.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="E_fC in construction" Note="embodied energy for fC infrastructure under construction" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="true" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1190" id="1190">
      <mxCell style="stock;fillColor=#FFFF00;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="179.75" y="226.5" width="70" height="14" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="P fC constructed" Note="power demand for building fC delayed by construction" FlowRate="[E_fC in construction]/[fC construction delay]" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1191" id="1191">
      <mxCell style="flow;strokeColor=#FFFF00;fontSize=6;" parent="2663" source="1190" target="235" edge="1">
        <mxGeometry x="-623.3499999999999" y="-202" width="100" height="100" as="geometry">
          <mxPoint x="-623.3499999999999" y="-102" as="sourcePoint" />
          <mxPoint x="247.2000000000001" y="398.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="217.5" y="297.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="1193" id="1193">
      <mxCell style="link" parent="2663" source="1192" target="1191" edge="1">
        <mxGeometry x="-182.5" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="-102.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-202.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_EoL fC total" Note="power reducing embodied energy from both initial and newly built fC" Equation="If [E_fC]&gt;{0.1 TW*a} Then&#xa;  [P_eolfC]+[P_eolfCnew]&#xa;Else&#xa;  [P_eolfCnew]&#xa;End If&#xa;" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1202" id="1202">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="117.5" y="503.5" width="40" height="27.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1203" id="1203">
      <mxCell style="link" parent="2663" source="237" target="1202" edge="1">
        <mxGeometry x="-182.5" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="-102.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-202.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1204" id="1204">
      <mxCell style="link" parent="2663" source="125" target="1202" edge="1">
        <mxGeometry x="-182.5" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="-102.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-202.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1055" name="P_build_fC1" oldId="1206" id="1206">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="2663" vertex="1">
        <mxGeometry x="117.5" y="189.5" width="86" height="20.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1207" id="1207">
      <mxCell style="link" parent="2663" source="1206" target="127" edge="1">
        <mxGeometry x="-182.5" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-182.5" y="-102.5" as="sourcePoint" />
          <mxPoint x="-82.5" y="-202.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1052" name="P_build_PV1" oldId="1216" id="1216">
      <mxCell style="variable;fontSize=10;opacity=30;" parent="2663" vertex="1">
        <mxGeometry x="667.5" y="197.75" width="70" height="24.25" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="140" id="140">
      <mxCell style="link;fontSize=12;" parent="2663" source="335" target="126" edge="1">
        <mxGeometry x="-115" y="45.5" width="100" height="100" as="geometry">
          <mxPoint x="128.09784796104788" y="269.70129764252425" as="sourcePoint" />
          <mxPoint x="-15" y="45.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1234" id="1234">
      <mxCell style="link" parent="2663" source="1235" target="1115" edge="1">
        <mxGeometry x="-166.75" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-166.75" y="-102.5" as="sourcePoint" />
          <mxPoint x="-66.75" y="-202.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1233" name="P_storage_loss" oldId="1235" id="1235">
      <mxCell style="variable;fontSize=6;opacity=30;" parent="2663" vertex="1">
        <mxGeometry x="497.5" y="222" width="52.62" height="17" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1240" name="P_build storage after transition" oldId="1241" id="1241">
      <mxCell style="variable;fontSize=6;opacity=30;" parent="2663" vertex="1">
        <mxGeometry x="586.87" y="305.12" width="35.25" height="35" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1242" id="1242">
      <mxCell style="link" parent="2663" source="1241" target="1098" edge="1">
        <mxGeometry x="-166.75" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-166.75" y="-102.5" as="sourcePoint" />
          <mxPoint x="-66.75" y="-202.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1246" name="P_build storage during transition" oldId="1247" id="1247">
      <mxCell style="variable;fontSize=6;opacity=30;" parent="2663" vertex="1">
        <mxGeometry x="586.8699999999999" y="167.75" width="40.63" height="40" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1248" id="1248">
      <mxCell style="link" parent="2663" source="1247" target="1098" edge="1">
        <mxGeometry x="-166.75" y="-202.5" width="100" height="100" as="geometry">
          <mxPoint x="-166.75" y="-102.5" as="sourcePoint" />
          <mxPoint x="-66.75" y="-202.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1296" id="1296">
      <mxCell style="link" parent="2663" source="1247" target="1558" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_supply to society curtailled" Note="supply to society that is restricted to P_demand&lt;br&gt;" Equation="Min([P_supply to society],[P_demand])" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1360" id="1360">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="792.25" y="20" width="78.5" height="46" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1361" id="1361">
      <mxCell style="link" parent="2663" source="442" target="1360" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="fC construction delay" Note="delay time for construction" Equation="0.2" Units="a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1192" id="1192">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="2663" vertex="1">
        <mxGeometry x="163" y="274.25" width="47" height="35.25" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_opCCS_1" Note="operating power for CCS" Equation="[P_opCCS]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1430" id="1430">
      <mxCell style="variable;fontSize=9;" parent="2663" vertex="1">
        <mxGeometry x="260" y="222" width="50" height="18.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1431" id="1431">
      <mxCell style="link" parent="2663" source="178" target="1430" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_build_PV2" Note="power demand by storage both for building and induced losses" Equation="[P_build_PV1]-[P_build storage during transition]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1558" id="1558">
      <mxCell style="variable;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="670" y="172.5" width="35.25" height="17" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1559" id="1559">
      <mxCell style="link" parent="2663" source="1558" target="191" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_build storage" Note="power demand by storage both for building and induced losses" Equation="[P_build storage flow]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1709" id="1709">
      <mxCell style="variable;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="587.25" y="283.38" width="35.25" height="17" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1710" id="1710">
      <mxCell style="link" parent="2663" source="1098" target="1709" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="material supply constrain switch" Note="&lt;div&gt;0= transition is not constrained by materials&lt;/div&gt;&lt;div&gt;1= transition is constrained&lt;br&gt;&lt;/div&gt;" Equation="1" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1853" id="1853">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="2663" vertex="1">
        <mxGeometry x="427.5" y="39.5" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1923" id="1923">
      <mxCell style="link" parent="2663" source="124" target="1202" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P opfC" Note="" Equation="[P_opfC]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1940" id="1940">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="110" y="210" width="37.5" height="23.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1941" id="1941">
      <mxCell style="link" parent="2663" source="126" target="1940" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P opPV" Note="" Equation="[P_opPV]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1943" id="1943">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="658.75" y="221.75" width="37.5" height="23.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1944" id="1944">
      <mxCell style="link" parent="2663" source="190" target="1943" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="P nom PV 1" Note="embodied energy of installed PV" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="2011" id="2011">
      <mxCell style="stock;fillColor=#00FFFF;fontSize=12;" parent="2663" vertex="1">
        <mxGeometry x="637.38" y="395.5" width="65" height="40" as="geometry" />
      </mxCell>
    </Stock>
    <Stock name="P nom PV 2" Note="embodied energy that reached minimum lifetime&lt;br&gt;" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="2012" id="2012">
      <mxCell style="stock;fillColor=#00FFFF;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="637.38" y="471.15999999999997" width="65" height="14" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="PV cap 2" Note="" FlowRate="Delay([PV cap 1], [T_resPV_min]/{1 Years}, 0)" OnlyPositive="true" TimeIndependent="false" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2013" id="2013">
      <mxCell style="flow;fontSize=6;strokeColor=#00FFFF;" parent="2663" source="2011" target="2012" edge="1">
        <mxGeometry x="-219.98" y="-65.5" width="100" height="100" as="geometry">
          <mxPoint x="-219.98" y="34.5" as="sourcePoint" />
          <mxPoint x="-119.98" y="-65.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="637.5" y="443.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="PV cap EoL" Note="" FlowRate="Delay3([PV cap 2], ([T_resPV]-[T_resPV_min])/{1 Years})" OnlyPositive="true" TimeIndependent="false" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2014" id="2014">
      <mxCell style="flow;fontSize=6;strokeColor=#00FFFF;" parent="2663" source="2012" edge="1">
        <mxGeometry x="-210" y="-68" width="100" height="100" as="geometry">
          <mxPoint x="-210" y="32" as="sourcePoint" />
          <mxPoint x="637.5" y="542" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="PV cap 1" Note="" FlowRate="[PV cap building]" OnlyPositive="true" TimeIndependent="false" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2015" id="2015">
      <mxCell style="flow;fontSize=6;strokeColor=#00FFFF;" parent="2663" target="2011" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="637.5" y="363.5" as="sourcePoint" />
          <mxPoint x="-202.5" y="33.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="2016" id="2016">
      <mxCell style="link" parent="2663" source="1175" target="2085" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2018" id="2018">
      <mxCell style="link" parent="2663" source="2015" target="2013" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="617.5" y="413.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2019" id="2019">
      <mxCell style="link" parent="2663" source="571" target="2013" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2020" id="2020">
      <mxCell style="link" parent="2663" source="183" target="2014" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2021" id="2021">
      <mxCell style="link" parent="2663" source="2013" target="2014" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="617.5" y="483.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2022" id="2022">
      <mxCell style="link" parent="2663" source="571" target="2014" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="647.5" y="513.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2023" id="2023">
      <mxCell style="link" parent="2663" source="2012" target="185" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="587.5" y="433.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2024" id="2024">
      <mxCell style="link" parent="2663" source="2011" target="185" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="597.5" y="393.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="PV cap building" Note="" Equation="Max({0 TW/a},smooth([P PV constructed]/[EPBT_PV],3*TimeStep()))" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2085" LiveGraph="{&quot;active&quot;:false}" id="2085">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="651.13" y="372" width="37.5" height="23.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="346" id="346">
      <mxCell style="link" parent="2663" source="1175" target="570" edge="1">
        <mxGeometry x="-165" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-165" y="49.5" as="sourcePoint" />
          <mxPoint x="-65" y="-50.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="797.5" y="433.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2087" id="2087">
      <mxCell style="link" parent="2663" source="2085" target="2015" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2100" oldId="2102" name="EPBT_PV" id="2102">
      <mxCell style="variable;fontSize=10;fillColor=#FDCDAC;opacity=30;" parent="2663" vertex="1">
        <mxGeometry x="707.4999999999997" y="358.24999999999994" width="50.75" height="27.7" as="geometry" />
      </mxCell>
    </Ghost>
    <Stock name="P nom DAC 1" Note="" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="2165" id="2165">
      <mxCell style="stock;fillColor=#00FFFF;fontSize=12;" parent="2663" vertex="1">
        <mxGeometry x="312.5" y="395.5" width="65" height="40" as="geometry" />
      </mxCell>
    </Stock>
    <Stock name="P nom DAC 2" Note="" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="2166" id="2166">
      <mxCell style="stock;fillColor=#00FFFF;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="312.5" y="467.5" width="65" height="14" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="DAC cap 2" Note="" FlowRate="Delay([DAC cap 1], [T_resCCS_min]/{1 Years}, 0)" OnlyPositive="true" TimeIndependent="false" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2167" id="2167">
      <mxCell style="flow;fontSize=6;strokeColor=#00FFFF;" parent="2663" source="2165" target="2166" edge="1">
        <mxGeometry x="-534.98" y="-66.75" width="100" height="100" as="geometry">
          <mxPoint x="-534.98" y="33.25" as="sourcePoint" />
          <mxPoint x="-434.98" y="-66.75" as="targetPoint" />
          <Array as="points">
            <mxPoint x="317.5" y="443.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="DAC cap EoL" Note="" FlowRate="Delay3([DAC cap 2], ([T_resCCS]-[T_resCCS_min])/{1 Years})" OnlyPositive="true" TimeIndependent="false" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2168" id="2168">
      <mxCell style="flow;fontSize=6;strokeColor=#00FFFF;" parent="2663" source="2166" edge="1">
        <mxGeometry x="-529.86" y="-69.25" width="100" height="100" as="geometry">
          <mxPoint x="-529.86" y="30.75" as="sourcePoint" />
          <mxPoint x="317.64" y="540.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="DAC cap 1" Note="" FlowRate="[DAC cap building]" OnlyPositive="true" TimeIndependent="false" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2169" id="2169">
      <mxCell style="flow;fontSize=6;strokeColor=#00FFFF;" parent="2663" target="2165" edge="1">
        <mxGeometry x="-522.36" y="-67.75" width="100" height="100" as="geometry">
          <mxPoint x="317.64" y="362.25" as="sourcePoint" />
          <mxPoint x="-522.36" y="32.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="2170" id="2170">
      <mxCell style="link" parent="2663" source="577" target="2167" edge="1">
        <mxGeometry x="-517.5" y="-67.75" width="100" height="100" as="geometry">
          <mxPoint x="352.55305403402883" y="452.20985678420675" as="sourcePoint" />
          <mxPoint x="-417.5" y="-67.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2171" id="2171">
      <mxCell style="link" parent="2663" source="169" target="2168" edge="1">
        <mxGeometry x="-517.5" y="-67.75" width="100" height="100" as="geometry">
          <mxPoint x="352.68113326973037" y="514.3874927795711" as="sourcePoint" />
          <mxPoint x="-417.5" y="-67.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2172" id="2172">
      <mxCell style="link" parent="2663" source="577" target="2168" edge="1">
        <mxGeometry x="-517.5" y="-67.75" width="100" height="100" as="geometry">
          <mxPoint x="371.0246501402478" y="460.8735637700487" as="sourcePoint" />
          <mxPoint x="332.5" y="512.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="DAC cap building" Note="" Equation="Max({0 TW/a},[P CCS constructed]/[CCS_EIT])" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2173" id="2173">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="336.13" y="368" width="37.5" height="23.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2174" id="2174">
      <mxCell style="link" parent="2663" source="2173" target="2169" edge="1">
        <mxGeometry x="-517.5" y="-67.75" width="100" height="100" as="geometry">
          <mxPoint x="-517.5" y="32.25" as="sourcePoint" />
          <mxPoint x="-417.5" y="-67.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2175" id="2175">
      <mxCell style="link" parent="2663" source="2169" target="2167" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="297.5" y="413.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2176" id="2176">
      <mxCell style="link" parent="2663" source="2167" target="2168" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="297.5" y="483.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2177" id="2177">
      <mxCell style="link" parent="2663" source="1184" target="2173" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2178" id="2178">
      <mxCell style="link" parent="2663" source="2304" target="2173" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2179" id="2179">
      <mxCell style="link" parent="2663" source="2165" target="171" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2180" id="2180">
      <mxCell style="link" parent="2663" source="2166" target="171" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="277.5" y="463.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="storage cap EoL" Note="" FlowRate="Delay3([storage cap 2], ([T_res storage]-[T_res storage_min])/{1 Years})" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2184" id="2184">
      <mxCell style="flow;fontSize=6;strokeColor=#00FFFF;" parent="2663" source="2185" edge="1">
        <mxGeometry x="-367.63" y="-69.25" width="100" height="100" as="geometry">
          <mxPoint x="-367.63" y="30.75" as="sourcePoint" />
          <mxPoint x="479.87" y="540.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="E nom storage 2" Note="embodied energy that reached minimum lifetime&lt;br&gt;" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="2185" id="2185">
      <mxCell style="stock;fillColor=#00FFFF;fontSize=6;" parent="2663" vertex="1">
        <mxGeometry x="478.63" y="467.5" width="52.37" height="16" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="storage cap 2" Note="" FlowRate="Delay([storage cap 1], [T_res storage_min]/{1 Years}, 0)" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2186" id="2186">
      <mxCell style="flow;fontSize=6;strokeColor=#00FFFF;" parent="2663" source="2187" target="2185" edge="1">
        <mxGeometry x="-377.61" y="-66.75" width="100" height="100" as="geometry">
          <mxPoint x="-377.61" y="33.25" as="sourcePoint" />
          <mxPoint x="-277.61" y="-66.75" as="targetPoint" />
          <Array as="points">
            <mxPoint x="479.87" y="442.25" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="E nom storage 1" Note="embodied energy of installed PV" InitialValue="0" StockMode="Store" Delay="0" Volume="100" NonNegative="false" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="true" oldId="2187" id="2187">
      <mxCell style="stock;fillColor=#00FFFF;fontSize=12;" parent="2663" vertex="1">
        <mxGeometry x="478.63" y="395.5" width="52.37" height="40" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="storage cap 1" Note="" FlowRate="[storage cap building]" OnlyPositive="true" TimeIndependent="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="2188" id="2188">
      <mxCell style="flow;fontSize=6;strokeColor=#00FFFF;" parent="2663" target="2187" edge="1">
        <mxGeometry x="-360.13" y="-67.75" width="100" height="100" as="geometry">
          <mxPoint x="479.87" y="362.25" as="sourcePoint" />
          <mxPoint x="-360.13" y="32.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Variable name="storage cap building" Note="" Equation="Smooth(Max({0 TW},[P_build storage flow]/[storage energy intensity]),3*TimeStep())" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2189" id="2189">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="493.5" y="353.5" width="37.5" height="38" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2190" id="2190">
      <mxCell style="link" parent="2663" source="2189" target="2188" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2191" id="2191">
      <mxCell style="link" parent="2663" source="2188" target="2186" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="467.5" y="413.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2192" id="2192">
      <mxCell style="link" parent="2663" source="2186" target="2184" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
          <Array as="points">
            <mxPoint x="467.5" y="473.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2193" id="2193">
      <mxCell style="link" parent="2663" source="1104" target="2186" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2194" id="2194">
      <mxCell style="link" parent="2663" source="1104" target="2184" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2195" id="2195">
      <mxCell style="link" parent="2663" source="1100" target="2184" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1072" oldId="2196" name="storage energy intensity" id="2196">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="2663" vertex="1">
        <mxGeometry x="495.5" y="300.38" width="33.5" height="34.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2197" id="2197">
      <mxCell style="link" parent="2663" source="2196" target="2189" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2198" id="2198">
      <mxCell style="link" parent="2663" source="1098" target="2189" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2200" id="2200">
      <mxCell style="link" parent="2663" source="2185" target="1111" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2201" id="2201">
      <mxCell style="link" parent="2663" source="2187" target="1111" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="storage capacity" Note="actual installed storage capactiy&lt;br&gt;" Equation="[E nom storage 2]+[E nom storage 1]" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1111" id="1111">
      <mxCell style="variable;fontSize=8;" parent="2663" vertex="1">
        <mxGeometry x="531" y="351.5" width="40.75" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="349" oldId="2304" name="CCS_EIT" id="2304">
      <mxCell style="variable;fontSize=10;opacity=30;" parent="2663" vertex="1">
        <mxGeometry x="383.37" y="360.75" width="50" height="21.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1053" id="1053">
      <mxCell style="link" parent="2663" source="1216" target="1558" edge="1">
        <mxGeometry x="-105" y="-50.5" width="100" height="100" as="geometry">
          <mxPoint x="-105" y="49.5" as="sourcePoint" />
          <mxPoint x="-5" y="-50.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2017" id="2017">
      <mxCell style="link" parent="2663" source="2102" target="2085" edge="1">
        <mxGeometry x="-202.5" y="-66.5" width="100" height="100" as="geometry">
          <mxPoint x="-202.5" y="33.5" as="sourcePoint" />
          <mxPoint x="-102.5" y="-66.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Display name="cumulative CO2 emissions" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" ThreeDimensional="false" Primitives="565,708,707,706,56" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" yAxis2="%o" Primitives2="" showMarkers="false" showLines="true" showArea="false" legendPosition="Automatic" yAxisMin="0" yAxisMin2="0" yAxisMax2="5" id="3">
      <mxCell style="roundImage;image=/builder/images/DisplayFull.png;" parent="1" vertex="1" visible="0">
        <mxGeometry x="50" y="20" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Folder name="Process emissions" Note="" Type="None" Solver="{&quot;enabled&quot;:false,&quot;algorithm&quot;:&quot;RK1&quot;,&quot;timeStep&quot;:1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="2337" id="2337">
      <mxCell style="folder" parent="1" vertex="1">
        <mxGeometry x="3070" y="679.01" width="360.69" height="312.34" as="geometry" />
      </mxCell>
    </Folder>
    <Ghost Source="2329" oldId="2332" name="Al prim CO2 emissions" id="2332">
      <mxCell style="variable;fontSize=8;fillColor=#CCFFFF;opacity=30;" parent="2337" vertex="1">
        <mxGeometry x="20" y="20" width="66.06" height="36" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="process CO2 emissions from materials" Note="direct process emissions&lt;br&gt;" Equation="[Al prim CO2 emissions]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2333" id="2333">
      <mxCell style="variable;fontSize=8;fillColor=#CCFFFF;" parent="2337" vertex="1">
        <mxGeometry x="20.000000000000455" y="75.3599999999999" width="66.06" height="36" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2334" id="2334">
      <mxCell style="link" parent="2337" source="2332" target="2333" edge="1">
        <mxGeometry x="-2320.31" y="-1205.5200000000002" width="100" height="100" as="geometry">
          <mxPoint x="-2320.31" y="-1105.5200000000002" as="sourcePoint" />
          <mxPoint x="-2220.31" y="-1205.5200000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="Aluminium cycle" Note="" Type="None" Solver="{&quot;enabled&quot;:false,&quot;algorithm&quot;:&quot;RK1&quot;,&quot;timeStep&quot;:1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="2025" id="2025">
      <mxCell style="folder" parent="1" vertex="1">
        <mxGeometry x="90.00000000000011" y="1610.6100000000001" width="170" height="151" as="geometry" />
      </mxCell>
    </Folder>
    <Flow name="Al recycling slew rate" Note="" FlowRate="If [d Al max recycling]&gt;[Al recycling increase limit] Then&#xa;  [Al recycling increase limit]&#xa;Else If [d Al max recycling]&lt;[Al recycling decrease limit] Then&#xa;  [Al recycling decrease limit]&#xa;Else&#xa;  [d Al max recycling]&#xa;End If" OnlyPositive="false" TimeIndependent="false" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1625" id="1625">
      <mxCell style="flow;startArrow=block;startFill=0;fontSize=6;" parent="2025" target="1624" edge="1">
        <mxGeometry x="-1992.4699999999998" y="-15.300000000000011" width="100" height="100" as="geometry">
          <mxPoint x="403.7499999999999" y="-290.0000000000002" as="sourcePoint" />
          <mxPoint x="-1992.4699999999998" y="84.70000000000002" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Folder name="capacity utilisation" Note="maximum possible capacity utilisation due to constraints of availability of RE&lt;br&gt;" Type="None" Solver="{&quot;enabled&quot;:false,&quot;algorithm&quot;:&quot;RK1&quot;,&quot;timeStep&quot;:1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="1971" id="1971">
      <mxCell style="folder" parent="1" vertex="1">
        <mxGeometry x="1705.8200000000002" y="640" width="180.31" height="190" as="geometry" />
      </mxCell>
    </Folder>
    <Variable name="max capacity utilization factor" Note="" Equation="1-(1-[min capacity utilization factor])*[P opPV]/([P opPV]+[P opfC])" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1939" id="1939">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="1971" vertex="1">
        <mxGeometry x="100.31000000000016" y="20" width="64.04" height="57.68" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="1940" oldId="1942" name="P opfC" id="1942">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="1971" vertex="1">
        <mxGeometry x="126.85000000000008" y="83.25" width="37.5" height="23.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1943" oldId="1945" name="P opPV" id="1945">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="1971" vertex="1">
        <mxGeometry x="79.35000000000008" y="83.25" width="37.5" height="23.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1946" id="1946">
      <mxCell style="link" parent="1971" source="1945" target="1939" edge="1">
        <mxGeometry x="-1332.71" y="-481.99999999999994" width="100" height="100" as="geometry">
          <mxPoint x="-1332.71" y="-381.99999999999994" as="sourcePoint" />
          <mxPoint x="-1232.71" y="-481.99999999999994" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1947" id="1947">
      <mxCell style="link" parent="1971" source="1942" target="1939" edge="1">
        <mxGeometry x="-1332.71" y="-481.99999999999994" width="100" height="100" as="geometry">
          <mxPoint x="-1332.71" y="-381.99999999999994" as="sourcePoint" />
          <mxPoint x="-1232.71" y="-481.99999999999994" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="min capacity utilization factor" Note="increases exponentially with independence time&lt;br&gt;" Equation="#[min capacity utilization factor without storage]+(1-[min capacity utilization factor without storage])*([independence time]/{0.3 Years})^0.5&#xa;1-(1-[min capacity utilization factor without storage])*exp(-8*[independence time]/{0.3 Years})" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1968" id="1968">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="1971" vertex="1">
        <mxGeometry x="10.31" y="26.340000000000035" width="46.08" height="45" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1969" id="1969">
      <mxCell style="link" parent="1971" source="1968" target="1939" edge="1">
        <mxGeometry x="-1332.71" y="-481.99999999999994" width="100" height="100" as="geometry">
          <mxPoint x="-1332.71" y="-381.99999999999994" as="sourcePoint" />
          <mxPoint x="-1232.71" y="-481.99999999999994" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="min capacity utilization factor without storage" Note="" Equation="0.3" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2338" id="2338">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="1971" vertex="1">
        <mxGeometry x="10.31" y="130" width="69.69" height="50" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="749" oldId="2340" name="independence time" id="2340">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;opacity=30;" parent="1971" vertex="1">
        <mxGeometry x="79.35000000000014" y="123.75" width="85" height="57.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2341" id="2341">
      <mxCell style="link" parent="1971" source="2338" target="1968" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2342" id="2342">
      <mxCell style="link" parent="1971" source="2340" target="1968" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="predefined scenarios" Note="" Type="None" Solver="{&quot;enabled&quot;:false,&quot;algorithm&quot;:&quot;RK1&quot;,&quot;timeStep&quot;:1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="1478" id="1478">
      <mxCell style="folder;fontSize=12;" parent="1" vertex="1">
        <mxGeometry x="3550" y="622.49" width="219.5" height="431.75" as="geometry" />
      </mxCell>
    </Folder>
    <Button name="All-in advanced" Note="" Function="pressButton(findName(&quot;setting base parameters&quot;))&#xa;setValue(findName(&quot;fC_repair&quot;), 0);&#xa;setValue(findName(&quot;CCS switch&quot;), 1);&#xa;setValue(findName(&quot;fC switch&quot;), 1);&#xa;setValue(findName(&quot;fC phase out&quot;), 1);&#xa;setValue(findName(&quot;demand growth switch&quot;), 0);&#xa;setValue(findName(&quot;population confidence selection&quot;), 2);&#xa;setValue(findName(&quot;growth rate&quot;), 0);&#xa;setValue(findName(&quot;P_demand per person aim&quot;), 680);&#xa;setValue(findName(&quot;demand adjustment delay time&quot;), 5);&#xa;setValue(findName(&quot;demand adjustment duration&quot;), 10);&#xa;setValue(findName(&quot;oversize PV&quot;), 1.2);&#xa;setValue(findName(&quot;alpha&quot;), 0.8);&#xa;setValue(findName(&quot;beta in transition&quot;), 1);&#xa;setValue(findName(&quot;beta after transition&quot;), 0.5);&#xa;setValue(findName(&quot;desert potential fraction&quot;), 0);&#xa;setValue(findName(&quot;buildings potential fraction&quot;), 0.85);&#xa;setValue(findName(&quot;PV repair proportional&quot;), 0.5);&#xa;setValue(findName(&quot;PV repair on demand&quot;), 0);&#xa;setValue(findName(&quot;PV repair inverse proportional&quot;), 20);&#xa;setValue(findName(&quot;PV repair increase limit&quot;), 2);&#xa;setValue(findName(&quot;PV repair decrease limit&quot;), -1);&#xa;setValue(findName(&quot;delta in transition&quot;), 0);&#xa;setValue(findName(&quot;delta for growing with demand&quot;), 0.8);&#xa;setValue(findName(&quot;tau_fC_phase_out&quot;), 5);&#xa;setValue(findName(&quot;fC_dep_phase_out&quot;), 0.01);&#xa;setValue(findName(&quot;epsilon in transition&quot;), 0);&#xa;setValue(findName(&quot;epsilon after transition&quot;), 1);&#xa;setValue(findName(&quot;CCS increase limit&quot;), 0.1);&#xa;setValue(findName(&quot;independence time&quot;), 0.005);&#xa;setValue(findName(&quot;fraction of daily demand stored&quot;), 0.1);&#xa;setValue(findName(&quot;relative weight chemical storage&quot;), 0.1);&#xa;setValue(findName(&quot;relative weight mechanical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight electro-chemical storage&quot;), 0.8);&#xa;setValue(findName(&quot;storage building time constant&quot;), 0.001);&#xa;setValue(findName(&quot;K_P&quot;), 8);&#xa;setValue(findName(&quot;K_I&quot;), 1);&#xa;setValue(findName(&quot;K_D&quot;), 0.001);&#xa;setValue(findName(&quot;gamma&quot;), 0.95);&#xa;setValue(findName(&quot;K_fC drain&quot;), 2);&#xa;setValue(findName(&quot;_PV_alpha decrease limit&quot;), -2);&#xa;setValue(findName(&quot;material supply constrain switch&quot;), 1);&#xa;setValue(findName(&quot;Al prim supply gap correction exponent&quot;), 6);&#xa;setValue(findName(&quot;Al prim CF correction threshold&quot;), 0);&#xa;setValue(findName(&quot;K_p for Al prim CF&quot;), 0.6);&#xa;setValue(findName(&quot;K_i for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;K_d for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;Al CF market factor&quot;), 0.1);&#xa;setValue(findName(&quot;Al CF market filling factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al market filling exponent&quot;), 1);&#xa;setValue(findName(&quot;Al market shortage correction exponent&quot;), 2);&#xa;setValue(findName(&quot;Al prim construction time&quot;), 5);&#xa;setValue(findName(&quot;Al prim min construction time&quot;), 2.5);&#xa;setValue(findName(&quot;Al prim CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al prim permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling construction time&quot;), 1);&#xa;setValue(findName(&quot;Al recycling CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al sec capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling increase limit&quot;), 1);&#xa;setValue(findName(&quot;Al recycling decrease limit&quot;), -1);&#xa;setValue(findName(&quot;Al recycling permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al dilution tau&quot;), 10);&#xa;setValue(findName(&quot;Al dilution ratio inf&quot;), 0.1);&#xa;setValue(findName(&quot;PV material intensity switch&quot;), 2);&#xa;setValue(findName(&quot;PV Al intensity tau&quot;), 5);&#xa;setValue(findName(&quot;societal Al intensity inf factor&quot;), 0.9478);&#xa;setValue(findName(&quot;societal Al intensity increase factor&quot;), 1.05);&#xa;setValue(findName(&quot;societal Al intensity tau&quot;), 6);&#xa;setValue(findName(&quot;DAC Al intensity tau&quot;), 30);&#xa;&#xa;runModel();" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1474" id="1474">
      <mxCell style="button;fontSize=10;" parent="1478" vertex="1">
        <mxGeometry x="50" y="341.75" width="120" height="24" as="geometry" />
      </mxCell>
    </Button>
    <Button name="All-in base" Note="" Function="pressButton(findName(&quot;setting base parameters&quot;))&#xa;setValue(findName(&quot;fC_repair&quot;), 0);&#xa;setValue(findName(&quot;CCS switch&quot;), 1);&#xa;setValue(findName(&quot;fC switch&quot;), 1);&#xa;setValue(findName(&quot;fC phase out&quot;), 1);&#xa;setValue(findName(&quot;demand growth switch&quot;), 0);&#xa;setValue(findName(&quot;population confidence selection&quot;), 2);&#xa;setValue(findName(&quot;growth rate&quot;), 0);&#xa;setValue(findName(&quot;P_demand per person aim&quot;), 680);&#xa;setValue(findName(&quot;demand adjustment delay time&quot;), 5);&#xa;setValue(findName(&quot;demand adjustment duration&quot;), 10);&#xa;setValue(findName(&quot;oversize PV&quot;), 1.2);&#xa;setValue(findName(&quot;alpha&quot;), 0.8);&#xa;setValue(findName(&quot;beta in transition&quot;), 1);&#xa;setValue(findName(&quot;beta after transition&quot;), 0.5);&#xa;setValue(findName(&quot;desert potential fraction&quot;), 0);&#xa;setValue(findName(&quot;buildings potential fraction&quot;), 0.85);&#xa;setValue(findName(&quot;PV repair proportional&quot;), 0.5);&#xa;setValue(findName(&quot;PV repair on demand&quot;), 0);&#xa;setValue(findName(&quot;PV repair inverse proportional&quot;), 20);&#xa;setValue(findName(&quot;PV repair increase limit&quot;), 0.5);&#xa;setValue(findName(&quot;PV repair decrease limit&quot;), -1);&#xa;setValue(findName(&quot;delta in transition&quot;), 0);&#xa;setValue(findName(&quot;delta for growing with demand&quot;), 0.8);&#xa;setValue(findName(&quot;tau_fC_phase_out&quot;), 10);&#xa;setValue(findName(&quot;fC_dep_phase_out&quot;), 0.02);&#xa;setValue(findName(&quot;epsilon in transition&quot;), 0);&#xa;setValue(findName(&quot;epsilon after transition&quot;), 1);&#xa;setValue(findName(&quot;CCS increase limit&quot;), 0.1);&#xa;setValue(findName(&quot;independence time&quot;), 0.005);&#xa;setValue(findName(&quot;fraction of daily demand stored&quot;), 0.1);&#xa;setValue(findName(&quot;relative weight chemical storage&quot;), 0.1);&#xa;setValue(findName(&quot;relative weight mechanical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight electro-chemical storage&quot;), 0.8);&#xa;setValue(findName(&quot;storage building time constant&quot;), 0.001);&#xa;setValue(findName(&quot;K_P&quot;), 8);&#xa;setValue(findName(&quot;K_I&quot;), 1);&#xa;setValue(findName(&quot;K_D&quot;), 0.001);&#xa;setValue(findName(&quot;gamma&quot;), 0.95);&#xa;setValue(findName(&quot;K_fC drain&quot;), 2);&#xa;setValue(findName(&quot;_PV_alpha decrease limit&quot;), -0.5);&#xa;setValue(findName(&quot;material supply constrain switch&quot;), 1);&#xa;setValue(findName(&quot;Al prim supply gap correction exponent&quot;), 4);&#xa;setValue(findName(&quot;Al prim CF correction threshold&quot;), 0);&#xa;setValue(findName(&quot;K_p for Al prim CF&quot;), 0.4);&#xa;setValue(findName(&quot;K_i for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;K_d for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;Al CF market factor&quot;), 0.3);&#xa;setValue(findName(&quot;Al CF market filling factor&quot;), 0.7);&#xa;setValue(findName(&quot;Al market filling exponent&quot;), 3);&#xa;setValue(findName(&quot;Al market shortage correction exponent&quot;), 2);&#xa;setValue(findName(&quot;Al prim construction time&quot;), 7);&#xa;setValue(findName(&quot;Al prim min construction time&quot;), 3);&#xa;setValue(findName(&quot;Al prim CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al prim permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling construction time&quot;), 2);&#xa;setValue(findName(&quot;Al recycling CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al sec capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling increase limit&quot;), 1);&#xa;setValue(findName(&quot;Al recycling decrease limit&quot;), -1);&#xa;setValue(findName(&quot;Al recycling permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al dilution tau&quot;), 50);&#xa;setValue(findName(&quot;Al dilution ratio inf&quot;), 0.5);&#xa;setValue(findName(&quot;PV material intensity switch&quot;), 0);&#xa;setValue(findName(&quot;PV Al intensity tau&quot;), 60);&#xa;setValue(findName(&quot;societal Al intensity inf factor&quot;), 0.9478);&#xa;setValue(findName(&quot;societal Al intensity increase factor&quot;), 1.05);&#xa;setValue(findName(&quot;societal Al intensity tau&quot;), 6);&#xa;setValue(findName(&quot;DAC Al intensity tau&quot;), 50);&#xa;&#xa;runModel();&#xa;" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2323" id="2323">
      <mxCell style="button;fontSize=10;" parent="1478" vertex="1">
        <mxGeometry x="49.1" y="253.75" width="120" height="24" as="geometry" />
      </mxCell>
    </Button>
    <Button name="All-in Energy Limit" Note="" Function="pressButton(findName(&quot;setting base parameters&quot;))&#xa;setValue(findName(&quot;fC_repair&quot;), 0);&#xa;setValue(findName(&quot;CCS switch&quot;), 1);&#xa;setValue(findName(&quot;fC switch&quot;), 1);&#xa;setValue(findName(&quot;fC phase out&quot;), 1);&#xa;setValue(findName(&quot;demand growth switch&quot;), 0);&#xa;setValue(findName(&quot;population confidence selection&quot;), 2);&#xa;setValue(findName(&quot;growth rate&quot;), 0);&#xa;setValue(findName(&quot;P_demand per person aim&quot;), 680);&#xa;setValue(findName(&quot;demand adjustment delay time&quot;), 5);&#xa;setValue(findName(&quot;demand adjustment duration&quot;), 10);&#xa;setValue(findName(&quot;oversize PV&quot;), 1.2);&#xa;setValue(findName(&quot;alpha&quot;), 0.8);&#xa;setValue(findName(&quot;beta in transition&quot;), 1);&#xa;setValue(findName(&quot;beta after transition&quot;), 0.5);&#xa;setValue(findName(&quot;desert potential fraction&quot;), 0);&#xa;setValue(findName(&quot;buildings potential fraction&quot;), 0.85);&#xa;setValue(findName(&quot;PV repair proportional&quot;), 0.5);&#xa;setValue(findName(&quot;PV repair on demand&quot;), 0);&#xa;setValue(findName(&quot;PV repair inverse proportional&quot;), 20);&#xa;setValue(findName(&quot;PV repair increase limit&quot;), 10);&#xa;setValue(findName(&quot;PV repair decrease limit&quot;), -1);&#xa;setValue(findName(&quot;delta in transition&quot;), 0);&#xa;setValue(findName(&quot;delta for growing with demand&quot;), 0.8);&#xa;setValue(findName(&quot;tau_fC_phase_out&quot;), 5);&#xa;setValue(findName(&quot;fC_dep_phase_out&quot;), 0.01);&#xa;setValue(findName(&quot;epsilon in transition&quot;), 0);&#xa;setValue(findName(&quot;epsilon after transition&quot;), 1);&#xa;setValue(findName(&quot;CCS increase limit&quot;), 10);&#xa;setValue(findName(&quot;independence time&quot;), 0.005);&#xa;setValue(findName(&quot;fraction of daily demand stored&quot;), 0.1);&#xa;setValue(findName(&quot;relative weight chemical storage&quot;), 0.1);&#xa;setValue(findName(&quot;relative weight mechanical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight electro-chemical storage&quot;), 0.8);&#xa;setValue(findName(&quot;storage building time constant&quot;), 0.001);&#xa;setValue(findName(&quot;K_P&quot;), 8);&#xa;setValue(findName(&quot;K_I&quot;), 1);&#xa;setValue(findName(&quot;K_D&quot;), 0.001);&#xa;setValue(findName(&quot;gamma&quot;), 0.95);&#xa;setValue(findName(&quot;K_fC drain&quot;), 2);&#xa;setValue(findName(&quot;_PV_alpha decrease limit&quot;), -10);&#xa;setValue(findName(&quot;material supply constrain switch&quot;), 0);&#xa;setValue(findName(&quot;Al prim supply gap correction exponent&quot;), 6);&#xa;setValue(findName(&quot;Al prim CF correction threshold&quot;), 0);&#xa;setValue(findName(&quot;K_p for Al prim CF&quot;), 0.3);&#xa;setValue(findName(&quot;K_i for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;K_d for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;Al CF market factor&quot;), 1);&#xa;setValue(findName(&quot;Al CF market filling factor&quot;), 0.4);&#xa;setValue(findName(&quot;Al market filling exponent&quot;), 1);&#xa;setValue(findName(&quot;Al market shortage correction exponent&quot;), 2);&#xa;setValue(findName(&quot;Al prim construction time&quot;), 0.2);&#xa;setValue(findName(&quot;Al prim min construction time&quot;), 0.1);&#xa;setValue(findName(&quot;Al prim CF building threshold&quot;), 0);&#xa;setValue(findName(&quot;Al prim permitting factor&quot;), 1);&#xa;setValue(findName(&quot;Al capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling construction time&quot;), 0.1);&#xa;setValue(findName(&quot;Al recycling CF building threshold&quot;), 0);&#xa;setValue(findName(&quot;Al sec capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling increase limit&quot;), 10);&#xa;setValue(findName(&quot;Al recycling decrease limit&quot;), -10);&#xa;setValue(findName(&quot;Al recycling permitting factor&quot;), 1);&#xa;setValue(findName(&quot;Al dilution tau&quot;), 1);&#xa;setValue(findName(&quot;Al dilution ratio inf&quot;), 0.01);&#xa;setValue(findName(&quot;PV material intensity switch&quot;), 0);&#xa;setValue(findName(&quot;PV Al intensity tau&quot;), 0.1);&#xa;setValue(findName(&quot;societal Al intensity inf factor&quot;), 0.9478);&#xa;setValue(findName(&quot;societal Al intensity increase factor&quot;), 1.05);&#xa;setValue(findName(&quot;societal Al intensity tau&quot;), 6);&#xa;setValue(findName(&quot;DAC Al intensity tau&quot;), 0.1);&#xa;&#xa;runModel();&#xa;" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2324" id="2324">
      <mxCell style="button;fontSize=10;" parent="1478" vertex="1">
        <mxGeometry x="89.5" y="391.75" width="120" height="24" as="geometry" />
      </mxCell>
    </Button>
    <Button name="Commitment+ base" Note="" Function="pressButton(findName(&quot;setting base parameters&quot;))&#xa;setValue(findName(&quot;fC_repair&quot;), 1);&#xa;setValue(findName(&quot;CCS switch&quot;), 1);&#xa;setValue(findName(&quot;fC switch&quot;), 1);&#xa;setValue(findName(&quot;fC phase out&quot;), 1);&#xa;setValue(findName(&quot;demand growth switch&quot;), 1);&#xa;setValue(findName(&quot;population confidence selection&quot;), 2);&#xa;setValue(findName(&quot;growth rate&quot;), 0.006);&#xa;setValue(findName(&quot;P_demand per person aim&quot;), 680);&#xa;setValue(findName(&quot;demand adjustment delay time&quot;), 5);&#xa;setValue(findName(&quot;demand adjustment duration&quot;), 10);&#xa;setValue(findName(&quot;oversize PV&quot;), 1.1);&#xa;setValue(findName(&quot;alpha&quot;), 0.7);&#xa;setValue(findName(&quot;beta in transition&quot;), 0.6);&#xa;setValue(findName(&quot;beta after transition&quot;), 0.5);&#xa;setValue(findName(&quot;desert potential fraction&quot;), 0.2);&#xa;setValue(findName(&quot;buildings potential fraction&quot;), 0.6);&#xa;setValue(findName(&quot;PV repair proportional&quot;), 0.5);&#xa;setValue(findName(&quot;PV repair on demand&quot;), 0);&#xa;setValue(findName(&quot;PV repair inverse proportional&quot;), 20);&#xa;setValue(findName(&quot;PV repair increase limit&quot;), 0.15);&#xa;setValue(findName(&quot;PV repair decrease limit&quot;), -10);&#xa;setValue(findName(&quot;delta in transition&quot;), 0);&#xa;setValue(findName(&quot;delta for growing with demand&quot;), 0.8);&#xa;setValue(findName(&quot;tau_fC_phase_out&quot;), 10);&#xa;setValue(findName(&quot;fC_dep_phase_out&quot;), 0.01);&#xa;setValue(findName(&quot;epsilon in transition&quot;), 0.5);&#xa;setValue(findName(&quot;epsilon after transition&quot;), 1);&#xa;setValue(findName(&quot;CCS increase limit&quot;), 0.01);&#xa;setValue(findName(&quot;independence time&quot;), 0.035);&#xa;setValue(findName(&quot;fraction of daily demand stored&quot;), 0.3);&#xa;setValue(findName(&quot;relative weight chemical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight mechanical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight electro-chemical storage&quot;), 0.6);&#xa;setValue(findName(&quot;storage building time constant&quot;), 0.003);&#xa;setValue(findName(&quot;K_P&quot;), 8);&#xa;setValue(findName(&quot;K_I&quot;), 1);&#xa;setValue(findName(&quot;K_D&quot;), 0.001);&#xa;setValue(findName(&quot;gamma&quot;), 0.95);&#xa;setValue(findName(&quot;K_fC drain&quot;), 0.1);&#xa;setValue(findName(&quot;_PV_alpha decrease limit&quot;), -0.4);&#xa;setValue(findName(&quot;material supply constrain switch&quot;), 1);&#xa;setValue(findName(&quot;Al prim supply gap correction exponent&quot;), 6);&#xa;setValue(findName(&quot;Al prim CF correction threshold&quot;), 0);&#xa;setValue(findName(&quot;K_p for Al prim CF&quot;), 0.4);&#xa;setValue(findName(&quot;K_i for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;K_d for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;Al CF market factor&quot;), 0.6);&#xa;setValue(findName(&quot;Al CF market filling factor&quot;), 0.3);&#xa;setValue(findName(&quot;Al market filling exponent&quot;), 2);&#xa;setValue(findName(&quot;Al market shortage correction exponent&quot;), 5);&#xa;setValue(findName(&quot;Al prim construction time&quot;), 7);&#xa;setValue(findName(&quot;Al prim min construction time&quot;), 3);&#xa;setValue(findName(&quot;Al prim CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al prim permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling construction time&quot;), 2);&#xa;setValue(findName(&quot;Al recycling CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al sec capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling increase limit&quot;), 1);&#xa;setValue(findName(&quot;Al recycling decrease limit&quot;), -1);&#xa;setValue(findName(&quot;Al recycling permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al dilution tau&quot;), 50);&#xa;setValue(findName(&quot;Al dilution ratio inf&quot;), 0.5);&#xa;setValue(findName(&quot;PV material intensity switch&quot;), 0);&#xa;setValue(findName(&quot;PV Al intensity tau&quot;), 60);&#xa;setValue(findName(&quot;societal Al intensity inf factor&quot;), 0.9478);&#xa;setValue(findName(&quot;societal Al intensity increase factor&quot;), 1.404);&#xa;setValue(findName(&quot;societal Al intensity tau&quot;), 12);&#xa;setValue(findName(&quot;DAC Al intensity tau&quot;), 50);&#xa;&#xa;runModel();&#xa;" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2325" id="2325">
      <mxCell style="button;fontSize=10;" parent="1478" vertex="1">
        <mxGeometry x="49.75" y="81.75" width="120" height="24" as="geometry" />
      </mxCell>
    </Button>
    <Button name="Commitment+ advanced" Note="" Function="pressButton(findName(&quot;setting base parameters&quot;))&#xa;setValue(findName(&quot;fC_repair&quot;), 1);&#xa;setValue(findName(&quot;CCS switch&quot;), 1);&#xa;setValue(findName(&quot;fC switch&quot;), 1);&#xa;setValue(findName(&quot;fC phase out&quot;), 1);&#xa;setValue(findName(&quot;demand growth switch&quot;), 1);&#xa;setValue(findName(&quot;population confidence selection&quot;), 2);&#xa;setValue(findName(&quot;growth rate&quot;), 0.006);&#xa;setValue(findName(&quot;P_demand per person aim&quot;), 680);&#xa;setValue(findName(&quot;demand adjustment delay time&quot;), 5);&#xa;setValue(findName(&quot;demand adjustment duration&quot;), 10);&#xa;setValue(findName(&quot;oversize PV&quot;), 1.1);&#xa;setValue(findName(&quot;alpha&quot;), 0.7);&#xa;setValue(findName(&quot;beta in transition&quot;), 0.6);&#xa;setValue(findName(&quot;beta after transition&quot;), 0.5);&#xa;setValue(findName(&quot;desert potential fraction&quot;), 0.2);&#xa;setValue(findName(&quot;buildings potential fraction&quot;), 0.6);&#xa;setValue(findName(&quot;PV repair proportional&quot;), 0.5);&#xa;setValue(findName(&quot;PV repair on demand&quot;), 0);&#xa;setValue(findName(&quot;PV repair inverse proportional&quot;), 20);&#xa;setValue(findName(&quot;PV repair increase limit&quot;), 0.4);&#xa;setValue(findName(&quot;PV repair decrease limit&quot;), -10);&#xa;setValue(findName(&quot;delta in transition&quot;), 0);&#xa;setValue(findName(&quot;delta for growing with demand&quot;), 0.8);&#xa;setValue(findName(&quot;tau_fC_phase_out&quot;), 10);&#xa;setValue(findName(&quot;fC_dep_phase_out&quot;), 0.01);&#xa;setValue(findName(&quot;epsilon in transition&quot;), 0.5);&#xa;setValue(findName(&quot;epsilon after transition&quot;), 1);&#xa;setValue(findName(&quot;CCS increase limit&quot;), 0.01);&#xa;setValue(findName(&quot;independence time&quot;), 0.035);&#xa;setValue(findName(&quot;fraction of daily demand stored&quot;), 0.3);&#xa;setValue(findName(&quot;relative weight chemical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight mechanical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight electro-chemical storage&quot;), 0.6);&#xa;setValue(findName(&quot;storage building time constant&quot;), 0.003);&#xa;setValue(findName(&quot;K_P&quot;), 8);&#xa;setValue(findName(&quot;K_I&quot;), 1);&#xa;setValue(findName(&quot;K_D&quot;), 0.001);&#xa;setValue(findName(&quot;gamma&quot;), 0.95);&#xa;setValue(findName(&quot;K_fC drain&quot;), 0.1);&#xa;setValue(findName(&quot;_PV_alpha decrease limit&quot;), -2);&#xa;setValue(findName(&quot;material supply constrain switch&quot;), 1);&#xa;setValue(findName(&quot;Al prim supply gap correction exponent&quot;), 6);&#xa;setValue(findName(&quot;Al prim CF correction threshold&quot;), 0);&#xa;setValue(findName(&quot;K_p for Al prim CF&quot;), 0.3);&#xa;setValue(findName(&quot;K_i for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;K_d for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;Al CF market factor&quot;), 0.6);&#xa;setValue(findName(&quot;Al CF market filling factor&quot;), 0.4);&#xa;setValue(findName(&quot;Al market filling exponent&quot;), 2);&#xa;setValue(findName(&quot;Al market shortage correction exponent&quot;), 1);&#xa;setValue(findName(&quot;Al prim construction time&quot;), 5);&#xa;setValue(findName(&quot;Al prim min construction time&quot;), 2.5);&#xa;setValue(findName(&quot;Al prim CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al prim permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling construction time&quot;), 1);&#xa;setValue(findName(&quot;Al recycling CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al sec capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling increase limit&quot;), 1);&#xa;setValue(findName(&quot;Al recycling decrease limit&quot;), -1);&#xa;setValue(findName(&quot;Al recycling permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al dilution tau&quot;), 10);&#xa;setValue(findName(&quot;Al dilution ratio inf&quot;), 0.1);&#xa;setValue(findName(&quot;PV material intensity switch&quot;), 1);&#xa;setValue(findName(&quot;PV Al intensity tau&quot;), 5);&#xa;setValue(findName(&quot;societal Al intensity inf factor&quot;), 0.9478);&#xa;setValue(findName(&quot;societal Al intensity increase factor&quot;), 1.404);&#xa;setValue(findName(&quot;societal Al intensity tau&quot;), 12);&#xa;setValue(findName(&quot;DAC Al intensity tau&quot;), 30);&#xa;&#xa;runModel();&#xa;" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2456" id="2456">
      <mxCell style="button;fontSize=10;" parent="1478" vertex="1">
        <mxGeometry x="49.1" y="173.88" width="120" height="24" as="geometry" />
      </mxCell>
    </Button>
    <Button name="Commitment+ Energy Limit" Note="" Function="pressButton(findName(&quot;setting base parameters&quot;))&#xa;setValue(findName(&quot;fC_repair&quot;), 1);&#xa;setValue(findName(&quot;CCS switch&quot;), 1);&#xa;setValue(findName(&quot;fC switch&quot;), 1);&#xa;setValue(findName(&quot;fC phase out&quot;), 1);&#xa;setValue(findName(&quot;demand growth switch&quot;), 1);&#xa;setValue(findName(&quot;population confidence selection&quot;), 2);&#xa;setValue(findName(&quot;growth rate&quot;), 0.006);&#xa;setValue(findName(&quot;P_demand per person aim&quot;), 680);&#xa;setValue(findName(&quot;demand adjustment delay time&quot;), 5);&#xa;setValue(findName(&quot;demand adjustment duration&quot;), 10);&#xa;setValue(findName(&quot;oversize PV&quot;), 1.1);&#xa;setValue(findName(&quot;alpha&quot;), 0.7);&#xa;setValue(findName(&quot;beta in transition&quot;), 0.6);&#xa;setValue(findName(&quot;beta after transition&quot;), 0.5);&#xa;setValue(findName(&quot;desert potential fraction&quot;), 0.2);&#xa;setValue(findName(&quot;buildings potential fraction&quot;), 0.6);&#xa;setValue(findName(&quot;PV repair proportional&quot;), 0.5);&#xa;setValue(findName(&quot;PV repair on demand&quot;), 0);&#xa;setValue(findName(&quot;PV repair inverse proportional&quot;), 20);&#xa;setValue(findName(&quot;PV repair increase limit&quot;), 10);&#xa;setValue(findName(&quot;PV repair decrease limit&quot;), -10);&#xa;setValue(findName(&quot;delta in transition&quot;), 0);&#xa;setValue(findName(&quot;delta for growing with demand&quot;), 0.8);&#xa;setValue(findName(&quot;tau_fC_phase_out&quot;), 10);&#xa;setValue(findName(&quot;fC_dep_phase_out&quot;), 0.01);&#xa;setValue(findName(&quot;epsilon in transition&quot;), 0.5);&#xa;setValue(findName(&quot;epsilon after transition&quot;), 1);&#xa;setValue(findName(&quot;CCS increase limit&quot;), 10);&#xa;setValue(findName(&quot;independence time&quot;), 0.035);&#xa;setValue(findName(&quot;fraction of daily demand stored&quot;), 0.3);&#xa;setValue(findName(&quot;relative weight chemical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight mechanical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight electro-chemical storage&quot;), 0.6);&#xa;setValue(findName(&quot;storage building time constant&quot;), 0.003);&#xa;setValue(findName(&quot;K_P&quot;), 8);&#xa;setValue(findName(&quot;K_I&quot;), 1);&#xa;setValue(findName(&quot;K_D&quot;), 0.001);&#xa;setValue(findName(&quot;gamma&quot;), 0.95);&#xa;setValue(findName(&quot;K_fC drain&quot;), 0.1);&#xa;setValue(findName(&quot;_PV_alpha decrease limit&quot;), -10);&#xa;setValue(findName(&quot;material supply constrain switch&quot;), 0);&#xa;setValue(findName(&quot;Al prim supply gap correction exponent&quot;), 6);&#xa;setValue(findName(&quot;Al prim CF correction threshold&quot;), 0);&#xa;setValue(findName(&quot;K_p for Al prim CF&quot;), 0.3);&#xa;setValue(findName(&quot;K_i for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;K_d for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;Al CF market factor&quot;), 0.6);&#xa;setValue(findName(&quot;Al CF market filling factor&quot;), 0.4);&#xa;setValue(findName(&quot;Al market filling exponent&quot;), 3);&#xa;setValue(findName(&quot;Al market shortage correction exponent&quot;), 2);&#xa;setValue(findName(&quot;Al prim construction time&quot;), 0.2);&#xa;setValue(findName(&quot;Al prim min construction time&quot;), 0.1);&#xa;setValue(findName(&quot;Al prim CF building threshold&quot;), 0);&#xa;setValue(findName(&quot;Al prim permitting factor&quot;), 1);&#xa;setValue(findName(&quot;Al capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling construction time&quot;), 1);&#xa;setValue(findName(&quot;Al recycling CF building threshold&quot;), 0);&#xa;setValue(findName(&quot;Al sec capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling increase limit&quot;), 1);&#xa;setValue(findName(&quot;Al recycling decrease limit&quot;), -1);&#xa;setValue(findName(&quot;Al recycling permitting factor&quot;), 1);&#xa;setValue(findName(&quot;Al dilution tau&quot;), 1);&#xa;setValue(findName(&quot;Al dilution ratio inf&quot;), 0.01);&#xa;setValue(findName(&quot;PV material intensity switch&quot;), 0);&#xa;setValue(findName(&quot;PV Al intensity tau&quot;), 60);&#xa;setValue(findName(&quot;societal Al intensity inf factor&quot;), 0.9478);&#xa;setValue(findName(&quot;societal Al intensity increase factor&quot;), 1.404);&#xa;setValue(findName(&quot;societal Al intensity tau&quot;), 12);&#xa;setValue(findName(&quot;DAC Al intensity tau&quot;), 0.1);&#xa;&#xa;runModel();&#xa;" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2457" id="2457">
      <mxCell style="button;fontSize=10;" parent="1478" vertex="1">
        <mxGeometry x="89.5" y="213.75" width="120" height="24" as="geometry" />
      </mxCell>
    </Button>
    <Button name="setting base parameters" Note="" Function="setValue(findName(&quot;Al in ground&quot;), 75);&#xa;setValue(findName(&quot;Al in-use 2026&quot;), 1.485);&#xa;setValue(findName(&quot;Al in fossil 2026&quot;), 0.163);&#xa;setValue(findName(&quot;Al market stock 0&quot;), 0.01);&#xa;setValue(findName(&quot;Al market filling target&quot;), 0.02);&#xa;setValue(findName(&quot;Al waste&quot;), 0.5);&#xa;setValue(findName(&quot;Al dilution ratio 0&quot;), 1.54);&#xa;setValue(findName(&quot;AL prim CF 2&quot;), 0.88);&#xa;setValue(findName(&quot;Al old prim capacity 0&quot;), 0.0798409090909091);&#xa;setValue(findName(&quot;Al old prim cap lifetime&quot;), 45);&#xa;setValue(findName(&quot;Al prim cap min lifetime&quot;), 10);&#xa;setValue(findName(&quot;Al prim cap lifetime&quot;), 45);&#xa;setValue(findName(&quot;Al old recycling capacity 0 &quot;), 0.055);&#xa;setValue(findName(&quot;Al old sec cap lifetime&quot;), 25);&#xa;setValue(findName(&quot;Al sec cap min lifetime&quot;), 10);&#xa;setValue(findName(&quot;Al sec cap lifetime&quot;), 25);&#xa;setValue(findName(&quot;AL sec production 2026&quot;), 0.046);&#xa;setValue(findName(&quot;Al max RR EoL scrap&quot;), 0.8);&#xa;setValue(findName(&quot;Al max RR manufacturing scrap&quot;), 0.99);&#xa;setValue(findName(&quot;manufacturing scarp fraction&quot;), 0.178);&#xa;setValue(findName(&quot;EI_Al prim cap construction&quot;), 0.000978);&#xa;setValue(findName(&quot;EI_Al prim prod new&quot;), 1.73650721220879);&#xa;setValue(findName(&quot;EI_Al prim prod old&quot;), 2.12310188353994);&#xa;setValue(findName(&quot;EI_Al sec cap construction&quot;), 0.000614);&#xa;setValue(findName(&quot;EI_Al sec prod new&quot;), 0.31688087814029);&#xa;setValue(findName(&quot;EI_Al sec prod old&quot;), 0.31688087814029);&#xa;setValue(findName(&quot;Al energy intensity 0&quot;), 1.40844364985351);&#xa;setValue(findName(&quot;EI_Al prim increase factor at CF=1&quot;), 1.2);&#xa;setValue(findName(&quot;EI_Al prim increase factor at CF=0&quot;), 1.1);&#xa;setValue(findName(&quot;Al prim CF_opt&quot;), 0.8);&#xa;setValue(findName(&quot;energy intensity of primary steel production&quot;), 0.333358683803585);&#xa;setValue(findName(&quot;energy intensity of solar glass production&quot;), 0.162559890485969);&#xa;setValue(findName(&quot;P_demand per person in 2026&quot;), 948);&#xa;setValue(findName(&quot;gobal population 2026&quot;), 8300000000);&#xa;setValue(findName(&quot;P_RE_2026&quot;), 1.623);&#xa;setValue(findName(&quot;Al demand 0&quot;), 0.0987);&#xa;setValue(findName(&quot;Al lifetime&quot;), 23);&#xa;setValue(findName(&quot;fC_EPBT&quot;), 3);&#xa;setValue(findName(&quot;E_fC&quot;), 26.63);&#xa;setValue(findName(&quot;T_LfC&quot;), 30);&#xa;setValue(findName(&quot;T_LfC_min&quot;), 25);&#xa;setValue(findName(&quot;fossil Al intensity&quot;), 0.006121);&#xa;setValue(findName(&quot;EIT_DAC 0&quot;), 0.116);&#xa;setValue(findName(&quot;T_resCCS&quot;), 25);&#xa;setValue(findName(&quot;T_resCCS_min&quot;), 20);&#xa;setValue(findName(&quot;DAC energy intensity&quot;), 0.15844);&#xa;setValue(findName(&quot;DAC Al intensity 0&quot;), 0.010098);&#xa;setValue(findName(&quot;DAC Al intensity inf&quot;), 0.000316);&#xa;setValue(findName(&quot;EPBT_PV 0&quot;), 1.5);&#xa;setValue(findName(&quot;PV Al intensity framed&quot;), 0.164740013166557);&#xa;setValue(findName(&quot;PV Al intensity frameless&quot;), 0.00700202764976959);&#xa;setValue(findName(&quot;PV steel intensity framed&quot;), 0.060709888084266);&#xa;setValue(findName(&quot;PV steel intensity frameless&quot;), 0.0873329822251481);&#xa;setValue(findName(&quot;PV glass intensity framed&quot;), 0.307781435154707);&#xa;setValue(findName(&quot;PV glass intensity frameless&quot;), 0.384726793943384);&#xa;setValue(findName(&quot;T_resPV&quot;), 30);&#xa;setValue(findName(&quot;T_resPV_min&quot;), 25);&#xa;setValue(findName(&quot;CO2_inAtm&amp;UpperOcean&quot;), 2682);&#xa;setValue(findName(&quot;natural leak&quot;), 0.8);&#xa;setValue(findName(&quot;fC emission intensity&quot;), 5.64);&#xa;setValue(findName(&quot;post combustion CCS energy intensity&quot;), 0.06);&#xa;setValue(findName(&quot;Al CO2 intensity&quot;), 3);&#xa;setValue(findName(&quot;TCRE 50&quot;), 0.45);&#xa;setValue(findName(&quot;T_res storage&quot;), 30);&#xa;setValue(findName(&quot;T_res storage_min&quot;), 15);&#xa;setValue(findName(&quot;maximum fraction of power stored for seasonal variations&quot;), 0.2);&#xa;setValue(findName(&quot;roundtrip efficiency electro-chemical storage&quot;), 0.94);&#xa;setValue(findName(&quot;roundtrip efficiency mechanical storage&quot;), 0.75);&#xa;setValue(findName(&quot;roundtrip efficiency chemical storage&quot;), 0.21);&#xa;setValue(findName(&quot;output efficiency electro-chemical storage&quot;), 0.97);&#xa;setValue(findName(&quot;output efficiency mechanical storage&quot;), 0.9);&#xa;setValue(findName(&quot;output efficiency chemical storage&quot;), 0.4);&#xa;setValue(findName(&quot;energy intensity electro-chemical storage&quot;), 300);&#xa;setValue(findName(&quot;energy intensity mechanical storage&quot;), 85);&#xa;setValue(findName(&quot;energy intensity chemical storage&quot;), 63);&#xa;setValue(findName(&quot;Al intensity electro-chemical storage&quot;), 16.25);&#xa;setValue(findName(&quot;Al intensity mechanical storage&quot;), 0.004);&#xa;setValue(findName(&quot;Al intensity chemical storage&quot;), 0.02);&#xa;&#xa;&#xa;&#xa;&#xa;&#xa;&#xa;&#xa;&#xa;" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2544" id="2544">
      <mxCell style="button;fontSize=10;" parent="1478" vertex="1">
        <mxGeometry x="29.5" y="41.75" width="120" height="24" as="geometry" />
      </mxCell>
    </Button>
    <Button name="Commitment+ base Al substitution in PV" Note="" Function="pressButton(findName(&quot;setting base parameters&quot;))&#xa;setValue(findName(&quot;fC_repair&quot;), 1);&#xa;setValue(findName(&quot;CCS switch&quot;), 1);&#xa;setValue(findName(&quot;fC switch&quot;), 1);&#xa;setValue(findName(&quot;fC phase out&quot;), 1);&#xa;setValue(findName(&quot;demand growth switch&quot;), 1);&#xa;setValue(findName(&quot;population confidence selection&quot;), 2);&#xa;setValue(findName(&quot;growth rate&quot;), 0.006);&#xa;setValue(findName(&quot;P_demand per person aim&quot;), 680);&#xa;setValue(findName(&quot;demand adjustment delay time&quot;), 5);&#xa;setValue(findName(&quot;demand adjustment duration&quot;), 10);&#xa;setValue(findName(&quot;oversize PV&quot;), 1.1);&#xa;setValue(findName(&quot;alpha&quot;), 0.7);&#xa;setValue(findName(&quot;beta in transition&quot;), 0.6);&#xa;setValue(findName(&quot;beta after transition&quot;), 0.5);&#xa;setValue(findName(&quot;desert potential fraction&quot;), 0.2);&#xa;setValue(findName(&quot;buildings potential fraction&quot;), 0.6);&#xa;setValue(findName(&quot;PV repair proportional&quot;), 0.5);&#xa;setValue(findName(&quot;PV repair on demand&quot;), 0);&#xa;setValue(findName(&quot;PV repair inverse proportional&quot;), 20);&#xa;setValue(findName(&quot;PV repair increase limit&quot;), 0.15);&#xa;setValue(findName(&quot;PV repair decrease limit&quot;), -10);&#xa;setValue(findName(&quot;delta in transition&quot;), 0);&#xa;setValue(findName(&quot;delta for growing with demand&quot;), 0.8);&#xa;setValue(findName(&quot;tau_fC_phase_out&quot;), 10);&#xa;setValue(findName(&quot;fC_dep_phase_out&quot;), 0.01);&#xa;setValue(findName(&quot;epsilon in transition&quot;), 0.5);&#xa;setValue(findName(&quot;epsilon after transition&quot;), 1);&#xa;setValue(findName(&quot;CCS increase limit&quot;), 0.01);&#xa;setValue(findName(&quot;independence time&quot;), 0.035);&#xa;setValue(findName(&quot;fraction of daily demand stored&quot;), 0.3);&#xa;setValue(findName(&quot;relative weight chemical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight mechanical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight electro-chemical storage&quot;), 0.6);&#xa;setValue(findName(&quot;storage building time constant&quot;), 0.003);&#xa;setValue(findName(&quot;K_P&quot;), 8);&#xa;setValue(findName(&quot;K_I&quot;), 1);&#xa;setValue(findName(&quot;K_D&quot;), 0.001);&#xa;setValue(findName(&quot;gamma&quot;), 0.95);&#xa;setValue(findName(&quot;K_fC drain&quot;), 0.1);&#xa;setValue(findName(&quot;_PV_alpha decrease limit&quot;), -0.4);&#xa;setValue(findName(&quot;material supply constrain switch&quot;), 1);&#xa;setValue(findName(&quot;Al prim supply gap correction exponent&quot;), 6);&#xa;setValue(findName(&quot;Al prim CF correction threshold&quot;), 0);&#xa;setValue(findName(&quot;K_p for Al prim CF&quot;), 0.4);&#xa;setValue(findName(&quot;K_i for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;K_d for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;Al CF market factor&quot;), 0.6);&#xa;setValue(findName(&quot;Al CF market filling factor&quot;), 0.3);&#xa;setValue(findName(&quot;Al market filling exponent&quot;), 2);&#xa;setValue(findName(&quot;Al market shortage correction exponent&quot;), 5);&#xa;setValue(findName(&quot;Al prim construction time&quot;), 7);&#xa;setValue(findName(&quot;Al prim min construction time&quot;), 3);&#xa;setValue(findName(&quot;Al prim CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al prim permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling construction time&quot;), 2);&#xa;setValue(findName(&quot;Al recycling CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al sec capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling increase limit&quot;), 1);&#xa;setValue(findName(&quot;Al recycling decrease limit&quot;), -1);&#xa;setValue(findName(&quot;Al recycling permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al dilution tau&quot;), 50);&#xa;setValue(findName(&quot;Al dilution ratio inf&quot;), 0.5);&#xa;setValue(findName(&quot;PV material intensity switch&quot;), 1);&#xa;setValue(findName(&quot;PV Al intensity tau&quot;), 5);&#xa;setValue(findName(&quot;societal Al intensity inf factor&quot;), 0.9478);&#xa;setValue(findName(&quot;societal Al intensity increase factor&quot;), 1.404);&#xa;setValue(findName(&quot;societal Al intensity tau&quot;), 12);&#xa;setValue(findName(&quot;DAC Al intensity tau&quot;), 50);&#xa;&#xa;runModel();&#xa;" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2657" id="2657">
      <mxCell style="button;fontSize=10;" parent="1478" vertex="1">
        <mxGeometry x="89.5" y="113.75" width="120" height="24" as="geometry" />
      </mxCell>
    </Button>
    <Button name="Commitment+ advanced no Al substitution in PV" Note="" Function="pressButton(findName(&quot;setting base parameters&quot;))&#xa;setValue(findName(&quot;fC_repair&quot;), 1);&#xa;setValue(findName(&quot;CCS switch&quot;), 1);&#xa;setValue(findName(&quot;fC switch&quot;), 1);&#xa;setValue(findName(&quot;fC phase out&quot;), 1);&#xa;setValue(findName(&quot;demand growth switch&quot;), 1);&#xa;setValue(findName(&quot;population confidence selection&quot;), 2);&#xa;setValue(findName(&quot;growth rate&quot;), 0.006);&#xa;setValue(findName(&quot;P_demand per person aim&quot;), 680);&#xa;setValue(findName(&quot;demand adjustment delay time&quot;), 5);&#xa;setValue(findName(&quot;demand adjustment duration&quot;), 10);&#xa;setValue(findName(&quot;oversize PV&quot;), 1.1);&#xa;setValue(findName(&quot;alpha&quot;), 0.7);&#xa;setValue(findName(&quot;beta in transition&quot;), 0.6);&#xa;setValue(findName(&quot;beta after transition&quot;), 0.5);&#xa;setValue(findName(&quot;desert potential fraction&quot;), 0.2);&#xa;setValue(findName(&quot;buildings potential fraction&quot;), 0.6);&#xa;setValue(findName(&quot;PV repair proportional&quot;), 0.5);&#xa;setValue(findName(&quot;PV repair on demand&quot;), 0);&#xa;setValue(findName(&quot;PV repair inverse proportional&quot;), 20);&#xa;setValue(findName(&quot;PV repair increase limit&quot;), 0.4);&#xa;setValue(findName(&quot;PV repair decrease limit&quot;), -10);&#xa;setValue(findName(&quot;delta in transition&quot;), 0);&#xa;setValue(findName(&quot;delta for growing with demand&quot;), 0.8);&#xa;setValue(findName(&quot;tau_fC_phase_out&quot;), 10);&#xa;setValue(findName(&quot;fC_dep_phase_out&quot;), 0.01);&#xa;setValue(findName(&quot;epsilon in transition&quot;), 0.5);&#xa;setValue(findName(&quot;epsilon after transition&quot;), 1);&#xa;setValue(findName(&quot;CCS increase limit&quot;), 0.01);&#xa;setValue(findName(&quot;independence time&quot;), 0.035);&#xa;setValue(findName(&quot;fraction of daily demand stored&quot;), 0.3);&#xa;setValue(findName(&quot;relative weight chemical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight mechanical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight electro-chemical storage&quot;), 0.6);&#xa;setValue(findName(&quot;storage building time constant&quot;), 0.003);&#xa;setValue(findName(&quot;K_P&quot;), 8);&#xa;setValue(findName(&quot;K_I&quot;), 1);&#xa;setValue(findName(&quot;K_D&quot;), 0.001);&#xa;setValue(findName(&quot;gamma&quot;), 0.95);&#xa;setValue(findName(&quot;K_fC drain&quot;), 0.1);&#xa;setValue(findName(&quot;_PV_alpha decrease limit&quot;), -2);&#xa;setValue(findName(&quot;material supply constrain switch&quot;), 1);&#xa;setValue(findName(&quot;Al prim supply gap correction exponent&quot;), 6);&#xa;setValue(findName(&quot;Al prim CF correction threshold&quot;), 0);&#xa;setValue(findName(&quot;K_p for Al prim CF&quot;), 0.3);&#xa;setValue(findName(&quot;K_i for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;K_d for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;Al CF market factor&quot;), 0.6);&#xa;setValue(findName(&quot;Al CF market filling factor&quot;), 0.4);&#xa;setValue(findName(&quot;Al market filling exponent&quot;), 2);&#xa;setValue(findName(&quot;Al market shortage correction exponent&quot;), 1);&#xa;setValue(findName(&quot;Al prim construction time&quot;), 5);&#xa;setValue(findName(&quot;Al prim min construction time&quot;), 2.5);&#xa;setValue(findName(&quot;Al prim CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al prim permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling construction time&quot;), 1);&#xa;setValue(findName(&quot;Al recycling CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al sec capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling increase limit&quot;), 1);&#xa;setValue(findName(&quot;Al recycling decrease limit&quot;), -1);&#xa;setValue(findName(&quot;Al recycling permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al dilution tau&quot;), 10);&#xa;setValue(findName(&quot;Al dilution ratio inf&quot;), 0.1);&#xa;setValue(findName(&quot;PV material intensity switch&quot;), 0);&#xa;setValue(findName(&quot;PV Al intensity tau&quot;), 60);&#xa;setValue(findName(&quot;societal Al intensity inf factor&quot;), 0.9478);&#xa;setValue(findName(&quot;societal Al intensity increase factor&quot;), 1.404);&#xa;setValue(findName(&quot;societal Al intensity tau&quot;), 12);&#xa;setValue(findName(&quot;DAC Al intensity tau&quot;), 30);&#xa;&#xa;runModel();&#xa;" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2658" id="2658">
      <mxCell style="button;fontSize=10;" parent="1478" vertex="1">
        <mxGeometry x="89.5" y="143.75" width="120" height="24" as="geometry" />
      </mxCell>
    </Button>
    <Button name="All-in base Al substituion in PV" Note="" Function="pressButton(findName(&quot;setting base parameters&quot;))&#xa;setValue(findName(&quot;fC_repair&quot;), 0);&#xa;setValue(findName(&quot;CCS switch&quot;), 1);&#xa;setValue(findName(&quot;fC switch&quot;), 1);&#xa;setValue(findName(&quot;fC phase out&quot;), 1);&#xa;setValue(findName(&quot;demand growth switch&quot;), 0);&#xa;setValue(findName(&quot;population confidence selection&quot;), 2);&#xa;setValue(findName(&quot;growth rate&quot;), 0);&#xa;setValue(findName(&quot;P_demand per person aim&quot;), 680);&#xa;setValue(findName(&quot;demand adjustment delay time&quot;), 5);&#xa;setValue(findName(&quot;demand adjustment duration&quot;), 10);&#xa;setValue(findName(&quot;oversize PV&quot;), 1.2);&#xa;setValue(findName(&quot;alpha&quot;), 0.8);&#xa;setValue(findName(&quot;beta in transition&quot;), 1);&#xa;setValue(findName(&quot;beta after transition&quot;), 0.5);&#xa;setValue(findName(&quot;desert potential fraction&quot;), 0);&#xa;setValue(findName(&quot;buildings potential fraction&quot;), 0.85);&#xa;setValue(findName(&quot;PV repair proportional&quot;), 0.5);&#xa;setValue(findName(&quot;PV repair on demand&quot;), 0);&#xa;setValue(findName(&quot;PV repair inverse proportional&quot;), 20);&#xa;setValue(findName(&quot;PV repair increase limit&quot;), 0.5);&#xa;setValue(findName(&quot;PV repair decrease limit&quot;), -1);&#xa;setValue(findName(&quot;delta in transition&quot;), 0);&#xa;setValue(findName(&quot;delta for growing with demand&quot;), 0.8);&#xa;setValue(findName(&quot;tau_fC_phase_out&quot;), 10);&#xa;setValue(findName(&quot;fC_dep_phase_out&quot;), 0.02);&#xa;setValue(findName(&quot;epsilon in transition&quot;), 0);&#xa;setValue(findName(&quot;epsilon after transition&quot;), 1);&#xa;setValue(findName(&quot;CCS increase limit&quot;), 0.1);&#xa;setValue(findName(&quot;independence time&quot;), 0.005);&#xa;setValue(findName(&quot;fraction of daily demand stored&quot;), 0.1);&#xa;setValue(findName(&quot;relative weight chemical storage&quot;), 0.1);&#xa;setValue(findName(&quot;relative weight mechanical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight electro-chemical storage&quot;), 0.8);&#xa;setValue(findName(&quot;storage building time constant&quot;), 0.001);&#xa;setValue(findName(&quot;K_P&quot;), 8);&#xa;setValue(findName(&quot;K_I&quot;), 1);&#xa;setValue(findName(&quot;K_D&quot;), 0.001);&#xa;setValue(findName(&quot;gamma&quot;), 0.95);&#xa;setValue(findName(&quot;K_fC drain&quot;), 2);&#xa;setValue(findName(&quot;_PV_alpha decrease limit&quot;), -0.5);&#xa;setValue(findName(&quot;material supply constrain switch&quot;), 1);&#xa;setValue(findName(&quot;Al prim supply gap correction exponent&quot;), 4);&#xa;setValue(findName(&quot;Al prim CF correction threshold&quot;), 0);&#xa;setValue(findName(&quot;K_p for Al prim CF&quot;), 0.4);&#xa;setValue(findName(&quot;K_i for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;K_d for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;Al CF market factor&quot;), 0.3);&#xa;setValue(findName(&quot;Al CF market filling factor&quot;), 0.7);&#xa;setValue(findName(&quot;Al market filling exponent&quot;), 3);&#xa;setValue(findName(&quot;Al market shortage correction exponent&quot;), 2);&#xa;setValue(findName(&quot;Al prim construction time&quot;), 7);&#xa;setValue(findName(&quot;Al prim min construction time&quot;), 3);&#xa;setValue(findName(&quot;Al prim CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al prim permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling construction time&quot;), 2);&#xa;setValue(findName(&quot;Al recycling CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al sec capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling increase limit&quot;), 1);&#xa;setValue(findName(&quot;Al recycling decrease limit&quot;), -1);&#xa;setValue(findName(&quot;Al recycling permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al dilution tau&quot;), 50);&#xa;setValue(findName(&quot;Al dilution ratio inf&quot;), 0.5);&#xa;setValue(findName(&quot;PV material intensity switch&quot;), 2);&#xa;setValue(findName(&quot;PV Al intensity tau&quot;), 5);&#xa;setValue(findName(&quot;societal Al intensity inf factor&quot;), 0.9478);&#xa;setValue(findName(&quot;societal Al intensity increase factor&quot;), 1.05);&#xa;setValue(findName(&quot;societal Al intensity tau&quot;), 6);&#xa;setValue(findName(&quot;DAC Al intensity tau&quot;), 50);&#xa;&#xa;runModel();&#xa;" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2659" id="2659">
      <mxCell style="button;fontSize=10;" parent="1478" vertex="1">
        <mxGeometry x="99.5" y="283.75" width="120" height="24" as="geometry" />
      </mxCell>
    </Button>
    <Button name="All-in advanced no Al substitution in PV" Note="" Function="pressButton(findName(&quot;setting base parameters&quot;))&#xa;setValue(findName(&quot;fC_repair&quot;), 0);&#xa;setValue(findName(&quot;CCS switch&quot;), 1);&#xa;setValue(findName(&quot;fC switch&quot;), 1);&#xa;setValue(findName(&quot;fC phase out&quot;), 1);&#xa;setValue(findName(&quot;demand growth switch&quot;), 0);&#xa;setValue(findName(&quot;population confidence selection&quot;), 2);&#xa;setValue(findName(&quot;growth rate&quot;), 0);&#xa;setValue(findName(&quot;P_demand per person aim&quot;), 680);&#xa;setValue(findName(&quot;demand adjustment delay time&quot;), 5);&#xa;setValue(findName(&quot;demand adjustment duration&quot;), 10);&#xa;setValue(findName(&quot;oversize PV&quot;), 1.2);&#xa;setValue(findName(&quot;alpha&quot;), 0.8);&#xa;setValue(findName(&quot;beta in transition&quot;), 1);&#xa;setValue(findName(&quot;beta after transition&quot;), 0.5);&#xa;setValue(findName(&quot;desert potential fraction&quot;), 0);&#xa;setValue(findName(&quot;buildings potential fraction&quot;), 0.85);&#xa;setValue(findName(&quot;PV repair proportional&quot;), 0.5);&#xa;setValue(findName(&quot;PV repair on demand&quot;), 0);&#xa;setValue(findName(&quot;PV repair inverse proportional&quot;), 20);&#xa;setValue(findName(&quot;PV repair increase limit&quot;), 2);&#xa;setValue(findName(&quot;PV repair decrease limit&quot;), -1);&#xa;setValue(findName(&quot;delta in transition&quot;), 0);&#xa;setValue(findName(&quot;delta for growing with demand&quot;), 0.8);&#xa;setValue(findName(&quot;tau_fC_phase_out&quot;), 5);&#xa;setValue(findName(&quot;fC_dep_phase_out&quot;), 0.01);&#xa;setValue(findName(&quot;epsilon in transition&quot;), 0);&#xa;setValue(findName(&quot;epsilon after transition&quot;), 1);&#xa;setValue(findName(&quot;CCS increase limit&quot;), 0.1);&#xa;setValue(findName(&quot;independence time&quot;), 0.005);&#xa;setValue(findName(&quot;fraction of daily demand stored&quot;), 0.1);&#xa;setValue(findName(&quot;relative weight chemical storage&quot;), 0.1);&#xa;setValue(findName(&quot;relative weight mechanical storage&quot;), 0.2);&#xa;setValue(findName(&quot;relative weight electro-chemical storage&quot;), 0.8);&#xa;setValue(findName(&quot;storage building time constant&quot;), 0.001);&#xa;setValue(findName(&quot;K_P&quot;), 8);&#xa;setValue(findName(&quot;K_I&quot;), 1);&#xa;setValue(findName(&quot;K_D&quot;), 0.001);&#xa;setValue(findName(&quot;gamma&quot;), 0.95);&#xa;setValue(findName(&quot;K_fC drain&quot;), 2);&#xa;setValue(findName(&quot;_PV_alpha decrease limit&quot;), -2);&#xa;setValue(findName(&quot;material supply constrain switch&quot;), 1);&#xa;setValue(findName(&quot;Al prim supply gap correction exponent&quot;), 6);&#xa;setValue(findName(&quot;Al prim CF correction threshold&quot;), 0);&#xa;setValue(findName(&quot;K_p for Al prim CF&quot;), 0.6);&#xa;setValue(findName(&quot;K_i for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;K_d for Al prim CF&quot;), 0);&#xa;setValue(findName(&quot;Al CF market factor&quot;), 0.1);&#xa;setValue(findName(&quot;Al CF market filling factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al market filling exponent&quot;), 1);&#xa;setValue(findName(&quot;Al market shortage correction exponent&quot;), 2);&#xa;setValue(findName(&quot;Al prim construction time&quot;), 5);&#xa;setValue(findName(&quot;Al prim min construction time&quot;), 2.5);&#xa;setValue(findName(&quot;Al prim CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al prim permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling construction time&quot;), 1);&#xa;setValue(findName(&quot;Al recycling CF building threshold&quot;), 0.7);&#xa;setValue(findName(&quot;Al sec capacity building exponent&quot;), 2);&#xa;setValue(findName(&quot;Al recycling increase limit&quot;), 1);&#xa;setValue(findName(&quot;Al recycling decrease limit&quot;), -1);&#xa;setValue(findName(&quot;Al recycling permitting factor&quot;), 0.2);&#xa;setValue(findName(&quot;Al dilution tau&quot;), 10);&#xa;setValue(findName(&quot;Al dilution ratio inf&quot;), 0.1);&#xa;setValue(findName(&quot;PV material intensity switch&quot;), 0);&#xa;setValue(findName(&quot;PV Al intensity tau&quot;), 60);&#xa;setValue(findName(&quot;societal Al intensity inf factor&quot;), 0.9478);&#xa;setValue(findName(&quot;societal Al intensity increase factor&quot;), 1.05);&#xa;setValue(findName(&quot;societal Al intensity tau&quot;), 6);&#xa;setValue(findName(&quot;DAC Al intensity tau&quot;), 30);&#xa;&#xa;runModel();&#xa;" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2660" id="2660">
      <mxCell style="button;fontSize=10;" parent="1478" vertex="1">
        <mxGeometry x="99.5" y="317.75" width="120" height="24" as="geometry" />
      </mxCell>
    </Button>
    <Folder name="CCS" Note="" Type="None" Solver="{&quot;enabled&quot;:false,&quot;algorithm&quot;:&quot;RK1&quot;,&quot;timeStep&quot;:1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="1448" id="1448">
      <mxCell style="folder" parent="1" vertex="1">
        <mxGeometry x="1347.44" y="644.25" width="322.62" height="188.5" as="geometry" />
      </mxCell>
    </Folder>
    <Variable name="conv_CCS" Note="&lt;div&gt;Conversion factor from consumed power to the removed CO2&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;" Equation="#[P_opCCS]/[CCS energy intensity]&#xa;[conv post combustion CCS]+[conv DAC]&#xa;" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="198" id="198">
      <mxCell style="variable;fontSize=8;fillColor=#CCFFFF;" parent="1448" vertex="1">
        <mxGeometry x="262.62" y="88.5" width="40" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="DAC energy intensity" Note="&lt;div&gt;Operational energy demand for CO2 removal from the atmosphere (DACCS)&lt;/div&gt;&lt;div&gt;ranges between 0.06 TW/(Gt/a) (ltDAC, Creutzig_2019) and 0.314 TW/(Gt/a) (htDAC, Realmonte_2019)&lt;/div&gt;&lt;div&gt;average for htDAC 0.24 TW/(Gt/a); average for ltDAC 0.083 TW/(Gt/a)&lt;/div&gt;" Equation="0.15844" Units="TW/(Gt/a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="0.6" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="907" id="907">
      <mxCell style="variable;fontSize=8;fillColor=#99CC00;" parent="1448" vertex="1">
        <mxGeometry x="115" y="20" width="40" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="908" id="908">
      <mxCell style="link" parent="1448" source="907" target="1438" edge="1">
        <mxGeometry x="-480" y="-614" width="100" height="100" as="geometry">
          <mxPoint x="-480" y="-514" as="sourcePoint" />
          <mxPoint x="-380" y="-614" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="post combustion CCS energy intensity" Note="TWa/Gt" Equation="0.06" Units="TW/(Gt/a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1426" id="1426">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="1448" vertex="1">
        <mxGeometry x="30" y="40" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1427" id="1427">
      <mxCell style="link" parent="1448" source="1426" target="1437" edge="1">
        <mxGeometry x="-500" y="-630" width="100" height="100" as="geometry">
          <mxPoint x="-500" y="-530" as="sourcePoint" />
          <mxPoint x="-400" y="-630" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="134" oldId="1429" name="conv_fC" id="1429">
      <mxCell style="variable;fontSize=8;fillColor=#CCFFFF;opacity=30;" parent="1448" vertex="1">
        <mxGeometry x="60" y="128.5" width="40" height="17" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1430" oldId="1432" name="P_opCCS_1" id="1432">
      <mxCell style="variable;fontSize=9;opacity=30;" parent="1448" vertex="1">
        <mxGeometry x="110" y="145.5" width="70" height="28.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1433" id="1433">
      <mxCell style="link" parent="1448" source="1429" target="1437" edge="1">
        <mxGeometry x="-500" y="-630" width="100" height="100" as="geometry">
          <mxPoint x="-500" y="-530" as="sourcePoint" />
          <mxPoint x="-400" y="-630" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1434" id="1434">
      <mxCell style="link" parent="1448" source="1432" target="1437" edge="1">
        <mxGeometry x="-500" y="-630" width="100" height="100" as="geometry">
          <mxPoint x="-500" y="-530" as="sourcePoint" />
          <mxPoint x="-400" y="-630" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="post combustion CCS maximum capture" Note="&lt;div&gt;Maximum efficiency of stack capture ~0.9&lt;/div&gt;&lt;div&gt;Fraction of emissions that can be captured at stacks: ~0.5&lt;/div&gt;&lt;div&gt;Other emissions are in transport or small stoves, where post combustion capture can hardly be implemented&lt;br&gt;&lt;/div&gt;" Equation="0.45" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1435" id="1435">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="1448" vertex="1">
        <mxGeometry x="10" y="80" width="60" height="50" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1436" id="1436">
      <mxCell style="link" parent="1448" source="1435" target="1437" edge="1">
        <mxGeometry x="-500" y="-630" width="100" height="100" as="geometry">
          <mxPoint x="-500" y="-530" as="sourcePoint" />
          <mxPoint x="-400" y="-630" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="conv post combustion CCS" Note="Mass flow of captured CO2 post combustion" Equation="If [P_opCCS_1]/[post combustion CCS energy intensity] &lt; [post combustion CCS maximum capture]*[conv_fC] And [Transition complete]=0 Then&#xa;    [P_opCCS_1]/[post combustion CCS energy intensity]&#xa;Else If [Transition complete]=0 Then&#xa;    [post combustion CCS maximum capture]*[conv_fC]&#xa;Else&#xa;    0&#xa;End If&#xa;" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1437" id="1437">
      <mxCell style="variable;fontSize=8;" parent="1448" vertex="1">
        <mxGeometry x="193.5" y="109" width="40" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="conv DAC" Note="Mass flow of captured CO2 direct air capture (DAC)&lt;br&gt;" Equation="If [CCS switch]=0 Then&#xa;    0&#xa;Else If [P_opCCS_1]/[post combustion CCS energy intensity] &lt; [post combustion CCS maximum capture]*[conv_fC] And [Transition complete]=0 Then&#xa;    0&#xa;Else If [P_opCCS_1]/[post combustion CCS energy intensity] &gt;= [post combustion CCS maximum capture]*[conv_fC] And [Transition complete]=0 Then&#xa;#    [P_opCCS_1]*((1-[post combustion CCS maximum capture]*[conv_fC]*[post combustion CCS energy intensity]/[P_opCCS_1])/[DAC energy intensity])&#xa;(([P_opCCS_1]-[post combustion CCS maximum capture]*[conv_fC]*[post combustion CCS energy intensity])/[DAC energy intensity])&#xa;Else&#xa;    [P_opCCS_1]/[DAC energy intensity]&#xa;End If" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1438" id="1438">
      <mxCell style="variable;fontSize=8;" parent="1448" vertex="1">
        <mxGeometry x="193.5" y="60" width="40" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1439" id="1439">
      <mxCell style="link" parent="1448" source="1426" target="1438" edge="1">
        <mxGeometry x="-500" y="-630" width="100" height="100" as="geometry">
          <mxPoint x="-500" y="-530" as="sourcePoint" />
          <mxPoint x="-400" y="-630" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1440" id="1440">
      <mxCell style="link" parent="1448" source="1432" target="1438" edge="1">
        <mxGeometry x="-500" y="-630" width="100" height="100" as="geometry">
          <mxPoint x="-500" y="-530" as="sourcePoint" />
          <mxPoint x="-400" y="-630" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1441" id="1441">
      <mxCell style="link" parent="1448" source="1435" target="1438" edge="1">
        <mxGeometry x="-500" y="-630" width="100" height="100" as="geometry">
          <mxPoint x="-500" y="-530" as="sourcePoint" />
          <mxPoint x="-400" y="-630" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1442" id="1442">
      <mxCell style="link" parent="1448" source="1429" target="1438" edge="1">
        <mxGeometry x="-500" y="-630" width="100" height="100" as="geometry">
          <mxPoint x="-500" y="-530" as="sourcePoint" />
          <mxPoint x="-400" y="-630" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1443" id="1443">
      <mxCell style="link" parent="1448" source="1437" target="198" edge="1">
        <mxGeometry x="-500" y="-630" width="100" height="100" as="geometry">
          <mxPoint x="-500" y="-530" as="sourcePoint" />
          <mxPoint x="-400" y="-630" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1444" id="1444">
      <mxCell style="link" parent="1448" source="1438" target="198" edge="1">
        <mxGeometry x="-500" y="-630" width="100" height="100" as="geometry">
          <mxPoint x="-500" y="-530" as="sourcePoint" />
          <mxPoint x="-400" y="-630" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="724" oldId="1445" name="Transition complete" id="1445">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="1448" vertex="1">
        <mxGeometry x="249.62" y="25" width="53" height="30" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1446" id="1446">
      <mxCell style="link" parent="1448" source="1445" target="1437" edge="1">
        <mxGeometry x="-500" y="-630" width="100" height="100" as="geometry">
          <mxPoint x="-500" y="-530" as="sourcePoint" />
          <mxPoint x="-400" y="-630" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1447" id="1447">
      <mxCell style="link" parent="1448" source="1445" target="1438" edge="1">
        <mxGeometry x="-500" y="-630" width="100" height="100" as="geometry">
          <mxPoint x="-500" y="-530" as="sourcePoint" />
          <mxPoint x="-400" y="-630" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="371" oldId="1476" name="CCS switch" id="1476">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;opacity=30;" parent="1448" vertex="1">
        <mxGeometry x="183.5" width="60" height="40" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1477" id="1477">
      <mxCell style="link" parent="1448" source="1476" target="1438" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="cumulative exceedance of 350ppm" Note="" Type="None" Solver="{&quot;enabled&quot;: false, &quot;algorithm&quot;: &quot;RK1&quot;, &quot;timeStep&quot;: 1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" id="1366">
      <mxCell style="folder" parent="1" vertex="1">
        <mxGeometry x="40" y="1153" width="400" height="130" as="geometry" />
      </mxCell>
    </Folder>
    <Ghost Source="56" name="CO2_inAtm&amp;UpperOcean" id="1060">
      <mxCell style="stock;fontSize=12;fillColor=#CCFFFF;opacity=30;" parent="1366" vertex="1">
        <mxGeometry x="20" y="30" width="150" height="20" as="geometry" />
      </mxCell>
    </Ghost>
    <Stock name="cumulated exceedance of climate thresholds" Note="integral of cumulative CO2 emission above 350ppm&lt;br&gt;" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="Gt*a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" id="1061">
      <mxCell style="stock" parent="1366" vertex="1">
        <mxGeometry x="180" y="60" width="160" height="50" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="cumulative emissions" Note="cumulative CO2 emissions remaining in atmosphere and upper ocean above 350ppm&lt;br&gt;" FlowRate="Max({0 Gt},[CO2_inAtm&amp;UpperOcean]-[350 ppm])" OnlyPositive="false" TimeIndependent="false" Units="Gt" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" id="1062">
      <mxCell style="flow;startArrow=block;startFill=0;" parent="1366" target="1061" edge="1">
        <mxGeometry x="-660" y="-1170" width="100" height="100" as="geometry">
          <mxPoint x="20" y="80" as="sourcePoint" />
          <mxPoint x="-660" y="-1070" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" id="1063">
      <mxCell style="link" parent="1366" source="1060" target="1062" edge="1">
        <mxGeometry x="-660" y="-1170" width="100" height="100" as="geometry">
          <mxPoint x="-660" y="-1070" as="sourcePoint" />
          <mxPoint x="-560" y="-1170" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="565" name="350 ppm" id="1064">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="1366" vertex="1">
        <mxGeometry x="190" y="20" width="70" height="20" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="1065">
      <mxCell style="link" parent="1366" source="1064" target="1062" edge="1">
        <mxGeometry x="-660" y="-1170" width="100" height="100" as="geometry">
          <mxPoint x="-660" y="-1070" as="sourcePoint" />
          <mxPoint x="-560" y="-1170" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="Demand by society" Note="" Type="None" Solver="{&quot;enabled&quot;: false, &quot;algorithm&quot;: &quot;RK1&quot;, &quot;timeStep&quot;: 1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" id="1359">
      <mxCell style="folder" parent="1" vertex="1">
        <mxGeometry x="1918" y="44" width="372" height="440" as="geometry" />
      </mxCell>
    </Folder>
    <Variable name="P_demand" Note="required demand by the system&lt;br&gt;" Equation="If [demand growth switch]==1 Then&#xa;    [P_demand expontential growth]&#xa;Else&#xa;    [P_demand adjustment]&#xa;End If" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="247" id="247">
      <mxCell style="variable;fontSize=12;fillColor=#FDCDAC;" parent="1359" vertex="1">
        <mxGeometry x="21" y="225.25" width="90" height="35" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_demand_0" Note="&lt;div&gt;power demand at t=0 (start) from the non-renewable (NR) energy system. power from renewable energy (RE) at t=0 is deducted.&lt;br&gt;&lt;/div&gt;" Equation="([gobal population 2026]*[P_demand per person in 2026]/{1 W})/(1e12)*{1 TW} - [P_RE_2026]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="560" id="560">
      <mxCell style="variable;fontSize=12;fillColor=#FDCDAC;" parent="1359" vertex="1">
        <mxGeometry x="21" y="152.5" width="90" height="35" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="growth rate" Note="&lt;div&gt;growth rate of power demand by society; if 0, demand stays constant throughout the simulation&lt;br&gt;&lt;/div&gt;" Equation="0.006" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.1" SliderMin="-0.1" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="561" id="561">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="1359" vertex="1">
        <mxGeometry x="20.000000000000064" y="370.5" width="90" height="25" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="562">
      <mxCell style="link" parent="1359" source="560" target="1315" edge="1">
        <mxGeometry x="-1151.32" y="-45" width="100" height="100" as="geometry">
          <mxPoint x="-1151.32" y="55" as="sourcePoint" />
          <mxPoint x="-1051.32" y="-45" as="targetPoint" />
          <Array as="points">
            <mxPoint x="100" y="210" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="563">
      <mxCell style="link" parent="1359" source="561" target="1315" edge="1">
        <mxGeometry x="-1079.32" y="-55" width="100" height="100" as="geometry">
          <mxPoint x="-1079.32" y="45" as="sourcePoint" />
          <mxPoint x="-979.3199999999999" y="-55" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_RE_2026" Note="" Equation="1.623" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1303" id="1303">
      <mxCell style="variable;fontSize=9;fillColor=#FFCC00;" parent="1359" vertex="1">
        <mxGeometry x="143.24" y="157.5" width="78.5" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_demand per person in 2026" Note="" Equation="948" Units="W" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1304" id="1304">
      <mxCell style="variable;fontSize=9;fillColor=#FFCC00;" parent="1359" vertex="1">
        <mxGeometry x="188.68000000000006" y="125" width="78.5" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_demand per person aim" Note="&lt;div&gt;energy demand in electric energy for different scenarios:&lt;br&gt;&lt;/div&gt;&lt;div&gt;- decent living energy (DLE, Millward-Hopkins et al. 2020): 300W/p&lt;/div&gt;&lt;div&gt;- low energy demand (Grubler et al. 2019): 680 W/p&lt;/div&gt;&lt;div&gt;- 2000W society: 2000W/p (https://www.local-energy.swiss/programme/2000-watt-gesellschaft\\#/)&lt;br&gt;&lt;/div&gt;" Equation="680" Units="W" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="2000" SliderMin="300" SliderStep="10" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1305" id="1305">
      <mxCell style="variable;fontSize=9;fillColor=#99CC00;" parent="1359" vertex="1">
        <mxGeometry x="293.5" y="225.25" width="78.5" height="34" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1306">
      <mxCell style="link" parent="1359" source="1309" target="560" edge="1">
        <mxGeometry x="-1171.32" y="-61" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="39" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-61" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1307">
      <mxCell style="link" parent="1359" source="1304" target="560" edge="1">
        <mxGeometry x="-1171.32" y="-61" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="39" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-61" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1308">
      <mxCell style="link" parent="1359" source="1303" target="560" edge="1">
        <mxGeometry x="-1171.32" y="-61" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="39" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-61" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="gobal population 2026" Note="&lt;div&gt;End of 2026&lt;br&gt;&lt;/div&gt;&lt;div&gt;https://www.worldometers.info/world-population/world-population-by-year/&lt;/div&gt;" Equation="8300000000" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1309" id="1309">
      <mxCell style="variable;fontSize=9;fillColor=#FFCC00;" parent="1359" vertex="1">
        <mxGeometry x="137.18000000000006" y="95" width="78.5" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="demand growth switch" Note="&lt;div&gt;If 1, &quot;P_demand&quot; growth exponentially.&lt;/div&gt;&lt;div&gt;If 0, &quot;P_demand&quot; adjusts to &quot;P_demand per person aim&quot;&lt;br&gt;&lt;/div&gt;" Equation="1" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1311" id="1311">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="1359" vertex="1">
        <mxGeometry x="30.000000000000064" y="289" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_demand expontential growth" Note="Demand by society from the previously NR energy system, which grows or degrows exponentially" Equation="([P_demand_0]+[P_RE_2026])*(1+[growth rate]*{1 a})^(Time()/{1 a})-[P_RE_2026]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1315" id="1315">
      <mxCell style="variable;fontSize=9;fillColor=#FDCDAC;" parent="1359" vertex="1">
        <mxGeometry x="118.68000000000006" y="244.5" width="90" height="35" as="geometry" />
      </mxCell>
    </Variable>
    <Stock name="demand adjustment" Note="integrated change, i.e. two times integrated change rate" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1316" id="1316">
      <mxCell style="stock;fontSize=10;" parent="1359" vertex="1">
        <mxGeometry x="247.18000000000006" y="271.5" width="100" height="20" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="demand change" Note="integrated change rate = triangular function&lt;br&gt;" FlowRate="[demand change 1]" OnlyPositive="false" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1317" id="1317">
      <mxCell style="flow;startArrow=block;startFill=0;fontSize=10;" parent="1359" target="1316" edge="1">
        <mxGeometry x="-818.8199999999999" y="257.25" width="100" height="100" as="geometry">
          <mxPoint x="298.68000000000006" y="324.5" as="sourcePoint" />
          <mxPoint x="-818.8199999999999" y="357.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="demand change rate" Note="positive change rate step function during first half of adjustment duration and negative step function for the second half" FlowRate="If Time()&lt;([demand adjustment delay time]) And Time()&gt;([demand adjustment delay time]-[demand adjustment effective duration]/2) Then&#xa;    4*{1 Years}*{1 Years} / [demand adjustment effective duration]^2&#xa;Else If Time()&gt;([demand adjustment delay time]) And Time()&lt;([demand adjustment delay time]+[demand adjustment effective duration]/2) Then&#xa;    -4*{1 Years}*{1 Years} / [demand adjustment effective duration]^2&#xa;Else&#xa;    0&#xa;End If&#xa;&#xa;&#xa;" OnlyPositive="false" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1318" id="1318">
      <mxCell style="flow;startArrow=block;startFill=0;fontSize=10;" parent="1359" target="1319" edge="1">
        <mxGeometry x="-818.8199999999999" y="293.25" width="100" height="100" as="geometry">
          <mxPoint x="298.68000000000006" y="394.5" as="sourcePoint" />
          <mxPoint x="-818.8199999999999" y="393.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="demand change 1" Note="integrted change rate" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="true" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AllowNegatives="false" oldId="1319" id="1319">
      <mxCell style="stock;fontSize=9;" parent="1359" vertex="1">
        <mxGeometry x="247.18000000000006" y="336.25" width="100" height="20" as="geometry" />
      </mxCell>
    </Stock>
    <Variable name="demand adjustment delay time" Note="time after the transition starts when half of the adjustment is finished, i.e. it marks the middle of the adjustment duration" Equation="5" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="80" SliderMin="2" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1320" id="1320">
      <mxCell style="variable;fontSize=9;fillColor=#99CC00;" parent="1359" vertex="1">
        <mxGeometry x="145.59000000000015" y="373.5" width="93.06" height="32" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="demand adjustment duration" Note="maximum duration of the adjustment period" Equation="10" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="80" SliderMin="2" SliderStep="2" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1321" id="1321">
      <mxCell style="variable;fontSize=9;fillColor=#99CC00;" parent="1359" vertex="1">
        <mxGeometry x="142.19000000000014" y="289" width="93.81" height="29.88" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="demand adjustment effective duration" Note="effective adjustment period: is either two time demand adjustment delay time of maximum demand adjustmnt duration, if the latter is shorter" Equation="Min(2*[demand adjustment delay time],[demand adjustment duration])" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="80" SliderMin="2" SliderStep="2" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1322" id="1322">
      <mxCell style="variable;fontSize=9;" parent="1359" vertex="1">
        <mxGeometry x="143.24" y="330" width="98.5" height="31" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1323">
      <mxCell style="link" parent="1359" source="1321" target="1322" edge="1">
        <mxGeometry x="-1172.07" y="-106" width="100" height="100" as="geometry">
          <mxPoint x="-1172.07" y="-6" as="sourcePoint" />
          <mxPoint x="-1072.07" y="-106" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1324">
      <mxCell style="link" parent="1359" source="1320" target="1322" edge="1">
        <mxGeometry x="-1172.07" y="-106" width="100" height="100" as="geometry">
          <mxPoint x="-1172.07" y="-6" as="sourcePoint" />
          <mxPoint x="-1072.07" y="-106" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1325">
      <mxCell style="link" parent="1359" source="1322" target="1318" edge="1">
        <mxGeometry x="-1171.32" y="-75.5" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="24.5" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-75.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1326">
      <mxCell style="link" parent="1359" source="1319" target="1317" edge="1">
        <mxGeometry x="-1171.32" y="-75.5" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="24.5" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-75.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1327">
      <mxCell style="link" parent="1359" source="1315" target="247" edge="1">
        <mxGeometry x="-1171.32" y="-61" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="39" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-61" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1328">
      <mxCell style="link" parent="1359" source="1311" target="247" edge="1">
        <mxGeometry x="-1171.32" y="-61" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="39" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-61" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1329">
      <mxCell style="link" parent="1359" source="1320" target="1318" edge="1">
        <mxGeometry x="-1171.32" y="-75.5" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="24.5" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-75.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_demand adjustment" Note="adjustment from today&#39;s demand per person to target demand per person" Equation="[global population]*[P_demand per person adjustment]*{1 TW}/(1e12 * {1 W}) - [P_RE_2026]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1330" id="1330">
      <mxCell style="variable;fontSize=9;fillColor=#FDCDAC;" parent="1359" vertex="1">
        <mxGeometry x="118.68000000000006" y="197" width="90" height="35" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_demand per person adjustment" Note="Adjusting from today&#39;s demand per person to target demand per person" Equation="(1-[demand adjustment])*[P_demand per person in 2026] + [demand adjustment]*[P_demand per person aim]" Units="W" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1331" id="1331">
      <mxCell style="variable;fontSize=9;fillColor=#FDCDAC;" parent="1359" vertex="1">
        <mxGeometry x="232.49" y="197" width="90" height="35" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1332">
      <mxCell style="link" parent="1359" source="1316" target="1331" edge="1">
        <mxGeometry x="-1171.32" y="-61" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="39" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-61" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1333">
      <mxCell style="link" parent="1359" source="1304" target="1331" edge="1">
        <mxGeometry x="-1171.32" y="-61" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="39" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-61" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1334">
      <mxCell style="link" parent="1359" source="1305" target="1331" edge="1">
        <mxGeometry x="-1171.32" y="-61" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="39" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-61" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1335">
      <mxCell style="link" parent="1359" source="1331" target="1330" edge="1">
        <mxGeometry x="-1171.32" y="-61" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="39" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-61" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1337">
      <mxCell style="link" parent="1359" source="1303" target="1330" edge="1">
        <mxGeometry x="-1171.32" y="-61" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="39" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-61" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1338">
      <mxCell style="link" parent="1359" source="1330" target="247" edge="1">
        <mxGeometry x="-1171.32" y="-61" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="39" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-61" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_supply to society per person" Note="power supply to society per person&lt;br&gt;" Equation="[P_supply to society curtailled]*{1e12 W}/{1 TW} *1/[global population]" Units="W" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1339" id="1339">
      <mxCell style="variable;fontSize=9;fillColor=#FDCDAC;" parent="1359" vertex="1">
        <mxGeometry x="20" y="20" width="90" height="35" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_demand per person" Note="power demand per person&lt;br&gt;" Equation="[P_demand]*{1e12 W}/{1 TW} *1/[global population]" Units="W" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1339" id="1342">
      <mxCell style="variable;fontSize=9;fillColor=#FDCDAC;" parent="1359" vertex="1">
        <mxGeometry x="20" y="65" width="90" height="35" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1343">
      <mxCell style="link" parent="1359" source="247" target="1342" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
          <Array as="points">
            <mxPoint x="-20" y="150" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="global population" Note="" Equation="If [population confidence selection]=1 Then&#xa;    [population low]*1e9&#xa;Else If [population confidence selection]=2 Then&#xa;    [population 50%]*1e9&#xa;Else&#xa;    [population high]*1e9&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1405" id="1405">
      <mxCell style="variable;fontSize=10;" parent="1359" vertex="1">
        <mxGeometry x="131" y="47" width="84" height="27" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1341">
      <mxCell style="link" parent="1359" source="1405" target="1339" edge="1">
        <mxGeometry x="-1171.32" y="-21" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="79" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-21" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1344">
      <mxCell style="link" parent="1359" source="1405" target="1342" edge="1">
        <mxGeometry x="-1171.32" y="-21" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="79" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-21" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1336">
      <mxCell style="link" parent="1359" source="1405" target="1330" edge="1">
        <mxGeometry x="-1171.32" y="-61" width="100" height="100" as="geometry">
          <mxPoint x="-1171.32" y="39" as="sourcePoint" />
          <mxPoint x="-1071.32" y="-61" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Converter name="population low" Note="data from world population prospects 2019" Source="Time" Data="0,8.053463069; 1,8.112671744; 2,8.171094256; 3,8.228679626; 4,8.276754247; 5,8.323983348; 6,8.370348397; 7,8.415788335; 8,8.460233802; 9,8.497829301; 10,8.534356563; 11,8.56979428; 12,8.604082857; 13,8.63714609; 14,8.669083377; 15,8.699820257; 16,8.729106671; 17,8.756937795; 18,8.783270761; 19,8.807985127; 20,8.830919599; 21,8.851963159; 22,8.870993038; 23,8.887932384; 24,8.902649002; 25,8.914983933; 26,8.924780196; 27,8.932022149; 28,8.936534118; 29,8.938560757; 30,8.937842094; 31,8.934525063; 32,8.928601207; 33,8.920173737; 34,8.909320767; 35,8.896111814; 36,8.880520482; 37,8.862865585; 38,8.843238969; 39,8.821808145; 40,8.798560322; 41,8.773679455; 42,8.747059923; 43,8.718871177; 44,8.689282803; 45,8.65817949; 46,8.625636955; 47,8.591597568; 48,8.556167252; 49,8.519374859; 50,8.481164751; 51,8.44146889; 52,8.400289539; 53,8.357579792; 54,8.313341641; 55,8.267661335; 56,8.220579359; 57,8.172068626; 58,8.12216132; 59,8.071002909; 60,8.018589562; 61,7.964936495; 62,7.910065554; 63,7.854017215; 64,7.796911009; 65,7.738849475; 66,7.679761584; 67,7.619736331; 68,7.558750984; 69,7.496937162; 70,7.434246034; 71,7.370837406; 72,7.306614668; 73,7.241654819; 74,7.175943331; 75,7.109619159; 76,7.042750382; 77,6.975881605" Interpolation="Linear" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1404" id="1404">
      <mxCell style="converter;fontSize=10;" parent="1359" vertex="1">
        <mxGeometry x="233.49" y="84" width="120" height="16" as="geometry" />
      </mxCell>
    </Converter>
    <Link name="Link" Note="" BiDirectional="false" oldId="1412" id="1412">
      <mxCell style="link" parent="1359" source="1404" target="1405" edge="1">
        <mxGeometry x="-1230" y="-72" width="100" height="100" as="geometry">
          <mxPoint x="-1230" y="28" as="sourcePoint" />
          <mxPoint x="-1130" y="-72" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Converter name="population 50%" Note="data from world population prospects 2019" Source="Time" Data="0,8.0820709; 1,8.155601099; 2,8.228375807; 3,8.300353212; 4,8.37160213; 5,8.442055453; 6,8.511723329; 7,8.580559324; 8,8.648506165; 9,8.715677802; 10,8.781919281; 11,8.847231061; 12,8.911563741; 13,8.974849663; 14,9.037203076; 15,9.098574977; 16,9.158747453; 17,9.217753531; 18,9.27559307; 19,9.332200631; 20,9.38747221; 21,9.441344637; 22,9.493742512; 23,9.544639095; 24,9.593956678; 25,9.641592262; 26,9.687440029; 27,9.731543492; 28,9.773770339; 29,9.814433747; 30,9.853288635; 31,9.890512569; 32,9.926097169; 33,9.960149356; 34,9.992730945; 35,10.02388928; 36,10.05352245; 37,10.08194477; 38,10.10920136; 39,10.135414; 40,10.16048423; 41,10.18454332; 42,10.20738648; 43,10.22915955; 44,10.25000801; 45,10.26973797; 46,10.28841177; 47,10.30592166; 48,10.32236295; 49,10.33775676; 50,10.35202623; 51,10.3650793; 52,10.3769091; 53,10.3874517; 54,10.3967123; 55,10.4047872; 56,10.41174664; 57,10.41752774; 58,10.42217524; 59,10.42587055; 60,10.42858225; 61,10.43031254; 62,10.43104566; 63,10.4308069; 64,10.42972835; 65,10.4279329; 66,10.42526939; 67,10.42181268; 68,10.41748158; 69,10.41243808; 70,10.4065441; 71,10.4000002; 72,10.39261149; 73,10.38442281; 74,10.37535409; 75,10.36553631; 76,10.35500242; 77,10.34446853" Interpolation="Linear" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1402" id="1402">
      <mxCell style="converter;fontSize=10;" parent="1359" vertex="1">
        <mxGeometry x="233" y="60" width="120" height="18" as="geometry" />
      </mxCell>
    </Converter>
    <Link name="Link" Note="" BiDirectional="false" oldId="1410" id="1410">
      <mxCell style="link" parent="1359" source="1402" target="1405" edge="1">
        <mxGeometry x="-1230" y="-72" width="100" height="100" as="geometry">
          <mxPoint x="-1230" y="28" as="sourcePoint" />
          <mxPoint x="-1130" y="-72" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Converter name="population high" Note="data from world population prospects 2019" Source="Time" Data="0,8.110676972; 1,8.198527559; 2,8.285655333; 3,8.37203022; 4,8.466467868; 5,8.560169352; 6,8.653174024; 7,8.745449423; 8,8.8369473; 9,8.93375324; 10,9.02976876; 11,9.125015853; 12,9.219450907; 13,9.313000359; 14,9.405788221; 15,9.497804184; 16,9.588892844; 17,9.679173841; 18,9.768733595; 19,9.857616137; 20,9.945840245; 21,10.03345753; 22,10.12051088; 23,10.20708927; 24,10.29324055; 25,10.37898856; 26,10.46434491; 27,10.54946756; 28,10.63430459; 29,10.71925716; 30,10.80409827; 31,10.88902365; 32,10.97400459; 33,11.05912994; 34,11.1444208; 35,11.22987517; 36,11.31529461; 37,11.40097343; 38,11.48690048; 39,11.57313295; 40,11.65945818; 41,11.74592514; 42,11.83220654; 43,11.91841042; 44,12.00465487; 45,12.09066945; 46,12.17651153; 47,12.2620456; 48,12.34738786; 49,12.4325903; 50,12.51759683; 51,12.60233687; 52,12.68684688; 53,12.77109791; 54,12.85515075; 55,12.93916383; 56,13.02328583; 57,13.10745413; 58,13.1917588; 59,13.27644773; 60,13.36147455; 61,13.44683828; 62,13.53248153; 63,13.61841188; 64,13.70476968; 65,13.7916955; 66,13.8789304; 67,13.96651667; 68,14.05428826; 69,14.14243509; 70,14.23069249; 71,14.31930676; 72,14.40795483; 73,14.49663894; 74,14.58520043; 75,14.67376801; 76,14.76234644; 77,14.85092486" Interpolation="Linear" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1400" id="1400">
      <mxCell style="converter;fontSize=10;" parent="1359" vertex="1">
        <mxGeometry x="233.49000000000024" y="29" width="120" height="26" as="geometry" />
      </mxCell>
    </Converter>
    <Link name="Link" Note="" BiDirectional="false" oldId="1408" id="1408">
      <mxCell style="link" parent="1359" source="1400" target="1405" edge="1">
        <mxGeometry x="-1230" y="-72" width="100" height="100" as="geometry">
          <mxPoint x="-1230" y="28" as="sourcePoint" />
          <mxPoint x="-1130" y="-72" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="population confidence selection" Note="1 = low; 2=50%; 3=high" Equation="2" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="3" SliderMin="1" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1406" id="1406">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="1359" vertex="1">
        <mxGeometry x="281" y="127.5" width="70" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1407" id="1407">
      <mxCell style="link" parent="1359" source="1406" target="1405" edge="1">
        <mxGeometry x="-1230" y="-30" width="100" height="100" as="geometry">
          <mxPoint x="-1230" y="70" as="sourcePoint" />
          <mxPoint x="-1130" y="-30" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2594" id="2594">
      <mxCell style="link" parent="1359" source="1303" target="1315" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="C clean up completed" Note="" Type="None" Solver="{&quot;enabled&quot;: false, &quot;algorithm&quot;: &quot;RK1&quot;, &quot;timeStep&quot;: 1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" id="953">
      <mxCell style="folder" parent="1" vertex="1">
        <mxGeometry x="40" y="1010" width="398.25" height="130" as="geometry" />
      </mxCell>
    </Folder>
    <State name="in clean up" Note="state of the system when clean up is still necessary" Active="true" Residency="0" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="944" id="944">
      <mxCell style="state" parent="953" vertex="1">
        <mxGeometry x="20" y="20" width="100" height="40" as="geometry" />
      </mxCell>
    </State>
    <Transition name="clean up completed" Note="" Trigger="Condition" Value="[CO2_inAtm&amp;UpperOcean]&lt;=[350 ppm]" Repeat="false" Recalculate="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="945" id="945">
      <mxCell style="transition" parent="953" source="944" target="946" edge="1">
        <mxGeometry x="-655" y="-798.8199999999999" width="100" height="100" as="geometry">
          <mxPoint x="-1172.75" y="-1469.06" as="sourcePoint" />
          <mxPoint x="-1072.75" y="-1569.06" as="targetPoint" />
          <Array as="points">
            <mxPoint x="196" y="39.75999999999999" />
          </Array>
          <mxPoint x="-3" y="-10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Transition>
    <State name="clean up complete" Note="clean up of atmosphere is completed" Active="false" Residency="0" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="946" id="946">
      <mxCell style="state" parent="953" vertex="1">
        <mxGeometry x="278.25" y="20" width="100" height="40" as="geometry" />
      </mxCell>
    </State>
    <Variable name="CCS complete" Note="" Equation="[clean up complete]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="947" id="947">
      <mxCell style="variable;fontSize=8;" parent="953" vertex="1">
        <mxGeometry x="301.75" y="80" width="53" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="948">
      <mxCell style="link" parent="953" source="946" target="947" edge="1">
        <mxGeometry x="-710" y="-980" width="100" height="100" as="geometry">
          <mxPoint x="-710" y="-880" as="sourcePoint" />
          <mxPoint x="-610" y="-980" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="565" name="350 ppm" id="936">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="953" vertex="1">
        <mxGeometry x="29.379999999999995" y="90" width="70.62" height="20" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="56" name="CO2_inAtm&amp;UpperOcean" id="937">
      <mxCell style="stock;fontSize=12;fillColor=#CCFFFF;opacity=30;" parent="953" vertex="1">
        <mxGeometry x="120" y="84.63" width="150.62" height="30.75" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="949">
      <mxCell style="link" parent="953" source="936" target="945" edge="1">
        <mxGeometry x="-710" y="-980" width="100" height="100" as="geometry">
          <mxPoint x="-710" y="-880" as="sourcePoint" />
          <mxPoint x="-610" y="-980" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="950">
      <mxCell style="link" parent="953" source="937" target="945" edge="1">
        <mxGeometry x="-710" y="-980" width="100" height="100" as="geometry">
          <mxPoint x="-710" y="-880" as="sourcePoint" />
          <mxPoint x="200" y="40" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="PID controller" Note="" Type="None" Solver="{&quot;enabled&quot;: false, &quot;algorithm&quot;: &quot;RK1&quot;, &quot;timeStep&quot;: 1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" id="862">
      <mxCell style="folder" parent="1" vertex="1">
        <mxGeometry x="3180" y="63.99999999999999" width="560" height="438" as="geometry" />
      </mxCell>
    </Folder>
    <Flow name="transition drain" Note="When transition is completed, CF_fC is drained to zero with a defined speed" FlowRate="If [Transition complete]=1 and [fC switch]=1 And [CF_fC_int]&gt;0 Then&#xa;  [K_fC drain]&#xa;Else&#xa;  0&#xa;End If" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" id="765">
      <mxCell style="flow;fontSize=8;" parent="862" source="390" edge="1">
        <mxGeometry y="38.54" width="100" height="100" as="geometry">
          <mxPoint x="-1170" y="138.25" as="sourcePoint" />
          <mxPoint x="10" y="371.495" as="targetPoint" />
          <mxPoint x="-25" y="8" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" id="767">
      <mxCell style="link" parent="862" source="766" target="765" edge="1">
        <mxGeometry x="-1135" width="100" height="100" as="geometry">
          <mxPoint x="-1135" y="100" as="sourcePoint" />
          <mxPoint x="-1035" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="768">
      <mxCell style="link" parent="862" source="731" target="765" edge="1">
        <mxGeometry x="-1135" width="100" height="100" as="geometry">
          <mxPoint x="-1135" y="100" as="sourcePoint" />
          <mxPoint x="-1035" as="targetPoint" />
          <Array as="points">
            <mxPoint x="190" y="361.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="769">
      <mxCell style="link" parent="862" source="511" target="765" edge="1">
        <mxGeometry x="-1135" width="100" height="100" as="geometry">
          <mxPoint x="-1135" y="100" as="sourcePoint" />
          <mxPoint x="-1035" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="cap_fC" Note="flow limiting capacity factor integral between 0 and 1" FlowRate="If [CF_fC_int]&gt;=1 And [difference_flow_fC]&gt;0 Then&#xa;    [difference_flow_fC]&#xa;Else If [CF_fC_int]&lt;=0 And [difference_flow_fC]&lt;0 Then&#xa;    [difference_flow_fC]&#xa;Else&#xa;    0&#xa;End If" OnlyPositive="false" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" id="812">
      <mxCell style="flow;fontSize=8;startArrow=block;startFill=0;" parent="862" source="390" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint x="-1263.75" y="77.93" as="sourcePoint" />
          <mxPoint x="10" y="301.5" as="targetPoint" />
          <mxPoint x="-25" y="-26" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" id="813">
      <mxCell style="link" parent="862" source="389" target="812" edge="1">
        <mxGeometry x="-1135" width="100" height="100" as="geometry">
          <mxPoint x="-1135" y="100" as="sourcePoint" />
          <mxPoint x="-1035" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="cap_PV" Note="flow limiting capacity factor integral between 0 and 1" FlowRate="If [CF_PV_int]&gt;=1 And [difference_flow_PV]&gt;0 Then&#xa;    [difference_flow_PV]&#xa;Else If [CF_PV_int]&lt;=0 And [difference_flow_PV]&lt;0 Then&#xa;    [difference_flow_PV]&#xa;Else&#xa;    0&#xa;End If" OnlyPositive="false" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" id="815">
      <mxCell style="flow;fontSize=8;startArrow=block;startFill=0;" parent="862" source="394" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint x="-1021.12" y="95.63" as="sourcePoint" />
          <mxPoint x="440" y="291.5" as="targetPoint" />
          <Array as="points" />
          <mxPoint x="3" y="-31" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" id="816">
      <mxCell style="link" parent="862" source="393" target="815" edge="1">
        <mxGeometry x="-1135" width="100" height="100" as="geometry">
          <mxPoint x="-1135" y="100" as="sourcePoint" />
          <mxPoint x="-1035" as="targetPoint" />
          <Array as="points">
            <mxPoint x="370" y="321.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="CF_error" Note="difference between required demand and actual supply, normalized with nominal capacity (i.e. the system&#39;s capacity factor error)&lt;br&gt;" Equation="([P_demand]-[P_supply to society])/([P_nomfC]+[P_nomPV])" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="139" id="139">
      <mxCell style="variable;fontSize=12;" parent="862" vertex="1">
        <mxGeometry x="205" y="72.81" width="80" height="30.25" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="K_P" Note="PID proportional constant" Equation="8" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="15" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="151" id="151">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="862" vertex="1">
        <mxGeometry x="484.8800000000001" y="20.939999999999998" width="35" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Stock name="integrated_error" Note="integrated error" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="283" id="283">
      <mxCell style="stock;fillColor=#C0C0C0;fontSize=8;fontColor=#FF0000;" parent="862" vertex="1">
        <mxGeometry x="454.8800000000001" y="81.44" width="70" height="13" as="geometry" />
      </mxCell>
    </Stock>
    <Flow name="error_flow" Note="eror" FlowRate="[CF_error]" OnlyPositive="false" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="284" id="284">
      <mxCell style="flow;startArrow=block;startFill=0;strokeColor=#969696;rounded=0;fontSize=8;fontColor=#FF0000;" parent="862" target="283" edge="1">
        <mxGeometry x="14.88000000000011" y="-5.810000000000002" width="100" height="100" as="geometry">
          <mxPoint x="394.8800000000001" y="92.02" as="sourcePoint" />
          <mxPoint x="-880.12" y="112.02000000000001" as="targetPoint" />
          <mxPoint y="-12" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="285" id="285">
      <mxCell style="link;fontSize=12;" parent="862" source="139" target="284" edge="1">
        <mxGeometry x="-864.53" y="-15.260000000000002" width="100" height="100" as="geometry">
          <mxPoint x="-864.53" y="84.74000000000001" as="sourcePoint" />
          <mxPoint x="-764.53" y="-15.260000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="delta_CF" Note="Capacity factor control difference&lt;br&gt;" Equation="[P]+[I]+[D]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="287" id="287">
      <mxCell style="variable;fontSize=12;" parent="862" vertex="1">
        <mxGeometry x="215" y="121.5" width="60" height="33.25" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="247" name="P_demand" oldId="314" id="314">
      <mxCell style="variable;fontSize=12;fillColor=#FDCDAC;opacity=30;" parent="862" vertex="1">
        <mxGeometry x="172.5" y="20.939999999999998" width="90" height="28.37" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="K_I" Note="PID integral constant" Equation="1" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="10" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="317" id="317">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="862" vertex="1">
        <mxGeometry x="487.3800000000001" y="104.19" width="32.5" height="32.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="318" id="318">
      <mxCell style="link" parent="862" source="314" target="139" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="321" id="321">
      <mxCell style="link" parent="862" source="317" target="417" edge="1">
        <mxGeometry x="54.88000000000011" y="-15.560000000000002" width="100" height="100" as="geometry">
          <mxPoint x="54.88000000000011" y="84.44" as="sourcePoint" />
          <mxPoint x="154.8800000000001" y="-15.560000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="CF_fC" Note="&lt;div&gt;The capacity factor of the machine. It is modulating the consumed/produced power. The capacity factor can be implemented as a power controller which e.g. keeps the energy content of the &#39;grid&#39; constant.&lt;/div&gt;" Equation="#IfThenElse([fC switch]=1, IfThenElse([Transition complete]=1, 0, IfThenElse([CF_fC_int]&gt;1, 1, [CF_fC_int])), IfThenElse([CF_fC_int]&gt;1, 1, [CF_fC_int]))&#xa;&#xa;IfThenElse([CF_fC_int]&gt;1, 1, [CF_fC_int])" Units="Unitless" MaxConstraintUsed="true" MinConstraintUsed="true" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="324" id="324">
      <mxCell style="variable;fontSize=12;" parent="862" vertex="1">
        <mxGeometry x="112.5" y="354.62" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="CF_PV" Note="&lt;div&gt;The capacity factor of the machine. It is modulating the consumed/produced power. The capacity factor can be implemented as a power controller which e.g. keeps the energy content of the &#39;grid&#39; constant.&lt;/div&gt;" Equation="IfThenElse([CF_PV_int]&gt;1, 1, [CF_PV_int])" Units="Unitless" MaxConstraintUsed="true" MinConstraintUsed="true" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="325" id="325">
      <mxCell style="variable;fontSize=12;" parent="862" vertex="1">
        <mxGeometry x="322.5" y="354.62" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="132" name="P_nomfC" oldId="383" id="383">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="862" vertex="1">
        <mxGeometry x="112.5" y="20" width="60" height="30.25" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="185" name="P_nomPV" oldId="384" id="384">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="862" vertex="1">
        <mxGeometry x="322.5" y="20" width="60" height="30.25" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="385" id="385">
      <mxCell style="link" parent="862" source="383" target="139" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="386" id="386">
      <mxCell style="link" parent="862" source="384" target="139" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="delta_CF_fC" Note="&lt;div&gt;The difference in capacity factor of the fossil machine.&lt;/div&gt;" Equation="IfThenElse([Transition complete]=1, 0, IfThenElse([P_nomfC]={0 TW}, 0, [delta_CF]*(1+[P_nomPV]/[P_nomfC]*(1-[control sharing fC PV]))))" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="387" id="387">
      <mxCell style="variable;fontSize=10;" parent="862" vertex="1">
        <mxGeometry x="112.5" y="195.87" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="delta_CF_PV" Note="&lt;div&gt;The difference in capacity factor of the PV machine.&lt;/div&gt;" Equation="If [Transition complete]=1 Then&#xa;  [delta_CF]&#xa;Else If [P_nomfC]={0 TW} Or [CF_fC]=0 Then&#xa;  [delta_CF]&#xa;Else If [CF_PV]=1 And [delta_CF]&gt;0 Then&#xa;  0&#xa;Else&#xa;  [control sharing fC PV]*[delta_CF]&#xa;End If&#xa;&#xa;&#xa;#IfThenElse([Transition complete]=1, [delta_CF], IfThenElse([P_nomfC]=0, [delta_CF],IfThenElse([CF_PV]=1, IfThenElse([delta_CF]&gt;0, 0, [control sharing fC PV]*[delta_CF]), [control sharing fC PV]*[delta_CF])))" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="388" id="388">
      <mxCell style="variable;fontSize=10;" parent="862" vertex="1">
        <mxGeometry x="322.5" y="195.87" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Flow name="difference_flow_fC" Note="" FlowRate="[delta_CF_fC]" OnlyPositive="false" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="389" id="389">
      <mxCell style="flow;startArrow=block;startFill=0;strokeColor=#969696;rounded=0;fontSize=8;" parent="862" target="390" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint x="142.44000000000005" y="270" as="sourcePoint" />
          <mxPoint x="-2207.5599999999995" y="286.5" as="targetPoint" />
          <mxPoint x="8" y="6" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="CF_fC_int" Note="integrated difference in capacity factor" InitialValue="([P_demand]+[P_EoL fC total])/[P_nomfC]" StockMode="Store" Delay="0" Volume="100" NonNegative="true" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="true" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="390" AllowNegatives="false" id="390">
      <mxCell style="stock;fillColor=#C0C0C0;fontSize=10;" parent="862" vertex="1">
        <mxGeometry x="100" y="321.87" width="85" height="22.75" as="geometry" />
      </mxCell>
    </Stock>
    <Link name="Link" Note="" BiDirectional="false" oldId="391" id="391">
      <mxCell style="link" parent="862" source="387" target="389" edge="1">
        <mxGeometry x="-35.5" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="-35.5" y="93.5" as="sourcePoint" />
          <mxPoint x="64.5" y="-6.500000000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="120" y="271.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="392" id="392">
      <mxCell style="link" parent="862" source="390" target="324" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Flow name="difference_flow_PV" Note="" FlowRate="[delta_CF_PV]" OnlyPositive="false" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="393" id="393">
      <mxCell style="flow;startArrow=block;startFill=0;strokeColor=#969696;rounded=0;fontSize=8;" parent="862" target="394" edge="1">
        <mxGeometry x="55" y="-27.880000000000003" width="100" height="100" as="geometry">
          <mxPoint x="352.5" y="270" as="sourcePoint" />
          <mxPoint x="-3072.4999999999995" y="283" as="targetPoint" />
          <mxPoint x="2" y="3" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Stock name="CF_PV_int" Note="integrated difference in capacity factor" InitialValue="1" StockMode="Store" Delay="0" Volume="100" NonNegative="true" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="true" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="394" AllowNegatives="false" id="394">
      <mxCell style="stock;fillColor=#C0C0C0;fontSize=10;" parent="862" vertex="1">
        <mxGeometry x="310" y="321.87" width="85" height="22.75" as="geometry" />
      </mxCell>
    </Stock>
    <Link name="Link" Note="" BiDirectional="false" oldId="395" id="395">
      <mxCell style="link" parent="862" source="388" target="393" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="375" y="280" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="396" id="396">
      <mxCell style="link" parent="862" source="394" target="325" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="397" id="397">
      <mxCell style="link" parent="862" source="287" target="387" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="398" id="398">
      <mxCell style="link" parent="862" source="287" target="388" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="control sharing fC PV" Note="&lt;div&gt;Sharing rule of control effort to stabilize demand between fC and PV.&lt;/div&gt;&lt;div&gt;0 = fC takes full control as long as LF_fC &amp;gt;0; (meanwhile LF_PV =1)&lt;/div&gt;&lt;div&gt;1 = equal sharing of control i.e. delta_LF_fC = delta_LF_PV&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;standard: 0&lt;br&gt;&lt;/div&gt;" Equation="0" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="403" id="403">
      <mxCell style="variable;fontSize=10;fillColor=#FDCDAC;" parent="862" vertex="1">
        <mxGeometry x="217.5" y="198.81" width="55" height="54.13" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="404">
      <mxCell style="link" parent="862" source="403" target="387" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="405">
      <mxCell style="link" parent="862" source="403" target="388" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="406">
      <mxCell style="link" parent="862" source="324" target="387" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="230" y="321.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="410">
      <mxCell style="link" parent="862" source="383" target="387" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="411">
      <mxCell style="link" parent="862" source="384" target="387" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="325" y="170" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="412">
      <mxCell style="link" parent="862" source="383" target="388" edge="1">
        <mxGeometry x="42.97000000000003" y="-5.530000000000001" width="100" height="100" as="geometry">
          <mxPoint x="42.97000000000003" y="94.47" as="sourcePoint" />
          <mxPoint x="142.97000000000003" y="-5.530000000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="165" y="170" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="413">
      <mxCell style="link" parent="862" source="384" target="388" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="415">
      <mxCell style="link" parent="862" source="151" target="416" edge="1">
        <mxGeometry x="54.88000000000011" y="-15.560000000000002" width="100" height="100" as="geometry">
          <mxPoint x="54.88000000000011" y="84.44" as="sourcePoint" />
          <mxPoint x="154.8800000000001" y="-15.560000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P" Note="proportional control contribution&lt;br&gt;" Equation="[CF_error]*[K_P]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="416" id="416">
      <mxCell style="variable;fontSize=12;" parent="862" vertex="1">
        <mxGeometry x="434.8800000000001" y="20.939999999999998" width="30" height="30.25" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="I" Note="integral control contribution" Equation="[integrated_error]*[K_I]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="417" id="417">
      <mxCell style="variable;fontSize=12;" parent="862" vertex="1">
        <mxGeometry x="436.1300000000001" y="104.19" width="30" height="30.25" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="418">
      <mxCell style="link" parent="862" source="283" target="417" edge="1">
        <mxGeometry x="54.88000000000011" y="-15.560000000000002" width="100" height="100" as="geometry">
          <mxPoint x="54.88000000000011" y="84.44" as="sourcePoint" />
          <mxPoint x="154.8800000000001" y="-15.560000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="419">
      <mxCell style="link" parent="862" source="139" target="416" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="D" Note="differential control contribution" Equation="[d_error]*[K_D]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="420" id="420">
      <mxCell style="variable;fontSize=12;" parent="862" vertex="1">
        <mxGeometry x="434.8800000000001" y="170.94" width="30" height="30.25" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="K_D" Note="PID differential constant" Equation="0.001" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="0.1" SliderMin="0" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="421" id="421">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="862" vertex="1">
        <mxGeometry x="486.1300000000001" y="170.94" width="32.5" height="32.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="422">
      <mxCell style="link" parent="862" source="421" target="420" edge="1">
        <mxGeometry x="54.88000000000011" y="-15.560000000000002" width="100" height="100" as="geometry">
          <mxPoint x="54.88000000000011" y="84.44" as="sourcePoint" />
          <mxPoint x="154.8800000000001" y="-15.560000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="d_error" Note="differentiated error" Equation="([CF_error]-Smooth([CF_error], TimeStep() / {1 Years}, [CF_error]))/TimeStep() * {1 Years}" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="423" id="423">
      <mxCell style="variable;fontSize=10;fontColor=#FF0000;" parent="862" vertex="1">
        <mxGeometry x="434.8800000000001" y="147.69" width="60" height="16.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="424">
      <mxCell style="link" parent="862" source="139" target="423" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="425">
      <mxCell style="link" parent="862" source="423" target="420" edge="1">
        <mxGeometry x="54.88000000000011" y="-15.560000000000002" width="100" height="100" as="geometry">
          <mxPoint x="54.88000000000011" y="84.44" as="sourcePoint" />
          <mxPoint x="154.8800000000001" y="-15.560000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="426">
      <mxCell style="link" parent="862" source="416" target="287" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="427">
      <mxCell style="link" parent="862" source="417" target="287" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="428">
      <mxCell style="link" parent="862" source="420" target="287" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="439">
      <mxCell style="link" parent="862" source="325" target="388" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="270" y="331.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="442" name="P_supply to society" id="444">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="862" vertex="1">
        <mxGeometry x="262.5" y="22.809999999999995" width="60" height="26.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="282">
      <mxCell style="link;fontSize=12;" parent="862" source="444" target="139" edge="1">
        <mxGeometry x="-1025" y="-10" width="100" height="100" as="geometry">
          <mxPoint x="-1025" y="90" as="sourcePoint" />
          <mxPoint x="-925" y="-10" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="510" name="fC switch" id="511">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;opacity=30;" parent="862" vertex="1">
        <mxGeometry x="56.25" y="395.74" width="56.25" height="18.88" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="518">
      <mxCell style="link" parent="862" source="511" target="324" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="520">
      <mxCell style="link" parent="862" source="384" target="324" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="330" y="321.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="521">
      <mxCell style="link" parent="862" source="314" target="324" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="-60" y="201.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="604">
      <mxCell style="link" parent="862" source="731" target="387" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="104.7128112689013" y="265.19676003791955" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="605">
      <mxCell style="link" parent="862" source="731" target="324" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="100.05020358702723" y="283.4606629312696" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="220" y="341.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="722">
      <mxCell style="link" parent="862" source="383" target="390" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="50" y="211.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="723">
      <mxCell style="link" parent="862" source="314" target="390" edge="1">
        <mxGeometry x="55" y="-6.500000000000001" width="100" height="100" as="geometry">
          <mxPoint x="55" y="93.5" as="sourcePoint" />
          <mxPoint x="155" y="-6.500000000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="50" y="181.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="724" name="Transition complete" oldId="731" id="731">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="862" vertex="1">
        <mxGeometry x="222" y="273.37" width="53" height="30" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="764">
      <mxCell style="link" parent="862" source="731" target="388" edge="1">
        <mxGeometry x="-5" y="-1.5" width="100" height="100" as="geometry">
          <mxPoint x="-5" y="98.5" as="sourcePoint" />
          <mxPoint x="95" y="-1.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="K_fC drain" Note="drainage velocity of CF_fC after transition is complete" Equation="0.1" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="10" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="766" id="766">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="862" vertex="1">
        <mxGeometry x="8.75" y="384.62" width="35" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="906">
      <mxCell style="link" parent="862" source="324" target="388" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
          <Array as="points">
            <mxPoint x="240" y="371.5" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1202" name="P_EoL fC total" id="1374">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="862" vertex="1">
        <mxGeometry x="215" y="370.87" width="34.5" height="27.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="1375">
      <mxCell style="link" parent="862" source="1374" target="390" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Setting Note="" Version="38" TimeLength="74" TimeStart="0" TimeStep="0.05" TimeUnits="Years" Units="a&lt;&gt;1&lt;&gt;Years&#xa;Gt&lt;&gt;1000000000&lt;&gt;Tonnes&#xa;GWh&lt;&gt;1000000000&lt;&gt;Watts*Hours&#xa;MW&lt;&gt;1&lt;&gt;Megawatts&#xa;PWh&lt;&gt;1000000000000000&lt;&gt;Watts*Hours&#xa;TW&lt;&gt;1000000000000&lt;&gt;Watts&#xa;W&lt;&gt;1&lt;&gt;Watts" HiddenUIGroups="Validation,User Interface" SolutionAlgorithm="RK4" BackgroundColor="white" Throttle="-1" Macros="" SensitivityPrimitives="1718" SensitivityRuns="50" SensitivityBounds="50, 80, 95, 100" SensitivityShowRuns="true" StyleSheet="{}" unfolding="{&quot;text&quot;:&quot;Root Node&quot;,&quot;data&quot;:&quot;&quot;,&quot;type&quot;:&quot;root&quot;,&quot;leaf&quot;:false,&quot;expanded&quot;:true,&quot;children&quot;:[{&quot;text&quot;:&quot;01 fossil baseline&quot;,&quot;data&quot;:&quot;&quot;,&quot;type&quot;:&quot;group&quot;,&quot;leaf&quot;:false,&quot;expanded&quot;:true,&quot;children&quot;:[{&quot;text&quot;:&quot;Show Message&quot;,&quot;data&quot;:&quot;&lt;div&gt;Baseline: we start with:&lt;/div&gt;&lt;div&gt;- Power demand is growing 3%/a;&lt;/div&gt;&lt;div&gt;- Only the fossil engine is in operation; i.e. the power demand is met by fossil supply.&lt;br&gt;&lt;/div&gt;&quot;,&quot;type&quot;:&quot;note&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]},{&quot;text&quot;:&quot;Value Change&quot;,&quot;data&quot;:&quot;{\\&quot;newValue\\&quot;:\\&quot;0.03\\&quot;,\\&quot;ids\\&quot;:[\\&quot;561\\&quot;]}&quot;,&quot;type&quot;:&quot;valueChange&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]},{&quot;text&quot;:&quot;Value Change&quot;,&quot;data&quot;:&quot;{\\&quot;newValue\\&quot;:\\&quot;0\\&quot;,\\&quot;ids\\&quot;:[\\&quot;371\\&quot;,\\&quot;523\\&quot;,\\&quot;218\\&quot;,\\&quot;788\\&quot;]}&quot;,&quot;type&quot;:&quot;valueChange&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]},{&quot;text&quot;:&quot;Value Change&quot;,&quot;data&quot;:&quot;{\\&quot;newValue\\&quot;:\\&quot;1\\&quot;,\\&quot;ids\\&quot;:[\\&quot;1311\\&quot;]}&quot;,&quot;type&quot;:&quot;valueChange&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]},{&quot;text&quot;:&quot;Run Simulation&quot;,&quot;data&quot;:&quot;{\\&quot;display\\&quot;:\\&quot;3\\&quot;}&quot;,&quot;type&quot;:&quot;simulate&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]}]},{&quot;text&quot;:&quot;02 fossil degrowth&quot;,&quot;type&quot;:&quot;group&quot;,&quot;leaf&quot;:false,&quot;expanded&quot;:true,&quot;children&quot;:[{&quot;text&quot;:&quot;Value Change&quot;,&quot;data&quot;:&quot;{\\&quot;newValue\\&quot;:\\&quot;-0.03\\&quot;,\\&quot;ids\\&quot;:[\\&quot;561\\&quot;]}&quot;,&quot;type&quot;:&quot;valueChange&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]},{&quot;text&quot;:&quot;Show Message&quot;,&quot;data&quot;:&quot;shrinking demand by -3%/a&lt;br&gt;&quot;,&quot;type&quot;:&quot;note&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]}]},{&quot;text&quot;:&quot;constant demand&quot;,&quot;data&quot;:&quot;&quot;,&quot;type&quot;:&quot;group&quot;,&quot;leaf&quot;:false,&quot;expanded&quot;:true,&quot;children&quot;:[{&quot;text&quot;:&quot;Show Message&quot;,&quot;data&quot;:&quot;Now we change the power demand to constant over time with the value in 2018. Still only the fossil engine is delivering.&lt;br&gt;&quot;,&quot;type&quot;:&quot;note&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]},{&quot;text&quot;:&quot;Value Change&quot;,&quot;data&quot;:&quot;{\\&quot;newValue\\&quot;:\\&quot;0\\&quot;,\\&quot;ids\\&quot;:[\\&quot;561\\&quot;]}&quot;,&quot;type&quot;:&quot;valueChange&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]},{&quot;text&quot;:&quot;Run Simulation&quot;,&quot;data&quot;:&quot;{\\&quot;display\\&quot;:\\&quot;3\\&quot;}&quot;,&quot;type&quot;:&quot;simulate&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]}]},{&quot;text&quot;:&quot;Show Message&quot;,&quot;data&quot;:&quot;Cummulative emissions reduce more than half from 10200 Gt in 2100 to 4800 Gt. &lt;br&gt;&quot;,&quot;type&quot;:&quot;note&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]},{&quot;text&quot;:&quot;fossil and CCS&quot;,&quot;data&quot;:&quot;&quot;,&quot;type&quot;:&quot;group&quot;,&quot;leaf&quot;:false,&quot;expanded&quot;:true,&quot;children&quot;:[{&quot;text&quot;:&quot;Visibility Change&quot;,&quot;data&quot;:&quot;{\\&quot;opacity\\&quot;:100,\\&quot;ids\\&quot;:[\\&quot;167\\&quot;,\\&quot;168\\&quot;,\\&quot;169\\&quot;,\\&quot;170\\&quot;,\\&quot;171\\&quot;,\\&quot;174\\&quot;,\\&quot;175\\&quot;,\\&quot;177\\&quot;,\\&quot;178\\&quot;,\\&quot;179\\&quot;,\\&quot;198\\&quot;,\\&quot;202\\&quot;,\\&quot;208\\&quot;,\\&quot;349\\&quot;,\\&quot;350\\&quot;,\\&quot;577\\&quot;,\\&quot;578\\&quot;,\\&quot;579\\&quot;,\\&quot;580\\&quot;,\\&quot;581\\&quot;,\\&quot;582\\&quot;,\\&quot;583\\&quot;,\\&quot;585\\&quot;,\\&quot;587\\&quot;,\\&quot;907\\&quot;,\\&quot;908\\&quot;]}&quot;,&quot;type&quot;:&quot;visibility&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]},{&quot;text&quot;:&quot;Value Change&quot;,&quot;data&quot;:&quot;{\\&quot;newValue\\&quot;:\\&quot;1\\&quot;,\\&quot;ids\\&quot;:[\\&quot;371\\&quot;]}&quot;,&quot;type&quot;:&quot;valueChange&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]},{&quot;text&quot;:&quot;Run Simulation&quot;,&quot;data&quot;:&quot;{\\&quot;display\\&quot;:\\&quot;3\\&quot;}&quot;,&quot;type&quot;:&quot;simulate&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]},{&quot;text&quot;:&quot;Note Message&quot;,&quot;data&quot;:&quot;{\\&quot;ids\\&quot;: []}&quot;,&quot;type&quot;:&quot;noteMessage&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]},{&quot;text&quot;:&quot;Show Message&quot;,&quot;data&quot;:&quot;Now we add CCS to the fossil engine to reduce the cumulative CO2 emissions. The fossil engine delivers the constant demand and powers the CCS.&lt;br&gt;&quot;,&quot;type&quot;:&quot;note&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]}]},{&quot;text&quot;:&quot;Value Change&quot;,&quot;data&quot;:&quot;{\\&quot;newValue\\&quot;:\\&quot;100\\&quot;,\\&quot;ids\\&quot;:[]}&quot;,&quot;type&quot;:&quot;valueChange&quot;,&quot;leaf&quot;:true,&quot;expanded&quot;:false,&quot;children&quot;:[]}]}" unfoldingStatus="on" unfoldingAuto="never" SlidersList="[{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;229&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;371&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;510&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;523&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1853&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;907&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;561&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1305&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1311&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1320&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1321&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1406&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;151&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;317&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;421&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;218&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;217&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;216&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;788&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;822&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;866&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;881&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;926&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;929&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1414&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1485&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1487&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1489&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;347&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;433&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1042&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;743&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;749&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;752&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1074&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1218&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1219&quot;},{&quot;type&quot;:&quot;primitive&quot;,&quot;id&quot;:&quot;1220&quot;}]" version="39" id="2">
      <mxCell parent="1" vertex="1" visible="0">
        <mxGeometry x="20" y="20" width="80" height="40" as="geometry" />
      </mxCell>
    </Setting>
    <Link name="Link" Note="" BiDirectional="false" id="339">
      <mxCell style="link" parent="1" source="182" target="338" edge="1">
        <mxGeometry x="-40" y="16" width="100" height="100" as="geometry">
          <mxPoint x="-40" y="116" as="sourcePoint" />
          <mxPoint x="60" y="16" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="341">
      <mxCell style="link" parent="1" source="185" target="338" edge="1">
        <mxGeometry x="-40" y="16" width="100" height="100" as="geometry">
          <mxPoint x="-40" y="116" as="sourcePoint" />
          <mxPoint x="60" y="16" as="targetPoint" />
          <Array as="points">
            <mxPoint x="970" y="440" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="344">
      <mxCell style="link" parent="1" source="183" target="338" edge="1">
        <mxGeometry x="-40" y="16" width="100" height="100" as="geometry">
          <mxPoint x="-40" y="116" as="sourcePoint" />
          <mxPoint x="60" y="16" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="564">
      <mxCell style="link" parent="1" source="560" target="143" edge="1">
        <mxGeometry x="20" y="16" width="100" height="100" as="geometry">
          <mxPoint x="20" y="116" as="sourcePoint" />
          <mxPoint x="120" y="16" as="targetPoint" />
          <Array as="points">
            <mxPoint x="1020" y="220" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="additional demand (growing and operating PV, CCS and fC)" Note="" Type="None" Solver="{&quot;enabled&quot;: false, &quot;algorithm&quot;: &quot;RK1&quot;, &quot;timeStep&quot;: 1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="368" id="368">
      <mxCell style="folder;image=None;shape=rectangle;" parent="1" vertex="1">
        <mxGeometry x="3890" y="29.999999999999986" width="1030" height="814" as="geometry">
          <mxRectangle x="1130" y="489" width="130" height="20" as="alternateBounds" />
        </mxGeometry>
      </mxCell>
    </Folder>
    <Variable name="CF_CCS" Note="The load factor of the machine. It is modulating the consumed/produced power. The load factor can be implemented as a power controller which e.g. keeps the energy content of the &#39;grid&#39; constant&lt;br&gt;" Equation="If [CF_CCS 2]&lt;0 Then&#xa;  0&#xa;Else If [CF_CCS 2]&gt;1 Then&#xa;  1&#xa;Else&#xa;  [CF_CCS 2]&#xa;End If" Units="Unitless" MaxConstraintUsed="true" MinConstraintUsed="true" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="180" id="180">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="620.88" y="661.32" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_CCS ordered" Note="Power to build new CCS capacity&lt;br&gt;" Equation="#[P_CCS ordered 2]&#xa;If [P_CCS ordered 2]&gt;=[maximum CCS installation rate] Then&#xa;  [maximum CCS installation rate]&#xa;Else&#xa;  [P_CCS ordered 2]&#xa;End If" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="206" id="206">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="445.51" y="661.3199999999999" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="362" id="362">
      <mxCell style="link" parent="368" source="380" target="873" edge="1">
        <mxGeometry x="-1095.12" y="-424.68000000000006" width="100" height="100" as="geometry">
          <mxPoint x="-1095.12" y="-324.68" as="sourcePoint" />
          <mxPoint x="-995.1199999999999" y="-424.68000000000006" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="365" id="365">
      <mxCell style="link" parent="368" source="380" target="832" edge="1">
        <mxGeometry x="-1014.5" y="-428.23" width="100" height="100" as="geometry">
          <mxPoint x="-1014.5" y="-328.23" as="sourcePoint" />
          <mxPoint x="-914.5" y="-428.23" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="171" name="P_nomCCS" oldId="367" id="367">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="534.25" y="510.49" width="60" height="26.76" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="369" id="369">
      <mxCell style="link" parent="368" source="367" target="873" edge="1">
        <mxGeometry x="-15.120000000000005" y="21.569999999999993" width="100" height="100" as="geometry">
          <mxPoint x="-15.120000000000005" y="121.57000000000002" as="sourcePoint" />
          <mxPoint x="84.88" y="21.569999999999993" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="370" id="370">
      <mxCell style="link" parent="368" source="367" target="832" edge="1">
        <mxGeometry x="-15.120000000000005" y="21.569999999999993" width="100" height="100" as="geometry">
          <mxPoint x="-15.120000000000005" y="121.57000000000002" as="sourcePoint" />
          <mxPoint x="84.88" y="21.569999999999993" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="371" name="CCS switch" oldId="372" id="372">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="535.5" y="462.06" width="60" height="36.86" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="373" id="373">
      <mxCell style="link" parent="368" source="372" target="832" edge="1">
        <mxGeometry x="-15.120000000000005" y="21.569999999999993" width="100" height="100" as="geometry">
          <mxPoint x="-15.120000000000005" y="121.57000000000002" as="sourcePoint" />
          <mxPoint x="84.88" y="21.569999999999993" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="378" id="378">
      <mxCell style="link" parent="368" source="372" target="873" edge="1">
        <mxGeometry x="-15.120000000000005" y="21.569999999999993" width="100" height="100" as="geometry">
          <mxPoint x="-15.120000000000005" y="121.57000000000002" as="sourcePoint" />
          <mxPoint x="84.88" y="21.569999999999993" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_CCS" Note="Power used for CCS only when clean up is not complete&lt;br&gt;" Equation="If [CCS complete]=0 Then&#xa;    If [Transition complete]=0 Then&#xa;        [epsilon in transition]*[P available for CCS]&#xa;    Else&#xa;        [epsilon after transition]*[P available for CCS]&#xa;    End If&#xa;Else&#xa;    0&#xa;End If" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="380" id="380">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="464.88" y="390.82" width="90" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="247" name="P_demand" oldId="441" id="441">
      <mxCell style="variable;fontSize=12;fillColor=#FDCDAC;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="265" y="29.63" width="90" height="23.75" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="beta in transition" Note="&lt;div&gt;Fraction of available capacity that is used to grow PV during transition&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;" Equation="0.6" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="218" id="218">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="368" vertex="1">
        <mxGeometry x="60" y="327" width="71" height="30.63" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="alpha" Note="Fraction of PV output that is made available to the remaining system during the transition. (1-alpha is used to grow the PV engine)" Equation="0.7" Units="Unitless" MaxConstraintUsed="true" MinConstraintUsed="true" MaxConstraint="1" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="217" id="217">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="368" vertex="1">
        <mxGeometry x="305" y="457.5" width="35" height="34.25" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="oversize PV" Note="factor of how much nominal power needs to be larger than demand P_nomPV / P_demand" Equation="1.1" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="2" SliderMin="1" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="216" id="216">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="368" vertex="1">
        <mxGeometry x="63" y="165.87" width="87" height="24.25" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P available for PV, variable" Note="Power to grow PV from idle capacity available in the system" Equation="If [Transition complete]=0 Then&#xa;  Max({0 TW},[beta in transition]*([P_nomfC]-[P system demand]-[P available for fC])*[gamma])*[Al supply gap correction function switched]&#xa;Else If [PV big enough]=0 Then&#xa;  [beta after transition]*[P for allocation to 3 machines]&#xa;Else&#xa;  0&#xa;End If" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="541" id="541">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="147.82" y="327" width="80" height="78.74" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_PV ordered from PV, alpha 1" Note="Power to grow PV from its own energy harvest (which is then not available for other uses in the system)&lt;br&gt;" Equation="If [Transition complete]=0 Then&#xa;  (1-[alpha])*[P_nomPV]*[Al supply gap correction function switched]&#xa;Else&#xa;  0&#xa;End If&#xa;&#xa;" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="543" id="543">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="225.31" y="400" width="70.63" height="66.57" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="546">
      <mxCell style="link" parent="368" source="217" target="543" edge="1">
        <mxGeometry x="85" y="77.25" width="100" height="100" as="geometry">
          <mxPoint x="85" y="177.25" as="sourcePoint" />
          <mxPoint x="185" y="77.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="547">
      <mxCell style="link" parent="368" source="794" target="543" edge="1">
        <mxGeometry x="85" y="77.25" width="100" height="100" as="geometry">
          <mxPoint x="235.3665150459865" y="470.7611920103162" as="sourcePoint" />
          <mxPoint x="185" y="77.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="549">
      <mxCell style="link" parent="368" source="851" target="700" edge="1">
        <mxGeometry x="85" y="77.25" width="100" height="100" as="geometry">
          <mxPoint x="85" y="177.25" as="sourcePoint" />
          <mxPoint x="209.5176917966303" y="563.5051818658707" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="551">
      <mxCell style="link" parent="368" source="992" target="700" edge="1">
        <mxGeometry x="85" y="77.25" width="100" height="100" as="geometry">
          <mxPoint x="85" y="177.25" as="sourcePoint" />
          <mxPoint x="234.76751995802715" y="570.43353916296" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_PV ordered" Note="Power to build new PV systems and for repair&lt;br&gt;" Equation="#[P_PV ordered from fC, variable]+[P_PV ordered from PV, alpha]+[P_PV ordered for repair]&#xa;&#xa;If [P_PV ordered from fC, variable]+[P_PV ordered from PV, alpha]+[P_PV ordered for repair]&gt;=[maximum PV installation rate] Then&#xa;  [maximum PV installation rate]&#xa;Else&#xa;  [P_PV ordered from fC, variable]+[P_PV ordered from PV, alpha]+[P_PV ordered for repair]&#xa;End If" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="700" id="700">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="150" y="655.99" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="724" name="Transition complete" id="771">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="370" y="278.87" width="53" height="30" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="P additional demand available" Note="Power for growing and operating PV, CCS and fC (repair excluded)" Equation="([P maximum supply]-[P system demand]-[P_PV ordered from PV, alpha 1])#*[Al supply gap correction function switched]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="780" id="780">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="260" y="99.5" width="80" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="782">
      <mxCell style="link" parent="368" source="820" target="541" edge="1">
        <mxGeometry x="15" y="-24" width="100" height="100" as="geometry">
          <mxPoint x="15" y="76" as="sourcePoint" />
          <mxPoint x="115" y="-24" as="targetPoint" />
          <Array as="points">
            <mxPoint x="260" y="177" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="783">
      <mxCell style="link" parent="368" source="218" target="541" edge="1">
        <mxGeometry x="15" y="-24" width="100" height="100" as="geometry">
          <mxPoint x="15" y="76" as="sourcePoint" />
          <mxPoint x="115" y="-24" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="784">
      <mxCell style="link" parent="368" source="771" target="541" edge="1">
        <mxGeometry x="15" y="-24" width="100" height="100" as="geometry">
          <mxPoint x="15" y="76" as="sourcePoint" />
          <mxPoint x="115" y="-24" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="beta after transition" Note="&lt;div&gt;Fraction of available idle capacity that is used to grow PV after transition when [P_nomPV]&amp;lt;[oversize PV]*[P_demand_req]&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;" Equation="0.5" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="788" id="788">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="368" vertex="1">
        <mxGeometry x="60" y="357.63" width="71" height="34.25" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="789">
      <mxCell style="link" parent="368" source="788" target="541" edge="1">
        <mxGeometry x="15" y="-24" width="100" height="100" as="geometry">
          <mxPoint x="15" y="76" as="sourcePoint" />
          <mxPoint x="115" y="-24" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="790">
      <mxCell style="link" parent="368" source="820" target="1264" edge="1">
        <mxGeometry x="15" y="-24" width="100" height="100" as="geometry">
          <mxPoint x="15" y="76" as="sourcePoint" />
          <mxPoint x="660.0956112461963" y="285.60209758851545" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="792">
      <mxCell style="link" parent="368" source="771" target="543" edge="1">
        <mxGeometry x="15" y="-24" width="100" height="100" as="geometry">
          <mxPoint x="15" y="76" as="sourcePoint" />
          <mxPoint x="115" y="-24" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="185" name="P_nomPV" id="794">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="255" y="252.26" width="60" height="30" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="132" name="P_nomfC" id="795">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="464.88" y="197.13" width="60" height="25.25" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="P for allocation to 3 machines" Note="Power for growing and operating PV, CCS and fC (repair excluded)" Equation="[gamma]*Max({0 TW},[P additional demand available])" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="820" id="820">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="385.5" y="97" width="74.5" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="821">
      <mxCell style="link" parent="368" source="780" target="820" edge="1">
        <mxGeometry x="10" y="-64" width="100" height="100" as="geometry">
          <mxPoint x="10" y="36" as="sourcePoint" />
          <mxPoint x="110" y="-64" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="gamma" Note="Fraction of available power for internal demand that is utilized" Equation="0.95" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="822" id="822">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="368" vertex="1">
        <mxGeometry x="388" y="24.379999999999995" width="53.5" height="34.25" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="823">
      <mxCell style="link" parent="368" source="822" target="820" edge="1">
        <mxGeometry x="10" y="-64" width="100" height="100" as="geometry">
          <mxPoint x="10" y="36" as="sourcePoint" />
          <mxPoint x="110" y="-64" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="829">
      <mxCell style="link" parent="368" source="543" target="780" edge="1">
        <mxGeometry x="15" y="-24" width="100" height="100" as="geometry">
          <mxPoint x="15" y="76" as="sourcePoint" />
          <mxPoint x="115" y="-24" as="targetPoint" />
          <Array as="points">
            <mxPoint x="340" y="357" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_CCS ordered 1" Note="Power required to grow CCS: whenever the maximum possible operation of CCS is smaller than the available power, the difference is invested in growing CCS.&lt;br&gt;" Equation="IfThenElse([CCS switch]=0, 0, IfThenElse([CF_CCS, max, effective]*[P_nomCCS]&gt;[P_CCS], 0, ([P_CCS]-[CF_CCS, max, effective]*[P_nomCCS])*[Al supply gap correction function switched]))" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="832" id="832">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="445.51" y="466.57" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="CCS increase limit" Note="maximum rate of change for increasing power for ordering new capacity&lt;br&gt;" Equation="0.01" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="10" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="834" id="834">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;" parent="368" vertex="1">
        <mxGeometry x="524.88" y="542.3299999999999" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="d_P_CCS ordered" Note="derivative" Equation="([P_CCS ordered 1]-[P_CCS ordered 2])/TimeStep()" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="835" id="835">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="445.5" y="542.3299999999999" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="836" id="836">
      <mxCell style="link" parent="368" source="832" target="835" edge="1">
        <mxGeometry x="-95.12" y="-134.43" width="100" height="100" as="geometry">
          <mxPoint x="-95.12" y="-34.43000000000001" as="sourcePoint" />
          <mxPoint x="4.8799999999999955" y="-134.43" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="P_CCS ordered 2" Note="power for ordering CCS capacity, limited by increase and decrease rates" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="838" id="838">
      <mxCell style="stock;fontSize=10;" parent="368" vertex="1">
        <mxGeometry x="441.5" y="614.02" width="80" height="29" as="geometry" />
      </mxCell>
    </Stock>
    <Link name="Link" Note="" BiDirectional="false" oldId="841" id="841">
      <mxCell style="link" parent="368" source="838" target="206" edge="1">
        <mxGeometry x="-395.12" y="-19.680000000000007" width="100" height="100" as="geometry">
          <mxPoint x="-395.12" y="80.32" as="sourcePoint" />
          <mxPoint x="-295.12" y="-19.680000000000007" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="CCS decrease limit" Note="maximum rate of change for decreasing power for ordering new capacity" Equation="-10.44" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0" SliderMin="-1" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="842" id="842">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;" parent="368" vertex="1">
        <mxGeometry x="524.88" y="661.3199999999999" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Flow name="_CCS slew rate" Note="rate of change for ramping up/down orders for new capacity" FlowRate="If [d_P_CCS ordered] &gt; [CCS increase limit] Then&#xa;  [CCS increase limit]&#xa;Else If [d_P_CCS ordered] &lt; [CCS decrease limit] Then&#xa;  [CCS decrease limit]&#xa;Else&#xa;  [d_P_CCS ordered]&#xa;End If" OnlyPositive="false" TimeIndependent="false" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="839" id="839">
      <mxCell style="flow;startArrow=block;startFill=0;fontSize=10;" parent="368" target="838" edge="1">
        <mxGeometry x="-125.12" y="-19.669999999999987" width="100" height="100" as="geometry">
          <mxPoint x="600.88" y="632.3299999999999" as="sourcePoint" />
          <mxPoint x="-1093.87" y="-458.27" as="targetPoint" />
          <mxPoint y="9" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="843" id="843">
      <mxCell style="link" parent="368" source="835" target="839" edge="1">
        <mxGeometry x="-1525.12" y="-448.68000000000006" width="100" height="100" as="geometry">
          <mxPoint x="-1525.12" y="-348.68" as="sourcePoint" />
          <mxPoint x="-1425.12" y="-448.68000000000006" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="844" id="844">
      <mxCell style="link" parent="368" source="834" target="839" edge="1">
        <mxGeometry x="-1525.12" y="-448.68000000000006" width="100" height="100" as="geometry">
          <mxPoint x="-1525.12" y="-348.68" as="sourcePoint" />
          <mxPoint x="-1425.12" y="-448.68000000000006" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="845" id="845">
      <mxCell style="link" parent="368" source="842" target="839" edge="1">
        <mxGeometry x="-1525.12" y="-448.68000000000006" width="100" height="100" as="geometry">
          <mxPoint x="-1525.12" y="-348.68" as="sourcePoint" />
          <mxPoint x="-1425.12" y="-448.68000000000006" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="_PV increase limit" Note="maximum rate of change for increasing power for ordering new capacity&lt;br&gt;" Equation="0.4" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="848" id="848">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;" parent="368" vertex="1">
        <mxGeometry x="135" y="450.49" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="d_P_PV ordered from fC, variable 1" Note="derivative" Equation="([P available for PV, variable]-[P_PV ordered from fC, variable])/TimeStep()" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="849" id="849">
      <mxCell style="variable;fontSize=8;" parent="368" vertex="1">
        <mxGeometry x="50.629999999999995" y="450.49" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="850" id="850">
      <mxCell style="link" parent="368" source="541" target="849" edge="1">
        <mxGeometry x="-1620" y="-632.89" width="100" height="100" as="geometry">
          <mxPoint x="110.63000000000147" y="487.11" as="sourcePoint" />
          <mxPoint x="-1520" y="-632.89" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="P_PV ordered from fC, variable" Note="power for ordering new PV capacity from idle capacity in the system" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="851" id="851">
      <mxCell style="stock;fontSize=10;" parent="368" vertex="1">
        <mxGeometry x="40" y="525.6" width="81.25" height="29" as="geometry" />
      </mxCell>
    </Stock>
    <Variable name="_PV decrease limit" Note="maximum rate of change for decreasing power for ordering new capacity" Equation="-10" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0" SliderMin="-10" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="854" id="854">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;" parent="368" vertex="1">
        <mxGeometry x="135" y="569.35" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Flow name="_PV slew rate" Note="rate of change for ramping up/down orders for new capacity" FlowRate="If [d_P_PV ordered from fC, variable 1] &gt; [_PV increase limit] Then&#xa;  [_PV increase limit]&#xa;Else If [d_P_PV ordered from fC, variable 1] &lt; [_PV decrease limit] Then&#xa;  [_PV decrease limit]&#xa;Else&#xa;  [d_P_PV ordered from fC, variable 1]&#xa;End If" OnlyPositive="false" TimeIndependent="false" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="855" id="855">
      <mxCell style="flow;startArrow=block;startFill=0;fontSize=10;" parent="368" target="851" edge="1">
        <mxGeometry x="-1650" y="-540.64" width="100" height="100" as="geometry">
          <mxPoint x="209.99999999999977" y="539.7599999999999" as="sourcePoint" />
          <mxPoint x="-2618.75" y="-979.24" as="targetPoint" />
          <mxPoint y="9" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="856" id="856">
      <mxCell style="link" parent="368" source="849" target="855" edge="1">
        <mxGeometry x="-3050" y="-1029.65" width="100" height="100" as="geometry">
          <mxPoint x="-3050" y="-929.6500000000001" as="sourcePoint" />
          <mxPoint x="-2950" y="-1029.65" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="857" id="857">
      <mxCell style="link" parent="368" source="848" target="855" edge="1">
        <mxGeometry x="-3050" y="-1029.65" width="100" height="100" as="geometry">
          <mxPoint x="-3050" y="-929.6500000000001" as="sourcePoint" />
          <mxPoint x="-2950" y="-1029.65" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="858" id="858">
      <mxCell style="link" parent="368" source="854" target="855" edge="1">
        <mxGeometry x="-3050" y="-1029.65" width="100" height="100" as="geometry">
          <mxPoint x="-3050" y="-929.6500000000001" as="sourcePoint" />
          <mxPoint x="-2950" y="-1029.65" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="859" id="859">
      <mxCell style="link" parent="368" source="851" target="849" edge="1">
        <mxGeometry x="15" y="-24" width="100" height="100" as="geometry">
          <mxPoint x="15" y="76" as="sourcePoint" />
          <mxPoint x="115" y="-24" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="863" id="863">
      <mxCell style="link" parent="368" source="838" target="835" edge="1">
        <mxGeometry x="-89.12" y="-18.669999999999987" width="100" height="100" as="geometry">
          <mxPoint x="-89.12" y="81.33" as="sourcePoint" />
          <mxPoint x="10.879999999999995" y="-18.669999999999987" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="864">
      <mxCell style="link" parent="368" source="441" target="1167" edge="1">
        <mxGeometry x="15" y="-24" width="100" height="100" as="geometry">
          <mxPoint x="15" y="76" as="sourcePoint" />
          <mxPoint x="115" y="-24" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P available for fC" Note="Power available to grow the fossil engine&lt;br&gt;" Equation="If [Transition complete]=0 And [CF_fC]&gt;0.5 Then&#xa;    ([delta in transition]*([P for allocation to 3 machines]) + [delta for growing with demand]*[proportion of growing fC needed]*([P for allocation to 3 machines]))*[Al supply gap correction function switched]&#xa;Else&#xa;  0&#xa;End If" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="865" id="865">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="807.5" y="212.26" width="90" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="delta in transition" Note="Fraction of the power used to grow the fossil engine during the transition&lt;br&gt;" Equation="0" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="866" id="866">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="368" vertex="1">
        <mxGeometry x="915" y="184.07" width="80" height="34.25" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="867">
      <mxCell style="link" parent="368" source="866" target="865" edge="1">
        <mxGeometry x="182.5" y="-67.25" width="100" height="100" as="geometry">
          <mxPoint x="182.5" y="32.75" as="sourcePoint" />
          <mxPoint x="282.5" y="-67.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="868">
      <mxCell style="link" parent="368" source="865" target="885" edge="1">
        <mxGeometry x="182.5" y="111.75" width="100" height="100" as="geometry">
          <mxPoint x="182.5" y="211.75" as="sourcePoint" />
          <mxPoint x="282.5" y="111.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="869">
      <mxCell style="link" parent="368" source="820" target="865" edge="1">
        <mxGeometry x="15" y="111.75" width="100" height="100" as="geometry">
          <mxPoint x="15" y="211.75" as="sourcePoint" />
          <mxPoint x="115" y="111.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="CF_CCS 1" Note="Capacity factor of CCS: tries to use as much of the available power as possible to operate CCS at maximum speed.&lt;br&gt;" Equation="IfThenElse([CCS switch]=0, 0, IfThenElse([P_CCS]&gt;=[CF_CCS, max, effective]*[P_nomCCS], [CF_CCS, max, effective], IfThenElse([P_nomCCS]&lt;={0 TW}, [CF_CCS, max, effective], ([P_CCS])/([P_nomCCS]))))" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="873" id="873">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="620.88" y="466.56999999999994" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="874">
      <mxCell style="link" parent="368" source="1007" target="180" edge="1">
        <mxGeometry x="15.620000000000005" y="95.02" width="100" height="100" as="geometry">
          <mxPoint x="15.620000000000005" y="195.01999999999998" as="sourcePoint" />
          <mxPoint x="115.62" y="95.02" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="oversize fC" Note="factor of how much nominal power needs to be larger than demand P_nomfC / P_demand" Equation="1.3" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="877" id="877">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;strokeColor=#000000;" parent="368" vertex="1">
        <mxGeometry x="459.5" y="31.750000000000007" width="87" height="24.25" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="878">
      <mxCell style="link" parent="368" source="795" target="1171" edge="1">
        <mxGeometry x="15" y="111.75" width="100" height="100" as="geometry">
          <mxPoint x="15" y="211.75" as="sourcePoint" />
          <mxPoint x="115" y="111.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="879">
      <mxCell style="link" parent="368" source="877" target="1171" edge="1">
        <mxGeometry x="182.5" y="-67.25" width="100" height="100" as="geometry">
          <mxPoint x="182.5" y="32.75" as="sourcePoint" />
          <mxPoint x="282.5" y="-67.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="880">
      <mxCell style="link" parent="368" source="441" target="1171" edge="1">
        <mxGeometry x="15" y="111.75" width="100" height="100" as="geometry">
          <mxPoint x="15" y="211.75" as="sourcePoint" />
          <mxPoint x="115" y="111.75" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="delta for growing with demand" Note="Fraction of the power used to grow the fossil engine if [P_nomfC] &amp;lt; [oversize fC] * [P_demand_req]&lt;br&gt;" Equation="0.8" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="881" id="881">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="368" vertex="1">
        <mxGeometry x="915" y="245.76" width="80" height="43" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="882">
      <mxCell style="link" parent="368" source="881" target="865" edge="1">
        <mxGeometry x="182.5" y="-67.25" width="100" height="100" as="geometry">
          <mxPoint x="182.5" y="32.75" as="sourcePoint" />
          <mxPoint x="282.5" y="-67.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="_fC increase limit" Note="maximum rate of change for increasing power for ordering new capacity&lt;br&gt;" Equation="2" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="884" id="884">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;" parent="368" vertex="1">
        <mxGeometry x="906" y="351.81" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="d_P_fC ordered" Note="differential of power for ordering additional fC capacity" Equation="([P available for fC]-[P_fC ordered])/TimeStep()" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="885" id="885">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="821.6300000000001" y="351.81" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Stock name="P_fC ordered" Note="power ordered for new capacity" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="886" id="886">
      <mxCell style="stock;fontSize=10;" parent="368" vertex="1">
        <mxGeometry x="811" y="426.92" width="81.25" height="29" as="geometry" />
      </mxCell>
    </Stock>
    <Variable name="_fC decrease limit" Note="maximum rate of change for decreasing power for ordering new capacity&lt;br&gt;" Equation="-2.96" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0" SliderMin="-10" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="888" id="888">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;" parent="368" vertex="1">
        <mxGeometry x="906" y="470.67" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Flow name="_fC slew rate" Note="rate of change for ramping up/down orders for new capacity" FlowRate="If [d_P_fC ordered] &gt; [_fC increase limit] Then&#xa;  [_fC increase limit]&#xa;Else If [d_P_fC ordered] &lt; [_fC decrease limit] Then&#xa;  [_fC decrease limit]&#xa;Else&#xa;  [d_P_fC ordered]&#xa;End If" OnlyPositive="false" TimeIndependent="false" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="889" id="889">
      <mxCell style="flow;startArrow=block;startFill=0;fontSize=10;" parent="368" target="886" edge="1">
        <mxGeometry x="-2009" y="-1128.32" width="100" height="100" as="geometry">
          <mxPoint x="980.9999999999998" y="441.07999999999987" as="sourcePoint" />
          <mxPoint x="-2977.75" y="-1566.92" as="targetPoint" />
          <mxPoint y="9" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="890" id="890">
      <mxCell style="link" parent="368" source="885" target="889" edge="1">
        <mxGeometry x="-3409" y="-1617.3300000000002" width="100" height="100" as="geometry">
          <mxPoint x="-3409" y="-1517.3300000000002" as="sourcePoint" />
          <mxPoint x="-3309" y="-1617.3300000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="891" id="891">
      <mxCell style="link" parent="368" source="884" target="889" edge="1">
        <mxGeometry x="-3409" y="-1617.3300000000002" width="100" height="100" as="geometry">
          <mxPoint x="-3409" y="-1517.3300000000002" as="sourcePoint" />
          <mxPoint x="-3309" y="-1617.3300000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="892" id="892">
      <mxCell style="link" parent="368" source="888" target="889" edge="1">
        <mxGeometry x="-3409" y="-1617.3300000000002" width="100" height="100" as="geometry">
          <mxPoint x="-3409" y="-1517.3300000000002" as="sourcePoint" />
          <mxPoint x="-3309" y="-1617.3300000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="893" id="893">
      <mxCell style="link" parent="368" source="886" target="885" edge="1">
        <mxGeometry x="-344" y="-611.6800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-344" y="-511.68" as="sourcePoint" />
          <mxPoint x="-244" y="-611.6800000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="324" name="CF_fC" id="922">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="824.5" y="150.57" width="60" height="29.87" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="923">
      <mxCell style="link" parent="368" source="922" target="865" edge="1">
        <mxGeometry x="182.5" y="-67.25" width="100" height="100" as="geometry">
          <mxPoint x="182.5" y="32.75" as="sourcePoint" />
          <mxPoint x="282.5" y="-67.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="epsilon in transition" Note="fraction of remaining power for additional demand used in CCS during the transition&lt;br&gt;" Equation="0.5" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="926" id="926">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="368" vertex="1">
        <mxGeometry x="360" y="357.63" width="78" height="37" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="927">
      <mxCell style="link" parent="368" source="926" target="380" edge="1">
        <mxGeometry x="81.5" y="111.75" width="100" height="100" as="geometry">
          <mxPoint x="81.5" y="211.75" as="sourcePoint" />
          <mxPoint x="181.5" y="111.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="928">
      <mxCell style="link" parent="368" source="771" target="380" edge="1">
        <mxGeometry x="15" y="111.75" width="100" height="100" as="geometry">
          <mxPoint x="15" y="211.75" as="sourcePoint" />
          <mxPoint x="115" y="111.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="epsilon after transition" Note="&lt;div&gt;fraction of remaining power for additional demand used in CCS after transition&lt;/div&gt;" Equation="1" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="929" id="929">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="368" vertex="1">
        <mxGeometry x="360" y="406.57" width="76.5" height="34.25" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="930">
      <mxCell style="link" parent="368" source="929" target="380" edge="1">
        <mxGeometry x="81.5" y="111.75" width="100" height="100" as="geometry">
          <mxPoint x="81.5" y="211.75" as="sourcePoint" />
          <mxPoint x="181.5" y="111.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="CF_CCS, max, effective" Note="Maximum capacity factor for CCS. If power is supplied by fossil engine, CF can reach 100%; when power is supplied by PV engine, then CF&amp;lt;CF_CCS max&lt;br&gt;" Equation="[fraction of supply fossil]+(1-[fraction of supply fossil])*[CF_CCS, max]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="932" id="932">
      <mxCell style="variable;fontSize=12;fillColor=#FDCDAC;" parent="368" vertex="1">
        <mxGeometry x="620.88" y="380.8199999999999" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="934">
      <mxCell style="link" parent="368" source="932" target="873" edge="1">
        <mxGeometry x="15" y="111.75" width="100" height="100" as="geometry">
          <mxPoint x="15" y="211.75" as="sourcePoint" />
          <mxPoint x="115" y="111.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="935">
      <mxCell style="link" parent="368" source="932" target="832" edge="1">
        <mxGeometry x="15" y="111.75" width="100" height="100" as="geometry">
          <mxPoint x="15" y="211.75" as="sourcePoint" />
          <mxPoint x="115" y="111.75" as="targetPoint" />
          <Array as="points">
            <mxPoint x="570" y="407" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="947" name="CCS complete" id="951">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="546.5000000000001" y="361.88" width="53" height="30" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="952">
      <mxCell style="link" parent="368" source="951" target="380" edge="1">
        <mxGeometry x="81.5" y="111.75" width="100" height="100" as="geometry">
          <mxPoint x="81.5" y="211.75" as="sourcePoint" />
          <mxPoint x="181.5" y="111.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="P_PV ordered from PV, alpha" Note="power for ordering new PV capacity from PV harvest during the transition" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="992" id="992">
      <mxCell style="stock;fontSize=10;" parent="368" vertex="1">
        <mxGeometry x="220" y="525.6" width="81.25" height="29" as="geometry" />
      </mxCell>
    </Stock>
    <Variable name="_PV_alpha decrease limit" Note="maximum rate of change for decreasing power for ordering new capacity" Equation="-0.4" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="0" SliderMin="-10" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="994" id="994">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;" parent="368" vertex="1">
        <mxGeometry x="315" y="569.35" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Flow name="_PV_a slew rate" Note="rate of change for ramping down orders for new capacity" FlowRate="If [d_P_PV ordered from PV, alpha] &lt; [_PV_alpha decrease limit] Then&#xa;  [_PV_alpha decrease limit]&#xa;Else&#xa;  [d_P_PV ordered from PV, alpha]&#xa;End If" OnlyPositive="false" TimeIndependent="false" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="995" id="995">
      <mxCell style="flow;startArrow=block;startFill=0;fontSize=10;" parent="368" target="992" edge="1">
        <mxGeometry x="-2600" y="-1029.6399999999999" width="100" height="100" as="geometry">
          <mxPoint x="389.9999999999998" y="539.7599999999999" as="sourcePoint" />
          <mxPoint x="-3568.75" y="-1468.24" as="targetPoint" />
          <mxPoint y="9" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="996" id="996">
      <mxCell style="link" parent="368" source="1000" target="995" edge="1">
        <mxGeometry x="-4000" y="-1518.65" width="100" height="100" as="geometry">
          <mxPoint x="285.24481270450883" y="497.639664589207" as="sourcePoint" />
          <mxPoint x="-3900" y="-1518.65" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="998" id="998">
      <mxCell style="link" parent="368" source="994" target="995" edge="1">
        <mxGeometry x="-3933.5" y="-1518.65" width="100" height="100" as="geometry">
          <mxPoint x="-3933.5" y="-1418.65" as="sourcePoint" />
          <mxPoint x="-3833.5" y="-1518.65" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="999" id="999">
      <mxCell style="link" parent="368" source="992" target="1000" edge="1">
        <mxGeometry x="-935" y="-513" width="100" height="100" as="geometry">
          <mxPoint x="-935" y="-413" as="sourcePoint" />
          <mxPoint x="260.6300000000001" y="510.4900000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="d_P_PV ordered from PV, alpha" Note="derivative of power for ordering PV from PV" Equation="([P_PV ordered from PV, alpha 1]-[P_PV ordered from PV, alpha])/TimeStep()" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1000" id="1000">
      <mxCell style="variable;fontSize=8;" parent="368" vertex="1">
        <mxGeometry x="227.82" y="480" width="65.63" height="35.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1001">
      <mxCell style="link" parent="368" source="543" target="1000" edge="1">
        <mxGeometry x="15" y="111.75" width="100" height="100" as="geometry">
          <mxPoint x="15" y="211.75" as="sourcePoint" />
          <mxPoint x="115" y="111.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="CF_CCS increase limit" Note="" Equation="0.3" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1004" id="1004">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;" parent="368" vertex="1">
        <mxGeometry x="698.3800000000002" y="541.3599999999999" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="dCF_CCS" Note="derivative" Equation="([CF_CCS 1]-[CF_CCS 2])/TimeStep()" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1005" id="1005">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="619.0000000000001" y="541.3599999999999" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1006" id="1006">
      <mxCell style="link" parent="368" source="873" target="1005" edge="1">
        <mxGeometry x="-1051.6200000000001" y="-624.4000000000001" width="100" height="100" as="geometry">
          <mxPoint x="649.0099999999999" y="525.5999999999999" as="sourcePoint" />
          <mxPoint x="-951.62" y="-624.4000000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Stock name="CF_CCS 2" Note="Capacity factor limited by increase and decrease limits" InitialValue="1" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1007" AllowNegatives="true" id="1007">
      <mxCell style="stock;fontSize=10;" parent="368" vertex="1">
        <mxGeometry x="615.0000000000001" y="613.05" width="80" height="29" as="geometry" />
      </mxCell>
    </Stock>
    <Variable name="CF_CCS decrease limit" Note="" Equation="-1.1" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0" SliderMin="-1" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1009" id="1009">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;" parent="368" vertex="1">
        <mxGeometry x="698.3800000000002" y="660.3499999999999" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Flow name="CF_CCS slew rate" Note="rate of change for ramping up/down orders for new capacity" FlowRate="#If [dCF_CCS] &gt; [CF_CCS increase limit] Then&#xa;#  [CF_CCS increase limit]&#xa;#Else &#xa;If [dCF_CCS] &lt; [CF_CCS decrease limit] Then&#xa;  [CF_CCS decrease limit]&#xa;Else&#xa;  [dCF_CCS]&#xa;End If" OnlyPositive="false" TimeIndependent="false" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1010" id="1010">
      <mxCell style="flow;startArrow=block;startFill=0;fontSize=10;" parent="368" target="1007" edge="1">
        <mxGeometry x="-1081.6200000000001" y="-509.64" width="100" height="100" as="geometry">
          <mxPoint x="774.3800000000002" y="631.3599999999999" as="sourcePoint" />
          <mxPoint x="-2050.37" y="-948.24" as="targetPoint" />
          <mxPoint y="9" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="1011" id="1011">
      <mxCell style="link" parent="368" source="1005" target="1010" edge="1">
        <mxGeometry x="-2481.62" y="-938.6500000000001" width="100" height="100" as="geometry">
          <mxPoint x="-2481.62" y="-838.6500000000001" as="sourcePoint" />
          <mxPoint x="-2381.62" y="-938.6500000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1012" id="1012">
      <mxCell style="link" parent="368" source="1004" target="1010" edge="1">
        <mxGeometry x="-2481.62" y="-938.6500000000001" width="100" height="100" as="geometry">
          <mxPoint x="-2481.62" y="-838.6500000000001" as="sourcePoint" />
          <mxPoint x="-2381.62" y="-938.6500000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1013" id="1013">
      <mxCell style="link" parent="368" source="1009" target="1010" edge="1">
        <mxGeometry x="-2481.62" y="-938.6500000000001" width="100" height="100" as="geometry">
          <mxPoint x="-2481.62" y="-838.6500000000001" as="sourcePoint" />
          <mxPoint x="-2381.62" y="-938.6500000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1014" id="1014">
      <mxCell style="link" parent="368" source="1007" target="1005" edge="1">
        <mxGeometry x="-1045.6200000000001" y="-508.64" width="100" height="100" as="geometry">
          <mxPoint x="-1045.6200000000001" y="-408.64" as="sourcePoint" />
          <mxPoint x="-945.62" y="-508.64" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1058">
      <mxCell style="link" parent="368" source="795" target="541" edge="1">
        <mxGeometry x="15" y="111.75" width="100" height="100" as="geometry">
          <mxPoint x="15" y="211.75" as="sourcePoint" />
          <mxPoint x="115" y="111.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P margin for control" Note="Power margin remaining for control (TW)&lt;br&gt;" Equation="If [P_supply to society]&lt;[P_demand] Then&#xa;    ([P_demand]-[P_supply to society])&#xa;Else&#xa;    0&#xa;End IF&#xa;" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="10" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1067" id="1067">
      <mxCell style="variable;fontSize=12;fillColor=#FDCDAC;" parent="368" vertex="1">
        <mxGeometry x="70" y="97" width="65" height="43" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1069">
      <mxCell style="link" parent="368" source="441" target="1067" edge="1">
        <mxGeometry x="15" y="111.75" width="100" height="100" as="geometry">
          <mxPoint x="15" y="211.75" as="sourcePoint" />
          <mxPoint x="115" y="111.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="442" name="P_supply to society" id="1070">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="14" y="70" width="70" height="29.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="1071">
      <mxCell style="link" parent="368" source="1070" target="1067" edge="1">
        <mxGeometry x="15" y="111.75" width="100" height="100" as="geometry">
          <mxPoint x="15" y="211.75" as="sourcePoint" />
          <mxPoint x="115" y="111.75" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1129" name="P_storage" id="1131">
      <mxCell style="variable;fontSize=6;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="210" y="25" width="40" height="33" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="P system demand" Note="Power used already in the system" Equation="[P_demand]+[P_storage]+[P_PV ordered for repair]+[P margin for control]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1155" id="1155">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="160" y="82.87000000000012" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1156">
      <mxCell style="link" parent="368" source="441" target="1155" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1157">
      <mxCell style="link" parent="368" source="1131" target="1155" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1159">
      <mxCell style="link" parent="368" source="1155" target="780" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1160">
      <mxCell style="link" parent="368" source="1067" target="1155" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P maximum supply" Note="maximum possible power input to the system (E_Technosphere)&lt;br&gt;" Equation="If [Transition complete]=0 Then&#xa;    [P_nomPV]+[P_nomfC]&#xa;Else&#xa;    [P_nomPV]+[P_nomfC]*[CF_fC]&#xa;End If" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1161" id="1161">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="340" y="180" width="60" height="42.38" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1162">
      <mxCell style="link" parent="368" source="794" target="1161" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1163">
      <mxCell style="link" parent="368" source="795" target="1161" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1164">
      <mxCell style="link" parent="368" source="771" target="1161" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1165">
      <mxCell style="link" parent="368" source="1161" target="780" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1166">
      <mxCell style="link" parent="368" source="1155" target="541" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="PV big enough" Note="is nominal power big enough to supply the required demand?" Equation="[P_nomPV]&gt;=[oversize PV]*[oversize PV to compensate storage losses]*[P_demand]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1167" id="1167">
      <mxCell style="variable;fontSize=8;" parent="368" vertex="1">
        <mxGeometry x="195" y="159.5" width="41.25" height="37" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1168">
      <mxCell style="link" parent="368" source="216" target="1167" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1169">
      <mxCell style="link" parent="368" source="794" target="1167" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1170">
      <mxCell style="link" parent="368" source="1167" target="541" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="proportion of growing fC needed" Note="determines the fraction of available power need to grow the fossil engine in order to keep it at least as large as P_demand * oversize fC&lt;br&gt;" Equation="Max(0,([P_nomfC]-[oversize fC]*[P_demand])/((1-[oversize fC])*[P_demand])*[fC growth multiplier])" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1171" id="1171">
      <mxCell style="variable;fontSize=8;" parent="368" vertex="1">
        <mxGeometry x="534.25" y="103.44" width="49.75" height="47.13" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1172">
      <mxCell style="link" parent="368" source="1171" target="865" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1173">
      <mxCell style="link" parent="368" source="865" target="1264" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="722.7340773061621" y="291.36304688771907" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1182">
      <mxCell style="link" parent="368" source="822" target="541" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1200">
      <mxCell style="link" parent="368" source="771" target="865" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="724" name="Transition complete" oldId="736" id="736">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="807.5" y="557.33" width="53" height="30" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="P_build_fC1" Note="power for ordering new fC either to grow fC or to repair it.&lt;br&gt;" Equation="If [Transition complete]=0 And [CF_fC]&gt;0.1 Then&#xa;  [P_fC ordered] + [fC_repair]*[P_EoL fC total]*[Al supply gap correction function switched]&#xa;Else&#xa;  [P_fC ordered]&#xa;End If" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1055" id="1055">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="807.5" y="480" width="86" height="53.24" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="721">
      <mxCell style="link" parent="368" source="736" target="1055" edge="1">
        <mxGeometry x="668.5" y="311.31" width="100" height="100" as="geometry">
          <mxPoint x="1091.7467532467535" y="561.31" as="sourcePoint" />
          <mxPoint x="768.5" y="311.31" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="231" id="231">
      <mxCell style="link;fontSize=12;" parent="368" source="230" target="1055" edge="1">
        <mxGeometry x="651" y="311.31" width="100" height="100" as="geometry">
          <mxPoint x="651" y="411.31" as="sourcePoint" />
          <mxPoint x="751" y="311.31" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="229" name="fC_repair" oldId="230" id="230">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="915" y="557.8600000000001" width="40" height="27" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="149" id="149">
      <mxCell style="link;fontSize=12;" parent="368" source="886" target="1055" edge="1">
        <mxGeometry x="1276" y="496.31" width="100" height="100" as="geometry">
          <mxPoint x="983.4481863736542" y="568.8618136263458" as="sourcePoint" />
          <mxPoint x="1376" y="496.31" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="324" name="CF_fC" id="1209">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="849.75" y="594.4200000000001" width="42.5" height="34.93" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1202" name="P_EoL fC total" id="1208">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="906" y="598.1300000000002" width="34.5" height="27.5" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="1210">
      <mxCell style="link" parent="368" source="1209" target="1055" edge="1">
        <mxGeometry x="-4" y="-98.68" width="100" height="100" as="geometry">
          <mxPoint x="-4" y="1.3199999999999932" as="sourcePoint" />
          <mxPoint x="96" y="-98.68" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1211">
      <mxCell style="link" parent="368" source="1208" target="1055" edge="1">
        <mxGeometry x="-4" y="-98.68" width="100" height="100" as="geometry">
          <mxPoint x="-4" y="1.3199999999999932" as="sourcePoint" />
          <mxPoint x="96" y="-98.68" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_PV_limit" Note="&lt;div&gt;Limit for PV energy conversion within Earth system boundaries (Desing et al. 2019):&lt;br&gt;&lt;/div&gt;&lt;div&gt;Built environment: 21TW&lt;/div&gt;&lt;div&gt;Built environment and deserts: 70TW&lt;br&gt;&lt;/div&gt;" Equation="21*[buildings potential fraction]+49*[desert potential fraction]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="70" SliderMin="21" SliderStep="10" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="566" id="566">
      <mxCell style="variable;fontSize=12;fillColor=#FDCDAC;" parent="368" vertex="1">
        <mxGeometry x="271.5" y="724.0000000000001" width="77" height="20" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="568">
      <mxCell style="link" parent="368" source="566" target="1052" edge="1">
        <mxGeometry x="-632.25" y="404" width="100" height="100" as="geometry">
          <mxPoint x="-632.25" y="504" as="sourcePoint" />
          <mxPoint x="-532.25" y="404" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_build_PV1" Note="" Equation="If [P_nomPV]&gt;=[P_PV_limit] Then&#xa;    0&#xa;Else If [P_nomPV]&gt;=[PV_limit margin]*[P_PV_limit] Then&#xa;    [P_PV ordered]*([P_nomPV]/(([PV_limit margin]-1)*[P_PV_limit])+1/(1-[PV_limit margin]))&#xa;Else&#xa;    [P_PV ordered]&#xa;End If" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1052" id="1052">
      <mxCell style="variable;fontSize=10;" parent="368" vertex="1">
        <mxGeometry x="265" y="693.35" width="86" height="20.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="189" id="189">
      <mxCell style="link;fontSize=12;" parent="368" source="700" target="1052" edge="1">
        <mxGeometry x="475.75" y="589" width="100" height="100" as="geometry">
          <mxPoint x="327.0885972574763" y="666.991795497205" as="sourcePoint" />
          <mxPoint x="575.75" y="589" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="910" name="P_PV ordered for repair" id="1215">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="45" y="666.85" width="71.25" height="47" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="1217">
      <mxCell style="link" parent="368" source="794" target="1052" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
          <Array as="points">
            <mxPoint x="460" y="607" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1262">
      <mxCell style="link" parent="368" source="1215" target="700" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P available for CCS" Note="power remaining to build and operate CCS" Equation="[P for allocation to 3 machines]-[P available for fC]-[P available for PV, variable]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1264" id="1264">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="480.2500000000001" y="317.6299999999999" width="90" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1265">
      <mxCell style="link" parent="368" source="541" target="1264" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1268">
      <mxCell style="link" parent="368" source="1264" target="380" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1270">
      <mxCell style="link" parent="368" source="865" target="541" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="fC growth multiplier" Note="constant factor multiplying " Equation="10" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="10" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="877" id="1363">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;" parent="368" vertex="1">
        <mxGeometry x="570.25" y="31.75" width="87" height="43" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1364">
      <mxCell style="link" parent="368" source="1363" target="1171" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="CF_CCS, max" Note="Maximum capacity factor for CCS when operated through PV engine through direct solar supply. If CCS was to operate at full capacity, intermittent solar supply would need to be stored. As storage is energetically expensive, CCS is operated with direct solar supply only, therefore limiting the maximum capacity factor to 1/pi = 0.3183.&lt;br&gt;" Equation="0.3183" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="932" id="1368">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;" parent="368" vertex="1">
        <mxGeometry x="695" y="334.6299999999999" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="fraction of supply fossil" Note="measures the fraction of the supply to E_Technosphere which is from fossil engine" Equation="1-[P_nomPV]/[P maximum supply]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="1" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="932" id="1369">
      <mxCell style="variable;fontSize=12;fillColor=#FDCDAC;" parent="368" vertex="1">
        <mxGeometry x="570.25" y="212.26" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1370">
      <mxCell style="link" parent="368" source="1161" target="1369" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1371">
      <mxCell style="link" parent="368" source="794" target="1369" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1372">
      <mxCell style="link" parent="368" source="1369" target="932" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1373">
      <mxCell style="link" parent="368" source="1368" target="932" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1386" name="oversize PV to compensate storage losses" id="1392">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="77.81999999999994" y="197.13" width="70" height="49.75" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="1393">
      <mxCell style="link" parent="368" source="1392" target="1167" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="910" name="P_PV ordered for repair" id="1396">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="56.25" y="10" width="60" height="60" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="1397">
      <mxCell style="link" parent="368" source="1396" target="1155" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="PV_limit margin" Note="factor from which P_PV ordered is reduced towards zero when approaching PV_limit" Equation="0.9" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0.8" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1398" id="1398">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;" parent="368" vertex="1">
        <mxGeometry x="351" y="673.35" width="77" height="36.65" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1399">
      <mxCell style="link" parent="368" source="1398" target="1052" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="desert potential fraction" Note="fraction of the PV potential in deserts that may be developed" Equation="0.2" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1414" id="1414">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="368" vertex="1">
        <mxGeometry x="323" y="754" width="77" height="49.05" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1415" id="1415">
      <mxCell style="link" parent="368" source="1414" target="566" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="maximum PV installation rate" Note="maximum power that can be invested in installing PV capacity, in order to avoid peaks&lt;br&gt;" Equation="2" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="true" SliderMax="10" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1485" id="1485">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="368" vertex="1">
        <mxGeometry x="131" y="744" width="77" height="49.05" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1486" id="1486">
      <mxCell style="link" parent="368" source="1485" target="700" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="maximum CCS installation rate" Note="maximum power that can be invested in installing CCS capacity, in order to avoid peaks&lt;br&gt;" Equation="0.9" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="true" SliderMax="3" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1487" id="1487">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="368" vertex="1">
        <mxGeometry x="436.5" y="744" width="77" height="49.05" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1488" id="1488">
      <mxCell style="link" parent="368" source="1487" target="206" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="buildings potential fraction" Note="fraction of the PV potential in deserts that may be developed" Equation="0.6" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1489" id="1489">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="368" vertex="1">
        <mxGeometry x="238" y="754" width="77" height="49.05" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1490" id="1490">
      <mxCell style="link" parent="368" source="1489" target="566" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1843" oldId="1845" name="Al supply gap correction function switched" id="1845">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="198" y="224.26000000000022" width="40" height="36" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1846" id="1846">
      <mxCell style="link" parent="368" source="1845" target="780" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1847" id="1847">
      <mxCell style="link" parent="368" source="1845" target="541" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1848" id="1848">
      <mxCell style="link" parent="368" source="1845" target="543" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="324" oldId="2454" name="CF_fC" id="2454">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="368" vertex="1">
        <mxGeometry x="404.88" y="222.26" width="35.12" height="27.74" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2455" id="2455">
      <mxCell style="link" parent="368" source="2454" target="1161" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_nomCCS eff" Note="" Equation="[CF_CCS, max, effective]*[P_nomCCS]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2458" id="2458">
      <mxCell style="variable;fontSize=12;" parent="368" vertex="1">
        <mxGeometry x="683.3800000000001" y="430.8199999999999" width="90" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2459" id="2459">
      <mxCell style="link" parent="368" source="932" target="2458" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2460" id="2460">
      <mxCell style="link" parent="368" source="367" target="2458" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2589" id="2589">
      <mxCell style="link" parent="368" source="1845" target="832" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2590" id="2590">
      <mxCell style="link" parent="368" source="1845" target="865" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
          <Array as="points">
            <mxPoint x="620" y="300.75" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2593" id="2593">
      <mxCell style="link" parent="368" source="1845" target="1055" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
          <Array as="points">
            <mxPoint x="630" y="300.75" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_PV build up" Note="Power to build new PV systems and for repair&lt;br&gt;" Equation="Min([P_PV ordered from fC, variable]+[P_PV ordered from PV, alpha],[maximum PV installation rate])" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2601" id="2601">
      <mxCell style="variable;fontSize=8;" parent="368" vertex="1">
        <mxGeometry x="50.62" y="640" width="60" height="15.99" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2602" id="2602">
      <mxCell style="link" parent="368" source="700" target="2601" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2603" id="2603">
      <mxCell style="link" parent="368" source="1215" target="2601" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2606" id="2606">
      <mxCell style="link" parent="368" source="851" target="2601" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2607" id="2607">
      <mxCell style="link" parent="368" source="992" target="2601" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2608" id="2608">
      <mxCell style="link" parent="368" source="1485" target="2601" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="Transition state" Note="determines whether the system is in transiton or beyond" Type="None" Solver="{&quot;enabled&quot;: false, &quot;algorithm&quot;: &quot;RK1&quot;, &quot;timeStep&quot;: 1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="730" id="730">
      <mxCell style="folder" parent="1" vertex="1">
        <mxGeometry x="43" y="830" width="392" height="170" as="geometry" />
      </mxCell>
    </Folder>
    <State name="in transition" Note="system is in transition from fossil to PV" Active="true" Residency="0" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="711" id="711">
      <mxCell style="state" parent="730" vertex="1">
        <mxGeometry x="20" y="20" width="100" height="40" as="geometry" />
      </mxCell>
    </State>
    <State name="transition complete state" Note="system has transitioned to PV" Active="false" Residency="0" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="712" id="712">
      <mxCell style="state" parent="730" vertex="1">
        <mxGeometry x="278.25" y="20" width="100" height="40" as="geometry" />
      </mxCell>
    </State>
    <Transition name="completed" Note="" Trigger="Condition" Value="[P_nomPV]&gt;=[oversize PV]*[oversize PV to compensate storage losses]*[P_demand]" Repeat="false" Recalculate="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="713" id="713">
      <mxCell style="transition" parent="730" source="711" target="712" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint x="-517.75" y="-670.24" as="sourcePoint" />
          <mxPoint x="-417.75" y="-770.24" as="targetPoint" />
          <Array as="points">
            <mxPoint x="196" y="39.76" />
            <mxPoint x="1940" y="-405" />
          </Array>
          <mxPoint x="-3" y="-10" as="offset" />
        </mxGeometry>
      </mxCell>
    </Transition>
    <Ghost Source="185" name="P_nomPV" oldId="714" id="714">
      <mxCell style="variable;fontSize=12;opacity=30;" parent="730" vertex="1">
        <mxGeometry x="32.25" y="120" width="60" height="40" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="247" name="P_demand" oldId="715" id="715">
      <mxCell style="variable;fontSize=12;fillColor=#FDCDAC;opacity=30;" parent="730" vertex="1">
        <mxGeometry x="112.5" y="120" width="92" height="40" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="216" name="oversize PV" oldId="716" id="716">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;opacity=30;" parent="730" vertex="1">
        <mxGeometry x="216.25" y="127.88" width="87" height="24.25" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="717" id="717">
      <mxCell style="link" parent="730" source="714" target="713" edge="1">
        <mxGeometry x="-517.75" y="-780" width="100" height="100" as="geometry">
          <mxPoint x="-517.75" y="-680" as="sourcePoint" />
          <mxPoint x="-417.75" y="-780" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="718" id="718">
      <mxCell style="link" parent="730" source="715" target="713" edge="1">
        <mxGeometry x="-517.75" y="-780" width="100" height="100" as="geometry">
          <mxPoint x="-517.75" y="-680" as="sourcePoint" />
          <mxPoint x="-417.75" y="-780" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="719" id="719">
      <mxCell style="link" parent="730" source="716" target="713" edge="1">
        <mxGeometry x="-517.75" y="-780" width="100" height="100" as="geometry">
          <mxPoint x="-517.75" y="-680" as="sourcePoint" />
          <mxPoint x="-417.75" y="-780" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Transition complete" Note="" Equation="[transition complete state]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="724" id="724">
      <mxCell style="variable;fontSize=8;" parent="730" vertex="1">
        <mxGeometry x="301.75" y="75" width="53" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="725" id="725">
      <mxCell style="link" parent="730" source="712" target="724" edge="1">
        <mxGeometry x="-517.75" y="-780" width="100" height="100" as="geometry">
          <mxPoint x="-517.75" y="-680" as="sourcePoint" />
          <mxPoint x="-417.75" y="-780" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1386" name="oversize PV to compensate storage losses" id="1394">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="730" vertex="1">
        <mxGeometry x="308.25" y="115.13" width="70" height="49.75" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="1395">
      <mxCell style="link" parent="730" source="1394" target="713" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="IPCC emission pathways" Note="IPCC emission pathways&lt;br /&gt;" Type="None" Solver="{&quot;enabled&quot;: false, &quot;algorithm&quot;: &quot;RK1&quot;, &quot;timeStep&quot;: 1}" Image="Plugin" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" AgentBase="" id="1022">
      <mxCell style="folder;image=None;shape=rectangle;imageFlipV=0;imageFlipH=0;" parent="1" vertex="1">
        <mxGeometry x="40" y="1290" width="400" height="230" as="geometry">
          <mxRectangle x="2200" y="850" width="128" height="128" as="alternateBounds" />
        </mxGeometry>
      </mxCell>
    </Folder>
    <Flow name="IPCC" Note="IPCC cumulative CO2 emissions, median" FlowRate="[IPCC 50%]" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1290" id="1290">
      <mxCell style="flow;startFill=0;dashed=1;strokeColor=#969696;" parent="1022" edge="1">
        <mxGeometry x="-330" y="-30" width="100" height="100" as="geometry">
          <mxPoint x="200" y="61.5" as="sourcePoint" />
          <mxPoint x="280" y="61.5" as="targetPoint" />
          <mxPoint y="-20" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="IPCC max" Note="IPCC cumulative CO2 emissions max" FlowRate="[IPCC 99.5%]" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1292" id="1292">
      <mxCell style="flow;startFill=0;dashed=1;strokeColor=#808080;" parent="1022" edge="1">
        <mxGeometry x="-2780" y="-505.40999999999997" width="100" height="100" as="geometry">
          <mxPoint x="200" y="124.59000000000003" as="sourcePoint" />
          <mxPoint x="280" y="124.59000000000003" as="targetPoint" />
          <mxPoint y="-20" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Flow name="IPCC min" Note="IPCC cumulative CO2 emissions min" FlowRate="[IPCC 0.5%]" OnlyPositive="true" TimeIndependent="false" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="1293" id="1293">
      <mxCell style="flow;startFill=0;dashed=1;strokeColor=#C0C0C0;" parent="1022" edge="1">
        <mxGeometry x="-2780" y="-440.40999999999997" width="100" height="100" as="geometry">
          <mxPoint x="200" y="189.59000000000003" as="sourcePoint" />
          <mxPoint x="280" y="189.59000000000003" as="targetPoint" />
          <mxPoint y="-20" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Converter name="IPCC 99.5%" Note="IPCC 1.5\xB0C warming pathways, maximum, net annual CO2 emissions (IPCC 2018, see figure SPM3a)" Source="Time" Data="0,2640.086609; 1,2678.561481; 2,2716.273133; 3,2752.997595; 4,2789.359813; 5,2824.65832; 6,2858.962008; 7,2892.353288; 8,2925.258212; 9,2957.411725; 10,2988.945488; 11,3019.587112; 12,3049.076191; 13,3077.612537; 14,3105.737046; 15,3133.219957; 16,3159.813447; 17,3185.897619; 18,3210.906278; 19,3235.216353; 20,3258.656007; 21,3281.358286; 22,3303.10736; 23,3324.233399; 24,3344.369318; 25,3364.057583; 26,3382.877659; 27,3401.159293; 28,3418.625556; 29,3435.804228; 30,3452.767262; 31,3468.733225; 32,3484.872879; 33,3500.607363; 34,3515.310519; 35,3530.403852; 36,3544.665602; 37,3558.900317; 38,3572.289742; 39,3584.958259; 40,3597.486956; 41,3609.592858; 42,3621.83157; 43,3633.331003; 44,3644.1281; 45,3654.50577; 46,3664.778629; 47,3674.794054; 48,3683.592806; 49,3693.024824; 50,3701.69537; 51,3709.922946; 52,3717.719339; 53,3725.087484; 54,3732.378048; 55,3739.648147; 56,3745.207703; 57,3750.544811; 58,3755.212159; 59,3760.110413; 60,3763.830114; 61,3768.511422; 62,3772.05423; 63,3775.294927; 64,3778.486923; 65,3780.518908; 66,3783.09689; 67,3784.717878; 68,3786.225319; 69,3787.364547; 70,3787.44197; 71,3788.200507; 72,3787.906674; 73,3786.842033; 74,3785.558512; 75,3783.918548; 76,3782.602963; 77,3780.107192" Interpolation="Linear" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1416" id="1416">
      <mxCell style="converter" parent="1022" vertex="1">
        <mxGeometry x="20" y="100" width="120" height="50" as="geometry" />
      </mxCell>
    </Converter>
    <Converter name="IPCC 0.5%" Note="" Source="Time" Data="0,2451.312479; 1,2482.627706; 2,2511.028934; 3,2536.420121; 4,2558.45437; 5,2577.178665; 6,2593.050033; 7,2605.84899; 8,2618.205124; 9,2629.445483; 10,2640.108669; 11,2649.611584; 12,2658.253148; 13,2666.186145; 14,2673.481818; 15,2679.714222; 16,2684.969572; 17,2689.173374; 18,2692.438582; 19,2694.989068; 20,2696.509039; 21,2698.538417; 22,2698.116997; 23,2697.291771; 24,2695.374097; 25,2692.583881; 26,2688.868006; 27,2684.695165; 28,2679.818057; 29,2675.279564; 30,2670.322058; 31,2665.178976; 32,2659.803945; 33,2655.842822; 34,2649.995068; 35,2644.914069; 36,2640.101412; 37,2634.196325; 38,2628.952086; 39,2623.526843; 40,2617.950418; 41,2612.374172; 42,2606.320007; 43,2600.480971; 44,2594.580576; 45,2587.85233; 46,2581.614868; 47,2575.878745; 48,2570.879049; 49,2563.525873; 50,2556.480857; 51,2549.718103; 52,2543.39579; 53,2535.848249; 54,2529.601644; 55,2521.799906; 56,2514.173705; 57,2507.469005; 58,2499.963059; 59,2493.078882; 60,2485.573269; 61,2477.466901; 62,2470.007817; 63,2462.697866; 64,2454.185582; 65,2446.718887; 66,2439.092269; 67,2431.207685; 68,2422.948922; 69,2413.629905; 70,2406.360803; 71,2396.323058; 72,2388.124524; 73,2378.832937; 74,2370.388205; 75,2361.847491; 76,2352.756841; 77,2343.012719" Interpolation="Linear" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1417" id="1417">
      <mxCell style="converter" parent="1022" vertex="1">
        <mxGeometry x="20" y="160" width="120" height="50" as="geometry" />
      </mxCell>
    </Converter>
    <Link name="Link" Note="" BiDirectional="false" oldId="1418" id="1418">
      <mxCell style="link" parent="1022" source="1416" target="1292" edge="1">
        <mxGeometry x="-240" width="100" height="100" as="geometry">
          <mxPoint x="-240" y="100" as="sourcePoint" />
          <mxPoint x="-140" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1419" id="1419">
      <mxCell style="link" parent="1022" source="1417" target="1293" edge="1">
        <mxGeometry x="-240" width="100" height="100" as="geometry">
          <mxPoint x="-240" y="100" as="sourcePoint" />
          <mxPoint x="-140" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Converter name="IPCC 50%" Note="" Source="Time" Data="0,2551.522634; 1,2586.755255; 2,2620.401796; 3,2652.377338; 4,2682.496906; 5,2710.922749; 6,2737.654402; 7,2762.62017; 8,2786.58655; 9,2809.622375; 10,2831.651275; 11,2852.512099; 12,2872.370957; 13,2891.243934; 14,2908.989623; 15,2925.97179; 16,2941.873133; 17,2956.601706; 18,2970.453123; 19,2983.13664; 20,2994.962218; 21,3005.692821; 22,3015.53319; 23,3024.273493; 24,3031.868151; 25,3038.682394; 26,3044.289589; 27,3048.961856; 28,3053.290792; 29,3057.45008; 30,3061.354142; 31,3064.96355; 32,3068.189374; 33,3071.348815; 34,3074.266469; 35,3076.782194; 36,3079.135205; 37,3081.185809; 38,3082.929776; 39,3084.379031; 40,3085.537367; 41,3086.484683; 42,3087.221455; 43,3087.673697; 44,3087.6661; 45,3087.564327; 46,3087.2583; 47,3086.617909; 48,3085.735437; 49,3084.675447; 50,3083.268364; 51,3081.694349; 52,3079.763653; 53,3077.562126; 54,3075.110422; 55,3072.429925; 56,3069.339881; 57,3066.130295; 58,3062.668894; 59,3058.84394; 60,3054.77609; 61,3050.574111; 62,3046.080131; 63,3041.249557; 64,3036.089178; 65,3030.755458; 66,3025.261199; 67,3019.366198; 68,3013.266564; 69,3006.869406; 70,3000.216392; 71,2993.275211; 72,2986.109662; 73,2978.69813; 74,2971.059464; 75,2963.079331; 76,2954.948244; 77,2946.327166" Interpolation="Linear" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1420" id="1420">
      <mxCell style="converter" parent="1022" vertex="1">
        <mxGeometry x="20" y="40" width="120" height="50" as="geometry" />
      </mxCell>
    </Converter>
    <Link name="Link" Note="" BiDirectional="false" oldId="1421" id="1421">
      <mxCell style="link" parent="1022" source="1420" target="1290" edge="1">
        <mxGeometry x="-240" width="100" height="100" as="geometry">
          <mxPoint x="-240" y="100" as="sourcePoint" />
          <mxPoint x="-140" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1212">
      <mxCell style="link" parent="1" source="588" target="338" edge="1">
        <mxGeometry x="20" y="-136" width="100" height="100" as="geometry">
          <mxPoint x="20" y="-36" as="sourcePoint" />
          <mxPoint x="120" y="-136" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1272">
      <mxCell style="link" parent="1" source="247" target="338" edge="1">
        <mxGeometry x="20" y="-136" width="100" height="100" as="geometry">
          <mxPoint x="20" y="-36" as="sourcePoint" />
          <mxPoint x="120" y="-136" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Text name="3 machines energy-material transition model" LabelPosition="Middle" id="1273">
      <mxCell style="text" parent="1" vertex="1">
        <mxGeometry x="272.5" y="30" width="687.5" height="50" as="geometry" />
      </mxCell>
    </Text>
    <Link name="Link" Note="" BiDirectional="false" id="1340">
      <mxCell style="link" parent="1" source="1360" target="1339" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1362">
      <mxCell style="link" parent="1" source="247" target="1360" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="fC phase out" Note="" Type="None" Solver="{&quot;enabled&quot;: false, &quot;algorithm&quot;: &quot;RK1&quot;, &quot;timeStep&quot;: 1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" id="536">
      <mxCell style="folder;image=None;shape=rectangle;" parent="1" vertex="1">
        <mxGeometry x="1060.05" y="642.5" width="252.75" height="185" as="geometry">
          <mxRectangle x="217.25" y="633.5" width="100" height="20" as="alternateBounds" />
        </mxGeometry>
      </mxCell>
    </Folder>
    <Variable name="fC_dep" Note="depreciation rate of initial embodied energy of fC" Equation="IfThenElse([fC phase out]=1, IfThenElse([Transition complete]=1, [fC_dep_phase_out], [fC_dep_init]), [fC_dep_init])" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.1" SliderMin="0.001" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="128" id="128">
      <mxCell style="variable;fontSize=12;" parent="536" vertex="1">
        <mxGeometry x="61.5" y="100" width="50" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="tau_fC" Note="time constant for depreciation of initial embodied energy of fC" Equation="IfThenElse([fC phase out]=1, IfThenElse([Transition complete]=1, [tau_fC_phase_out], [tau_fC_init]), [tau_fC_init])" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="225" id="225">
      <mxCell style="variable;fontSize=12;" parent="536" vertex="1">
        <mxGeometry x="136.5" y="100" width="50" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="523" name="fC phase out" id="524">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;opacity=30;" parent="536" vertex="1">
        <mxGeometry x="99.5" y="25" width="60" height="60" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="525">
      <mxCell style="link" parent="536" source="524" target="225" edge="1">
        <mxGeometry x="-167.25" y="-520" width="100" height="100" as="geometry">
          <mxPoint x="-167.25" y="-420" as="sourcePoint" />
          <mxPoint x="-67.25" y="-520" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="526">
      <mxCell style="link" parent="536" source="524" target="128" edge="1">
        <mxGeometry x="-167.25" y="-520" width="100" height="100" as="geometry">
          <mxPoint x="-167.25" y="-420" as="sourcePoint" />
          <mxPoint x="-67.25" y="-520" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="tau_fC_init" Note="time constant for depreciation" Equation="10" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="552" id="552">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="536" vertex="1">
        <mxGeometry x="186.5" y="30" width="50" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="tau_fC_phase_out" Note="time constant for depreciation during phase out" Equation="10" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="553" id="553">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="536" vertex="1">
        <mxGeometry x="186.5" y="70" width="50" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="554">
      <mxCell style="link" parent="536" source="552" target="225" edge="1">
        <mxGeometry x="32.75" y="-5" width="100" height="100" as="geometry">
          <mxPoint x="32.75" y="95" as="sourcePoint" />
          <mxPoint x="132.75" y="-5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="555">
      <mxCell style="link" parent="536" source="553" target="225" edge="1">
        <mxGeometry x="32.75" y="-5" width="100" height="100" as="geometry">
          <mxPoint x="32.75" y="95" as="sourcePoint" />
          <mxPoint x="132.75" y="-5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="fC_dep_init" Note="initial depreciation rate of initial fC embodied energy&lt;br&gt;" Equation="0.01" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.1" SliderMin="0.001" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="556" id="556">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="536" vertex="1">
        <mxGeometry x="22.75" y="30" width="50" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="fC_dep_phase_out" Note="increased depreciation rate for fC during phase out&lt;br&gt;" Equation="0.01" Units="1/Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="0.1" SliderMin="0.001" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="557" id="557">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="536" vertex="1">
        <mxGeometry x="22.75" y="70" width="50" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="558">
      <mxCell style="link" parent="536" source="556" target="128" edge="1">
        <mxGeometry x="32.75" y="-5" width="100" height="100" as="geometry">
          <mxPoint x="32.75" y="95" as="sourcePoint" />
          <mxPoint x="132.75" y="-5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="559">
      <mxCell style="link" parent="536" source="557" target="128" edge="1">
        <mxGeometry x="32.75" y="-5" width="100" height="100" as="geometry">
          <mxPoint x="32.75" y="95" as="sourcePoint" />
          <mxPoint x="132.75" y="-5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="724" name="Transition complete" id="737">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="536" vertex="1">
        <mxGeometry x="99.5" y="145" width="53" height="30" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="738">
      <mxCell style="link" parent="536" source="737" target="128" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="739">
      <mxCell style="link" parent="536" source="737" target="225" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="PV repair" Note="" Type="None" Solver="{&quot;enabled&quot;: false, &quot;algorithm&quot;: &quot;RK1&quot;, &quot;timeStep&quot;: 1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" oldId="432" id="432">
      <mxCell style="folder;image=None;shape=rectangle;" parent="1" vertex="1">
        <mxGeometry x="1949.42" y="513.25" width="330" height="340" as="geometry">
          <mxRectangle x="970" y="399" width="80" height="20" as="alternateBounds" />
        </mxGeometry>
      </mxCell>
    </Folder>
    <Variable name="P_PV ordered for repair 1" Note="power ordered for repairing PV&lt;br&gt;" Equation="If [PV repair on demand]=1 Then&#xa;    [P_eolPV]&#xa;#Else If [PV repair on demand]=0 And [Transition complete]=1 And [P_nomPV]&gt;[P_demand] And [P_nomPV]&lt;0.95*[P_PV_limit] Then&#xa;#    ({1 TW}*{1 TW}/([P_nomPV]-[P_demand])*[PV repair inverse proportional]+[PV repair proportional]*([E_PV])/([T_resPV]))&#xa;&#xa;Else If [PV repair on demand]=0 And [Transition complete]=1 Then&#xa;  [P_PV repair order]&#xa;Else&#xa;    0&#xa;End If" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="338" id="338">
      <mxCell style="variable;fontSize=12;" parent="432" vertex="1">
        <mxGeometry x="20" y="20" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="PV repair proportional" Note="factor of continuous repair of PV after the transition proportional to the current embodied energy of PV, i.e. if embodied energy is high, more additional PV is installed than if embodied energy is low&lt;br&gt;" Equation="0.5" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="347" id="347">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="432" vertex="1">
        <mxGeometry x="110" y="60" width="80" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="348" id="348">
      <mxCell style="link" parent="432" source="347" target="338" edge="1">
        <mxGeometry x="-923" y="-414.25" width="100" height="100" as="geometry">
          <mxPoint x="-923" y="-314.25" as="sourcePoint" />
          <mxPoint x="-823" y="-414.25" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="PV repair on demand" Note="&lt;div&gt;If 1, PV&amp;nbsp; is repaired on demand (i.e. when becoming EoL)&lt;br&gt;&lt;/div&gt;" Equation="0" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="433" id="433">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="432" vertex="1">
        <mxGeometry x="110" y="25.81" width="80" height="34.19" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="434" id="434">
      <mxCell style="link" parent="432" source="433" target="338" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="724" name="Transition complete" oldId="830" id="830">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="432" vertex="1">
        <mxGeometry x="57" y="89.22000000000003" width="53" height="30" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="831" id="831">
      <mxCell style="link" parent="432" source="830" target="338" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_PV ordered for repair" Note="Power ordered for repair of PV constrained by increase and decrease limits&lt;br&gt;" Equation="[P_PV ordered for repair 2]*[Al supply gap correction function switched]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="910" id="910">
      <mxCell style="variable;fontSize=12;" parent="432" vertex="1">
        <mxGeometry x="24.009999999999987" y="268.99" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="PV repair increase limit" Note="maximum rate of change for increasing PV repair power" Equation="0.15" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="10" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="911" id="911">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;" parent="432" vertex="1">
        <mxGeometry x="110.00000000000011" y="158.43999999999994" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="d_P_PV ordered for repair 1" Note="derivative of power ordered for repair&lt;br&gt;" Equation="([P_PV ordered for repair 1]-[P_PV ordered for repair 2])/TimeStep()" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="912" id="912">
      <mxCell style="variable;fontSize=12;" parent="432" vertex="1">
        <mxGeometry x="23.999999999999996" y="149.99999999999994" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Stock name="P_PV ordered for repair 2" Note="integrated derivative of power order for repair" InitialValue="0" StockMode="Store" Delay="10" Volume="100" NonNegative="false" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="913" id="913">
      <mxCell style="stock;fontSize=10;" parent="432" vertex="1">
        <mxGeometry x="19.999999999999996" y="221.69000000000005" width="80" height="29" as="geometry" />
      </mxCell>
    </Stock>
    <Link name="Link" Note="" BiDirectional="false" oldId="914" id="914">
      <mxCell style="link" parent="432" source="913" target="910" edge="1">
        <mxGeometry x="-1946.62" y="-901.01" width="100" height="100" as="geometry">
          <mxPoint x="-1946.62" y="-801.01" as="sourcePoint" />
          <mxPoint x="-1846.62" y="-901.01" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="PV repair decrease limit" Note="maximum rate of decreasing power for PV repair" Equation="-10" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0" SliderMin="-1" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="915" id="915">
      <mxCell style="variable;fontSize=12;fillColor=#FFCC00;" parent="432" vertex="1">
        <mxGeometry x="140.0000000000001" y="268.99" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Flow name="PV repair slew rate" Note="derivative of power order for PV repair constrained by decrease and increase limits" FlowRate="If [d_P_PV ordered for repair 1] &gt; [PV repair increase limit] Then&#xa;  [PV repair increase limit]&#xa;Else If [d_P_PV ordered for repair 1] &lt; [PV repair decrease limit] Then&#xa;  [PV repair decrease limit]&#xa;Else&#xa;  [d_P_PV ordered for repair 1]&#xa;End If" OnlyPositive="false" TimeIndependent="false" Units="TW/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" oldId="916" id="916">
      <mxCell style="flow;startArrow=block;startFill=0;fontSize=10;" parent="432" target="913" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint x="179.3800000000001" y="240" as="sourcePoint" />
          <mxPoint x="-2645.37" y="-1339.6" as="targetPoint" />
          <mxPoint x="3" y="16" as="offset" />
        </mxGeometry>
      </mxCell>
    </Flow>
    <Link name="Link" Note="" BiDirectional="false" oldId="917" id="917">
      <mxCell style="link" parent="432" source="912" target="916" edge="1">
        <mxGeometry x="-3076.62" y="-1330.01" width="100" height="100" as="geometry">
          <mxPoint x="-3076.62" y="-1230.01" as="sourcePoint" />
          <mxPoint x="-2976.62" y="-1330.01" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="918" id="918">
      <mxCell style="link" parent="432" source="911" target="916" edge="1">
        <mxGeometry x="-3076.62" y="-1330.01" width="100" height="100" as="geometry">
          <mxPoint x="-3076.62" y="-1230.01" as="sourcePoint" />
          <mxPoint x="-2976.62" y="-1330.01" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="919" id="919">
      <mxCell style="link" parent="432" source="915" target="916" edge="1">
        <mxGeometry x="-3086.5999999999995" y="-1330.15" width="100" height="100" as="geometry">
          <mxPoint x="-3086.5999999999995" y="-1230.15" as="sourcePoint" />
          <mxPoint x="-2986.5999999999995" y="-1330.15" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="920" id="920">
      <mxCell style="link" parent="432" source="913" target="912" edge="1">
        <mxGeometry x="-1640.62" y="-900" width="100" height="100" as="geometry">
          <mxPoint x="-1640.62" y="-800" as="sourcePoint" />
          <mxPoint x="-1540.62" y="-900" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="921" id="921">
      <mxCell style="link" parent="432" source="338" target="912" edge="1">
        <mxGeometry x="-47.5" width="100" height="100" as="geometry">
          <mxPoint x="-47.5" y="100" as="sourcePoint" />
          <mxPoint x="52.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="PV repair inverse proportional" Note="factor for continuous repair of PV after the transition proportional to the inverse of idle capacity (i.e. nominal power minus P_demand), i.e. if idle capacity is small, more PV is additionally installed than if it is large. &lt;br&gt;" Equation="20" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="20" SliderMin="0" SliderStep="0.1" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1042" id="1042">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="432" vertex="1">
        <mxGeometry x="110" y="100" width="80" height="48.44" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="1043" id="1043">
      <mxCell style="link" parent="432" source="1042" target="338" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="566" name="P_PV_limit" oldId="1213" id="1213">
      <mxCell style="variable;fontSize=12;fillColor=#FDCDAC;opacity=30;" parent="432" vertex="1">
        <mxGeometry x="57" y="130" width="63" height="20" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="1214" id="1214">
      <mxCell style="link" parent="432" source="1213" target="338" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1843" oldId="2133" name="Al supply gap correction function switched" id="2133">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="432" vertex="1">
        <mxGeometry x="90.00000000000023" y="275.24999999999983" width="57.56" height="47.49" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2134" id="2134">
      <mxCell style="link" parent="432" source="2133" target="910" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_PV repair order" Note="power ordered for repairing PV&lt;br&gt;" Equation="Max(0,(1-(([P_demand]-[P_nomPV])/([P_demand]-[P_PV_limit]))^6))*[maximum PV installation rate]" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2435" id="2435">
      <mxCell style="variable;fontSize=12;" parent="432" vertex="1">
        <mxGeometry x="246" y="55.30000000000001" width="60" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2437" id="2437">
      <mxCell style="link" parent="432" source="1213" target="2435" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1485" oldId="2439" name="maximum PV installation rate" id="2439">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;opacity=30;" parent="432" vertex="1">
        <mxGeometry x="237.5" y="130.00000000000006" width="77" height="49.05" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2440" id="2440">
      <mxCell style="link" parent="432" source="2439" target="2435" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2441" id="2441">
      <mxCell style="link" parent="432" source="2435" target="338" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Folder name="Storage as part of PV" Note="" Type="None" Solver="{&quot;enabled&quot;: false, &quot;algorithm&quot;: &quot;RK1&quot;, &quot;timeStep&quot;: 1}" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" AgentBase="" id="763">
      <mxCell style="folder;image=None;shape=rectangle;" parent="1" vertex="1">
        <mxGeometry x="2420" y="48" width="736.36" height="540" as="geometry">
          <mxRectangle x="589.13" y="746" width="160" height="20" as="alternateBounds" />
        </mxGeometry>
      </mxCell>
    </Folder>
    <Variable name="independence time" Note="&lt;div&gt;Time that the storage allows to be independent of the PV power supply.&lt;/div&gt;&lt;div&gt;To level out daily variation: ~14.5h (0.0016a)&lt;br&gt;&lt;/div&gt;&lt;div&gt;To level out seasonal variation: 84h (at 0\xB0N/S;0.01a); 500h (20\xB0N/S; 0.06a), 1183h (40\xB0N/S; 0.13a), 2666h (60\xB0N/S; 0.3a) assuming constant demand throughout the year. https://beyondthisbriefanomaly.org/2015/08/30/an-integrated-view-of-energy-transition-what-can-we-learn/&lt;/div&gt;" Equation="0.035" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="0.13" SliderMin="0" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="749" id="749">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="763" vertex="1">
        <mxGeometry x="394.61" y="117.5" width="85" height="57.5" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="fraction of daily demand stored" Note="denotes the fraction of daily power demand that needs to be provided through storage. Current demand patterns require between 0.4 and 0.6, while aligning demand with solar supply can reduce this fraction towards zero (Desing et al. 2021).&lt;br&gt;" Equation="0.3" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="0.55" SliderMin="0" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="752" id="752">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;" parent="763" vertex="1">
        <mxGeometry x="256.61" y="33.5" width="80" height="57.5" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="storage roundtrip efficiency" Note="output energy from storage / input energy into storage&lt;br&gt;" Equation="1/([fraction electro-chemical storage]/[roundtrip efficiency electro-chemical storage]+[fraction mechanical storage]/[roundtrip efficiency mechanical storage]+[fraction  chemical storage]/[roundtrip efficiency chemical storage])&#xa;#[roundtrip efficiency electro-chemical storage]*[fraction electro-chemical storage]+[roundtrip efficiency mechanical storage]*[fraction mechanical storage]+[roundtrip efficiency chemical storage]*[fraction  chemical storage]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0.7" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="753" id="753">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="763" vertex="1">
        <mxGeometry x="574.36" y="132.5" width="57.5" height="57.5" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="fraction of power stored" Note="represents the fraction of power demand which needs to be provided through storage. It comprises the fraction of daily demand stored and the fraction of power stored to level out seasonal variations. The latter is calculated as a function of independence time and the maximum fraction of power stored for seasonal variations, i.e. a linear increase with independence time until the maximum fraction is reached for full independence (i.e. independence time = 0.3a)&lt;br&gt;" Equation="If [independence time]&gt;{0.0016 Years} Then&#xa;    [fraction of daily demand stored] +[maximum fraction of power stored for seasonal variations]*([independence time]-{0.0016 Years})/{0.3 Years}&#xa;Else&#xa;    [fraction of daily demand stored]&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0.7" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="754" id="754">
      <mxCell style="variable;fontSize=10;" parent="763" vertex="1">
        <mxGeometry x="391.11" y="46" width="72.5" height="35.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="755">
      <mxCell style="link" parent="763" source="749" target="754" edge="1">
        <mxGeometry x="-79.89" y="-884.5" width="100" height="100" as="geometry">
          <mxPoint x="-79.89" y="-784.5" as="sourcePoint" />
          <mxPoint x="20.11" y="-884.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="756">
      <mxCell style="link" parent="763" source="752" target="754" edge="1">
        <mxGeometry x="-79.89" y="-884.5" width="100" height="100" as="geometry">
          <mxPoint x="-79.89" y="-784.5" as="sourcePoint" />
          <mxPoint x="20.11" y="-884.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="storage loss coefficient" Note="&lt;div&gt;storage losses have to be provided in addition to power demand. &lt;br&gt;&lt;/div&gt;&lt;div&gt;P_opPV = P_demand * (1+ fraction of power stored * (1/roundtrip efficiency -1)&lt;br&gt;&lt;/div&gt;" Equation="[fraction of power stored]*(1/[storage roundtrip efficiency]-1)" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0.7" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="757" id="757">
      <mxCell style="variable;fontSize=8;" parent="763" vertex="1">
        <mxGeometry x="574.36" y="90" width="82" height="33.5" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="758">
      <mxCell style="link" parent="763" source="753" target="757" edge="1">
        <mxGeometry x="-43.34999999999998" y="-880.08" width="100" height="100" as="geometry">
          <mxPoint x="-43.34999999999998" y="-780.08" as="sourcePoint" />
          <mxPoint x="56.64999999999999" y="-880.08" as="targetPoint" />
          <Array as="points">
            <mxPoint x="567.36" y="128" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="759">
      <mxCell style="link" parent="763" source="754" target="757" edge="1">
        <mxGeometry x="-4.640000000000001" y="-880" width="100" height="100" as="geometry">
          <mxPoint x="-4.640000000000001" y="-780" as="sourcePoint" />
          <mxPoint x="95.36" y="-880" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="energy intensity electro-chemical storage" Note="&lt;div&gt;embodied electric energy / storage capacity for electro-chemical storage , i.e. batteries. E.g. for Li-Ion NMC111: 457, NMC811: 323, NCA: 339 (Crenna et al. 2020, Desing et al. 2021)&lt;br&gt;&lt;/div&gt;" Equation="300" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="400" SliderMin="200" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1074" id="1074">
      <mxCell style="variable;fontSize=8;fillColor=#99CC00;" parent="763" vertex="1">
        <mxGeometry x="172.61" y="195.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="roundtrip efficiency electro-chemical storage" Note="For Li-Ion batteries: output energy from storage / input energy into storage = 0.94 (Desing and WIdmer 2022)&lt;br&gt;" Equation="0.94" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1075" id="1075">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="574.36" y="200" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="energy intensity mechanical storage" Note="&lt;div&gt;embodied electric energy / storage capacity for mechanical storage technologies. E.g. pumped hydro storage: EI=85 (Desing et al. 2021)&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;" Equation="85" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="30" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1076" id="1076">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="172.61" y="235.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="roundtrip efficiency mechanical storage" Note="For pumped hydro storage: output energy from storage / input energy into storage = 0.75 (Desing et al. 2021)&lt;br&gt;" Equation="0.75" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1077" id="1077">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="574.36" y="240" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="energy intensity chemical storage" Note="embodied electric energy / storage capacity for chemical storage, i.e. synthetic fuels. E.g. PEM electrolyzer to make H2 from H2O and methanization with CO2 from DAC to CH4: EI=60 (Zhang et al. 2017, Desing et al. 2021)&lt;br&gt;" Equation="63" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="30" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1078" id="1078">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="172.61" y="275.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="roundtrip efficiency chemical storage" Note="For synthetic CH4: output energy from storage / input energy into storage = 0.21 (Desing and Widmer 2022)&lt;br&gt;" Equation="0.21" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1079" id="1079">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="574.36" y="280" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="fraction mechanical storage" Note="scaling relative weights so that sum over all storage technologies equals 1; if all relative weights are zero, all storage technologies are given equal shares.&lt;br&gt;" Equation="If [sum weights]=0 Then&#xa;    1/3&#xa;Else&#xa;    [relative weight mechanical storage]/[sum weights]&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1080" id="1080">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="763" vertex="1">
        <mxGeometry x="324.61" y="235.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="fraction electro-chemical storage" Note="scaling relative weights so that sum over all storage technologies equals 1; if all relative weights are zero, all storage technologies are given equal shares.&lt;br&gt;" Equation="If [sum weights]=0 Then&#xa;    1/3&#xa;Else&#xa;    [relative weight electro-chemical storage]/[sum weights]&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1081" id="1081">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="763" vertex="1">
        <mxGeometry x="324.61" y="195.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="fraction  chemical storage" Note="scaling relative weights so that sum over all storage technologies equals 1; if all relative weights are zero, all storage technologies are given equal shares.&lt;br&gt;" Equation="If [sum weights]=0 Then&#xa;    1/3&#xa;Else&#xa;    [relative weight chemical storage]/[sum weights]&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1082" id="1082">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="763" vertex="1">
        <mxGeometry x="324.61" y="275.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1085">
      <mxCell style="link" parent="763" source="1074" target="2211" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1086">
      <mxCell style="link" parent="763" source="1076" target="2211" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1087">
      <mxCell style="link" parent="763" source="1078" target="2211" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1088">
      <mxCell style="link" parent="763" source="1081" target="2211" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1089">
      <mxCell style="link" parent="763" source="1080" target="2211" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1090">
      <mxCell style="link" parent="763" source="1082" target="2211" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1091">
      <mxCell style="link" parent="763" source="1081" target="753" edge="1">
        <mxGeometry x="172.61" y="-30" width="100" height="100" as="geometry">
          <mxPoint x="172.61" y="70" as="sourcePoint" />
          <mxPoint x="272.61" y="-30" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1092">
      <mxCell style="link" parent="763" source="1080" target="753" edge="1">
        <mxGeometry x="172.61" y="-30" width="100" height="100" as="geometry">
          <mxPoint x="172.61" y="70" as="sourcePoint" />
          <mxPoint x="272.61" y="-30" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1093">
      <mxCell style="link" parent="763" source="1082" target="753" edge="1">
        <mxGeometry x="172.61" y="-30" width="100" height="100" as="geometry">
          <mxPoint x="172.61" y="70" as="sourcePoint" />
          <mxPoint x="272.61" y="-30" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1094">
      <mxCell style="link" parent="763" source="1075" target="753" edge="1">
        <mxGeometry x="227.86" y="-30" width="100" height="100" as="geometry">
          <mxPoint x="227.86" y="70" as="sourcePoint" />
          <mxPoint x="327.86" y="-30" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1095">
      <mxCell style="link" parent="763" source="1077" target="753" edge="1">
        <mxGeometry x="227.86" y="-30" width="100" height="100" as="geometry">
          <mxPoint x="227.86" y="70" as="sourcePoint" />
          <mxPoint x="327.86" y="-30" as="targetPoint" />
          <Array as="points">
            <mxPoint x="567.36" y="218" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1096">
      <mxCell style="link" parent="763" source="1079" target="753" edge="1">
        <mxGeometry x="172.61" y="-30" width="100" height="100" as="geometry">
          <mxPoint x="172.61" y="70" as="sourcePoint" />
          <mxPoint x="272.61" y="-30" as="targetPoint" />
          <Array as="points">
            <mxPoint x="492.11" y="218" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="required storage capacity" Note="Storage capacity depends on the demand that needs to be stored for the period of the independence time enlarged by the output losses.&lt;br&gt;" Equation="[fraction of power stored]*[P_demand]*[independence time]/[storage output efficiency]" Units="TW * a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1117" id="1117">
      <mxCell style="variable;fontSize=8;" parent="763" vertex="1">
        <mxGeometry x="497.86" y="386.99" width="70" height="45.5" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="247" name="P_demand" id="1118">
      <mxCell style="variable;fontSize=12;fillColor=#FDCDAC;opacity=30;" parent="763" vertex="1">
        <mxGeometry x="597.8600000000001" y="392.24" width="90" height="35" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="1119">
      <mxCell style="link" parent="763" source="1118" target="1117" edge="1">
        <mxGeometry x="168.36" y="11.740000000000002" width="100" height="100" as="geometry">
          <mxPoint x="168.36" y="111.74000000000001" as="sourcePoint" />
          <mxPoint x="268.36" y="11.740000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="PV vs storage energy intensity" Note="&lt;div&gt;relationship between energy intensity of PV and energy intensity of storage, or in other words, for each unit of energy invested in PV, how much energy needs to be invested in corresponding storage?&lt;br&gt;&lt;/div&gt;&lt;div&gt;EPBT_PV / (EI storage * independence time)&lt;/div&gt;" Equation="If [independence time]={0 a} Then&#xa;    0&#xa;Else&#xa;    [EPBT_PV]/([storage energy intensity]*[independence time])&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0.7" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1194" id="1194">
      <mxCell style="variable;fontSize=6;" parent="763" vertex="1">
        <mxGeometry x="302.11" y="115.5" width="49.75" height="49" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1195">
      <mxCell style="link" parent="763" source="2261" target="1194" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1196">
      <mxCell style="link" parent="763" source="749" target="1194" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1197">
      <mxCell style="link" parent="763" source="2113" target="1194" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="relative weight chemical storage" Note="&lt;div&gt;importance of storage technology. If 0, technology is not included in the storage technology mix&lt;br&gt;&lt;/div&gt;" Equation="0.2" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1218" id="1218">
      <mxCell style="variable;fontSize=8;fillColor=#99CC00;" parent="763" vertex="1">
        <mxGeometry x="412.11" y="280.5" width="70" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="relative weight mechanical storage" Note="&lt;div&gt;importance of storage technology. If 0, technology is not included in the storage technology mix&lt;br&gt;&lt;/div&gt;" Equation="0.2" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1219" id="1219">
      <mxCell style="variable;fontSize=8;fillColor=#99CC00;" parent="763" vertex="1">
        <mxGeometry x="412.11" y="240.5" width="70" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="relative weight electro-chemical storage" Note="&lt;div&gt;importance of storage technology. If 0, technology is not included in the storage technology mix&lt;br&gt;&lt;/div&gt;" Equation="0.6" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="true" SliderMax="1" SliderMin="0" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1220" id="1220">
      <mxCell style="variable;fontSize=8;fillColor=#99CC00;" parent="763" vertex="1">
        <mxGeometry x="412.11" y="195.5" width="70" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="sum weights" Note="" Equation="[relative weight chemical storage]+[relative weight mechanical storage]+[relative weight electro-chemical storage]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1221" id="1221">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="763" vertex="1">
        <mxGeometry x="412.11" y="336.75" width="70" height="28.75" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1222">
      <mxCell style="link" parent="763" source="1218" target="1221" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1223">
      <mxCell style="link" parent="763" source="1219" target="1221" edge="1">
        <mxGeometry x="172.61" y="-30" width="100" height="100" as="geometry">
          <mxPoint x="172.61" y="70" as="sourcePoint" />
          <mxPoint x="272.61" y="-30" as="targetPoint" />
          <Array as="points">
            <mxPoint x="522.11" y="298" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1224">
      <mxCell style="link" parent="763" source="1220" target="1221" edge="1">
        <mxGeometry x="172.61" y="-30" width="100" height="100" as="geometry">
          <mxPoint x="172.61" y="70" as="sourcePoint" />
          <mxPoint x="272.61" y="-30" as="targetPoint" />
          <Array as="points">
            <mxPoint x="542.11" y="278" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1225">
      <mxCell style="link" parent="763" source="1220" target="1081" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1226">
      <mxCell style="link" parent="763" source="1219" target="1080" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1227">
      <mxCell style="link" parent="763" source="1218" target="1082" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1228">
      <mxCell style="link" parent="763" source="1221" target="1082" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1229">
      <mxCell style="link" parent="763" source="1221" target="1080" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1230">
      <mxCell style="link" parent="763" source="1221" target="1081" edge="1">
        <mxGeometry x="152.61" y="-34.5" width="100" height="100" as="geometry">
          <mxPoint x="152.61" y="65.5" as="sourcePoint" />
          <mxPoint x="252.61" y="-34.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="761">
      <mxCell style="link" parent="763" source="757" target="1233" edge="1">
        <mxGeometry x="-52.760000000000005" y="824" width="100" height="100" as="geometry">
          <mxPoint x="560.7473551422247" y="339.39551316558504" as="sourcePoint" />
          <mxPoint x="47.239999999999995" y="824" as="targetPoint" />
          <Array as="points">
            <mxPoint x="532.11" y="128" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_storage_loss" Note="power lost for storing the required fraction of power demand&lt;br&gt;" Equation="If [required storage capacity]&lt;={0 TW * a} Then&#xa;    0&#xa;Else&#xa;    [P_supply to society curtailled]*[storage loss coefficient]*[storage capacity]/[required storage capacity]&#xa;End If" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1233" id="1233">
      <mxCell style="variable;fontSize=6;" parent="763" vertex="1">
        <mxGeometry x="557.86" y="449.74" width="50.5" height="44" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="P_build storage after transition" Note="maintaining storage capacity at a level high enough to provide required storage capacity&lt;br&gt;" Equation="Max([Transition complete shifted]*([required storage capacity]-[storage capacity])/[storage building time constant],{0 TW})" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1240" id="1240">
      <mxCell style="variable;fontSize=6;" parent="763" vertex="1">
        <mxGeometry x="467.86" y="451.74" width="40.63" height="42" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1243">
      <mxCell style="link" parent="763" source="1117" target="1240" edge="1">
        <mxGeometry x="168.36" y="11.740000000000002" width="100" height="100" as="geometry">
          <mxPoint x="168.36" y="111.74000000000001" as="sourcePoint" />
          <mxPoint x="268.36" y="11.740000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="724" name="Transition complete" id="1143">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="763" vertex="1">
        <mxGeometry x="377.86" y="463.12" width="53" height="19.25" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="1245">
      <mxCell style="link" parent="763" source="1143" target="1240" edge="1">
        <mxGeometry x="168.36" y="11.740000000000002" width="100" height="100" as="geometry">
          <mxPoint x="168.36" y="111.74000000000001" as="sourcePoint" />
          <mxPoint x="268.36" y="11.740000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="P_build storage during transition" Note="power to build storage capacity during the transition until storage capacity reaches the required storage capacity&lt;br&gt;" Equation="[P_PV build up]*[fraction of P invested in RE necessary for storage]&#xa;#If [Transition complete]=0 And [storage capacity]&lt;[required storage capacity] Then&#xa;#If [storage capacity]&lt;[required storage capacity] Then&#xa;#[P_PV build up]    /(1+[oversize PV]*[oversize PV to compensate storage losses]*[PV vs storage energy intensity]*[storage output efficiency]/[fraction of power stored])&#xa;  #[P_build_PV1]/(1+[oversize PV]*[oversize PV to compensate storage losses]*[PV vs storage energy intensity]*[storage output efficiency]/[fraction of power stored])&#xa;#Else&#xa;#    {0 TW}&#xa;#End If" Units="TW" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1246" id="1246">
      <mxCell style="variable;fontSize=6;" parent="763" vertex="1">
        <mxGeometry x="295.98" y="491.75" width="40.63" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1249">
      <mxCell style="link" parent="763" source="1194" target="2609" edge="1">
        <mxGeometry x="172.61" y="-30" width="100" height="100" as="geometry">
          <mxPoint x="172.61" y="70" as="sourcePoint" />
          <mxPoint x="272.61" y="-30" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1251">
      <mxCell style="link" parent="763" source="1117" target="2609" edge="1">
        <mxGeometry x="168.36" y="11.740000000000002" width="100" height="100" as="geometry">
          <mxPoint x="168.36" y="111.74000000000001" as="sourcePoint" />
          <mxPoint x="268.36" y="11.740000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1257">
      <mxCell style="link" parent="763" source="1117" target="1233" edge="1">
        <mxGeometry x="168.36" y="11.740000000000002" width="100" height="100" as="geometry">
          <mxPoint x="168.36" y="111.74000000000001" as="sourcePoint" />
          <mxPoint x="268.36" y="11.740000000000002" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1259">
      <mxCell style="link" parent="763" source="749" target="1117" edge="1">
        <mxGeometry x="172.61" y="-30" width="100" height="100" as="geometry">
          <mxPoint x="172.61" y="70" as="sourcePoint" />
          <mxPoint x="272.61" y="-30" as="targetPoint" />
          <Array as="points">
            <mxPoint x="532.11" y="208" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="output efficiency electro-chemical storage" Note="For Li-Ion batteries: output energy from storage / stored energy in storage = 0.97 (Desing et al. 2021)&lt;br&gt;" Equation="0.97" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1274" id="1274">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="106.36" y="185.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="output efficiency mechanical storage" Note="For pumped hydro storage: output energy from storage / stored energy in storage = 0.9 (Desing et al. 2021)" Equation="0.9" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1275" id="1275">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="106.36" y="230.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="output efficiency chemical storage" Note="For synthetic methane: output energy from storage / stored energy in storage = 0.4 (Desing et al. 2021)" Equation="0.4" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1276" id="1276">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="106.36" y="275.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="storage output efficiency" Note="output energy from storage / stored energy in storage&lt;br&gt;" Equation="1/([fraction electro-chemical storage]/[output efficiency electro-chemical storage]+[fraction mechanical storage]/[output efficiency mechanical storage]+[fraction  chemical storage]/[output efficiency chemical storage])&#xa;&#xa;#[output efficiency electro-chemical storage]*[fraction electro-chemical storage]+[output efficiency mechanical storage]*[fraction mechanical storage]+[output efficiency chemical storage]*[fraction  chemical storage]" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0.7" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1277" id="1277">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="763" vertex="1">
        <mxGeometry x="113.11" y="330.87" width="59.5" height="40.51" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1278">
      <mxCell style="link" parent="763" source="1274" target="1277" edge="1">
        <mxGeometry x="171.86" y="10" width="100" height="100" as="geometry">
          <mxPoint x="171.86" y="110" as="sourcePoint" />
          <mxPoint x="271.86" y="10" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1279">
      <mxCell style="link" parent="763" source="1275" target="1277" edge="1">
        <mxGeometry x="171.86" y="10" width="100" height="100" as="geometry">
          <mxPoint x="171.86" y="110" as="sourcePoint" />
          <mxPoint x="271.86" y="10" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1280">
      <mxCell style="link" parent="763" source="1276" target="1277" edge="1">
        <mxGeometry x="171.86" y="10" width="100" height="100" as="geometry">
          <mxPoint x="171.86" y="110" as="sourcePoint" />
          <mxPoint x="271.86" y="10" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1281">
      <mxCell style="link" parent="763" source="1081" target="1277" edge="1">
        <mxGeometry x="171.86" y="10" width="100" height="100" as="geometry">
          <mxPoint x="171.86" y="110" as="sourcePoint" />
          <mxPoint x="271.86" y="10" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1282">
      <mxCell style="link" parent="763" source="1080" target="1277" edge="1">
        <mxGeometry x="171.86" y="10" width="100" height="100" as="geometry">
          <mxPoint x="171.86" y="110" as="sourcePoint" />
          <mxPoint x="271.86" y="10" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1283">
      <mxCell style="link" parent="763" source="1082" target="1277" edge="1">
        <mxGeometry x="171.86" y="10" width="100" height="100" as="geometry">
          <mxPoint x="171.86" y="110" as="sourcePoint" />
          <mxPoint x="271.86" y="10" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1284">
      <mxCell style="link" parent="763" source="1277" target="1117" edge="1">
        <mxGeometry x="167.61" y="51.74" width="100" height="100" as="geometry">
          <mxPoint x="167.61" y="151.74" as="sourcePoint" />
          <mxPoint x="267.61" y="51.74" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="storage building time constant" Note="adjustment time constant for maintaining storage capacity&lt;br&gt;" Equation="0.003" Units="Years" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="0.1" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1287" id="1287">
      <mxCell style="variable;fontSize=6;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="517.23" y="467.74" width="40.63" height="42" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1288">
      <mxCell style="link" parent="763" source="1287" target="1240" edge="1">
        <mxGeometry x="167.61" y="51.74" width="100" height="100" as="geometry">
          <mxPoint x="167.61" y="151.74" as="sourcePoint" />
          <mxPoint x="267.61" y="51.74" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1289">
      <mxCell style="link" parent="763" source="1277" target="2609" edge="1">
        <mxGeometry x="167.61" y="51.74" width="100" height="100" as="geometry">
          <mxPoint x="167.61" y="151.74" as="sourcePoint" />
          <mxPoint x="267.61" y="51.74" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="maximum fraction of power stored for seasonal variations" Note="seasonal variations of average daily yield throughout the year depend on the latitude. As more than 90% of the world&#39;s population live in the &quot;sun belt&quot; where seasonal variations are low (Victoria et al. 2021), we estimate that the maximum fraction of power stored to level out seasonal variation globally is 0.2." Equation="0.2" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0.7" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="754" id="1376">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="508.49" y="20" width="113.37" height="60" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1377">
      <mxCell style="link" parent="763" source="1376" target="754" edge="1">
        <mxGeometry x="151.86" y="5.5" width="100" height="100" as="geometry">
          <mxPoint x="151.86" y="105.5" as="sourcePoint" />
          <mxPoint x="251.86" y="5.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1378">
      <mxCell style="link" parent="763" source="754" target="1117" edge="1">
        <mxGeometry x="171.86" y="10" width="100" height="100" as="geometry">
          <mxPoint x="171.86" y="110" as="sourcePoint" />
          <mxPoint x="271.86" y="10" as="targetPoint" />
          <Array as="points">
            <mxPoint x="541.36" y="153" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="216" name="oversize PV" id="1381">
      <mxCell style="variable;fontSize=12;fillColor=#99CC00;opacity=30;" parent="763" vertex="1">
        <mxGeometry x="351.86" y="385.24" width="87" height="24.25" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="1382">
      <mxCell style="link" parent="763" source="1381" target="2609" edge="1">
        <mxGeometry x="171.86" y="10" width="100" height="100" as="geometry">
          <mxPoint x="171.86" y="110" as="sourcePoint" />
          <mxPoint x="271.86" y="10" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1383">
      <mxCell style="link" parent="763" source="754" target="2609" edge="1">
        <mxGeometry x="171.86" y="10" width="100" height="100" as="geometry">
          <mxPoint x="171.86" y="110" as="sourcePoint" />
          <mxPoint x="271.86" y="10" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="oversize PV to compensate storage losses" Note="" Equation="If [independence time]&gt;{0 a} Then&#xa;    1+[storage loss coefficient]&#xa;Else&#xa;    1&#xa;End If" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="1" SliderMin="0" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1386" id="1386">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;" parent="763" vertex="1">
        <mxGeometry x="499.61" y="109.74" width="70" height="49.75" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" id="1389">
      <mxCell style="link" parent="763" source="1386" target="2609" edge="1">
        <mxGeometry x="106.36" y="6.74" width="100" height="100" as="geometry">
          <mxPoint x="106.36" y="106.74" as="sourcePoint" />
          <mxPoint x="206.36" y="6.74" as="targetPoint" />
          <Array as="points" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1390">
      <mxCell style="link" parent="763" source="749" target="1386" edge="1">
        <mxGeometry x="86.36" y="2.24" width="100" height="100" as="geometry">
          <mxPoint x="86.36" y="102.24" as="sourcePoint" />
          <mxPoint x="186.36" y="2.24" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1391">
      <mxCell style="link" parent="763" source="757" target="1386" edge="1">
        <mxGeometry x="106.36" y="6.74" width="100" height="100" as="geometry">
          <mxPoint x="106.36" y="106.74" as="sourcePoint" />
          <mxPoint x="206.36" y="6.74" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1422" id="1422">
      <mxCell style="link" parent="763" source="1274" target="2211" edge="1">
        <mxGeometry x="106.36" y="6.74" width="100" height="100" as="geometry">
          <mxPoint x="106.36" y="106.74" as="sourcePoint" />
          <mxPoint x="206.36" y="6.74" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1423" id="1423">
      <mxCell style="link" parent="763" source="1275" target="2211" edge="1">
        <mxGeometry x="106.36" y="6.74" width="100" height="100" as="geometry">
          <mxPoint x="106.36" y="106.74" as="sourcePoint" />
          <mxPoint x="206.36" y="6.74" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1424" id="1424">
      <mxCell style="link" parent="763" source="1276" target="2211" edge="1">
        <mxGeometry x="106.36" y="6.74" width="100" height="100" as="geometry">
          <mxPoint x="106.36" y="106.74" as="sourcePoint" />
          <mxPoint x="206.36" y="6.74" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1425" id="1425">
      <mxCell style="link" parent="763" source="1277" target="2211" edge="1">
        <mxGeometry x="106.36" y="6.74" width="100" height="100" as="geometry">
          <mxPoint x="106.36" y="106.74" as="sourcePoint" />
          <mxPoint x="206.36" y="6.74" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="1360" name="P_supply to society curtailled" oldId="1379" id="1379">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="763" vertex="1">
        <mxGeometry x="656.36" y="434.4899999999998" width="78.5" height="46" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="1237">
      <mxCell style="link" parent="763" source="1379" target="1233" edge="1">
        <mxGeometry x="-183.51" y="116.74" width="100" height="100" as="geometry">
          <mxPoint x="-183.51" y="216.74" as="sourcePoint" />
          <mxPoint x="-83.51" y="116.74" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2100" oldId="2113" name="EPBT_PV" id="2113">
      <mxCell style="variable;fontSize=10;fillColor=#FDCDAC;opacity=30;" parent="763" vertex="1">
        <mxGeometry x="182.23999999999967" y="104.79999999999997" width="50.75" height="27.7" as="geometry" />
      </mxCell>
    </Ghost>
    <Variable name="Al intensity electro-chemical storage" Note="" Equation="16.25" Units="Gt/(TW*a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="400" SliderMin="200" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2114" id="2114">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="26.360000000000014" y="190.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al intensity mechanical storage" Note="" Equation="0.004" Units="Gt/(TW*a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="30" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2115" id="2115">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="26.360000000000014" y="230.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al intensity chemical storage" Note="" Equation="0.02" Units="Gt/(TW*a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="30" SliderStep="0.001" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2116" id="2116">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="26.360000000000014" y="270.5" width="70" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2118" id="2118">
      <mxCell style="link" parent="763" source="2114" target="1702" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2119" id="2119">
      <mxCell style="link" parent="763" source="2115" target="1702" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2120" id="2120">
      <mxCell style="link" parent="763" source="2116" target="1702" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2123" id="2123">
      <mxCell style="link" parent="763" source="1081" target="1702" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2124" id="2124">
      <mxCell style="link" parent="763" source="1080" target="1702" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2125" id="2125">
      <mxCell style="link" parent="763" source="1082" target="1702" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="storage Al intensity" Note="" Equation="[storage output efficiency]*([Al intensity electro-chemical storage]*[fraction electro-chemical storage]/[output efficiency electro-chemical storage]+[Al intensity mechanical storage]*[fraction mechanical storage]/[output efficiency mechanical storage]+[Al intensity chemical storage]*[fraction  chemical storage]/[output efficiency chemical storage])" Units="Gt/(TW*a)" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="0.31" SliderMin="0.06" SliderStep="0.01" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="1702" id="1702">
      <mxCell style="variable;fontSize=8;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="26.36" y="141.21" width="61.96" height="40.07" as="geometry" />
      </mxCell>
    </Variable>
    <Variable name="Al to storage" Note="" Equation="[storage cap building]*[storage Al intensity]" Units="Gt/a" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2127" id="2127">
      <mxCell style="variable;fontSize=6;" parent="763" vertex="1">
        <mxGeometry x="37.02000000000005" y="85.75" width="40.63" height="42" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2128" id="2128">
      <mxCell style="link" parent="763" source="2204" target="2127" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2129" id="2129">
      <mxCell style="link" parent="763" source="1702" target="2127" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2189" oldId="2204" name="storage cap building" id="2204">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="763" vertex="1">
        <mxGeometry x="38.59000000000002" y="33.5" width="37.5" height="38" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2240" id="2240">
      <mxCell style="link" parent="763" source="1276" target="1702" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2241" id="2241">
      <mxCell style="link" parent="763" source="1275" target="1702" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2242" id="2242">
      <mxCell style="link" parent="763" source="1274" target="1702" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2243" id="2243">
      <mxCell style="link" parent="763" source="1277" target="1702" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="EI storage 0" Note="at time zero&lt;br&gt;" Equation="[storage output efficiency]*([energy intensity electro-chemical storage]*[fraction electro-chemical storage]/[output efficiency electro-chemical storage]+[energy intensity mechanical storage]*[fraction mechanical storage]/[output efficiency mechanical storage]+[energy intensity chemical storage]*[fraction  chemical storage]/[output efficiency chemical storage])&#xa;([energy intensity electro-chemical storage]*[fraction electro-chemical storage]+[energy intensity mechanical storage]*[fraction mechanical storage]+[energy intensity chemical storage]*[fraction  chemical storage])" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="2" SliderMin="1.5" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2211" id="2211">
      <mxCell style="variable;fontSize=10;fillColor=#FFCC00;" parent="763" vertex="1">
        <mxGeometry x="174.8600000000008" y="140.50000000000034" width="50.75" height="49.5" as="geometry" />
      </mxCell>
    </Variable>
    <Ghost Source="1072" oldId="2261" name="storage energy intensity" id="2261">
      <mxCell style="variable;fontSize=8;fillColor=#FDCDAC;opacity=30;" parent="763" vertex="1">
        <mxGeometry x="165.61" y="51" width="69.25" height="40" as="geometry" />
      </mxCell>
    </Ghost>
    <Ghost Source="1111" oldId="2203" name="storage capacity" id="2203">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="763" vertex="1">
        <mxGeometry x="242.61" y="394.49" width="32" height="40" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" id="1250">
      <mxCell style="link" parent="763" source="2203" target="2609" edge="1">
        <mxGeometry x="168.36" y="11.740000000000009" width="100" height="100" as="geometry">
          <mxPoint x="168.36" y="111.74000000000001" as="sourcePoint" />
          <mxPoint x="268.36" y="11.740000000000009" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1244">
      <mxCell style="link" parent="763" source="2203" target="1240" edge="1">
        <mxGeometry x="168.36" y="11.740000000000009" width="100" height="100" as="geometry">
          <mxPoint x="168.36" y="111.74000000000001" as="sourcePoint" />
          <mxPoint x="268.36" y="11.740000000000009" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" id="1258">
      <mxCell style="link" parent="763" source="2203" target="1233" edge="1">
        <mxGeometry x="168.36" y="11.740000000000009" width="100" height="100" as="geometry">
          <mxPoint x="168.36" y="111.74000000000001" as="sourcePoint" />
          <mxPoint x="268.36" y="11.740000000000009" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Ghost Source="2601" oldId="2604" name="P_PV build up" id="2604">
      <mxCell style="variable;fontSize=8;opacity=30;" parent="763" vertex="1">
        <mxGeometry x="225.60999999999967" y="482.37" width="60" height="15.99" as="geometry" />
      </mxCell>
    </Ghost>
    <Link name="Link" Note="" BiDirectional="false" oldId="2605" id="2605">
      <mxCell style="link" parent="763" source="2604" target="1246" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="fraction of P invested in RE necessary for storage" Note="" Equation="1/(1+[oversize PV]*[oversize PV to compensate storage losses]*[PV vs storage energy intensity]*[storage output efficiency]/[fraction of power stored])" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="69" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2609" id="2609">
      <mxCell style="variable;fontSize=6;" parent="763" vertex="1">
        <mxGeometry x="295.98000000000013" y="442.37" width="40.63" height="40" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2610" id="2610">
      <mxCell style="link" parent="763" source="2609" target="1246" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Variable name="Transition complete shifted" Note="" Equation="Delay3([Transition complete], {1 a},0)" Units="Unitless" MaxConstraintUsed="false" MinConstraintUsed="false" MaxConstraint="100" MinConstraint="0" ShowSlider="false" SliderMax="100" SliderMin="0" SliderStep="" Image="None" FlipHorizontal="false" FlipVertical="false" LabelPosition="Middle" oldId="2614" id="2614">
      <mxCell style="variable;fontSize=8;" parent="763" vertex="1">
        <mxGeometry x="385.8599999999997" y="493.74" width="53" height="30" as="geometry" />
      </mxCell>
    </Variable>
    <Link name="Link" Note="" BiDirectional="false" oldId="2615" id="2615">
      <mxCell style="link" parent="763" source="1143" target="2614" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2616" id="2616">
      <mxCell style="link" parent="763" source="2614" target="1240" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1617" id="1617">
      <mxCell style="link" parent="1" source="1549" target="1602" edge="1">
        <mxGeometry x="-730.99" y="646.4100000000001" width="100" height="100" as="geometry">
          <mxPoint x="-730.99" y="746.4100000000001" as="sourcePoint" />
          <mxPoint x="-630.99" y="646.4100000000001" as="targetPoint" />
          <Array as="points">
            <mxPoint x="640" y="1530" />
          </Array>
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1627" id="1627">
      <mxCell style="link" parent="1" source="1626" target="1625" edge="1">
        <mxGeometry x="965.2900000000001" y="1185.73" width="100" height="100" as="geometry">
          <mxPoint x="965.2900000000001" y="1285.7299999999998" as="sourcePoint" />
          <mxPoint x="1065.29" y="1185.73" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1629" id="1629">
      <mxCell style="link" parent="1" source="1608" target="1628" edge="1">
        <mxGeometry x="-749.66" y="703.49" width="100" height="100" as="geometry">
          <mxPoint x="-749.66" y="803.49" as="sourcePoint" />
          <mxPoint x="-649.66" y="703.49" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1631" id="1631">
      <mxCell style="link" parent="1" source="1628" target="1625" edge="1">
        <mxGeometry x="970.2900000000001" y="1231.52" width="100" height="100" as="geometry">
          <mxPoint x="970.2900000000001" y="1331.52" as="sourcePoint" />
          <mxPoint x="1070.29" y="1231.52" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1639" id="1639">
      <mxCell style="link" parent="1" source="1638" target="1625" edge="1">
        <mxGeometry x="965.2900000000001" y="1185.73" width="100" height="100" as="geometry">
          <mxPoint x="965.2900000000001" y="1285.7299999999998" as="sourcePoint" />
          <mxPoint x="1065.29" y="1185.73" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1740" id="1740">
      <mxCell style="link" parent="1" source="1739" target="1506" edge="1">
        <mxGeometry x="-704.66" y="367.38000000000005" width="100" height="100" as="geometry">
          <mxPoint x="-704.66" y="467.38000000000005" as="sourcePoint" />
          <mxPoint x="-604.66" y="367.38000000000005" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="1633" id="1633">
      <mxCell style="link" parent="1" source="1693" target="1645" edge="1">
        <mxGeometry x="-734.66" y="587.3800000000001" width="100" height="100" as="geometry">
          <mxPoint x="-734.66" y="687.3800000000001" as="sourcePoint" />
          <mxPoint x="-634.66" y="587.3800000000001" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2436" id="2436">
      <mxCell style="link" parent="1" source="185" target="2435" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="2438" id="2438">
      <mxCell style="link" parent="1" source="247" target="2435" edge="1">
        <mxGeometry width="100" height="100" as="geometry">
          <mxPoint y="100" as="sourcePoint" />
          <mxPoint x="100" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Display name="overview" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" ThreeDimensional="false" Primitives="185,132,126,190,182,178,1360,247,442" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" legendPosition="Automatic" id="1002">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="Export" Note="" Type="Tabular" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" ThreeDimensional="false" Primitives="56,1016,1061,247,1360,171,132,185,178,126,190,1098,179,127,191,1202,1099,168,182,1115,229,371,510,523,907,561,1305,1311,1320,1321,347,433,1042,218,217,216,788,822,866,877,881,926,929,749,752,1074,1218,1219,1220,134,198,1405,1497,1938,1757,1506,1603,1965,1868,1635,2100,349,1072,1976,1587,2181,2053,2041,2035,1495,1578,1545,1546,1511,2309,708,565,706,707,1731,2299,2094,1498,1700,2151,1832,1958,2383,1843,2442,1695,1504,1492,2312,2458,1111,1702,2464,2528,1894,1939,2407,2418,1883,2401,2064" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" legendPosition="Automatic" id="1037">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="Energy stocks" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" ThreeDimensional="false" Primitives="124,235,588,585,1108" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" legendPosition="Automatic" id="252">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="P_PV" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" ThreeDimensional="false" Primitives="338,190,185,191,182" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" legendPosition="Automatic" id="509">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="P_CCS" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" ThreeDimensional="false" Primitives="171,178,179,168" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" legendPosition="Automatic" id="516">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="P_fC" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" ThreeDimensional="false" Primitives="132,126,127,237,125" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" legendPosition="Automatic" id="517">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="storage" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" ThreeDimensional="false" Primitives="1115,1098" Primitives2="1111,1117" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" legendPosition="Automatic" id="1126">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="Al supply" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" Primitives="1497,1506,1603,1938,1578,2383" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" oldId="2105" legendPosition="Automatic" id="2105">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="Alu use" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" Primitives="1578,1505,1499,1498,1731,1716,1700,1695" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" oldId="1593" legendPosition="Automatic" id="1593">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="Alu stock" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" Primitives="1493,1534,1587,1495,1715,1494" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" oldId="1592" legendPosition="Automatic" id="1592">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="checks" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" Primitives="1868,1635,1843,1546,1545" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" oldId="2106" legendPosition="Automatic" id="2106">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="controller" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" ThreeDimensional="false" Primitives="324,325" Primitives2="139,287" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" legendPosition="Automatic" id="153">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="Demand per person" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" ThreeDimensional="false" Primitives="1339,1305,1304,1342,1331" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" legendPosition="Automatic" id="1358">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="IPCC comparison" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" ThreeDimensional="false" Primitives="56,565,1290,1292,1293,708" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" legendPosition="Automatic" xAxisMin="0" yAxisMin="0" yAxisMax="4000" id="1035">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="StocksFlows" Note="" Type="Tabular" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" Primitives="191,1098,179,127,588,1108,585,1072,1082,1081,1080,743,222" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" oldId="1491" legendPosition="Automatic" id="1491">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="Export additionals" Note="" Type="Tabular" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" ThreeDimensional="false" Primitives="708,707,565,706,1290,1292,1293" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" legendPosition="Automatic" id="1367">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="Export CO2 balance" Note="" Type="Tabular" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" Primitives="56,57,194,1016" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" legendPosition="Automatic" oldId="1480" id="1480">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Display name="Temperature" Note="" Type="Time Series" xAxis="Time (%u)" yAxis="" yAxis2="" showMarkers="false" showLines="true" showArea="false" Primitives="2464" Primitives2="" AutoAddPrimitives="false" ScatterplotOrder="X Primitive, Y Primitive" Image="Display" FlipHorizontal="false" FlipVertical="false" LabelPosition="Bottom" oldId="2492" legendPosition="Automatic" yAxisMin="0" id="2492">
      <mxCell style="display" parent="1" vertex="1" visible="0">
        <mxGeometry x="10" y="10" width="64" height="64" as="geometry" />
      </mxCell>
    </Display>
    <Link name="Link" Note="" BiDirectional="false" id="226">
      <mxCell style="link;fontSize=12;" parent="1" source="225" target="237" edge="1">
        <mxGeometry x="13.629999999999995" y="123.5" width="100" height="100" as="geometry">
          <mxPoint x="13.629999999999995" y="223.5" as="sourcePoint" />
          <mxPoint x="113.63" y="123.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
    <Link name="Link" Note="" BiDirectional="false" oldId="129" id="129">
      <mxCell style="link;fontSize=12;" parent="1" source="128" target="237" edge="1">
        <mxGeometry x="158.63" y="220.5" width="100" height="100" as="geometry">
          <mxPoint x="158.63" y="320.5" as="sourcePoint" />
          <mxPoint x="258.63" y="220.5" as="targetPoint" />
        </mxGeometry>
      </mxCell>
    </Link>
  </root>
</InsightMakerModel>
`;

  // lib/xmlConverter.ts
  var import_xml2js2 = __toESM(require_xml2js(), 1);
  function parseGeometry(mxCell) {
    if (!mxCell?.mxGeometry?.[0]?.$) return null;
    const geom = mxCell.mxGeometry[0].$;
    return {
      x: parseFloat(geom.x) || 0,
      y: parseFloat(geom.y) || 0,
      width: parseFloat(geom.width) || 0,
      height: parseFloat(geom.height) || 0
    };
  }
  function parseElement(element, elementType) {
    const $ = element.$;
    if (!$) return null;
    const id2 = $.id;
    const name = $.name;
    const mxCell = element.mxCell?.[0];
    const geometry = parseGeometry(mxCell);
    const style2 = mxCell?.$?.style || "";
    const parent = mxCell?.$?.parent;
    let result = {
      id: id2,
      name,
      type: elementType.toUpperCase()
    };
    if (parent && parent !== "1") {
      result.folder = parent;
    }
    if (geometry) {
      result.display = {
        coordinates: [geometry.x, geometry.y],
        size: [geometry.width, geometry.height]
      };
    }
    if (style2) {
      result.display = result.display || {};
      result.display.style = style2;
    }
    switch (elementType) {
      case "Flow":
        if (mxCell?.$?.source) {
          result.from = mxCell.$.source;
        }
        if (mxCell?.$?.target) {
          result.to = mxCell.$.target;
        }
        break;
      case "Link":
        if (mxCell?.$?.source) {
          result.from = mxCell.$.source;
        }
        if (mxCell?.$?.target) {
          result.to = mxCell.$.target;
        }
        break;
      case "Ghost":
        if ($.Source) {
          result.source = $.Source;
        }
        break;
    }
    return result;
  }
  function resolveReferences(elements) {
    const idToName = {};
    return elements;
  }
  async function convertInsightMakerXmlToJson(xmlContent) {
    try {
      const parsed = await (0, import_xml2js2.parseStringPromise)(xmlContent, {
        explicitArray: true,
        mergeAttrs: false,
        attrkey: "$",
        charkey: "_"
      });
      const insightMaker = parsed.InsightMakerModel;
      if (!insightMaker?.root?.[0]) {
        throw new Error("Invalid InsightMaker file: missing root element");
      }
      const root2 = insightMaker.root[0];
      const elements = [];
      const idToName = {};
      const displays = [];
      const allElementTypes = [
        "Stock",
        "Flow",
        "Variable",
        "Link",
        "Converter",
        "Folder",
        "Display",
        "Button",
        "Picture",
        "Text",
        "Ghost"
      ];
      for (const elementType of allElementTypes) {
        const typeElements = root2[elementType];
        if (!typeElements) continue;
        for (const element of typeElements) {
          const $ = element.$;
          if ($?.id) {
            idToName[$.id] = $.name || "";
          }
          if (elementType !== "Display") {
            const parsed2 = parseElement(element, elementType);
            if (parsed2) {
              elements.push(parsed2);
            }
          }
        }
      }
      const displayElements = root2.Display;
      if (displayElements) {
        for (const display of displayElements) {
          const $ = display.$;
          if ($) {
            const primitiveIds = $?.Primitives?.split(",").map((id2) => id2.trim()) || [];
            const primitiveIds2 = $?.Primitives2?.split(",").map((id2) => id2.trim()).filter((id2) => id2) || [];
            displays.push({
              id: $.id || "",
              name: $.name || "",
              type: $.Type || "Time Series",
              primitiveIds,
              primitiveIds2: primitiveIds2.length > 0 ? primitiveIds2 : void 0
            });
          }
        }
      }
      const resolvedElements = resolveReferences(elements);
      return {
        elements: resolvedElements,
        displays,
        idToName
      };
    } catch (error) {
      throw error;
    }
  }

  // utils/layoutAlgorithm.ts
  var NODE_MARGIN = 120;
  var FOLDER_PADDING = 60;
  var FOLDER_HEADER_HEIGHT = 45;
  var FOLDER_MARGIN = 40;
  var DEFAULT_FOLDER_ID = "__ROOT__";
  function extractNeighbors(items) {
    const neighbors = /* @__PURE__ */ new Map();
    for (const item of items) {
      neighbors.set(item.id, {});
    }
    for (const item of items) {
      const itemCenterX = item.x + item.width / 2;
      const itemCenterY = item.y + item.height / 2;
      let closestTop = null;
      let closestBottom = null;
      let closestLeft = null;
      let closestRight = null;
      for (const other of items) {
        if (other.id === item.id) continue;
        const otherCenterX = other.x + other.width / 2;
        const otherCenterY = other.y + other.height / 2;
        const dx = otherCenterX - itemCenterX;
        const dy = otherCenterY - itemCenterY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        if (angle >= -135 && angle < -45) {
          if (!closestTop || dist < closestTop.dist) {
            closestTop = { id: other.id, dist };
          }
        } else if (angle >= -45 && angle < 45) {
          if (!closestRight || dist < closestRight.dist) {
            closestRight = { id: other.id, dist };
          }
        } else if (angle >= 45 && angle < 135) {
          if (!closestBottom || dist < closestBottom.dist) {
            closestBottom = { id: other.id, dist };
          }
        } else {
          if (!closestLeft || dist < closestLeft.dist) {
            closestLeft = { id: other.id, dist };
          }
        }
      }
      const itemNeighbors = neighbors.get(item.id);
      if (closestTop) itemNeighbors.top = closestTop.id;
      if (closestBottom) itemNeighbors.bottom = closestBottom.id;
      if (closestLeft) itemNeighbors.left = closestLeft.id;
      if (closestRight) itemNeighbors.right = closestRight.id;
    }
    return neighbors;
  }
  function rectsOverlap(r1, r2, margin = 0) {
    return !(r1.x + r1.width + margin <= r2.x || r2.x + r2.width + margin <= r1.x || r1.y + r1.height + margin <= r2.y || r2.y + r2.height + margin <= r1.y);
  }
  function getOverlapAmount(r1, r2) {
    const overlapX = Math.min(r1.x + r1.width, r2.x + r2.width) - Math.max(r1.x, r2.x);
    const overlapY = Math.min(r1.y + r1.height, r2.y + r2.height) - Math.max(r1.y, r2.y);
    return { x: Math.max(0, overlapX), y: Math.max(0, overlapY) };
  }
  function resolveCollisions(rects, options) {
    const { maxIterations, margin } = options;
    const result = rects.map((r2) => ({ ...r2 }));
    for (let iter = 0; iter < maxIterations; iter++) {
      let hasCollision = false;
      for (let i2 = 0; i2 < result.length; i2++) {
        for (let j = i2 + 1; j < result.length; j++) {
          if (rectsOverlap(result[i2], result[j], margin)) {
            hasCollision = true;
            const overlap = getOverlapAmount(result[i2], result[j]);
            const pushX = (overlap.x + margin) / 2;
            const pushY = (overlap.y + margin) / 2;
            const center1X = result[i2].x + result[i2].width / 2;
            const center1Y = result[i2].y + result[i2].height / 2;
            const center2X = result[j].x + result[j].width / 2;
            const center2Y = result[j].y + result[j].height / 2;
            if (overlap.x < overlap.y) {
              if (center1X < center2X) {
                result[i2].x -= pushX;
                result[j].x += pushX;
              } else {
                result[i2].x += pushX;
                result[j].x -= pushX;
              }
            } else {
              if (center1Y < center2Y) {
                result[i2].y -= pushY;
                result[j].y += pushY;
              } else {
                result[i2].y += pushY;
                result[j].y -= pushY;
              }
            }
          }
        }
      }
      if (!hasCollision) break;
    }
    return result;
  }
  function arrangeNodesWithNeighbors(nodes, neighborMap) {
    if (nodes.length === 0) return [];
    if (nodes.length === 1) {
      return [{ id: nodes[0].id, x: 0, y: 0, width: nodes[0].width, height: nodes[0].height }];
    }
    const nodeMap = new Map(nodes.map((n2) => [n2.id, n2]));
    const positioned = /* @__PURE__ */ new Map();
    const toProcess = new Set(nodes.map((n2) => n2.id));
    const firstNode = nodes[0];
    positioned.set(firstNode.id, {
      id: firstNode.id,
      x: 0,
      y: 0,
      width: firstNode.width,
      height: firstNode.height
    });
    toProcess.delete(firstNode.id);
    let maxIterations = nodes.length * 10;
    while (toProcess.size > 0 && maxIterations-- > 0) {
      for (const nodeId of toProcess) {
        const node = nodeMap.get(nodeId);
        const neighbors = neighborMap.get(nodeId);
        let placed = false;
        if (neighbors?.left && positioned.has(neighbors.left)) {
          const leftNeighbor = positioned.get(neighbors.left);
          positioned.set(nodeId, {
            id: nodeId,
            x: leftNeighbor.x + leftNeighbor.width + NODE_MARGIN,
            y: leftNeighbor.y,
            width: node.width,
            height: node.height
          });
          placed = true;
        } else if (neighbors?.right && positioned.has(neighbors.right)) {
          const rightNeighbor = positioned.get(neighbors.right);
          positioned.set(nodeId, {
            id: nodeId,
            x: rightNeighbor.x - node.width - NODE_MARGIN,
            y: rightNeighbor.y,
            width: node.width,
            height: node.height
          });
          placed = true;
        } else if (neighbors?.top && positioned.has(neighbors.top)) {
          const topNeighbor = positioned.get(neighbors.top);
          positioned.set(nodeId, {
            id: nodeId,
            x: topNeighbor.x,
            y: topNeighbor.y + topNeighbor.height + NODE_MARGIN,
            width: node.width,
            height: node.height
          });
          placed = true;
        } else if (neighbors?.bottom && positioned.has(neighbors.bottom)) {
          const bottomNeighbor = positioned.get(neighbors.bottom);
          positioned.set(nodeId, {
            id: nodeId,
            x: bottomNeighbor.x,
            y: bottomNeighbor.y - node.height - NODE_MARGIN,
            width: node.width,
            height: node.height
          });
          placed = true;
        }
        if (placed) {
          toProcess.delete(nodeId);
        }
      }
      if (toProcess.size > 0) {
        const stuckBefore = toProcess.size;
        if (stuckBefore === toProcess.size) {
          const nextNodeId = toProcess.values().next().value;
          const nextNode = nodeMap.get(nextNodeId);
          let maxY = 0;
          for (const rect of positioned.values()) {
            maxY = Math.max(maxY, rect.y + rect.height);
          }
          positioned.set(nextNodeId, {
            id: nextNodeId,
            x: 0,
            y: maxY + NODE_MARGIN,
            width: nextNode.width,
            height: nextNode.height
          });
          toProcess.delete(nextNodeId);
        }
      }
    }
    let yOffset = 0;
    for (const rect of positioned.values()) {
      yOffset = Math.max(yOffset, rect.y + rect.height);
    }
    for (const nodeId of toProcess) {
      const node = nodeMap.get(nodeId);
      positioned.set(nodeId, {
        id: nodeId,
        x: 0,
        y: yOffset + NODE_MARGIN,
        width: node.width,
        height: node.height
      });
      yOffset += node.height + NODE_MARGIN;
    }
    const rects = Array.from(positioned.values());
    return resolveCollisions(rects, { maxIterations: 100, margin: NODE_MARGIN });
  }
  function arrangeFoldersWithNeighbors(folders, neighborMap) {
    if (folders.length === 0) return [];
    if (folders.length === 1) {
      return [{ id: folders[0].id, x: 0, y: 0, width: folders[0].width, height: folders[0].height }];
    }
    const folderMap = new Map(folders.map((f2) => [f2.id, f2]));
    const positioned = /* @__PURE__ */ new Map();
    const toProcess = new Set(folders.map((f2) => f2.id));
    const firstFolder = folders[0];
    positioned.set(firstFolder.id, {
      id: firstFolder.id,
      x: 0,
      y: 0,
      width: firstFolder.width,
      height: firstFolder.height
    });
    toProcess.delete(firstFolder.id);
    let maxIterations = folders.length * 10;
    while (toProcess.size > 0 && maxIterations-- > 0) {
      for (const folderId of toProcess) {
        const folder = folderMap.get(folderId);
        const neighbors = neighborMap.get(folderId);
        let placed = false;
        if (neighbors?.left && positioned.has(neighbors.left)) {
          const leftNeighbor = positioned.get(neighbors.left);
          positioned.set(folderId, {
            id: folderId,
            x: leftNeighbor.x + leftNeighbor.width + FOLDER_MARGIN,
            y: leftNeighbor.y,
            width: folder.width,
            height: folder.height
          });
          placed = true;
        } else if (neighbors?.right && positioned.has(neighbors.right)) {
          const rightNeighbor = positioned.get(neighbors.right);
          positioned.set(folderId, {
            id: folderId,
            x: rightNeighbor.x - folder.width - FOLDER_MARGIN,
            y: rightNeighbor.y,
            width: folder.width,
            height: folder.height
          });
          placed = true;
        } else if (neighbors?.top && positioned.has(neighbors.top)) {
          const topNeighbor = positioned.get(neighbors.top);
          positioned.set(folderId, {
            id: folderId,
            x: topNeighbor.x,
            y: topNeighbor.y + topNeighbor.height + FOLDER_MARGIN,
            width: folder.width,
            height: folder.height
          });
          placed = true;
        } else if (neighbors?.bottom && positioned.has(neighbors.bottom)) {
          const bottomNeighbor = positioned.get(neighbors.bottom);
          positioned.set(folderId, {
            id: folderId,
            x: bottomNeighbor.x,
            y: bottomNeighbor.y - folder.height - FOLDER_MARGIN,
            width: folder.width,
            height: folder.height
          });
          placed = true;
        }
        if (placed) {
          toProcess.delete(folderId);
        }
      }
      if (toProcess.size > 0) {
        const stuckBefore = toProcess.size;
        if (stuckBefore === toProcess.size) {
          const nextFolderId = toProcess.values().next().value;
          const nextFolder = folderMap.get(nextFolderId);
          let maxX = 0;
          for (const rect of positioned.values()) {
            maxX = Math.max(maxX, rect.x + rect.width);
          }
          positioned.set(nextFolderId, {
            id: nextFolderId,
            x: maxX + FOLDER_MARGIN,
            y: 0,
            width: nextFolder.width,
            height: nextFolder.height
          });
          toProcess.delete(nextFolderId);
        }
      }
    }
    let xOffset = 0;
    for (const rect of positioned.values()) {
      xOffset = Math.max(xOffset, rect.x + rect.width);
    }
    for (const folderId of toProcess) {
      const folder = folderMap.get(folderId);
      positioned.set(folderId, {
        id: folderId,
        x: xOffset + FOLDER_MARGIN,
        y: 0,
        width: folder.width,
        height: folder.height
      });
      xOffset += folder.width + FOLDER_MARGIN;
    }
    const rects = Array.from(positioned.values());
    return resolveCollisions(rects, { maxIterations: 100, margin: FOLDER_MARGIN });
  }
  function normalizePositions(rects) {
    if (rects.length === 0) return rects;
    let minX = Infinity;
    let minY = Infinity;
    for (const rect of rects) {
      minX = Math.min(minX, rect.x);
      minY = Math.min(minY, rect.y);
    }
    return rects.map((r2) => ({
      ...r2,
      x: r2.x - minX,
      y: r2.y - minY
    }));
  }
  function calculateFolderLayout(nodes, folders) {
    const folderMap = new Map(folders.map((f2) => [f2.id, f2]));
    const orphanNodes = [];
    const assignedNodes = [];
    for (const node of nodes) {
      if (node.folderId && folderMap.has(node.folderId)) {
        assignedNodes.push(node);
      } else {
        orphanNodes.push(node);
      }
    }
    const allFolders = [...folders];
    if (orphanNodes.length > 0) {
      allFolders.push({
        id: DEFAULT_FOLDER_ID,
        name: "Root",
        x: 0,
        y: 0,
        width: 300,
        height: 200
      });
      for (const node of orphanNodes) {
        assignedNodes.push({ ...node, folderId: DEFAULT_FOLDER_ID });
      }
    }
    const folderNeighbors = extractNeighbors(allFolders);
    const nodesByFolder = /* @__PURE__ */ new Map();
    for (const folder of allFolders) {
      nodesByFolder.set(folder.id, []);
    }
    for (const node of assignedNodes) {
      nodesByFolder.get(node.folderId).push(node);
    }
    const folderNodePositions = /* @__PURE__ */ new Map();
    const folderSizes = /* @__PURE__ */ new Map();
    for (const folder of allFolders) {
      const folderNodes = nodesByFolder.get(folder.id) || [];
      if (folderNodes.length === 0) {
        folderSizes.set(folder.id, { width: 200, height: 100, childCount: 0 });
        folderNodePositions.set(folder.id, []);
        continue;
      }
      const nodeNeighbors = extractNeighbors(folderNodes);
      const arrangedNodes = arrangeNodesWithNeighbors(folderNodes, nodeNeighbors);
      const normalizedNodes = normalizePositions(arrangedNodes);
      folderNodePositions.set(folder.id, normalizedNodes);
      let maxX = 0;
      let maxY = 0;
      for (const rect of normalizedNodes) {
        maxX = Math.max(maxX, rect.x + rect.width);
        maxY = Math.max(maxY, rect.y + rect.height);
      }
      folderSizes.set(folder.id, {
        width: maxX + FOLDER_PADDING * 2,
        height: maxY + FOLDER_PADDING + FOLDER_HEADER_HEIGHT,
        childCount: folderNodes.length
      });
    }
    const foldersWithSizes = allFolders.map((f2) => ({
      id: f2.id,
      ...folderSizes.get(f2.id)
    }));
    const arrangedFolders = arrangeFoldersWithNeighbors(foldersWithSizes, folderNeighbors);
    const normalizedFolders = normalizePositions(arrangedFolders);
    const folderResults = normalizedFolders.map((f2) => ({
      id: f2.id,
      x: f2.x,
      y: f2.y,
      width: f2.width,
      height: f2.height,
      childCount: folderSizes.get(f2.id)?.childCount || 0
    }));
    const nodeResults = [];
    for (const folderResult of folderResults) {
      const nodePositions = folderNodePositions.get(folderResult.id) || [];
      for (const nodePos of nodePositions) {
        nodeResults.push({
          id: nodePos.id,
          x: nodePos.x + FOLDER_PADDING,
          y: nodePos.y + FOLDER_HEADER_HEIGHT,
          width: nodePos.width,
          height: nodePos.height,
          parentId: folderResult.id
        });
      }
    }
    return {
      nodes: nodeResults,
      folders: folderResults
    };
  }

  // lib/styleParser.ts
  function parseStyle(styleString) {
    const parsed = {};
    if (!styleString) return parsed;
    const parts = styleString.split(";").filter((p2) => p2.trim());
    for (const part of parts) {
      const trimmed = part.trim();
      if (["stock", "flow", "variable", "converter", "folder", "button", "picture", "text"].includes(trimmed.toLowerCase())) {
        parsed.elementType = trimmed.toLowerCase();
        continue;
      }
      if (trimmed.includes("=")) {
        const [key, value] = trimmed.split("=").map((s2) => s2.trim());
        switch (key.toLowerCase()) {
          case "fillcolor":
            parsed.fillColor = value;
            break;
          case "strokecolor":
            parsed.strokeColor = value;
            break;
          case "fontsize":
            parsed.fontSize = parseInt(value, 10);
            break;
          case "fontcolor":
            parsed.fontColor = value;
            break;
          case "fontstyle":
            parsed.fontStyle = value;
            break;
          case "fontfamily":
            parsed.fontFamily = value;
            break;
          case "opacity":
            parsed.opacity = parseFloat(value);
            break;
          case "rounded":
            parsed.rounded = value === "1" || value === "true";
            break;
          case "strokewidth":
            parsed.strokeWidth = parseInt(value, 10);
            break;
          case "strokedasharray":
            parsed.strokeDasharray = value;
            break;
          case "startarrow":
            parsed.startArrow = value;
            break;
          case "startfill":
            parsed.startFill = value === "1" || value === "true";
            break;
          case "endarrow":
            parsed.endArrow = value;
            break;
          case "endfill":
            parsed.endFill = value === "1" || value === "true";
            break;
          default:
            parsed[key] = value;
        }
      }
    }
    return parsed;
  }
  function getElementColor(elementType, styleColor, _styleElementType) {
    if (styleColor) {
      return styleColor;
    }
    switch (elementType) {
      case "STOCK":
        return "#3b82f6";
      // Blue
      case "FLOW":
        return "#ef4444";
      // Red
      case "VARIABLE":
        return "#10b981";
      // Green
      case "CONVERTER":
        return "#f59e0b";
      // Orange
      case "LINK":
        return "#64748b";
      // Slate
      case "FOLDER":
        return "#8b5cf6";
      // Purple
      case "DISPLAY":
        return "#06b6d4";
      // Cyan
      default:
        return "#6b7280";
    }
  }
  function getStyleBasedFillColor(styleElementType) {
    if (!styleElementType) return "#ffffff";
    switch (styleElementType.toLowerCase()) {
      case "stock":
        return "#dbeafe";
      // Light blue
      case "flow":
        return "#fee2e2";
      // Light red
      case "variable":
        return "#dcfce7";
      // Light green
      case "converter":
        return "#fed7aa";
      // Light orange
      case "folder":
        return "#ede9fe";
      // Light purple
      default:
        return "#ffffff";
    }
  }

  // utils/visualizer/buildLayoutData.ts
  function buildLayoutNodes(model, converted, layoutFolders, idToNameMap) {
    const jsonElementMap = /* @__PURE__ */ new Map();
    converted.elements.forEach((jsonEl) => {
      if (jsonEl.name) {
        if (jsonEl.type === "GHOST") {
          jsonElementMap.set(`__ghost__${jsonEl.name}`, jsonEl);
        } else if (jsonEl.type === "FOLDER") {
          jsonElementMap.set(`__folder__${jsonEl.name}`, jsonEl);
        } else {
          jsonElementMap.set(jsonEl.name, jsonEl);
        }
      }
    });
    const elements = model.find();
    const nodeElements = elements.filter((el) => {
      const className = el.constructor.name;
      return className !== "Link" && className !== "Flow" && className !== "Folder";
    });
    const layoutNodes = [];
    nodeElements.forEach((el) => {
      const jsonEl = jsonElementMap.get(el.name);
      const display = jsonEl?.display;
      const elementClass = el.constructor.name;
      let elementType = "VARIABLE";
      if (elementClass === "Stock") elementType = "STOCK";
      else if (elementClass === "Converter") elementType = "CONVERTER";
      const styleString = display?.style;
      const parsedStyle = parseStyle(styleString);
      if (isGhostNode(parsedStyle)) {
        elementType = "GHOST";
      }
      const defaultDims = NODE_DIMENSIONS[elementType] || NODE_DIMENSIONS.VARIABLE;
      let width = defaultDims.width;
      let height2 = defaultDims.height;
      if (display?.size && Array.isArray(display.size) && display.size[0] > 0 && display.size[1] > 0) {
        width = display.size[0] * 1.5;
        height2 = display.size[1] * 1.5;
      }
      const fontSize = parsedStyle.fontSize || 11;
      const minSize = ensureMinNodeSize(width, height2, el.name, elementType, fontSize);
      width = minSize.width;
      height2 = minSize.height;
      let x2 = 0, y2 = 0;
      if (display?.coordinates && Array.isArray(display.coordinates)) {
        x2 = display.coordinates[0] * 1.5;
        y2 = display.coordinates[1] * 1.5;
      }
      let folderId;
      if (jsonEl?.folder) {
        const folderName = idToNameMap.get(jsonEl.folder);
        if (folderName && layoutFolders.some((f2) => f2.id === folderName)) {
          folderId = folderName;
        }
      }
      layoutNodes.push({
        id: el.name,
        name: el.name,
        x: x2,
        y: y2,
        width,
        height: height2,
        folderId,
        type: elementType
      });
    });
    const addedNodeIds = new Set(layoutNodes.map((n2) => n2.id));
    converted.elements.forEach((jsonEl) => {
      if (jsonEl.type !== "GHOST") return;
      const ghostId = `__ghost__${jsonEl.id || jsonEl.name}`;
      if (addedNodeIds.has(ghostId)) return;
      const display = jsonEl.display;
      const defaultDims = NODE_DIMENSIONS.GHOST;
      let width = defaultDims.width;
      let height2 = defaultDims.height;
      if (display?.size && Array.isArray(display.size) && display.size[0] > 0 && display.size[1] > 0) {
        width = display.size[0] * 1.5;
        height2 = display.size[1] * 1.5;
      }
      const ghostStyleString = display?.style;
      const ghostParsedStyle = parseStyle(ghostStyleString);
      const ghostFontSize = ghostParsedStyle.fontSize || 10;
      const ghostMinSize = ensureMinNodeSize(width, height2, jsonEl.name || "", "GHOST", ghostFontSize);
      width = ghostMinSize.width;
      height2 = ghostMinSize.height;
      let x2 = 0, y2 = 0;
      if (display?.coordinates && Array.isArray(display.coordinates)) {
        x2 = display.coordinates[0] * 1.5;
        y2 = display.coordinates[1] * 1.5;
      }
      let folderId;
      if (jsonEl.folder) {
        const folderName = idToNameMap.get(jsonEl.folder);
        if (folderName && layoutFolders.some((f2) => f2.id === folderName)) {
          folderId = folderName;
        }
      }
      layoutNodes.push({
        id: ghostId,
        name: jsonEl.name || "",
        x: x2,
        y: y2,
        width,
        height: height2,
        folderId,
        type: "GHOST"
      });
      addedNodeIds.add(ghostId);
    });
    return layoutNodes;
  }
  function buildLayoutFolders(converted) {
    const folderJsonElements = converted.elements.filter((el) => el.type === "FOLDER");
    const layoutFolders = [];
    folderJsonElements.forEach((jsonFolder) => {
      if (!jsonFolder.name) return;
      const display = jsonFolder.display;
      let x2 = 0, y2 = 0;
      let width = 300, height2 = 200;
      if (display?.coordinates && Array.isArray(display.coordinates)) {
        x2 = display.coordinates[0] * 1.5;
        y2 = display.coordinates[1] * 1.5;
      }
      if (display?.size && Array.isArray(display.size)) {
        width = (display.size[0] || 300) * 1.5;
        height2 = (display.size[1] || 200) * 1.5;
      }
      layoutFolders.push({
        id: jsonFolder.name,
        name: jsonFolder.name,
        x: x2,
        y: y2,
        width,
        height: height2
      });
    });
    return layoutFolders;
  }
  function buildIdToNameMap(converted) {
    const idToNameMap = /* @__PURE__ */ new Map();
    converted.elements.forEach((jsonEl) => {
      if (jsonEl.id && jsonEl.name) {
        idToNameMap.set(jsonEl.id, jsonEl.name);
      }
    });
    return idToNameMap;
  }
  function buildJsonElementMap(converted) {
    const jsonElementMap = /* @__PURE__ */ new Map();
    converted.elements.forEach((jsonEl) => {
      if (jsonEl.name) {
        if (jsonEl.type === "GHOST") {
          jsonElementMap.set(`__ghost__${jsonEl.name}`, jsonEl);
        } else if (jsonEl.type === "FOLDER") {
          jsonElementMap.set(`__folder__${jsonEl.name}`, jsonEl);
        } else {
          jsonElementMap.set(jsonEl.name, jsonEl);
        }
      }
    });
    return jsonElementMap;
  }

  // utils/visualizer/buildNodes.ts
  function createNodes(options) {
    const { model, converted, layoutResult, jsonElementMap, idToNameMap } = options;
    const newNodes = [];
    const nodeIds = /* @__PURE__ */ new Set();
    const nodeElements = model.find().filter((el) => {
      const className = el.constructor.name;
      return className !== "Link" && className !== "Flow" && className !== "Folder";
    });
    const ghostElementMap = /* @__PURE__ */ new Map();
    converted.elements.forEach((jsonEl) => {
      if (jsonEl.type === "GHOST" && jsonEl.id) {
        ghostElementMap.set(`__ghost__${jsonEl.id}`, jsonEl);
      }
    });
    createFolderNodes(layoutResult, jsonElementMap, newNodes, nodeIds);
    createRegularNodes(layoutResult, nodeElements, jsonElementMap, idToNameMap, ghostElementMap, newNodes, nodeIds);
    return { nodes: newNodes, nodeIds };
  }
  function createFolderNodes(layoutResult, jsonElementMap, nodes, nodeIds) {
    layoutResult.folders.forEach((folderLayout, folderIndex) => {
      const isRootFolder = folderLayout.id === "__ROOT__";
      const jsonFolder = isRootFolder ? null : jsonElementMap.get(`__folder__${folderLayout.id}`);
      const display = jsonFolder?.display;
      const styleString = display?.style;
      const parsedStyle = parseStyle(styleString);
      const folderBorderColor = isRootFolder ? "#6b7280" : getFolderColor(folderIndex);
      nodes.push({
        id: folderLayout.id,
        type: "folderNode",
        data: {
          label: isRootFolder ? "Unassigned Elements" : folderLayout.id,
          type: "FOLDER",
          doc: isRootFolder ? "Elements without a folder assignment" : void 0,
          childCount: folderLayout.childCount,
          borderColor: parsedStyle.strokeColor || folderBorderColor,
          fontSize: parsedStyle.fontSize || 12,
          fontColor: parsedStyle.fontColor || "#1f2937"
        },
        position: { x: folderLayout.x, y: folderLayout.y },
        style: {
          width: folderLayout.width,
          height: folderLayout.height,
          pointerEvents: "none"
          // Make folder transparent to clicks
        },
        // Make folder completely non-interactive - clicks pass through
        selectable: false,
        draggable: false,
        focusable: false
      });
      nodeIds.add(folderLayout.id);
    });
  }
  function createRegularNodes(layoutResult, nodeElements, jsonElementMap, idToNameMap, ghostElementMap, nodes, nodeIds) {
    layoutResult.nodes.forEach((nodeLayout) => {
      const isGhostFromXML = nodeLayout.id.startsWith("__ghost__");
      if (isGhostFromXML) {
        createGhostNode(nodeLayout, ghostElementMap, idToNameMap, nodes, nodeIds);
        return;
      }
      const el = nodeElements.find((e2) => e2.name === nodeLayout.id);
      if (!el) return;
      const jsonEl = jsonElementMap.get(nodeLayout.id);
      const display = jsonEl?.display;
      const elementClass = el.constructor.name;
      let elementType = "VARIABLE";
      if (elementClass === "Stock") elementType = "STOCK";
      else if (elementClass === "Converter") elementType = "CONVERTER";
      const styleString = display?.style;
      const parsedStyle = parseStyle(styleString);
      if (isGhostNode(parsedStyle)) {
        elementType = "GHOST";
      }
      let nodeType = "variableNode";
      if (elementType === "STOCK") nodeType = "stockNode";
      else if (elementType === "CONVERTER") nodeType = "converterNode";
      else if (elementType === "GHOST") nodeType = "ghostNode";
      const borderColor = getElementColor(elementType, parsedStyle.strokeColor);
      const fillColor = parsedStyle.fillColor || getStyleBasedFillColor(parsedStyle.elementType || elementType.toLowerCase());
      let sourceElementName;
      if (elementType === "GHOST" && jsonEl?.source) {
        sourceElementName = idToNameMap.get(jsonEl.source) || jsonEl.source;
      }
      const node = {
        id: nodeLayout.id,
        type: nodeType,
        data: {
          label: el.name,
          type: elementType,
          doc: el.doc,
          units: el.units,
          style: parsedStyle,
          borderColor,
          fillColor,
          fontSize: parsedStyle.fontSize,
          fontColor: parsedStyle.fontColor,
          opacity: parsedStyle.opacity,
          simulationResults: void 0,
          modelData: void 0,
          width: nodeLayout.width,
          height: nodeLayout.height,
          // For ghost nodes: reference to the original element
          ...elementType === "GHOST" && sourceElementName ? { source: sourceElementName } : {}
        },
        position: { x: nodeLayout.x, y: nodeLayout.y },
        style: {
          width: nodeLayout.width,
          height: nodeLayout.height
        }
      };
      if (nodeLayout.parentId) {
        node.parentId = nodeLayout.parentId;
        node.extent = "parent";
      }
      nodes.push(node);
      nodeIds.add(nodeLayout.id);
    });
  }
  function createGhostNode(nodeLayout, ghostElementMap, idToNameMap, nodes, nodeIds) {
    const ghostJsonEl = ghostElementMap.get(nodeLayout.id);
    if (!ghostJsonEl) return;
    const display = ghostJsonEl.display;
    const styleString = display?.style;
    const parsedStyle = parseStyle(styleString);
    const borderColor = getElementColor("GHOST", parsedStyle.strokeColor);
    const fillColor = parsedStyle.fillColor || getStyleBasedFillColor("ghost");
    let sourceElementName;
    if (ghostJsonEl.source) {
      sourceElementName = idToNameMap.get(ghostJsonEl.source) || ghostJsonEl.source;
    }
    const node = {
      id: nodeLayout.id,
      type: "ghostNode",
      data: {
        label: ghostJsonEl.name || "",
        type: "GHOST",
        style: parsedStyle,
        borderColor,
        fillColor,
        fontSize: parsedStyle.fontSize,
        fontColor: parsedStyle.fontColor,
        opacity: parsedStyle.opacity || 30,
        simulationResults: void 0,
        modelData: void 0,
        source: sourceElementName,
        // Reference to the original element for data
        width: nodeLayout.width,
        height: nodeLayout.height
      },
      position: { x: nodeLayout.x, y: nodeLayout.y },
      style: {
        width: nodeLayout.width,
        height: nodeLayout.height
      }
    };
    if (nodeLayout.parentId) {
      node.parentId = nodeLayout.parentId;
      node.extent = "parent";
    }
    nodes.push(node);
    nodeIds.add(nodeLayout.id);
  }
  function createPlaceholderNode(id2) {
    return {
      id: id2,
      type: "variableNode",
      data: {
        label: id2,
        type: "MISSING",
        doc: "Cloud/External source",
        borderColor: "#999999",
        fillColor: "#e5e5e5"
      },
      position: { x: 0, y: 0 }
    };
  }

  // utils/visualizer/buildEdges.ts
  function createEdges(options) {
    const { model, converted, layoutNodes, layoutResult, idToNameMap, nodeIds, onFlowClick } = options;
    const newEdges = [];
    const placeholderNodeIds = [];
    let edgeCount = 0;
    const nodeToFolder = /* @__PURE__ */ new Map();
    layoutResult.nodes.forEach((nodeLayout) => {
      if (nodeLayout.parentId) {
        nodeToFolder.set(nodeLayout.id, nodeLayout.parentId);
      }
    });
    const sourceToGhostsByFolder = buildSourceToGhostMap(layoutNodes);
    const flowConnections = collectFlowConnections(converted, idToNameMap);
    const resolveEndpoints = (sourceName, targetName) => resolveEdgeEndpoints(sourceName, targetName, nodeToFolder, sourceToGhostsByFolder);
    const links = model.findLinks();
    links.forEach((link) => {
      const node = link._node;
      const sourceNode = node?.source;
      const targetNode = node?.target;
      if (sourceNode && targetNode) {
        const sourceName = sourceNode.attributes?.get("name");
        const targetName = targetNode.attributes?.get("name");
        if (sourceName && targetName) {
          const resolvedEndpoints = resolveEndpoints(sourceName, targetName);
          if (!resolvedEndpoints) {
            return;
          }
          const [resolvedSource, resolvedTarget] = resolvedEndpoints;
          const connectionKey = `${sourceName}_${targetName}`;
          if (flowConnections.has(connectionKey)) {
            return;
          }
          const linkJsonEl = converted.elements.find(
            (el) => el.type === "LINK" && (idToNameMap.get(el.from || "") === sourceName || el.from === sourceName) && (idToNameMap.get(el.to || "") === targetName || el.to === targetName)
          );
          const linkStyleString = linkJsonEl?.display?.style;
          const linkParsedStyle = parseStyle(linkStyleString);
          newEdges.push(createLinkEdge(resolvedSource, resolvedTarget, linkParsedStyle, edgeCount++));
        }
      }
    });
    converted.elements.forEach((jsonEl) => {
      if (jsonEl.type === "FLOW" && jsonEl.name) {
        const fromId = jsonEl.from;
        const toId = jsonEl.to;
        const fromName = idToNameMap.get(fromId || "") || fromId;
        const toName = idToNameMap.get(toId || "") || toId;
        let resolvedFrom = fromName;
        let resolvedTo = toName;
        if (fromName && toName) {
          const resolvedEndpoints = resolveEndpoints(fromName, toName);
          if (!resolvedEndpoints) {
            return;
          }
          [resolvedFrom, resolvedTo] = resolvedEndpoints;
        }
        const styleString = jsonEl.display?.style;
        const parsedStyle = parseStyle(styleString);
        const strokeColor = parsedStyle.strokeColor || "#ef4444";
        if (resolvedFrom && !nodeIds.has(resolvedFrom)) {
          placeholderNodeIds.push(resolvedFrom);
        }
        if (resolvedTo && !nodeIds.has(resolvedTo)) {
          placeholderNodeIds.push(resolvedTo);
        }
        if (resolvedFrom && resolvedTo) {
          newEdges.push(createFlowEdge(resolvedFrom, resolvedTo, jsonEl.name, parsedStyle, strokeColor, onFlowClick));
        }
      }
    });
    return { edges: newEdges, placeholderNodeIds };
  }
  function buildSourceToGhostMap(layoutNodes) {
    const sourceToGhostsByFolder = /* @__PURE__ */ new Map();
    layoutNodes.forEach((node) => {
      if (node.id.startsWith("__ghost__") && node.folderId) {
        const sourceName = node.name;
        if (!sourceToGhostsByFolder.has(sourceName)) {
          sourceToGhostsByFolder.set(sourceName, /* @__PURE__ */ new Map());
        }
        sourceToGhostsByFolder.get(sourceName).set(node.folderId, node.id);
      }
    });
    return sourceToGhostsByFolder;
  }
  function collectFlowConnections(converted, idToNameMap) {
    const flowConnections = /* @__PURE__ */ new Set();
    converted.elements.forEach((jsonEl) => {
      if (jsonEl.type === "FLOW" && jsonEl.from && jsonEl.to) {
        const fromName = idToNameMap.get(jsonEl.from) || jsonEl.from;
        const toName = idToNameMap.get(jsonEl.to) || jsonEl.to;
        flowConnections.add(`${fromName}_${toName}`);
        flowConnections.add(`${toName}_${fromName}`);
      }
    });
    return flowConnections;
  }
  function findGhostInFolder(elementName, folderId, sourceToGhostsByFolder) {
    const ghostsByFolder = sourceToGhostsByFolder.get(elementName);
    if (ghostsByFolder) {
      return ghostsByFolder.get(folderId);
    }
    return void 0;
  }
  function resolveEdgeEndpoints(sourceName, targetName, nodeToFolder, sourceToGhostsByFolder) {
    const sourceFolder = nodeToFolder.get(sourceName);
    const targetFolder = nodeToFolder.get(targetName);
    if (sourceFolder && targetFolder && sourceFolder === targetFolder) {
      return [sourceName, targetName];
    }
    if (sourceFolder) {
      const ghostOfTargetInSourceFolder = findGhostInFolder(targetName, sourceFolder, sourceToGhostsByFolder);
      if (ghostOfTargetInSourceFolder) {
        return [sourceName, ghostOfTargetInSourceFolder];
      }
    }
    if (targetFolder) {
      const ghostOfSourceInTargetFolder = findGhostInFolder(sourceName, targetFolder, sourceToGhostsByFolder);
      if (ghostOfSourceInTargetFolder) {
        return [ghostOfSourceInTargetFolder, targetName];
      }
    }
    return null;
  }
  function createLinkEdge(source, target, style2, edgeIndex) {
    return {
      id: `link_${source}_${target}_${edgeIndex}`,
      source,
      target,
      animated: false,
      type: "smoothstep",
      style: {
        stroke: style2.strokeColor || "#94a3b8",
        strokeWidth: style2.strokeWidth || 1,
        strokeDasharray: style2.strokeDasharray || "4 2"
      }
    };
  }
  function createFlowEdge(source, target, flowName, style2, strokeColor, onFlowClick) {
    return {
      id: `flow_${source}_to_${target}_${flowName}`,
      source,
      target,
      animated: false,
      type: "flowEdge",
      data: {
        flowName,
        flowDescription: style2,
        style: style2,
        strokeColor,
        onFlowClick
      },
      style: {
        stroke: strokeColor,
        strokeWidth: style2.strokeWidth || 2
      }
    };
  }

  // components/ModelVisualizer.tsx
  var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
  function ModelVisualizer() {
    const [nodes, setNodes, onNodesChange] = useNodesState([]);
    const [edges, setEdges, onEdgesChange] = useEdgesState([]);
    const [modelData, setModelData] = (0, import_react23.useState)(null);
    const [convertedData, setConvertedData] = (0, import_react23.useState)(null);
    const [loading, setLoading] = (0, import_react23.useState)(false);
    const [isCalculatingLayout, setIsCalculatingLayout] = (0, import_react23.useState)(false);
    const [showResultsModal, setShowResultsModal] = (0, import_react23.useState)(false);
    const [showDetailModal, setShowDetailModal] = (0, import_react23.useState)(false);
    const [detailElementId, setDetailElementId] = (0, import_react23.useState)(null);
    const [pendingLayoutRecalc, setPendingLayoutRecalc] = (0, import_react23.useState)(false);
    const [xmlContent, setXmlContent] = (0, import_react23.useState)("");
    const [cachedFolderStructure, setCachedFolderStructure] = (0, import_react23.useState)(null);
    const containerRef = (0, import_react23.useRef)(null);
    const { sidebarWidth, isResizing, showScenarioPanel, setShowScenarioPanel, startResizing, COLLAPSED_WIDTH: COLLAPSED_WIDTH2 } = useSidebarResize({ containerRef });
    const { handleEdgeClick, handlePaneClick } = useHighlighting({ setNodes, setEdges });
    const {
      simulationResults,
      isRunningSimulation,
      hasRunSimulation,
      setHasRunSimulation,
      handleRunSimulation,
      downloadAllResults,
      createResultsFromCache,
      setSimulationResults,
      setIsRunningSimulation,
      error,
      setError
    } = useSimulation({
      modelData,
      convertedData,
      setNodes,
      setPendingLayoutRecalc
    });
    const {
      buttons,
      setButtons,
      currentScenario,
      scenarioHistory,
      cachedScenarios,
      setCachedScenarios,
      selectedDisplayScenarios,
      setSelectedDisplayScenarios,
      showScenarioDropdown,
      setShowScenarioDropdown,
      handleRunScenario
    } = useScenarios({
      modelData,
      setModelData,
      xmlContent,
      setNodes,
      setPendingLayoutRecalc,
      setHasRunSimulation,
      downloadAllResults,
      createResultsFromCache,
      setSimulationResults,
      setIsRunningSimulation,
      setError
    });
    const handleNodeClick2 = (0, import_react23.useCallback)(
      (_event, node) => {
        if (modelData) {
          if (node.type === "folderNode" || node.data?.type === "FOLDER") {
            return;
          }
          const elementId = node.data?.source || node.data?.label || node.id;
          setDetailElementId(elementId);
          setShowDetailModal(true);
        }
      },
      [modelData]
    );
    const handleFlowClick = (0, import_react23.useCallback)((flowName) => {
      setDetailElementId(flowName);
      setShowDetailModal(true);
    }, []);
    const handleFileUpload = (0, import_react23.useCallback)(
      async (fileContent) => {
        try {
          setLoading(true);
          setIsCalculatingLayout(true);
          setError(null);
          setXmlContent(fileContent);
          const currentModelHash = generateModelHash(fileContent);
          const cached = await getCachedScenarioNames(currentModelHash);
          setCachedScenarios(cached);
          const model = loadInsightMaker(fileContent);
          setModelData(model);
          const converted = await convertInsightMakerXmlToJson(fileContent);
          setConvertedData(converted);
          const parsedButtons = await parseButtonsFromXml(fileContent);
          setButtons(parsedButtons.buttons);
          const idToNameMap = buildIdToNameMap(converted);
          const jsonElementMap = buildJsonElementMap(converted);
          const layoutFolders = buildLayoutFolders(converted);
          setCachedFolderStructure({
            layoutFolders,
            idToNameMap
          });
          const layoutNodes = buildLayoutNodes(model, converted, layoutFolders, idToNameMap);
          const layoutResult = calculateFolderLayout(layoutNodes, layoutFolders);
          const { nodes: newNodes, nodeIds } = createNodes({
            model,
            converted,
            layoutResult,
            jsonElementMap,
            idToNameMap
          });
          const { edges: newEdges, placeholderNodeIds } = createEdges({
            model,
            converted,
            layoutNodes,
            layoutResult,
            idToNameMap,
            nodeIds,
            onFlowClick: handleFlowClick
          });
          placeholderNodeIds.forEach((id2) => {
            if (!nodeIds.has(id2)) {
              newNodes.push(createPlaceholderNode(id2));
              nodeIds.add(id2);
            }
          });
          setNodes(newNodes);
          setEdges(newEdges);
          setLoading(false);
          setIsCalculatingLayout(false);
        } catch (err) {
          console.error("Error loading model:", err);
          setError(err instanceof Error ? err.message : "Failed to load model");
          setLoading(false);
          setIsCalculatingLayout(false);
        }
      },
      [setNodes, setEdges, handleFlowClick, setError, setCachedScenarios, setButtons]
    );
    (0, import_react23.useEffect)(() => {
      const loadDefaultModel = async () => {
        try {
          await handleFileUpload(defaultModelXML);
        } catch (err) {
          console.error("Failed to load default model:", err);
          setError(err instanceof Error ? err.message : "Failed to load default model");
          setLoading(false);
        }
      };
      loadDefaultModel();
    }, [handleFileUpload, setError]);
    (0, import_react23.useEffect)(() => {
      if (modelData && !hasRunSimulation && !isRunningSimulation && buttons.length > 0) {
        const runnableButtons = buttons.filter((b2) => b2.runsModel);
        if (runnableButtons.length === 0) {
          handleRunSimulation();
          return;
        }
        const defaultScenario = runnableButtons.find((b2) => b2.name === "Commitment+ base") || runnableButtons[0];
        if (defaultScenario) {
          const resolvedValues = resolveButtonInheritance(buttons);
          const values = resolvedValues.get(defaultScenario.name) || defaultScenario.setValues;
          handleRunScenario(values, defaultScenario.name);
        } else {
          handleRunSimulation();
        }
      } else if (modelData && !hasRunSimulation && !isRunningSimulation && buttons.length === 0) {
        handleRunSimulation();
      }
    }, [modelData, hasRunSimulation, isRunningSimulation, handleRunSimulation, handleRunScenario, buttons]);
    (0, import_react23.useEffect)(() => {
      if (!pendingLayoutRecalc || !modelData || !convertedData || nodes.length === 0 || !cachedFolderStructure) {
        return;
      }
      setIsCalculatingLayout(true);
      const { layoutFolders, idToNameMap } = cachedFolderStructure;
      const layoutNodes = buildLayoutNodes(modelData, convertedData, layoutFolders, idToNameMap);
      const layoutResult = calculateFolderLayout(layoutNodes, layoutFolders);
      setNodes((currentNodes) => {
        const layoutMap = /* @__PURE__ */ new Map();
        layoutResult.folders.forEach((f2) => {
          layoutMap.set(f2.id, { x: f2.x, y: f2.y, width: f2.width, height: f2.height });
        });
        layoutResult.nodes.forEach((n2) => {
          layoutMap.set(n2.id, { x: n2.x, y: n2.y, width: n2.width, height: n2.height, parentId: n2.parentId });
        });
        return currentNodes.map((node) => {
          const layout = layoutMap.get(node.id);
          if (layout) {
            return {
              ...node,
              position: { x: layout.x, y: layout.y },
              style: {
                ...node.style,
                width: layout.width,
                height: layout.height
              },
              data: {
                ...node.data,
                width: layout.width,
                height: layout.height
              },
              ...layout.parentId ? { parentId: layout.parentId, extent: "parent" } : {}
            };
          }
          return node;
        });
      });
      setPendingLayoutRecalc(false);
      setIsCalculatingLayout(false);
    }, [pendingLayoutRecalc, modelData, convertedData, nodes.length, setNodes, cachedFolderStructure]);
    const elementCount = modelData ? modelData.find().length : 0;
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("div", { className: "w-full h-full flex flex-col bg-gradient-to-br from-gray-50 to-gray-100 swiss-card", children: [
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        VisualizerHeader_default,
        {
          modelData,
          elementCount,
          simulationResults,
          hasRunSimulation,
          isRunningSimulation,
          scenarioHistory,
          selectedDisplayScenarios,
          setSelectedDisplayScenarios,
          showScenarioDropdown,
          setShowScenarioDropdown,
          onShowResultsModal: () => setShowResultsModal(true),
          onRunSimulation: handleRunSimulation
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("div", { className: "bg-white border-b border-gray-200 px-6 py-2", children: /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("div", { className: "max-w-[98%] mx-auto flex items-center gap-4", children: [
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ModelFileInput, { onFileUpload: handleFileUpload, loading }),
        error && /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("div", { className: "flex items-center gap-2 text-red-600 text-sm bg-red-50 px-3 py-2 rounded-md border border-red-200", children: [
          /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
            "path",
            {
              strokeLinecap: "round",
              strokeLinejoin: "round",
              strokeWidth: 2,
              d: "M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
            }
          ) }),
          error
        ] })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("div", { ref: containerRef, className: "flex-1 min-h-0 relative overflow-hidden", children: /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("div", { className: "absolute inset-0 p-6 flex gap-4", children: [
        buttons.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
            "div",
            {
              className: "h-full flex-shrink-0 transition-all duration-150",
              style: { width: showScenarioPanel ? `${sidebarWidth}px` : `${COLLAPSED_WIDTH2}px` },
              children: showScenarioPanel ? /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("div", { className: "h-full bg-white rounded-2xl shadow-xl border border-gray-200 overflow-hidden flex flex-col", children: [
                /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("div", { className: "flex items-center justify-between p-2 border-b border-gray-100", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("span", { className: "text-xs font-medium text-gray-500 uppercase tracking-wide pl-2", children: "Scenarios" }),
                  /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
                    "button",
                    {
                      onClick: () => setShowScenarioPanel(false),
                      className: "p-1.5 text-gray-400 hover:text-gray-600 hover:bg-gray-100 rounded swiss-btn swiss-btn--secondary",
                      title: "Collapse panel",
                      children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
                        "path",
                        {
                          strokeLinecap: "round",
                          strokeLinejoin: "round",
                          strokeWidth: 2,
                          d: "M11 19l-7-7 7-7m8 14l-7-7 7-7"
                        }
                      ) })
                    }
                  )
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("div", { className: "flex-1 overflow-hidden", children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
                  ScenarioPanel,
                  {
                    buttons,
                    onRunScenario: handleRunScenario,
                    isRunning: isRunningSimulation,
                    currentScenario,
                    scenarioHistory,
                    cachedScenarios
                  }
                ) })
              ] }) : /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
                "button",
                {
                  onClick: () => setShowScenarioPanel(true),
                  className: "h-full w-full bg-white rounded-2xl shadow-xl border border-gray-200 flex items-center justify-center hover:bg-gray-50 transition-colors swiss-btn swiss-btn--secondary",
                  title: "Show scenarios",
                  children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("svg", { className: "w-5 h-5 text-gray-500", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M13 5l7 7-7 7M5 5l7 7-7 7" }) })
                }
              )
            }
          ),
          showScenarioPanel && /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
            "div",
            {
              onMouseDown: startResizing,
              title: "Resize scenarios panel",
              className: "h-full flex-shrink-0",
              style: {
                width: "6px",
                cursor: "col-resize",
                background: isResizing ? "rgba(0,0,0,0.08)" : "transparent",
                zIndex: 40
              }
            }
          )
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
          VisualizerCanvas_default,
          {
            nodes,
            edges,
            onNodesChange,
            onEdgesChange,
            onNodeClick: handleNodeClick2,
            onEdgeClick: handleEdgeClick,
            onPaneClick: handlePaneClick,
            isCalculatingLayout,
            isRunningSimulation,
            currentScenario
          }
        )
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        SimulationResultsModal,
        {
          isOpen: showResultsModal,
          onClose: () => setShowResultsModal(false),
          selectedElement: null,
          simulationResults,
          modelData,
          convertedData,
          scenarioHistory
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        ElementDetailModal,
        {
          isOpen: showDetailModal,
          onClose: () => setShowDetailModal(false),
          elementId: detailElementId,
          simulationResults,
          modelData,
          scenarioHistory,
          selectedDisplayScenarios
        }
      )
    ] });
  }

  // standalone.tsx
  var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
  var container = document.getElementById("root");
  if (container) {
    const root2 = (0, import_client.createRoot)(container);
    root2.render(
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(import_react24.default.StrictMode, { children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ModelVisualizer, {}) })
    );
  }
})();
/*! Bundled license information:

react/cjs/react.production.js:
  (**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.js:
  (**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.js:
  (**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.production.js:
  (**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.production.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.js:
  (**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
*/

  </script>
</body>
</html>